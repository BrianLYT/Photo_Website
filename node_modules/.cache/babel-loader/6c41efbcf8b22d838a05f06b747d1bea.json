{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  SyncBailHook\n} = require(\"tapable\");\n\nconst {\n  RawSource,\n  CachedSource,\n  CompatSource\n} = require(\"webpack-sources\");\n\nconst Compilation = require(\"../Compilation\");\n\nconst WebpackError = require(\"../WebpackError\");\n\nconst {\n  compareSelect,\n  compareStrings\n} = require(\"../util/comparators\");\n\nconst createHash = require(\"../util/createHash\");\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n\nconst EMPTY_SET = new Set();\n\nconst addToList = (itemOrItems, list) => {\n  if (Array.isArray(itemOrItems)) {\n    for (const item of itemOrItems) {\n      list.add(item);\n    }\n  } else if (itemOrItems) {\n    list.add(itemOrItems);\n  }\n};\n/**\n * @template T\n * @param {T[]} input list\n * @param {function(T): Buffer} fn map function\n * @returns {Buffer[]} buffers without duplicates\n */\n\n\nconst mapAndDeduplicateBuffers = (input, fn) => {\n  // Buffer.equals compares size first so this should be efficient enough\n  // If it becomes a performance problem we can use a map and group by size\n  // instead of looping over all assets.\n  const result = [];\n\n  outer: for (const value of input) {\n    const buf = fn(value);\n\n    for (const other of result) {\n      if (buf.equals(other)) continue outer;\n    }\n\n    result.push(buf);\n  }\n\n  return result;\n};\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\n\n\nconst quoteMeta = str => {\n  return str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\nconst cachedSourceMap = new WeakMap();\n\nconst toCachedSource = source => {\n  if (source instanceof CachedSource) {\n    return source;\n  }\n\n  const entry = cachedSourceMap.get(source);\n  if (entry !== undefined) return entry;\n  const newSource = new CachedSource(CompatSource.from(source));\n  cachedSourceMap.set(source, newSource);\n  return newSource;\n};\n/**\n * @typedef {Object} AssetInfoForRealContentHash\n * @property {string} name\n * @property {AssetInfo} info\n * @property {Source} source\n * @property {RawSource | undefined} newSource\n * @property {RawSource | undefined} newSourceWithoutOwn\n * @property {string} content\n * @property {Set<string>} ownHashes\n * @property {Promise} contentComputePromise\n * @property {Promise} contentComputeWithoutOwnPromise\n * @property {Set<string>} referencedHashes\n * @property {Set<string>} hashes\n */\n\n/**\n * @typedef {Object} CompilationHooks\n * @property {SyncBailHook<[Buffer[], string], string>} updateHash\n */\n\n/** @type {WeakMap<Compilation, CompilationHooks>} */\n\n\nconst compilationHooksMap = new WeakMap();\n\nclass RealContentHashPlugin {\n  /**\n   * @param {Compilation} compilation the compilation\n   * @returns {CompilationHooks} the attached hooks\n   */\n  static getCompilationHooks(compilation) {\n    if (!(compilation instanceof Compilation)) {\n      throw new TypeError(\"The 'compilation' argument must be an instance of Compilation\");\n    }\n\n    let hooks = compilationHooksMap.get(compilation);\n\n    if (hooks === undefined) {\n      hooks = {\n        updateHash: new SyncBailHook([\"content\", \"oldHash\"])\n      };\n      compilationHooksMap.set(compilation, hooks);\n    }\n\n    return hooks;\n  }\n\n  constructor(_ref) {\n    let {\n      hashFunction,\n      hashDigest\n    } = _ref;\n    this._hashFunction = hashFunction;\n    this._hashDigest = hashDigest;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"RealContentHashPlugin\", compilation => {\n      const cacheAnalyse = compilation.getCache(\"RealContentHashPlugin|analyse\");\n      const cacheGenerate = compilation.getCache(\"RealContentHashPlugin|generate\");\n      const hooks = RealContentHashPlugin.getCompilationHooks(compilation);\n      compilation.hooks.processAssets.tapPromise({\n        name: \"RealContentHashPlugin\",\n        stage: Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH\n      }, async () => {\n        const assets = compilation.getAssets();\n        /** @type {AssetInfoForRealContentHash[]} */\n\n        const assetsWithInfo = [];\n        const hashToAssets = new Map();\n\n        for (const {\n          source,\n          info,\n          name\n        } of assets) {\n          const cachedSource = toCachedSource(source);\n          const content = cachedSource.source();\n          /** @type {Set<string>} */\n\n          const hashes = new Set();\n          addToList(info.contenthash, hashes);\n          const data = {\n            name,\n            info,\n            source: cachedSource,\n\n            /** @type {RawSource | undefined} */\n            newSource: undefined,\n\n            /** @type {RawSource | undefined} */\n            newSourceWithoutOwn: undefined,\n            content,\n\n            /** @type {Set<string>} */\n            ownHashes: undefined,\n            contentComputePromise: undefined,\n            contentComputeWithoutOwnPromise: undefined,\n\n            /** @type {Set<string>} */\n            referencedHashes: undefined,\n            hashes\n          };\n          assetsWithInfo.push(data);\n\n          for (const hash of hashes) {\n            const list = hashToAssets.get(hash);\n\n            if (list === undefined) {\n              hashToAssets.set(hash, [data]);\n            } else {\n              list.push(data);\n            }\n          }\n        }\n\n        if (hashToAssets.size === 0) return;\n        const hashRegExp = new RegExp(Array.from(hashToAssets.keys(), quoteMeta).join(\"|\"), \"g\");\n        await Promise.all(assetsWithInfo.map(async asset => {\n          const {\n            name,\n            source,\n            content,\n            hashes\n          } = asset;\n\n          if (Buffer.isBuffer(content)) {\n            asset.referencedHashes = EMPTY_SET;\n            asset.ownHashes = EMPTY_SET;\n            return;\n          }\n\n          const etag = cacheAnalyse.mergeEtags(cacheAnalyse.getLazyHashedEtag(source), Array.from(hashes).join(\"|\"));\n          [asset.referencedHashes, asset.ownHashes] = await cacheAnalyse.providePromise(name, etag, () => {\n            const referencedHashes = new Set();\n            let ownHashes = new Set();\n            const inContent = content.match(hashRegExp);\n\n            if (inContent) {\n              for (const hash of inContent) {\n                if (hashes.has(hash)) {\n                  ownHashes.add(hash);\n                  continue;\n                }\n\n                referencedHashes.add(hash);\n              }\n            }\n\n            return [referencedHashes, ownHashes];\n          });\n        }));\n\n        const getDependencies = hash => {\n          const assets = hashToAssets.get(hash);\n\n          if (!assets) {\n            const referencingAssets = assetsWithInfo.filter(asset => asset.referencedHashes.has(hash));\n            const err = new WebpackError(`RealContentHashPlugin\nSome kind of unexpected caching problem occurred.\nAn asset was cached with a reference to another asset (${hash}) that's not in the compilation anymore.\nEither the asset was incorrectly cached, or the referenced asset should also be restored from cache.\nReferenced by:\n${referencingAssets.map(a => {\n              const match = new RegExp(`.{0,20}${quoteMeta(hash)}.{0,20}`).exec(a.content);\n              return ` - ${a.name}: ...${match ? match[0] : \"???\"}...`;\n            }).join(\"\\n\")}`);\n            compilation.errors.push(err);\n            return undefined;\n          }\n\n          const hashes = new Set();\n\n          for (const {\n            referencedHashes,\n            ownHashes\n          } of assets) {\n            if (!ownHashes.has(hash)) {\n              for (const hash of ownHashes) {\n                hashes.add(hash);\n              }\n            }\n\n            for (const hash of referencedHashes) {\n              hashes.add(hash);\n            }\n          }\n\n          return hashes;\n        };\n\n        const hashInfo = hash => {\n          const assets = hashToAssets.get(hash);\n          return `${hash} (${Array.from(assets, a => a.name)})`;\n        };\n\n        const hashesInOrder = new Set();\n\n        for (const hash of hashToAssets.keys()) {\n          const add = (hash, stack) => {\n            const deps = getDependencies(hash);\n            if (!deps) return;\n            stack.add(hash);\n\n            for (const dep of deps) {\n              if (hashesInOrder.has(dep)) continue;\n\n              if (stack.has(dep)) {\n                throw new Error(`Circular hash dependency ${Array.from(stack, hashInfo).join(\" -> \")} -> ${hashInfo(dep)}`);\n              }\n\n              add(dep, stack);\n            }\n\n            hashesInOrder.add(hash);\n            stack.delete(hash);\n          };\n\n          if (hashesInOrder.has(hash)) continue;\n          add(hash, new Set());\n        }\n\n        const hashToNewHash = new Map();\n\n        const getEtag = asset => cacheGenerate.mergeEtags(cacheGenerate.getLazyHashedEtag(asset.source), Array.from(asset.referencedHashes, hash => hashToNewHash.get(hash)).join(\"|\"));\n\n        const computeNewContent = asset => {\n          if (asset.contentComputePromise) return asset.contentComputePromise;\n          return asset.contentComputePromise = (async () => {\n            if (asset.ownHashes.size > 0 || Array.from(asset.referencedHashes).some(hash => hashToNewHash.get(hash) !== hash)) {\n              const identifier = asset.name;\n              const etag = getEtag(asset);\n              asset.newSource = await cacheGenerate.providePromise(identifier, etag, () => {\n                const newContent = asset.content.replace(hashRegExp, hash => hashToNewHash.get(hash));\n                return new RawSource(newContent);\n              });\n            }\n          })();\n        };\n\n        const computeNewContentWithoutOwn = asset => {\n          if (asset.contentComputeWithoutOwnPromise) return asset.contentComputeWithoutOwnPromise;\n          return asset.contentComputeWithoutOwnPromise = (async () => {\n            if (asset.ownHashes.size > 0 || Array.from(asset.referencedHashes).some(hash => hashToNewHash.get(hash) !== hash)) {\n              const identifier = asset.name + \"|without-own\";\n              const etag = getEtag(asset);\n              asset.newSourceWithoutOwn = await cacheGenerate.providePromise(identifier, etag, () => {\n                const newContent = asset.content.replace(hashRegExp, hash => {\n                  if (asset.ownHashes.has(hash)) {\n                    return \"\";\n                  }\n\n                  return hashToNewHash.get(hash);\n                });\n                return new RawSource(newContent);\n              });\n            }\n          })();\n        };\n\n        const comparator = compareSelect(a => a.name, compareStrings);\n\n        for (const oldHash of hashesInOrder) {\n          const assets = hashToAssets.get(oldHash);\n          assets.sort(comparator);\n          const hash = createHash(this._hashFunction);\n          await Promise.all(assets.map(asset => asset.ownHashes.has(oldHash) ? computeNewContentWithoutOwn(asset) : computeNewContent(asset)));\n          const assetsContent = mapAndDeduplicateBuffers(assets, asset => {\n            if (asset.ownHashes.has(oldHash)) {\n              return asset.newSourceWithoutOwn ? asset.newSourceWithoutOwn.buffer() : asset.source.buffer();\n            } else {\n              return asset.newSource ? asset.newSource.buffer() : asset.source.buffer();\n            }\n          });\n          let newHash = hooks.updateHash.call(assetsContent, oldHash);\n\n          if (!newHash) {\n            for (const content of assetsContent) {\n              hash.update(content);\n            }\n\n            const digest = hash.digest(this._hashDigest);\n            newHash =\n            /** @type {string} */\n            digest.slice(0, oldHash.length);\n          }\n\n          hashToNewHash.set(oldHash, newHash);\n        }\n\n        await Promise.all(assetsWithInfo.map(async asset => {\n          await computeNewContent(asset);\n          const newName = asset.name.replace(hashRegExp, hash => hashToNewHash.get(hash));\n          const infoUpdate = {};\n          const hash = asset.info.contenthash;\n          infoUpdate.contenthash = Array.isArray(hash) ? hash.map(hash => hashToNewHash.get(hash)) : hashToNewHash.get(hash);\n\n          if (asset.newSource !== undefined) {\n            compilation.updateAsset(asset.name, asset.newSource, infoUpdate);\n          } else {\n            compilation.updateAsset(asset.name, asset.source, infoUpdate);\n          }\n\n          if (asset.name !== newName) {\n            compilation.renameAsset(asset.name, newName);\n          }\n        }));\n      });\n    });\n  }\n\n}\n\nmodule.exports = RealContentHashPlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/optimize/RealContentHashPlugin.js"],"names":["SyncBailHook","require","RawSource","CachedSource","CompatSource","Compilation","WebpackError","compareSelect","compareStrings","createHash","EMPTY_SET","Set","addToList","itemOrItems","list","Array","isArray","item","add","mapAndDeduplicateBuffers","input","fn","result","outer","value","buf","other","equals","push","quoteMeta","str","replace","cachedSourceMap","WeakMap","toCachedSource","source","entry","get","undefined","newSource","from","set","compilationHooksMap","RealContentHashPlugin","getCompilationHooks","compilation","TypeError","hooks","updateHash","constructor","hashFunction","hashDigest","_hashFunction","_hashDigest","apply","compiler","tap","cacheAnalyse","getCache","cacheGenerate","processAssets","tapPromise","name","stage","PROCESS_ASSETS_STAGE_OPTIMIZE_HASH","assets","getAssets","assetsWithInfo","hashToAssets","Map","info","cachedSource","content","hashes","contenthash","data","newSourceWithoutOwn","ownHashes","contentComputePromise","contentComputeWithoutOwnPromise","referencedHashes","hash","size","hashRegExp","RegExp","keys","join","Promise","all","map","asset","Buffer","isBuffer","etag","mergeEtags","getLazyHashedEtag","providePromise","inContent","match","has","getDependencies","referencingAssets","filter","err","a","exec","errors","hashInfo","hashesInOrder","stack","deps","dep","Error","delete","hashToNewHash","getEtag","computeNewContent","some","identifier","newContent","computeNewContentWithoutOwn","comparator","oldHash","sort","assetsContent","buffer","newHash","call","update","digest","slice","length","newName","infoUpdate","updateAsset","renameAsset","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAmBC,OAAO,CAAC,SAAD,CAAhC;;AACA,MAAM;AAAEC,EAAAA,SAAF;AAAaC,EAAAA,YAAb;AAA2BC,EAAAA;AAA3B,IAA4CH,OAAO,CAAC,iBAAD,CAAzD;;AACA,MAAMI,WAAW,GAAGJ,OAAO,CAAC,gBAAD,CAA3B;;AACA,MAAMK,YAAY,GAAGL,OAAO,CAAC,iBAAD,CAA5B;;AACA,MAAM;AAAEM,EAAAA,aAAF;AAAiBC,EAAAA;AAAjB,IAAoCP,OAAO,CAAC,qBAAD,CAAjD;;AACA,MAAMQ,UAAU,GAAGR,OAAO,CAAC,oBAAD,CAA1B;AAEA;;AACA;;AACA;;;AAEA,MAAMS,SAAS,GAAG,IAAIC,GAAJ,EAAlB;;AAEA,MAAMC,SAAS,GAAG,CAACC,WAAD,EAAcC,IAAd,KAAuB;AACxC,MAAIC,KAAK,CAACC,OAAN,CAAcH,WAAd,CAAJ,EAAgC;AAC/B,SAAK,MAAMI,IAAX,IAAmBJ,WAAnB,EAAgC;AAC/BC,MAAAA,IAAI,CAACI,GAAL,CAASD,IAAT;AACA;AACD,GAJD,MAIO,IAAIJ,WAAJ,EAAiB;AACvBC,IAAAA,IAAI,CAACI,GAAL,CAASL,WAAT;AACA;AACD,CARD;AAUA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMM,wBAAwB,GAAG,CAACC,KAAD,EAAQC,EAAR,KAAe;AAC/C;AACA;AACA;AACA,QAAMC,MAAM,GAAG,EAAf;;AACAC,EAAAA,KAAK,EAAE,KAAK,MAAMC,KAAX,IAAoBJ,KAApB,EAA2B;AACjC,UAAMK,GAAG,GAAGJ,EAAE,CAACG,KAAD,CAAd;;AACA,SAAK,MAAME,KAAX,IAAoBJ,MAApB,EAA4B;AAC3B,UAAIG,GAAG,CAACE,MAAJ,CAAWD,KAAX,CAAJ,EAAuB,SAASH,KAAT;AACvB;;AACDD,IAAAA,MAAM,CAACM,IAAP,CAAYH,GAAZ;AACA;;AACD,SAAOH,MAAP;AACA,CAbD;AAeA;AACA;AACA;AACA;AACA;;;AACA,MAAMO,SAAS,GAAGC,GAAG,IAAI;AACxB,SAAOA,GAAG,CAACC,OAAJ,CAAY,uBAAZ,EAAqC,MAArC,CAAP;AACA,CAFD;;AAIA,MAAMC,eAAe,GAAG,IAAIC,OAAJ,EAAxB;;AAEA,MAAMC,cAAc,GAAGC,MAAM,IAAI;AAChC,MAAIA,MAAM,YAAYhC,YAAtB,EAAoC;AACnC,WAAOgC,MAAP;AACA;;AACD,QAAMC,KAAK,GAAGJ,eAAe,CAACK,GAAhB,CAAoBF,MAApB,CAAd;AACA,MAAIC,KAAK,KAAKE,SAAd,EAAyB,OAAOF,KAAP;AACzB,QAAMG,SAAS,GAAG,IAAIpC,YAAJ,CAAiBC,YAAY,CAACoC,IAAb,CAAkBL,MAAlB,CAAjB,CAAlB;AACAH,EAAAA,eAAe,CAACS,GAAhB,CAAoBN,MAApB,EAA4BI,SAA5B;AACA,SAAOA,SAAP;AACA,CATD;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AACA,MAAMG,mBAAmB,GAAG,IAAIT,OAAJ,EAA5B;;AAEA,MAAMU,qBAAN,CAA4B;AAC3B;AACD;AACA;AACA;AAC2B,SAAnBC,mBAAmB,CAACC,WAAD,EAAc;AACvC,QAAI,EAAEA,WAAW,YAAYxC,WAAzB,CAAJ,EAA2C;AAC1C,YAAM,IAAIyC,SAAJ,CACL,+DADK,CAAN;AAGA;;AACD,QAAIC,KAAK,GAAGL,mBAAmB,CAACL,GAApB,CAAwBQ,WAAxB,CAAZ;;AACA,QAAIE,KAAK,KAAKT,SAAd,EAAyB;AACxBS,MAAAA,KAAK,GAAG;AACPC,QAAAA,UAAU,EAAE,IAAIhD,YAAJ,CAAiB,CAAC,SAAD,EAAY,SAAZ,CAAjB;AADL,OAAR;AAGA0C,MAAAA,mBAAmB,CAACD,GAApB,CAAwBI,WAAxB,EAAqCE,KAArC;AACA;;AACD,WAAOA,KAAP;AACA;;AAEDE,EAAAA,WAAW,OAA+B;AAAA,QAA9B;AAAEC,MAAAA,YAAF;AAAgBC,MAAAA;AAAhB,KAA8B;AACzC,SAAKC,aAAL,GAAqBF,YAArB;AACA,SAAKG,WAAL,GAAmBF,UAAnB;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCG,EAAAA,KAAK,CAACC,QAAD,EAAW;AACfA,IAAAA,QAAQ,CAACR,KAAT,CAAeF,WAAf,CAA2BW,GAA3B,CAA+B,uBAA/B,EAAwDX,WAAW,IAAI;AACtE,YAAMY,YAAY,GAAGZ,WAAW,CAACa,QAAZ,CACpB,+BADoB,CAArB;AAGA,YAAMC,aAAa,GAAGd,WAAW,CAACa,QAAZ,CACrB,gCADqB,CAAtB;AAGA,YAAMX,KAAK,GAAGJ,qBAAqB,CAACC,mBAAtB,CAA0CC,WAA1C,CAAd;AACAA,MAAAA,WAAW,CAACE,KAAZ,CAAkBa,aAAlB,CAAgCC,UAAhC,CACC;AACCC,QAAAA,IAAI,EAAE,uBADP;AAECC,QAAAA,KAAK,EAAE1D,WAAW,CAAC2D;AAFpB,OADD,EAKC,YAAY;AACX,cAAMC,MAAM,GAAGpB,WAAW,CAACqB,SAAZ,EAAf;AACA;;AACA,cAAMC,cAAc,GAAG,EAAvB;AACA,cAAMC,YAAY,GAAG,IAAIC,GAAJ,EAArB;;AACA,aAAK,MAAM;AAAElC,UAAAA,MAAF;AAAUmC,UAAAA,IAAV;AAAgBR,UAAAA;AAAhB,SAAX,IAAqCG,MAArC,EAA6C;AAC5C,gBAAMM,YAAY,GAAGrC,cAAc,CAACC,MAAD,CAAnC;AACA,gBAAMqC,OAAO,GAAGD,YAAY,CAACpC,MAAb,EAAhB;AACA;;AACA,gBAAMsC,MAAM,GAAG,IAAI9D,GAAJ,EAAf;AACAC,UAAAA,SAAS,CAAC0D,IAAI,CAACI,WAAN,EAAmBD,MAAnB,CAAT;AACA,gBAAME,IAAI,GAAG;AACZb,YAAAA,IADY;AAEZQ,YAAAA,IAFY;AAGZnC,YAAAA,MAAM,EAAEoC,YAHI;;AAIZ;AACAhC,YAAAA,SAAS,EAAED,SALC;;AAMZ;AACAsC,YAAAA,mBAAmB,EAAEtC,SAPT;AAQZkC,YAAAA,OARY;;AASZ;AACAK,YAAAA,SAAS,EAAEvC,SAVC;AAWZwC,YAAAA,qBAAqB,EAAExC,SAXX;AAYZyC,YAAAA,+BAA+B,EAAEzC,SAZrB;;AAaZ;AACA0C,YAAAA,gBAAgB,EAAE1C,SAdN;AAeZmC,YAAAA;AAfY,WAAb;AAiBAN,UAAAA,cAAc,CAACvC,IAAf,CAAoB+C,IAApB;;AACA,eAAK,MAAMM,IAAX,IAAmBR,MAAnB,EAA2B;AAC1B,kBAAM3D,IAAI,GAAGsD,YAAY,CAAC/B,GAAb,CAAiB4C,IAAjB,CAAb;;AACA,gBAAInE,IAAI,KAAKwB,SAAb,EAAwB;AACvB8B,cAAAA,YAAY,CAAC3B,GAAb,CAAiBwC,IAAjB,EAAuB,CAACN,IAAD,CAAvB;AACA,aAFD,MAEO;AACN7D,cAAAA,IAAI,CAACc,IAAL,CAAU+C,IAAV;AACA;AACD;AACD;;AACD,YAAIP,YAAY,CAACc,IAAb,KAAsB,CAA1B,EAA6B;AAC7B,cAAMC,UAAU,GAAG,IAAIC,MAAJ,CAClBrE,KAAK,CAACyB,IAAN,CAAW4B,YAAY,CAACiB,IAAb,EAAX,EAAgCxD,SAAhC,EAA2CyD,IAA3C,CAAgD,GAAhD,CADkB,EAElB,GAFkB,CAAnB;AAIA,cAAMC,OAAO,CAACC,GAAR,CACLrB,cAAc,CAACsB,GAAf,CAAmB,MAAMC,KAAN,IAAe;AACjC,gBAAM;AAAE5B,YAAAA,IAAF;AAAQ3B,YAAAA,MAAR;AAAgBqC,YAAAA,OAAhB;AAAyBC,YAAAA;AAAzB,cAAoCiB,KAA1C;;AACA,cAAIC,MAAM,CAACC,QAAP,CAAgBpB,OAAhB,CAAJ,EAA8B;AAC7BkB,YAAAA,KAAK,CAACV,gBAAN,GAAyBtE,SAAzB;AACAgF,YAAAA,KAAK,CAACb,SAAN,GAAkBnE,SAAlB;AACA;AACA;;AACD,gBAAMmF,IAAI,GAAGpC,YAAY,CAACqC,UAAb,CACZrC,YAAY,CAACsC,iBAAb,CAA+B5D,MAA/B,CADY,EAEZpB,KAAK,CAACyB,IAAN,CAAWiC,MAAX,EAAmBa,IAAnB,CAAwB,GAAxB,CAFY,CAAb;AAIA,WAACI,KAAK,CAACV,gBAAP,EAAyBU,KAAK,CAACb,SAA/B,IACC,MAAMpB,YAAY,CAACuC,cAAb,CAA4BlC,IAA5B,EAAkC+B,IAAlC,EAAwC,MAAM;AACnD,kBAAMb,gBAAgB,GAAG,IAAIrE,GAAJ,EAAzB;AACA,gBAAIkE,SAAS,GAAG,IAAIlE,GAAJ,EAAhB;AACA,kBAAMsF,SAAS,GAAGzB,OAAO,CAAC0B,KAAR,CAAcf,UAAd,CAAlB;;AACA,gBAAIc,SAAJ,EAAe;AACd,mBAAK,MAAMhB,IAAX,IAAmBgB,SAAnB,EAA8B;AAC7B,oBAAIxB,MAAM,CAAC0B,GAAP,CAAWlB,IAAX,CAAJ,EAAsB;AACrBJ,kBAAAA,SAAS,CAAC3D,GAAV,CAAc+D,IAAd;AACA;AACA;;AACDD,gBAAAA,gBAAgB,CAAC9D,GAAjB,CAAqB+D,IAArB;AACA;AACD;;AACD,mBAAO,CAACD,gBAAD,EAAmBH,SAAnB,CAAP;AACA,WAdK,CADP;AAgBA,SA3BD,CADK,CAAN;;AA8BA,cAAMuB,eAAe,GAAGnB,IAAI,IAAI;AAC/B,gBAAMhB,MAAM,GAAGG,YAAY,CAAC/B,GAAb,CAAiB4C,IAAjB,CAAf;;AACA,cAAI,CAAChB,MAAL,EAAa;AACZ,kBAAMoC,iBAAiB,GAAGlC,cAAc,CAACmC,MAAf,CAAsBZ,KAAK,IACpDA,KAAK,CAACV,gBAAN,CAAuBmB,GAAvB,CAA2BlB,IAA3B,CADyB,CAA1B;AAGA,kBAAMsB,GAAG,GAAG,IAAIjG,YAAJ,CAAkB;AACrC;AACA,yDAAyD2E,IAAK;AAC9D;AACA;AACA,EAAEoB,iBAAiB,CACjBZ,GADA,CACIe,CAAC,IAAI;AACT,oBAAMN,KAAK,GAAG,IAAId,MAAJ,CAAY,UAASvD,SAAS,CAACoD,IAAD,CAAO,SAArC,EAA+CwB,IAA/C,CACbD,CAAC,CAAChC,OADW,CAAd;AAGA,qBAAQ,MAAKgC,CAAC,CAAC1C,IAAK,QAAOoC,KAAK,GAAGA,KAAK,CAAC,CAAD,CAAR,GAAc,KAAM,KAApD;AACA,aANA,EAOAZ,IAPA,CAOK,IAPL,CAOW,EAZM,CAAZ;AAaAzC,YAAAA,WAAW,CAAC6D,MAAZ,CAAmB9E,IAAnB,CAAwB2E,GAAxB;AACA,mBAAOjE,SAAP;AACA;;AACD,gBAAMmC,MAAM,GAAG,IAAI9D,GAAJ,EAAf;;AACA,eAAK,MAAM;AAAEqE,YAAAA,gBAAF;AAAoBH,YAAAA;AAApB,WAAX,IAA8CZ,MAA9C,EAAsD;AACrD,gBAAI,CAACY,SAAS,CAACsB,GAAV,CAAclB,IAAd,CAAL,EAA0B;AACzB,mBAAK,MAAMA,IAAX,IAAmBJ,SAAnB,EAA8B;AAC7BJ,gBAAAA,MAAM,CAACvD,GAAP,CAAW+D,IAAX;AACA;AACD;;AACD,iBAAK,MAAMA,IAAX,IAAmBD,gBAAnB,EAAqC;AACpCP,cAAAA,MAAM,CAACvD,GAAP,CAAW+D,IAAX;AACA;AACD;;AACD,iBAAOR,MAAP;AACA,SAlCD;;AAmCA,cAAMkC,QAAQ,GAAG1B,IAAI,IAAI;AACxB,gBAAMhB,MAAM,GAAGG,YAAY,CAAC/B,GAAb,CAAiB4C,IAAjB,CAAf;AACA,iBAAQ,GAAEA,IAAK,KAAIlE,KAAK,CAACyB,IAAN,CAAWyB,MAAX,EAAmBuC,CAAC,IAAIA,CAAC,CAAC1C,IAA1B,CAAgC,GAAnD;AACA,SAHD;;AAIA,cAAM8C,aAAa,GAAG,IAAIjG,GAAJ,EAAtB;;AACA,aAAK,MAAMsE,IAAX,IAAmBb,YAAY,CAACiB,IAAb,EAAnB,EAAwC;AACvC,gBAAMnE,GAAG,GAAG,CAAC+D,IAAD,EAAO4B,KAAP,KAAiB;AAC5B,kBAAMC,IAAI,GAAGV,eAAe,CAACnB,IAAD,CAA5B;AACA,gBAAI,CAAC6B,IAAL,EAAW;AACXD,YAAAA,KAAK,CAAC3F,GAAN,CAAU+D,IAAV;;AACA,iBAAK,MAAM8B,GAAX,IAAkBD,IAAlB,EAAwB;AACvB,kBAAIF,aAAa,CAACT,GAAd,CAAkBY,GAAlB,CAAJ,EAA4B;;AAC5B,kBAAIF,KAAK,CAACV,GAAN,CAAUY,GAAV,CAAJ,EAAoB;AACnB,sBAAM,IAAIC,KAAJ,CACJ,4BAA2BjG,KAAK,CAACyB,IAAN,CAC3BqE,KAD2B,EAE3BF,QAF2B,EAG1BrB,IAH0B,CAGrB,MAHqB,CAGb,OAAMqB,QAAQ,CAACI,GAAD,CAAM,EAJ9B,CAAN;AAMA;;AACD7F,cAAAA,GAAG,CAAC6F,GAAD,EAAMF,KAAN,CAAH;AACA;;AACDD,YAAAA,aAAa,CAAC1F,GAAd,CAAkB+D,IAAlB;AACA4B,YAAAA,KAAK,CAACI,MAAN,CAAahC,IAAb;AACA,WAlBD;;AAmBA,cAAI2B,aAAa,CAACT,GAAd,CAAkBlB,IAAlB,CAAJ,EAA6B;AAC7B/D,UAAAA,GAAG,CAAC+D,IAAD,EAAO,IAAItE,GAAJ,EAAP,CAAH;AACA;;AACD,cAAMuG,aAAa,GAAG,IAAI7C,GAAJ,EAAtB;;AACA,cAAM8C,OAAO,GAAGzB,KAAK,IACpB/B,aAAa,CAACmC,UAAd,CACCnC,aAAa,CAACoC,iBAAd,CAAgCL,KAAK,CAACvD,MAAtC,CADD,EAECpB,KAAK,CAACyB,IAAN,CAAWkD,KAAK,CAACV,gBAAjB,EAAmCC,IAAI,IACtCiC,aAAa,CAAC7E,GAAd,CAAkB4C,IAAlB,CADD,EAEEK,IAFF,CAEO,GAFP,CAFD,CADD;;AAOA,cAAM8B,iBAAiB,GAAG1B,KAAK,IAAI;AAClC,cAAIA,KAAK,CAACZ,qBAAV,EAAiC,OAAOY,KAAK,CAACZ,qBAAb;AACjC,iBAAQY,KAAK,CAACZ,qBAAN,GAA8B,CAAC,YAAY;AAClD,gBACCY,KAAK,CAACb,SAAN,CAAgBK,IAAhB,GAAuB,CAAvB,IACAnE,KAAK,CAACyB,IAAN,CAAWkD,KAAK,CAACV,gBAAjB,EAAmCqC,IAAnC,CACCpC,IAAI,IAAIiC,aAAa,CAAC7E,GAAd,CAAkB4C,IAAlB,MAA4BA,IADrC,CAFD,EAKE;AACD,oBAAMqC,UAAU,GAAG5B,KAAK,CAAC5B,IAAzB;AACA,oBAAM+B,IAAI,GAAGsB,OAAO,CAACzB,KAAD,CAApB;AACAA,cAAAA,KAAK,CAACnD,SAAN,GAAkB,MAAMoB,aAAa,CAACqC,cAAd,CACvBsB,UADuB,EAEvBzB,IAFuB,EAGvB,MAAM;AACL,sBAAM0B,UAAU,GAAG7B,KAAK,CAAClB,OAAN,CAAczC,OAAd,CAAsBoD,UAAtB,EAAkCF,IAAI,IACxDiC,aAAa,CAAC7E,GAAd,CAAkB4C,IAAlB,CADkB,CAAnB;AAGA,uBAAO,IAAI/E,SAAJ,CAAcqH,UAAd,CAAP;AACA,eARsB,CAAxB;AAUA;AACD,WApBqC,GAAtC;AAqBA,SAvBD;;AAwBA,cAAMC,2BAA2B,GAAG9B,KAAK,IAAI;AAC5C,cAAIA,KAAK,CAACX,+BAAV,EACC,OAAOW,KAAK,CAACX,+BAAb;AACD,iBAAQW,KAAK,CAACX,+BAAN,GAAwC,CAAC,YAAY;AAC5D,gBACCW,KAAK,CAACb,SAAN,CAAgBK,IAAhB,GAAuB,CAAvB,IACAnE,KAAK,CAACyB,IAAN,CAAWkD,KAAK,CAACV,gBAAjB,EAAmCqC,IAAnC,CACCpC,IAAI,IAAIiC,aAAa,CAAC7E,GAAd,CAAkB4C,IAAlB,MAA4BA,IADrC,CAFD,EAKE;AACD,oBAAMqC,UAAU,GAAG5B,KAAK,CAAC5B,IAAN,GAAa,cAAhC;AACA,oBAAM+B,IAAI,GAAGsB,OAAO,CAACzB,KAAD,CAApB;AACAA,cAAAA,KAAK,CAACd,mBAAN,GAA4B,MAAMjB,aAAa,CAACqC,cAAd,CACjCsB,UADiC,EAEjCzB,IAFiC,EAGjC,MAAM;AACL,sBAAM0B,UAAU,GAAG7B,KAAK,CAAClB,OAAN,CAAczC,OAAd,CAClBoD,UADkB,EAElBF,IAAI,IAAI;AACP,sBAAIS,KAAK,CAACb,SAAN,CAAgBsB,GAAhB,CAAoBlB,IAApB,CAAJ,EAA+B;AAC9B,2BAAO,EAAP;AACA;;AACD,yBAAOiC,aAAa,CAAC7E,GAAd,CAAkB4C,IAAlB,CAAP;AACA,iBAPiB,CAAnB;AASA,uBAAO,IAAI/E,SAAJ,CAAcqH,UAAd,CAAP;AACA,eAdgC,CAAlC;AAgBA;AACD,WA1B+C,GAAhD;AA2BA,SA9BD;;AA+BA,cAAME,UAAU,GAAGlH,aAAa,CAACiG,CAAC,IAAIA,CAAC,CAAC1C,IAAR,EAActD,cAAd,CAAhC;;AACA,aAAK,MAAMkH,OAAX,IAAsBd,aAAtB,EAAqC;AACpC,gBAAM3C,MAAM,GAAGG,YAAY,CAAC/B,GAAb,CAAiBqF,OAAjB,CAAf;AACAzD,UAAAA,MAAM,CAAC0D,IAAP,CAAYF,UAAZ;AACA,gBAAMxC,IAAI,GAAGxE,UAAU,CAAC,KAAK2C,aAAN,CAAvB;AACA,gBAAMmC,OAAO,CAACC,GAAR,CACLvB,MAAM,CAACwB,GAAP,CAAWC,KAAK,IACfA,KAAK,CAACb,SAAN,CAAgBsB,GAAhB,CAAoBuB,OAApB,IACGF,2BAA2B,CAAC9B,KAAD,CAD9B,GAEG0B,iBAAiB,CAAC1B,KAAD,CAHrB,CADK,CAAN;AAOA,gBAAMkC,aAAa,GAAGzG,wBAAwB,CAAC8C,MAAD,EAASyB,KAAK,IAAI;AAC/D,gBAAIA,KAAK,CAACb,SAAN,CAAgBsB,GAAhB,CAAoBuB,OAApB,CAAJ,EAAkC;AACjC,qBAAOhC,KAAK,CAACd,mBAAN,GACJc,KAAK,CAACd,mBAAN,CAA0BiD,MAA1B,EADI,GAEJnC,KAAK,CAACvD,MAAN,CAAa0F,MAAb,EAFH;AAGA,aAJD,MAIO;AACN,qBAAOnC,KAAK,CAACnD,SAAN,GACJmD,KAAK,CAACnD,SAAN,CAAgBsF,MAAhB,EADI,GAEJnC,KAAK,CAACvD,MAAN,CAAa0F,MAAb,EAFH;AAGA;AACD,WAV6C,CAA9C;AAWA,cAAIC,OAAO,GAAG/E,KAAK,CAACC,UAAN,CAAiB+E,IAAjB,CAAsBH,aAAtB,EAAqCF,OAArC,CAAd;;AACA,cAAI,CAACI,OAAL,EAAc;AACb,iBAAK,MAAMtD,OAAX,IAAsBoD,aAAtB,EAAqC;AACpC3C,cAAAA,IAAI,CAAC+C,MAAL,CAAYxD,OAAZ;AACA;;AACD,kBAAMyD,MAAM,GAAGhD,IAAI,CAACgD,MAAL,CAAY,KAAK5E,WAAjB,CAAf;AACAyE,YAAAA,OAAO;AAAG;AAAuBG,YAAAA,MAAM,CAACC,KAAP,CAAa,CAAb,EAAgBR,OAAO,CAACS,MAAxB,CAAjC;AACA;;AACDjB,UAAAA,aAAa,CAACzE,GAAd,CAAkBiF,OAAlB,EAA2BI,OAA3B;AACA;;AACD,cAAMvC,OAAO,CAACC,GAAR,CACLrB,cAAc,CAACsB,GAAf,CAAmB,MAAMC,KAAN,IAAe;AACjC,gBAAM0B,iBAAiB,CAAC1B,KAAD,CAAvB;AACA,gBAAM0C,OAAO,GAAG1C,KAAK,CAAC5B,IAAN,CAAW/B,OAAX,CAAmBoD,UAAnB,EAA+BF,IAAI,IAClDiC,aAAa,CAAC7E,GAAd,CAAkB4C,IAAlB,CADe,CAAhB;AAIA,gBAAMoD,UAAU,GAAG,EAAnB;AACA,gBAAMpD,IAAI,GAAGS,KAAK,CAACpB,IAAN,CAAWI,WAAxB;AACA2D,UAAAA,UAAU,CAAC3D,WAAX,GAAyB3D,KAAK,CAACC,OAAN,CAAciE,IAAd,IACtBA,IAAI,CAACQ,GAAL,CAASR,IAAI,IAAIiC,aAAa,CAAC7E,GAAd,CAAkB4C,IAAlB,CAAjB,CADsB,GAEtBiC,aAAa,CAAC7E,GAAd,CAAkB4C,IAAlB,CAFH;;AAIA,cAAIS,KAAK,CAACnD,SAAN,KAAoBD,SAAxB,EAAmC;AAClCO,YAAAA,WAAW,CAACyF,WAAZ,CACC5C,KAAK,CAAC5B,IADP,EAEC4B,KAAK,CAACnD,SAFP,EAGC8F,UAHD;AAKA,WAND,MAMO;AACNxF,YAAAA,WAAW,CAACyF,WAAZ,CAAwB5C,KAAK,CAAC5B,IAA9B,EAAoC4B,KAAK,CAACvD,MAA1C,EAAkDkG,UAAlD;AACA;;AAED,cAAI3C,KAAK,CAAC5B,IAAN,KAAesE,OAAnB,EAA4B;AAC3BvF,YAAAA,WAAW,CAAC0F,WAAZ,CAAwB7C,KAAK,CAAC5B,IAA9B,EAAoCsE,OAApC;AACA;AACD,SAzBD,CADK,CAAN;AA4BA,OAzQF;AA2QA,KAnRD;AAoRA;;AApT0B;;AAuT5BI,MAAM,CAACC,OAAP,GAAiB9F,qBAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { SyncBailHook } = require(\"tapable\");\nconst { RawSource, CachedSource, CompatSource } = require(\"webpack-sources\");\nconst Compilation = require(\"../Compilation\");\nconst WebpackError = require(\"../WebpackError\");\nconst { compareSelect, compareStrings } = require(\"../util/comparators\");\nconst createHash = require(\"../util/createHash\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nconst EMPTY_SET = new Set();\n\nconst addToList = (itemOrItems, list) => {\n\tif (Array.isArray(itemOrItems)) {\n\t\tfor (const item of itemOrItems) {\n\t\t\tlist.add(item);\n\t\t}\n\t} else if (itemOrItems) {\n\t\tlist.add(itemOrItems);\n\t}\n};\n\n/**\n * @template T\n * @param {T[]} input list\n * @param {function(T): Buffer} fn map function\n * @returns {Buffer[]} buffers without duplicates\n */\nconst mapAndDeduplicateBuffers = (input, fn) => {\n\t// Buffer.equals compares size first so this should be efficient enough\n\t// If it becomes a performance problem we can use a map and group by size\n\t// instead of looping over all assets.\n\tconst result = [];\n\touter: for (const value of input) {\n\t\tconst buf = fn(value);\n\t\tfor (const other of result) {\n\t\t\tif (buf.equals(other)) continue outer;\n\t\t}\n\t\tresult.push(buf);\n\t}\n\treturn result;\n};\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nconst quoteMeta = str => {\n\treturn str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\nconst cachedSourceMap = new WeakMap();\n\nconst toCachedSource = source => {\n\tif (source instanceof CachedSource) {\n\t\treturn source;\n\t}\n\tconst entry = cachedSourceMap.get(source);\n\tif (entry !== undefined) return entry;\n\tconst newSource = new CachedSource(CompatSource.from(source));\n\tcachedSourceMap.set(source, newSource);\n\treturn newSource;\n};\n\n/**\n * @typedef {Object} AssetInfoForRealContentHash\n * @property {string} name\n * @property {AssetInfo} info\n * @property {Source} source\n * @property {RawSource | undefined} newSource\n * @property {RawSource | undefined} newSourceWithoutOwn\n * @property {string} content\n * @property {Set<string>} ownHashes\n * @property {Promise} contentComputePromise\n * @property {Promise} contentComputeWithoutOwnPromise\n * @property {Set<string>} referencedHashes\n * @property {Set<string>} hashes\n */\n\n/**\n * @typedef {Object} CompilationHooks\n * @property {SyncBailHook<[Buffer[], string], string>} updateHash\n */\n\n/** @type {WeakMap<Compilation, CompilationHooks>} */\nconst compilationHooksMap = new WeakMap();\n\nclass RealContentHashPlugin {\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @returns {CompilationHooks} the attached hooks\n\t */\n\tstatic getCompilationHooks(compilation) {\n\t\tif (!(compilation instanceof Compilation)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t\"The 'compilation' argument must be an instance of Compilation\"\n\t\t\t);\n\t\t}\n\t\tlet hooks = compilationHooksMap.get(compilation);\n\t\tif (hooks === undefined) {\n\t\t\thooks = {\n\t\t\t\tupdateHash: new SyncBailHook([\"content\", \"oldHash\"])\n\t\t\t};\n\t\t\tcompilationHooksMap.set(compilation, hooks);\n\t\t}\n\t\treturn hooks;\n\t}\n\n\tconstructor({ hashFunction, hashDigest }) {\n\t\tthis._hashFunction = hashFunction;\n\t\tthis._hashDigest = hashDigest;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"RealContentHashPlugin\", compilation => {\n\t\t\tconst cacheAnalyse = compilation.getCache(\n\t\t\t\t\"RealContentHashPlugin|analyse\"\n\t\t\t);\n\t\t\tconst cacheGenerate = compilation.getCache(\n\t\t\t\t\"RealContentHashPlugin|generate\"\n\t\t\t);\n\t\t\tconst hooks = RealContentHashPlugin.getCompilationHooks(compilation);\n\t\t\tcompilation.hooks.processAssets.tapPromise(\n\t\t\t\t{\n\t\t\t\t\tname: \"RealContentHashPlugin\",\n\t\t\t\t\tstage: Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH\n\t\t\t\t},\n\t\t\t\tasync () => {\n\t\t\t\t\tconst assets = compilation.getAssets();\n\t\t\t\t\t/** @type {AssetInfoForRealContentHash[]} */\n\t\t\t\t\tconst assetsWithInfo = [];\n\t\t\t\t\tconst hashToAssets = new Map();\n\t\t\t\t\tfor (const { source, info, name } of assets) {\n\t\t\t\t\t\tconst cachedSource = toCachedSource(source);\n\t\t\t\t\t\tconst content = cachedSource.source();\n\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\tconst hashes = new Set();\n\t\t\t\t\t\taddToList(info.contenthash, hashes);\n\t\t\t\t\t\tconst data = {\n\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\tsource: cachedSource,\n\t\t\t\t\t\t\t/** @type {RawSource | undefined} */\n\t\t\t\t\t\t\tnewSource: undefined,\n\t\t\t\t\t\t\t/** @type {RawSource | undefined} */\n\t\t\t\t\t\t\tnewSourceWithoutOwn: undefined,\n\t\t\t\t\t\t\tcontent,\n\t\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\t\townHashes: undefined,\n\t\t\t\t\t\t\tcontentComputePromise: undefined,\n\t\t\t\t\t\t\tcontentComputeWithoutOwnPromise: undefined,\n\t\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\t\treferencedHashes: undefined,\n\t\t\t\t\t\t\thashes\n\t\t\t\t\t\t};\n\t\t\t\t\t\tassetsWithInfo.push(data);\n\t\t\t\t\t\tfor (const hash of hashes) {\n\t\t\t\t\t\t\tconst list = hashToAssets.get(hash);\n\t\t\t\t\t\t\tif (list === undefined) {\n\t\t\t\t\t\t\t\thashToAssets.set(hash, [data]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlist.push(data);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (hashToAssets.size === 0) return;\n\t\t\t\t\tconst hashRegExp = new RegExp(\n\t\t\t\t\t\tArray.from(hashToAssets.keys(), quoteMeta).join(\"|\"),\n\t\t\t\t\t\t\"g\"\n\t\t\t\t\t);\n\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\tassetsWithInfo.map(async asset => {\n\t\t\t\t\t\t\tconst { name, source, content, hashes } = asset;\n\t\t\t\t\t\t\tif (Buffer.isBuffer(content)) {\n\t\t\t\t\t\t\t\tasset.referencedHashes = EMPTY_SET;\n\t\t\t\t\t\t\t\tasset.ownHashes = EMPTY_SET;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst etag = cacheAnalyse.mergeEtags(\n\t\t\t\t\t\t\t\tcacheAnalyse.getLazyHashedEtag(source),\n\t\t\t\t\t\t\t\tArray.from(hashes).join(\"|\")\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t[asset.referencedHashes, asset.ownHashes] =\n\t\t\t\t\t\t\t\tawait cacheAnalyse.providePromise(name, etag, () => {\n\t\t\t\t\t\t\t\t\tconst referencedHashes = new Set();\n\t\t\t\t\t\t\t\t\tlet ownHashes = new Set();\n\t\t\t\t\t\t\t\t\tconst inContent = content.match(hashRegExp);\n\t\t\t\t\t\t\t\t\tif (inContent) {\n\t\t\t\t\t\t\t\t\t\tfor (const hash of inContent) {\n\t\t\t\t\t\t\t\t\t\t\tif (hashes.has(hash)) {\n\t\t\t\t\t\t\t\t\t\t\t\townHashes.add(hash);\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treferencedHashes.add(hash);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn [referencedHashes, ownHashes];\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t\tconst getDependencies = hash => {\n\t\t\t\t\t\tconst assets = hashToAssets.get(hash);\n\t\t\t\t\t\tif (!assets) {\n\t\t\t\t\t\t\tconst referencingAssets = assetsWithInfo.filter(asset =>\n\t\t\t\t\t\t\t\tasset.referencedHashes.has(hash)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst err = new WebpackError(`RealContentHashPlugin\nSome kind of unexpected caching problem occurred.\nAn asset was cached with a reference to another asset (${hash}) that's not in the compilation anymore.\nEither the asset was incorrectly cached, or the referenced asset should also be restored from cache.\nReferenced by:\n${referencingAssets\n\t.map(a => {\n\t\tconst match = new RegExp(`.{0,20}${quoteMeta(hash)}.{0,20}`).exec(\n\t\t\ta.content\n\t\t);\n\t\treturn ` - ${a.name}: ...${match ? match[0] : \"???\"}...`;\n\t})\n\t.join(\"\\n\")}`);\n\t\t\t\t\t\t\tcompilation.errors.push(err);\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst hashes = new Set();\n\t\t\t\t\t\tfor (const { referencedHashes, ownHashes } of assets) {\n\t\t\t\t\t\t\tif (!ownHashes.has(hash)) {\n\t\t\t\t\t\t\t\tfor (const hash of ownHashes) {\n\t\t\t\t\t\t\t\t\thashes.add(hash);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const hash of referencedHashes) {\n\t\t\t\t\t\t\t\thashes.add(hash);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn hashes;\n\t\t\t\t\t};\n\t\t\t\t\tconst hashInfo = hash => {\n\t\t\t\t\t\tconst assets = hashToAssets.get(hash);\n\t\t\t\t\t\treturn `${hash} (${Array.from(assets, a => a.name)})`;\n\t\t\t\t\t};\n\t\t\t\t\tconst hashesInOrder = new Set();\n\t\t\t\t\tfor (const hash of hashToAssets.keys()) {\n\t\t\t\t\t\tconst add = (hash, stack) => {\n\t\t\t\t\t\t\tconst deps = getDependencies(hash);\n\t\t\t\t\t\t\tif (!deps) return;\n\t\t\t\t\t\t\tstack.add(hash);\n\t\t\t\t\t\t\tfor (const dep of deps) {\n\t\t\t\t\t\t\t\tif (hashesInOrder.has(dep)) continue;\n\t\t\t\t\t\t\t\tif (stack.has(dep)) {\n\t\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\t`Circular hash dependency ${Array.from(\n\t\t\t\t\t\t\t\t\t\t\tstack,\n\t\t\t\t\t\t\t\t\t\t\thashInfo\n\t\t\t\t\t\t\t\t\t\t).join(\" -> \")} -> ${hashInfo(dep)}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tadd(dep, stack);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thashesInOrder.add(hash);\n\t\t\t\t\t\t\tstack.delete(hash);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (hashesInOrder.has(hash)) continue;\n\t\t\t\t\t\tadd(hash, new Set());\n\t\t\t\t\t}\n\t\t\t\t\tconst hashToNewHash = new Map();\n\t\t\t\t\tconst getEtag = asset =>\n\t\t\t\t\t\tcacheGenerate.mergeEtags(\n\t\t\t\t\t\t\tcacheGenerate.getLazyHashedEtag(asset.source),\n\t\t\t\t\t\t\tArray.from(asset.referencedHashes, hash =>\n\t\t\t\t\t\t\t\thashToNewHash.get(hash)\n\t\t\t\t\t\t\t).join(\"|\")\n\t\t\t\t\t\t);\n\t\t\t\t\tconst computeNewContent = asset => {\n\t\t\t\t\t\tif (asset.contentComputePromise) return asset.contentComputePromise;\n\t\t\t\t\t\treturn (asset.contentComputePromise = (async () => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tasset.ownHashes.size > 0 ||\n\t\t\t\t\t\t\t\tArray.from(asset.referencedHashes).some(\n\t\t\t\t\t\t\t\t\thash => hashToNewHash.get(hash) !== hash\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst identifier = asset.name;\n\t\t\t\t\t\t\t\tconst etag = getEtag(asset);\n\t\t\t\t\t\t\t\tasset.newSource = await cacheGenerate.providePromise(\n\t\t\t\t\t\t\t\t\tidentifier,\n\t\t\t\t\t\t\t\t\tetag,\n\t\t\t\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t\t\t\tconst newContent = asset.content.replace(hashRegExp, hash =>\n\t\t\t\t\t\t\t\t\t\t\thashToNewHash.get(hash)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\treturn new RawSource(newContent);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})());\n\t\t\t\t\t};\n\t\t\t\t\tconst computeNewContentWithoutOwn = asset => {\n\t\t\t\t\t\tif (asset.contentComputeWithoutOwnPromise)\n\t\t\t\t\t\t\treturn asset.contentComputeWithoutOwnPromise;\n\t\t\t\t\t\treturn (asset.contentComputeWithoutOwnPromise = (async () => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tasset.ownHashes.size > 0 ||\n\t\t\t\t\t\t\t\tArray.from(asset.referencedHashes).some(\n\t\t\t\t\t\t\t\t\thash => hashToNewHash.get(hash) !== hash\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst identifier = asset.name + \"|without-own\";\n\t\t\t\t\t\t\t\tconst etag = getEtag(asset);\n\t\t\t\t\t\t\t\tasset.newSourceWithoutOwn = await cacheGenerate.providePromise(\n\t\t\t\t\t\t\t\t\tidentifier,\n\t\t\t\t\t\t\t\t\tetag,\n\t\t\t\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t\t\t\tconst newContent = asset.content.replace(\n\t\t\t\t\t\t\t\t\t\t\thashRegExp,\n\t\t\t\t\t\t\t\t\t\t\thash => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (asset.ownHashes.has(hash)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\treturn hashToNewHash.get(hash);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\treturn new RawSource(newContent);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})());\n\t\t\t\t\t};\n\t\t\t\t\tconst comparator = compareSelect(a => a.name, compareStrings);\n\t\t\t\t\tfor (const oldHash of hashesInOrder) {\n\t\t\t\t\t\tconst assets = hashToAssets.get(oldHash);\n\t\t\t\t\t\tassets.sort(comparator);\n\t\t\t\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\t\tassets.map(asset =>\n\t\t\t\t\t\t\t\tasset.ownHashes.has(oldHash)\n\t\t\t\t\t\t\t\t\t? computeNewContentWithoutOwn(asset)\n\t\t\t\t\t\t\t\t\t: computeNewContent(asset)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst assetsContent = mapAndDeduplicateBuffers(assets, asset => {\n\t\t\t\t\t\t\tif (asset.ownHashes.has(oldHash)) {\n\t\t\t\t\t\t\t\treturn asset.newSourceWithoutOwn\n\t\t\t\t\t\t\t\t\t? asset.newSourceWithoutOwn.buffer()\n\t\t\t\t\t\t\t\t\t: asset.source.buffer();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn asset.newSource\n\t\t\t\t\t\t\t\t\t? asset.newSource.buffer()\n\t\t\t\t\t\t\t\t\t: asset.source.buffer();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tlet newHash = hooks.updateHash.call(assetsContent, oldHash);\n\t\t\t\t\t\tif (!newHash) {\n\t\t\t\t\t\t\tfor (const content of assetsContent) {\n\t\t\t\t\t\t\t\thash.update(content);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst digest = hash.digest(this._hashDigest);\n\t\t\t\t\t\t\tnewHash = /** @type {string} */ (digest.slice(0, oldHash.length));\n\t\t\t\t\t\t}\n\t\t\t\t\t\thashToNewHash.set(oldHash, newHash);\n\t\t\t\t\t}\n\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\tassetsWithInfo.map(async asset => {\n\t\t\t\t\t\t\tawait computeNewContent(asset);\n\t\t\t\t\t\t\tconst newName = asset.name.replace(hashRegExp, hash =>\n\t\t\t\t\t\t\t\thashToNewHash.get(hash)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tconst infoUpdate = {};\n\t\t\t\t\t\t\tconst hash = asset.info.contenthash;\n\t\t\t\t\t\t\tinfoUpdate.contenthash = Array.isArray(hash)\n\t\t\t\t\t\t\t\t? hash.map(hash => hashToNewHash.get(hash))\n\t\t\t\t\t\t\t\t: hashToNewHash.get(hash);\n\n\t\t\t\t\t\t\tif (asset.newSource !== undefined) {\n\t\t\t\t\t\t\t\tcompilation.updateAsset(\n\t\t\t\t\t\t\t\t\tasset.name,\n\t\t\t\t\t\t\t\t\tasset.newSource,\n\t\t\t\t\t\t\t\t\tinfoUpdate\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcompilation.updateAsset(asset.name, asset.source, infoUpdate);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (asset.name !== newName) {\n\t\t\t\t\t\t\t\tcompilation.renameAsset(asset.name, newName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = RealContentHashPlugin;\n"]},"metadata":{},"sourceType":"script"}