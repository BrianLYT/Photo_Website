{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Sergey Melyukov @smelukov\n*/\n\"use strict\";\n\nconst {\n  UsageState\n} = require(\"../ExportsInfo\");\n/** @typedef {import(\"estree\").Node} AnyNode */\n\n/** @typedef {import(\"../Dependency\")} Dependency */\n\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n\n/** @typedef {import(\"../ModuleGraphConnection\").ConnectionState} ConnectionState */\n\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @typedef {Map<TopLevelSymbol | null, Set<string | TopLevelSymbol> | true>} InnerGraph */\n\n/** @typedef {function(boolean | Set<string> | undefined): void} UsageCallback */\n\n/**\n * @typedef {Object} StateObject\n * @property {InnerGraph} innerGraph\n * @property {TopLevelSymbol=} currentTopLevelSymbol\n * @property {Map<TopLevelSymbol, Set<UsageCallback>>} usageCallbackMap\n */\n\n/** @typedef {false|StateObject} State */\n\n/** @type {WeakMap<ParserState, State>} */\n\n\nconst parserStateMap = new WeakMap();\nconst topLevelSymbolTag = Symbol(\"top level symbol\");\n/**\n * @param {ParserState} parserState parser state\n * @returns {State} state\n */\n\nfunction getState(parserState) {\n  return parserStateMap.get(parserState);\n}\n/**\n * @param {ParserState} parserState parser state\n * @returns {void}\n */\n\n\nexports.bailout = parserState => {\n  parserStateMap.set(parserState, false);\n};\n/**\n * @param {ParserState} parserState parser state\n * @returns {void}\n */\n\n\nexports.enable = parserState => {\n  const state = parserStateMap.get(parserState);\n\n  if (state === false) {\n    return;\n  }\n\n  parserStateMap.set(parserState, {\n    innerGraph: new Map(),\n    currentTopLevelSymbol: undefined,\n    usageCallbackMap: new Map()\n  });\n};\n/**\n * @param {ParserState} parserState parser state\n * @returns {boolean} true, when enabled\n */\n\n\nexports.isEnabled = parserState => {\n  const state = parserStateMap.get(parserState);\n  return !!state;\n};\n/**\n * @param {ParserState} state parser state\n * @param {TopLevelSymbol | null} symbol the symbol, or null for all symbols\n * @param {string | TopLevelSymbol | true} usage usage data\n * @returns {void}\n */\n\n\nexports.addUsage = (state, symbol, usage) => {\n  const innerGraphState = getState(state);\n\n  if (innerGraphState) {\n    const {\n      innerGraph\n    } = innerGraphState;\n    const info = innerGraph.get(symbol);\n\n    if (usage === true) {\n      innerGraph.set(symbol, true);\n    } else if (info === undefined) {\n      innerGraph.set(symbol, new Set([usage]));\n    } else if (info !== true) {\n      info.add(usage);\n    }\n  }\n};\n/**\n * @param {JavascriptParser} parser the parser\n * @param {string} name name of variable\n * @param {string | TopLevelSymbol | true} usage usage data\n * @returns {void}\n */\n\n\nexports.addVariableUsage = (parser, name, usage) => {\n  const symbol =\n  /** @type {TopLevelSymbol} */\n  parser.getTagData(name, topLevelSymbolTag) || exports.tagTopLevelSymbol(parser, name);\n\n  if (symbol) {\n    exports.addUsage(parser.state, symbol, usage);\n  }\n};\n/**\n * @param {ParserState} state parser state\n * @returns {void}\n */\n\n\nexports.inferDependencyUsage = state => {\n  const innerGraphState = getState(state);\n\n  if (!innerGraphState) {\n    return;\n  }\n\n  const {\n    innerGraph,\n    usageCallbackMap\n  } = innerGraphState;\n  const processed = new Map(); // flatten graph to terminal nodes (string, undefined or true)\n\n  const nonTerminal = new Set(innerGraph.keys());\n\n  while (nonTerminal.size > 0) {\n    for (const key of nonTerminal) {\n      /** @type {Set<string|TopLevelSymbol> | true} */\n      let newSet = new Set();\n      let isTerminal = true;\n      const value = innerGraph.get(key);\n      let alreadyProcessed = processed.get(key);\n\n      if (alreadyProcessed === undefined) {\n        alreadyProcessed = new Set();\n        processed.set(key, alreadyProcessed);\n      }\n\n      if (value !== true && value !== undefined) {\n        for (const item of value) {\n          alreadyProcessed.add(item);\n        }\n\n        for (const item of value) {\n          if (typeof item === \"string\") {\n            newSet.add(item);\n          } else {\n            const itemValue = innerGraph.get(item);\n\n            if (itemValue === true) {\n              newSet = true;\n              break;\n            }\n\n            if (itemValue !== undefined) {\n              for (const i of itemValue) {\n                if (i === key) continue;\n                if (alreadyProcessed.has(i)) continue;\n                newSet.add(i);\n\n                if (typeof i !== \"string\") {\n                  isTerminal = false;\n                }\n              }\n            }\n          }\n        }\n\n        if (newSet === true) {\n          innerGraph.set(key, true);\n        } else if (newSet.size === 0) {\n          innerGraph.set(key, undefined);\n        } else {\n          innerGraph.set(key, newSet);\n        }\n      }\n\n      if (isTerminal) {\n        nonTerminal.delete(key); // For the global key, merge with all other keys\n\n        if (key === null) {\n          const globalValue = innerGraph.get(null);\n\n          if (globalValue) {\n            for (const [key, value] of innerGraph) {\n              if (key !== null && value !== true) {\n                if (globalValue === true) {\n                  innerGraph.set(key, true);\n                } else {\n                  const newSet = new Set(value);\n\n                  for (const item of globalValue) {\n                    newSet.add(item);\n                  }\n\n                  innerGraph.set(key, newSet);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  /** @type {Map<Dependency, true | Set<string>>} */\n\n\n  for (const [symbol, callbacks] of usageCallbackMap) {\n    const usage =\n    /** @type {true | Set<string> | undefined} */\n    innerGraph.get(symbol);\n\n    for (const callback of callbacks) {\n      callback(usage === undefined ? false : usage);\n    }\n  }\n};\n/**\n * @param {ParserState} state parser state\n * @param {UsageCallback} onUsageCallback on usage callback\n */\n\n\nexports.onUsage = (state, onUsageCallback) => {\n  const innerGraphState = getState(state);\n\n  if (innerGraphState) {\n    const {\n      usageCallbackMap,\n      currentTopLevelSymbol\n    } = innerGraphState;\n\n    if (currentTopLevelSymbol) {\n      let callbacks = usageCallbackMap.get(currentTopLevelSymbol);\n\n      if (callbacks === undefined) {\n        callbacks = new Set();\n        usageCallbackMap.set(currentTopLevelSymbol, callbacks);\n      }\n\n      callbacks.add(onUsageCallback);\n    } else {\n      onUsageCallback(true);\n    }\n  } else {\n    onUsageCallback(undefined);\n  }\n};\n/**\n * @param {ParserState} state parser state\n * @param {TopLevelSymbol} symbol the symbol\n */\n\n\nexports.setTopLevelSymbol = (state, symbol) => {\n  const innerGraphState = getState(state);\n\n  if (innerGraphState) {\n    innerGraphState.currentTopLevelSymbol = symbol;\n  }\n};\n/**\n * @param {ParserState} state parser state\n * @returns {TopLevelSymbol|void} usage data\n */\n\n\nexports.getTopLevelSymbol = state => {\n  const innerGraphState = getState(state);\n\n  if (innerGraphState) {\n    return innerGraphState.currentTopLevelSymbol;\n  }\n};\n/**\n * @param {JavascriptParser} parser parser\n * @param {string} name name of variable\n * @returns {TopLevelSymbol} symbol\n */\n\n\nexports.tagTopLevelSymbol = (parser, name) => {\n  const innerGraphState = getState(parser.state);\n  if (!innerGraphState) return;\n  parser.defineVariable(name);\n  const existingTag =\n  /** @type {TopLevelSymbol} */\n  parser.getTagData(name, topLevelSymbolTag);\n\n  if (existingTag) {\n    return existingTag;\n  }\n\n  const fn = new TopLevelSymbol(name);\n  parser.tagVariable(name, topLevelSymbolTag, fn);\n  return fn;\n};\n/**\n * @param {Dependency} dependency the dependency\n * @param {Set<string> | boolean} usedByExports usedByExports info\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @param {RuntimeSpec} runtime runtime\n * @returns {boolean} false, when unused. Otherwise true\n */\n\n\nexports.isDependencyUsedByExports = (dependency, usedByExports, moduleGraph, runtime) => {\n  if (usedByExports === false) return false;\n\n  if (usedByExports !== true && usedByExports !== undefined) {\n    const selfModule = moduleGraph.getParentModule(dependency);\n    const exportsInfo = moduleGraph.getExportsInfo(selfModule);\n    let used = false;\n\n    for (const exportName of usedByExports) {\n      if (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused) used = true;\n    }\n\n    if (!used) return false;\n  }\n\n  return true;\n};\n/**\n * @param {Dependency} dependency the dependency\n * @param {Set<string> | boolean} usedByExports usedByExports info\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @returns {null | false | function(ModuleGraphConnection, RuntimeSpec): ConnectionState} function to determine if the connection is active\n */\n\n\nexports.getDependencyUsedByExportsCondition = (dependency, usedByExports, moduleGraph) => {\n  if (usedByExports === false) return false;\n\n  if (usedByExports !== true && usedByExports !== undefined) {\n    const selfModule = moduleGraph.getParentModule(dependency);\n    const exportsInfo = moduleGraph.getExportsInfo(selfModule);\n    return (connections, runtime) => {\n      for (const exportName of usedByExports) {\n        if (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused) return true;\n      }\n\n      return false;\n    };\n  }\n\n  return null;\n};\n\nclass TopLevelSymbol {\n  /**\n   * @param {string} name name of the variable\n   */\n  constructor(name) {\n    this.name = name;\n  }\n\n}\n\nexports.TopLevelSymbol = TopLevelSymbol;\nexports.topLevelSymbolTag = topLevelSymbolTag;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/optimize/InnerGraph.js"],"names":["UsageState","require","parserStateMap","WeakMap","topLevelSymbolTag","Symbol","getState","parserState","get","exports","bailout","set","enable","state","innerGraph","Map","currentTopLevelSymbol","undefined","usageCallbackMap","isEnabled","addUsage","symbol","usage","innerGraphState","info","Set","add","addVariableUsage","parser","name","getTagData","tagTopLevelSymbol","inferDependencyUsage","processed","nonTerminal","keys","size","key","newSet","isTerminal","value","alreadyProcessed","item","itemValue","i","has","delete","globalValue","callbacks","callback","onUsage","onUsageCallback","setTopLevelSymbol","getTopLevelSymbol","defineVariable","existingTag","fn","TopLevelSymbol","tagVariable","isDependencyUsedByExports","dependency","usedByExports","moduleGraph","runtime","selfModule","getParentModule","exportsInfo","getExportsInfo","used","exportName","getUsed","Unused","getDependencyUsedByExportsCondition","connections","constructor"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Sergey Melyukov @smelukov\n*/\n\n\"use strict\";\n\nconst { UsageState } = require(\"../ExportsInfo\");\n\n/** @typedef {import(\"estree\").Node} AnyNode */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n/** @typedef {import(\"../ModuleGraphConnection\").ConnectionState} ConnectionState */\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @typedef {Map<TopLevelSymbol | null, Set<string | TopLevelSymbol> | true>} InnerGraph */\n/** @typedef {function(boolean | Set<string> | undefined): void} UsageCallback */\n\n/**\n * @typedef {Object} StateObject\n * @property {InnerGraph} innerGraph\n * @property {TopLevelSymbol=} currentTopLevelSymbol\n * @property {Map<TopLevelSymbol, Set<UsageCallback>>} usageCallbackMap\n */\n\n/** @typedef {false|StateObject} State */\n\n/** @type {WeakMap<ParserState, State>} */\nconst parserStateMap = new WeakMap();\nconst topLevelSymbolTag = Symbol(\"top level symbol\");\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {State} state\n */\nfunction getState(parserState) {\n\treturn parserStateMap.get(parserState);\n}\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {void}\n */\nexports.bailout = parserState => {\n\tparserStateMap.set(parserState, false);\n};\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {void}\n */\nexports.enable = parserState => {\n\tconst state = parserStateMap.get(parserState);\n\tif (state === false) {\n\t\treturn;\n\t}\n\tparserStateMap.set(parserState, {\n\t\tinnerGraph: new Map(),\n\t\tcurrentTopLevelSymbol: undefined,\n\t\tusageCallbackMap: new Map()\n\t});\n};\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {boolean} true, when enabled\n */\nexports.isEnabled = parserState => {\n\tconst state = parserStateMap.get(parserState);\n\treturn !!state;\n};\n\n/**\n * @param {ParserState} state parser state\n * @param {TopLevelSymbol | null} symbol the symbol, or null for all symbols\n * @param {string | TopLevelSymbol | true} usage usage data\n * @returns {void}\n */\nexports.addUsage = (state, symbol, usage) => {\n\tconst innerGraphState = getState(state);\n\n\tif (innerGraphState) {\n\t\tconst { innerGraph } = innerGraphState;\n\t\tconst info = innerGraph.get(symbol);\n\t\tif (usage === true) {\n\t\t\tinnerGraph.set(symbol, true);\n\t\t} else if (info === undefined) {\n\t\t\tinnerGraph.set(symbol, new Set([usage]));\n\t\t} else if (info !== true) {\n\t\t\tinfo.add(usage);\n\t\t}\n\t}\n};\n\n/**\n * @param {JavascriptParser} parser the parser\n * @param {string} name name of variable\n * @param {string | TopLevelSymbol | true} usage usage data\n * @returns {void}\n */\nexports.addVariableUsage = (parser, name, usage) => {\n\tconst symbol =\n\t\t/** @type {TopLevelSymbol} */ (\n\t\t\tparser.getTagData(name, topLevelSymbolTag)\n\t\t) || exports.tagTopLevelSymbol(parser, name);\n\tif (symbol) {\n\t\texports.addUsage(parser.state, symbol, usage);\n\t}\n};\n\n/**\n * @param {ParserState} state parser state\n * @returns {void}\n */\nexports.inferDependencyUsage = state => {\n\tconst innerGraphState = getState(state);\n\n\tif (!innerGraphState) {\n\t\treturn;\n\t}\n\n\tconst { innerGraph, usageCallbackMap } = innerGraphState;\n\tconst processed = new Map();\n\t// flatten graph to terminal nodes (string, undefined or true)\n\tconst nonTerminal = new Set(innerGraph.keys());\n\twhile (nonTerminal.size > 0) {\n\t\tfor (const key of nonTerminal) {\n\t\t\t/** @type {Set<string|TopLevelSymbol> | true} */\n\t\t\tlet newSet = new Set();\n\t\t\tlet isTerminal = true;\n\t\t\tconst value = innerGraph.get(key);\n\t\t\tlet alreadyProcessed = processed.get(key);\n\t\t\tif (alreadyProcessed === undefined) {\n\t\t\t\talreadyProcessed = new Set();\n\t\t\t\tprocessed.set(key, alreadyProcessed);\n\t\t\t}\n\t\t\tif (value !== true && value !== undefined) {\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\talreadyProcessed.add(item);\n\t\t\t\t}\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\tif (typeof item === \"string\") {\n\t\t\t\t\t\tnewSet.add(item);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst itemValue = innerGraph.get(item);\n\t\t\t\t\t\tif (itemValue === true) {\n\t\t\t\t\t\t\tnewSet = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (itemValue !== undefined) {\n\t\t\t\t\t\t\tfor (const i of itemValue) {\n\t\t\t\t\t\t\t\tif (i === key) continue;\n\t\t\t\t\t\t\t\tif (alreadyProcessed.has(i)) continue;\n\t\t\t\t\t\t\t\tnewSet.add(i);\n\t\t\t\t\t\t\t\tif (typeof i !== \"string\") {\n\t\t\t\t\t\t\t\t\tisTerminal = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (newSet === true) {\n\t\t\t\t\tinnerGraph.set(key, true);\n\t\t\t\t} else if (newSet.size === 0) {\n\t\t\t\t\tinnerGraph.set(key, undefined);\n\t\t\t\t} else {\n\t\t\t\t\tinnerGraph.set(key, newSet);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isTerminal) {\n\t\t\t\tnonTerminal.delete(key);\n\n\t\t\t\t// For the global key, merge with all other keys\n\t\t\t\tif (key === null) {\n\t\t\t\t\tconst globalValue = innerGraph.get(null);\n\t\t\t\t\tif (globalValue) {\n\t\t\t\t\t\tfor (const [key, value] of innerGraph) {\n\t\t\t\t\t\t\tif (key !== null && value !== true) {\n\t\t\t\t\t\t\t\tif (globalValue === true) {\n\t\t\t\t\t\t\t\t\tinnerGraph.set(key, true);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst newSet = new Set(value);\n\t\t\t\t\t\t\t\t\tfor (const item of globalValue) {\n\t\t\t\t\t\t\t\t\t\tnewSet.add(item);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tinnerGraph.set(key, newSet);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @type {Map<Dependency, true | Set<string>>} */\n\tfor (const [symbol, callbacks] of usageCallbackMap) {\n\t\tconst usage = /** @type {true | Set<string> | undefined} */ (\n\t\t\tinnerGraph.get(symbol)\n\t\t);\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback(usage === undefined ? false : usage);\n\t\t}\n\t}\n};\n\n/**\n * @param {ParserState} state parser state\n * @param {UsageCallback} onUsageCallback on usage callback\n */\nexports.onUsage = (state, onUsageCallback) => {\n\tconst innerGraphState = getState(state);\n\n\tif (innerGraphState) {\n\t\tconst { usageCallbackMap, currentTopLevelSymbol } = innerGraphState;\n\t\tif (currentTopLevelSymbol) {\n\t\t\tlet callbacks = usageCallbackMap.get(currentTopLevelSymbol);\n\n\t\t\tif (callbacks === undefined) {\n\t\t\t\tcallbacks = new Set();\n\t\t\t\tusageCallbackMap.set(currentTopLevelSymbol, callbacks);\n\t\t\t}\n\n\t\t\tcallbacks.add(onUsageCallback);\n\t\t} else {\n\t\t\tonUsageCallback(true);\n\t\t}\n\t} else {\n\t\tonUsageCallback(undefined);\n\t}\n};\n\n/**\n * @param {ParserState} state parser state\n * @param {TopLevelSymbol} symbol the symbol\n */\nexports.setTopLevelSymbol = (state, symbol) => {\n\tconst innerGraphState = getState(state);\n\n\tif (innerGraphState) {\n\t\tinnerGraphState.currentTopLevelSymbol = symbol;\n\t}\n};\n\n/**\n * @param {ParserState} state parser state\n * @returns {TopLevelSymbol|void} usage data\n */\nexports.getTopLevelSymbol = state => {\n\tconst innerGraphState = getState(state);\n\n\tif (innerGraphState) {\n\t\treturn innerGraphState.currentTopLevelSymbol;\n\t}\n};\n\n/**\n * @param {JavascriptParser} parser parser\n * @param {string} name name of variable\n * @returns {TopLevelSymbol} symbol\n */\nexports.tagTopLevelSymbol = (parser, name) => {\n\tconst innerGraphState = getState(parser.state);\n\tif (!innerGraphState) return;\n\n\tparser.defineVariable(name);\n\n\tconst existingTag = /** @type {TopLevelSymbol} */ (\n\t\tparser.getTagData(name, topLevelSymbolTag)\n\t);\n\tif (existingTag) {\n\t\treturn existingTag;\n\t}\n\n\tconst fn = new TopLevelSymbol(name);\n\tparser.tagVariable(name, topLevelSymbolTag, fn);\n\treturn fn;\n};\n\n/**\n * @param {Dependency} dependency the dependency\n * @param {Set<string> | boolean} usedByExports usedByExports info\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @param {RuntimeSpec} runtime runtime\n * @returns {boolean} false, when unused. Otherwise true\n */\nexports.isDependencyUsedByExports = (\n\tdependency,\n\tusedByExports,\n\tmoduleGraph,\n\truntime\n) => {\n\tif (usedByExports === false) return false;\n\tif (usedByExports !== true && usedByExports !== undefined) {\n\t\tconst selfModule = moduleGraph.getParentModule(dependency);\n\t\tconst exportsInfo = moduleGraph.getExportsInfo(selfModule);\n\t\tlet used = false;\n\t\tfor (const exportName of usedByExports) {\n\t\t\tif (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused)\n\t\t\t\tused = true;\n\t\t}\n\t\tif (!used) return false;\n\t}\n\treturn true;\n};\n\n/**\n * @param {Dependency} dependency the dependency\n * @param {Set<string> | boolean} usedByExports usedByExports info\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @returns {null | false | function(ModuleGraphConnection, RuntimeSpec): ConnectionState} function to determine if the connection is active\n */\nexports.getDependencyUsedByExportsCondition = (\n\tdependency,\n\tusedByExports,\n\tmoduleGraph\n) => {\n\tif (usedByExports === false) return false;\n\tif (usedByExports !== true && usedByExports !== undefined) {\n\t\tconst selfModule = moduleGraph.getParentModule(dependency);\n\t\tconst exportsInfo = moduleGraph.getExportsInfo(selfModule);\n\t\treturn (connections, runtime) => {\n\t\t\tfor (const exportName of usedByExports) {\n\t\t\t\tif (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t}\n\treturn null;\n};\n\nclass TopLevelSymbol {\n\t/**\n\t * @param {string} name name of the variable\n\t */\n\tconstructor(name) {\n\t\tthis.name = name;\n\t}\n}\n\nexports.TopLevelSymbol = TopLevelSymbol;\nexports.topLevelSymbolTag = topLevelSymbolTag;\n"]},"metadata":{},"sourceType":"script"}