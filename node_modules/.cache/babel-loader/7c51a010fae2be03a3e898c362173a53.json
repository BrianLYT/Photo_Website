{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  forEachBail\n} = require(\"enhanced-resolve\");\n\nconst asyncLib = require(\"neo-async\");\n\nconst getLazyHashedEtag = require(\"./cache/getLazyHashedEtag\");\n\nconst mergeEtags = require(\"./cache/mergeEtags\");\n/** @typedef {import(\"./Cache\")} Cache */\n\n/** @typedef {import(\"./Cache\").Etag} Etag */\n\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n\n/** @typedef {import(\"./cache/getLazyHashedEtag\").HashableObject} HashableObject */\n\n/** @typedef {typeof import(\"./util/Hash\")} HashConstructor */\n\n/**\n * @template T\n * @callback CallbackCache\n * @param {(WebpackError | null)=} err\n * @param {T=} result\n * @returns {void}\n */\n\n/**\n * @template T\n * @callback CallbackNormalErrorCache\n * @param {(Error | null)=} err\n * @param {T=} result\n * @returns {void}\n */\n\n\nclass MultiItemCache {\n  /**\n   * @param {ItemCacheFacade[]} items item caches\n   */\n  constructor(items) {\n    this._items = items;\n    if (items.length === 1) return (\n      /** @type {any} */\n      items[0]\n    );\n  }\n  /**\n   * @template T\n   * @param {CallbackCache<T>} callback signals when the value is retrieved\n   * @returns {void}\n   */\n\n\n  get(callback) {\n    forEachBail(this._items, (item, callback) => item.get(callback), callback);\n  }\n  /**\n   * @template T\n   * @returns {Promise<T>} promise with the data\n   */\n\n\n  getPromise() {\n    const next = i => {\n      return this._items[i].getPromise().then(result => {\n        if (result !== undefined) return result;\n        if (++i < this._items.length) return next(i);\n      });\n    };\n\n    return next(0);\n  }\n  /**\n   * @template T\n   * @param {T} data the value to store\n   * @param {CallbackCache<void>} callback signals when the value is stored\n   * @returns {void}\n   */\n\n\n  store(data, callback) {\n    asyncLib.each(this._items, (item, callback) => item.store(data, callback), callback);\n  }\n  /**\n   * @template T\n   * @param {T} data the value to store\n   * @returns {Promise<void>} promise signals when the value is stored\n   */\n\n\n  storePromise(data) {\n    return Promise.all(this._items.map(item => item.storePromise(data))).then(() => {});\n  }\n\n}\n\nclass ItemCacheFacade {\n  /**\n   * @param {Cache} cache the root cache\n   * @param {string} name the child cache item name\n   * @param {Etag | null} etag the etag\n   */\n  constructor(cache, name, etag) {\n    this._cache = cache;\n    this._name = name;\n    this._etag = etag;\n  }\n  /**\n   * @template T\n   * @param {CallbackCache<T>} callback signals when the value is retrieved\n   * @returns {void}\n   */\n\n\n  get(callback) {\n    this._cache.get(this._name, this._etag, callback);\n  }\n  /**\n   * @template T\n   * @returns {Promise<T>} promise with the data\n   */\n\n\n  getPromise() {\n    return new Promise((resolve, reject) => {\n      this._cache.get(this._name, this._etag, (err, data) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(data);\n        }\n      });\n    });\n  }\n  /**\n   * @template T\n   * @param {T} data the value to store\n   * @param {CallbackCache<void>} callback signals when the value is stored\n   * @returns {void}\n   */\n\n\n  store(data, callback) {\n    this._cache.store(this._name, this._etag, data, callback);\n  }\n  /**\n   * @template T\n   * @param {T} data the value to store\n   * @returns {Promise<void>} promise signals when the value is stored\n   */\n\n\n  storePromise(data) {\n    return new Promise((resolve, reject) => {\n      this._cache.store(this._name, this._etag, data, err => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n  /**\n   * @template T\n   * @param {function(CallbackNormalErrorCache<T>): void} computer function to compute the value if not cached\n   * @param {CallbackNormalErrorCache<T>} callback signals when the value is retrieved\n   * @returns {void}\n   */\n\n\n  provide(computer, callback) {\n    this.get((err, cacheEntry) => {\n      if (err) return callback(err);\n      if (cacheEntry !== undefined) return cacheEntry;\n      computer((err, result) => {\n        if (err) return callback(err);\n        this.store(result, err => {\n          if (err) return callback(err);\n          callback(null, result);\n        });\n      });\n    });\n  }\n  /**\n   * @template T\n   * @param {function(): Promise<T> | T} computer function to compute the value if not cached\n   * @returns {Promise<T>} promise with the data\n   */\n\n\n  async providePromise(computer) {\n    const cacheEntry = await this.getPromise();\n    if (cacheEntry !== undefined) return cacheEntry;\n    const result = await computer();\n    await this.storePromise(result);\n    return result;\n  }\n\n}\n\nclass CacheFacade {\n  /**\n   * @param {Cache} cache the root cache\n   * @param {string} name the child cache name\n   * @param {string | HashConstructor} hashFunction the hash function to use\n   */\n  constructor(cache, name, hashFunction) {\n    this._cache = cache;\n    this._name = name;\n    this._hashFunction = hashFunction;\n  }\n  /**\n   * @param {string} name the child cache name#\n   * @returns {CacheFacade} child cache\n   */\n\n\n  getChildCache(name) {\n    return new CacheFacade(this._cache, `${this._name}|${name}`, this._hashFunction);\n  }\n  /**\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @returns {ItemCacheFacade} item cache\n   */\n\n\n  getItemCache(identifier, etag) {\n    return new ItemCacheFacade(this._cache, `${this._name}|${identifier}`, etag);\n  }\n  /**\n   * @param {HashableObject} obj an hashable object\n   * @returns {Etag} an etag that is lazy hashed\n   */\n\n\n  getLazyHashedEtag(obj) {\n    return getLazyHashedEtag(obj, this._hashFunction);\n  }\n  /**\n   * @param {Etag} a an etag\n   * @param {Etag} b another etag\n   * @returns {Etag} an etag that represents both\n   */\n\n\n  mergeEtags(a, b) {\n    return mergeEtags(a, b);\n  }\n  /**\n   * @template T\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @param {CallbackCache<T>} callback signals when the value is retrieved\n   * @returns {void}\n   */\n\n\n  get(identifier, etag, callback) {\n    this._cache.get(`${this._name}|${identifier}`, etag, callback);\n  }\n  /**\n   * @template T\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @returns {Promise<T>} promise with the data\n   */\n\n\n  getPromise(identifier, etag) {\n    return new Promise((resolve, reject) => {\n      this._cache.get(`${this._name}|${identifier}`, etag, (err, data) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(data);\n        }\n      });\n    });\n  }\n  /**\n   * @template T\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @param {T} data the value to store\n   * @param {CallbackCache<void>} callback signals when the value is stored\n   * @returns {void}\n   */\n\n\n  store(identifier, etag, data, callback) {\n    this._cache.store(`${this._name}|${identifier}`, etag, data, callback);\n  }\n  /**\n   * @template T\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @param {T} data the value to store\n   * @returns {Promise<void>} promise signals when the value is stored\n   */\n\n\n  storePromise(identifier, etag, data) {\n    return new Promise((resolve, reject) => {\n      this._cache.store(`${this._name}|${identifier}`, etag, data, err => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n  /**\n   * @template T\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @param {function(CallbackNormalErrorCache<T>): void} computer function to compute the value if not cached\n   * @param {CallbackNormalErrorCache<T>} callback signals when the value is retrieved\n   * @returns {void}\n   */\n\n\n  provide(identifier, etag, computer, callback) {\n    this.get(identifier, etag, (err, cacheEntry) => {\n      if (err) return callback(err);\n      if (cacheEntry !== undefined) return cacheEntry;\n      computer((err, result) => {\n        if (err) return callback(err);\n        this.store(identifier, etag, result, err => {\n          if (err) return callback(err);\n          callback(null, result);\n        });\n      });\n    });\n  }\n  /**\n   * @template T\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @param {function(): Promise<T> | T} computer function to compute the value if not cached\n   * @returns {Promise<T>} promise with the data\n   */\n\n\n  async providePromise(identifier, etag, computer) {\n    const cacheEntry = await this.getPromise(identifier, etag);\n    if (cacheEntry !== undefined) return cacheEntry;\n    const result = await computer();\n    await this.storePromise(identifier, etag, result);\n    return result;\n  }\n\n}\n\nmodule.exports = CacheFacade;\nmodule.exports.ItemCacheFacade = ItemCacheFacade;\nmodule.exports.MultiItemCache = MultiItemCache;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/CacheFacade.js"],"names":["forEachBail","require","asyncLib","getLazyHashedEtag","mergeEtags","MultiItemCache","constructor","items","_items","length","get","callback","item","getPromise","next","i","then","result","undefined","store","data","each","storePromise","Promise","all","map","ItemCacheFacade","cache","name","etag","_cache","_name","_etag","resolve","reject","err","provide","computer","cacheEntry","providePromise","CacheFacade","hashFunction","_hashFunction","getChildCache","getItemCache","identifier","obj","a","b","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { forEachBail } = require(\"enhanced-resolve\");\nconst asyncLib = require(\"neo-async\");\nconst getLazyHashedEtag = require(\"./cache/getLazyHashedEtag\");\nconst mergeEtags = require(\"./cache/mergeEtags\");\n\n/** @typedef {import(\"./Cache\")} Cache */\n/** @typedef {import(\"./Cache\").Etag} Etag */\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n/** @typedef {import(\"./cache/getLazyHashedEtag\").HashableObject} HashableObject */\n/** @typedef {typeof import(\"./util/Hash\")} HashConstructor */\n\n/**\n * @template T\n * @callback CallbackCache\n * @param {(WebpackError | null)=} err\n * @param {T=} result\n * @returns {void}\n */\n\n/**\n * @template T\n * @callback CallbackNormalErrorCache\n * @param {(Error | null)=} err\n * @param {T=} result\n * @returns {void}\n */\n\nclass MultiItemCache {\n\t/**\n\t * @param {ItemCacheFacade[]} items item caches\n\t */\n\tconstructor(items) {\n\t\tthis._items = items;\n\t\tif (items.length === 1) return /** @type {any} */ (items[0]);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {CallbackCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tget(callback) {\n\t\tforEachBail(this._items, (item, callback) => item.get(callback), callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tgetPromise() {\n\t\tconst next = i => {\n\t\t\treturn this._items[i].getPromise().then(result => {\n\t\t\t\tif (result !== undefined) return result;\n\t\t\t\tif (++i < this._items.length) return next(i);\n\t\t\t});\n\t\t};\n\t\treturn next(0);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {T} data the value to store\n\t * @param {CallbackCache<void>} callback signals when the value is stored\n\t * @returns {void}\n\t */\n\tstore(data, callback) {\n\t\tasyncLib.each(\n\t\t\tthis._items,\n\t\t\t(item, callback) => item.store(data, callback),\n\t\t\tcallback\n\t\t);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {T} data the value to store\n\t * @returns {Promise<void>} promise signals when the value is stored\n\t */\n\tstorePromise(data) {\n\t\treturn Promise.all(this._items.map(item => item.storePromise(data))).then(\n\t\t\t() => {}\n\t\t);\n\t}\n}\n\nclass ItemCacheFacade {\n\t/**\n\t * @param {Cache} cache the root cache\n\t * @param {string} name the child cache item name\n\t * @param {Etag | null} etag the etag\n\t */\n\tconstructor(cache, name, etag) {\n\t\tthis._cache = cache;\n\t\tthis._name = name;\n\t\tthis._etag = etag;\n\t}\n\n\t/**\n\t * @template T\n\t * @param {CallbackCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tget(callback) {\n\t\tthis._cache.get(this._name, this._etag, callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tgetPromise() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._cache.get(this._name, this._etag, (err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(data);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {T} data the value to store\n\t * @param {CallbackCache<void>} callback signals when the value is stored\n\t * @returns {void}\n\t */\n\tstore(data, callback) {\n\t\tthis._cache.store(this._name, this._etag, data, callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {T} data the value to store\n\t * @returns {Promise<void>} promise signals when the value is stored\n\t */\n\tstorePromise(data) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._cache.store(this._name, this._etag, data, err => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {function(CallbackNormalErrorCache<T>): void} computer function to compute the value if not cached\n\t * @param {CallbackNormalErrorCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tprovide(computer, callback) {\n\t\tthis.get((err, cacheEntry) => {\n\t\t\tif (err) return callback(err);\n\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\tcomputer((err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tthis.store(result, err => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tcallback(null, result);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {function(): Promise<T> | T} computer function to compute the value if not cached\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tasync providePromise(computer) {\n\t\tconst cacheEntry = await this.getPromise();\n\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\tconst result = await computer();\n\t\tawait this.storePromise(result);\n\t\treturn result;\n\t}\n}\n\nclass CacheFacade {\n\t/**\n\t * @param {Cache} cache the root cache\n\t * @param {string} name the child cache name\n\t * @param {string | HashConstructor} hashFunction the hash function to use\n\t */\n\tconstructor(cache, name, hashFunction) {\n\t\tthis._cache = cache;\n\t\tthis._name = name;\n\t\tthis._hashFunction = hashFunction;\n\t}\n\n\t/**\n\t * @param {string} name the child cache name#\n\t * @returns {CacheFacade} child cache\n\t */\n\tgetChildCache(name) {\n\t\treturn new CacheFacade(\n\t\t\tthis._cache,\n\t\t\t`${this._name}|${name}`,\n\t\t\tthis._hashFunction\n\t\t);\n\t}\n\n\t/**\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @returns {ItemCacheFacade} item cache\n\t */\n\tgetItemCache(identifier, etag) {\n\t\treturn new ItemCacheFacade(\n\t\t\tthis._cache,\n\t\t\t`${this._name}|${identifier}`,\n\t\t\tetag\n\t\t);\n\t}\n\n\t/**\n\t * @param {HashableObject} obj an hashable object\n\t * @returns {Etag} an etag that is lazy hashed\n\t */\n\tgetLazyHashedEtag(obj) {\n\t\treturn getLazyHashedEtag(obj, this._hashFunction);\n\t}\n\n\t/**\n\t * @param {Etag} a an etag\n\t * @param {Etag} b another etag\n\t * @returns {Etag} an etag that represents both\n\t */\n\tmergeEtags(a, b) {\n\t\treturn mergeEtags(a, b);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {CallbackCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tget(identifier, etag, callback) {\n\t\tthis._cache.get(`${this._name}|${identifier}`, etag, callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tgetPromise(identifier, etag) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._cache.get(`${this._name}|${identifier}`, etag, (err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(data);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {T} data the value to store\n\t * @param {CallbackCache<void>} callback signals when the value is stored\n\t * @returns {void}\n\t */\n\tstore(identifier, etag, data, callback) {\n\t\tthis._cache.store(`${this._name}|${identifier}`, etag, data, callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {T} data the value to store\n\t * @returns {Promise<void>} promise signals when the value is stored\n\t */\n\tstorePromise(identifier, etag, data) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._cache.store(`${this._name}|${identifier}`, etag, data, err => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {function(CallbackNormalErrorCache<T>): void} computer function to compute the value if not cached\n\t * @param {CallbackNormalErrorCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tprovide(identifier, etag, computer, callback) {\n\t\tthis.get(identifier, etag, (err, cacheEntry) => {\n\t\t\tif (err) return callback(err);\n\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\tcomputer((err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tthis.store(identifier, etag, result, err => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tcallback(null, result);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {function(): Promise<T> | T} computer function to compute the value if not cached\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tasync providePromise(identifier, etag, computer) {\n\t\tconst cacheEntry = await this.getPromise(identifier, etag);\n\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\tconst result = await computer();\n\t\tawait this.storePromise(identifier, etag, result);\n\t\treturn result;\n\t}\n}\n\nmodule.exports = CacheFacade;\nmodule.exports.ItemCacheFacade = ItemCacheFacade;\nmodule.exports.MultiItemCache = MultiItemCache;\n"]},"metadata":{},"sourceType":"script"}