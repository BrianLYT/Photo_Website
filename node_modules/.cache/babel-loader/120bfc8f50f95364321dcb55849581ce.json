{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst PureExpressionDependency = require(\"../dependencies/PureExpressionDependency\");\n\nconst InnerGraph = require(\"./InnerGraph\");\n/** @typedef {import(\"estree\").ClassDeclaration} ClassDeclarationNode */\n\n/** @typedef {import(\"estree\").ClassExpression} ClassExpressionNode */\n\n/** @typedef {import(\"estree\").Node} Node */\n\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclaratorNode */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Dependency\")} Dependency */\n\n/** @typedef {import(\"../dependencies/HarmonyImportSpecifierDependency\")} HarmonyImportSpecifierDependency */\n\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n\n/** @typedef {import(\"./InnerGraph\").InnerGraph} InnerGraph */\n\n/** @typedef {import(\"./InnerGraph\").TopLevelSymbol} TopLevelSymbol */\n\n\nconst {\n  topLevelSymbolTag\n} = InnerGraph;\n\nclass InnerGraphPlugin {\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"InnerGraphPlugin\", (compilation, _ref) => {\n      let {\n        normalModuleFactory\n      } = _ref;\n      const logger = compilation.getLogger(\"webpack.InnerGraphPlugin\");\n      compilation.dependencyTemplates.set(PureExpressionDependency, new PureExpressionDependency.Template());\n      /**\n       * @param {JavascriptParser} parser the parser\n       * @param {Object} parserOptions options\n       * @returns {void}\n       */\n\n      const handler = (parser, parserOptions) => {\n        const onUsageSuper = sup => {\n          InnerGraph.onUsage(parser.state, usedByExports => {\n            switch (usedByExports) {\n              case undefined:\n              case true:\n                return;\n\n              default:\n                {\n                  const dep = new PureExpressionDependency(sup.range);\n                  dep.loc = sup.loc;\n                  dep.usedByExports = usedByExports;\n                  parser.state.module.addDependency(dep);\n                  break;\n                }\n            }\n          });\n        };\n\n        parser.hooks.program.tap(\"InnerGraphPlugin\", () => {\n          InnerGraph.enable(parser.state);\n        });\n        parser.hooks.finish.tap(\"InnerGraphPlugin\", () => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          logger.time(\"infer dependency usage\");\n          InnerGraph.inferDependencyUsage(parser.state);\n          logger.timeAggregate(\"infer dependency usage\");\n        }); // During prewalking the following datastructures are filled with\n        // nodes that have a TopLevelSymbol assigned and\n        // variables are tagged with the assigned TopLevelSymbol\n        // We differ 3 types of nodes:\n        // 1. full statements (export default, function declaration)\n        // 2. classes (class declaration, class expression)\n        // 3. variable declarators (const x = ...)\n\n        /** @type {WeakMap<Node, TopLevelSymbol>} */\n\n        const statementWithTopLevelSymbol = new WeakMap();\n        /** @type {WeakMap<Node, Node>} */\n\n        const statementPurePart = new WeakMap();\n        /** @type {WeakMap<ClassExpressionNode | ClassDeclarationNode, TopLevelSymbol>} */\n\n        const classWithTopLevelSymbol = new WeakMap();\n        /** @type {WeakMap<VariableDeclaratorNode, TopLevelSymbol>} */\n\n        const declWithTopLevelSymbol = new WeakMap();\n        /** @type {WeakSet<VariableDeclaratorNode>} */\n\n        const pureDeclarators = new WeakSet(); // The following hooks are used during prewalking:\n\n        parser.hooks.preStatement.tap(\"InnerGraphPlugin\", statement => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n\n          if (parser.scope.topLevelScope === true) {\n            if (statement.type === \"FunctionDeclaration\") {\n              const name = statement.id ? statement.id.name : \"*default*\";\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              statementWithTopLevelSymbol.set(statement, fn);\n              return true;\n            }\n          }\n        });\n        parser.hooks.blockPreStatement.tap(\"InnerGraphPlugin\", statement => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n\n          if (parser.scope.topLevelScope === true) {\n            if (statement.type === \"ClassDeclaration\") {\n              const name = statement.id ? statement.id.name : \"*default*\";\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              classWithTopLevelSymbol.set(statement, fn);\n              return true;\n            }\n\n            if (statement.type === \"ExportDefaultDeclaration\") {\n              const name = \"*default*\";\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              const decl = statement.declaration;\n\n              if (decl.type === \"ClassExpression\" || decl.type === \"ClassDeclaration\") {\n                classWithTopLevelSymbol.set(decl, fn);\n              } else if (parser.isPure(decl, statement.range[0])) {\n                statementWithTopLevelSymbol.set(statement, fn);\n\n                if (!decl.type.endsWith(\"FunctionExpression\") && !decl.type.endsWith(\"Declaration\") && decl.type !== \"Literal\") {\n                  statementPurePart.set(statement, decl);\n                }\n              }\n            }\n          }\n        });\n        parser.hooks.preDeclarator.tap(\"InnerGraphPlugin\", (decl, statement) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n\n          if (parser.scope.topLevelScope === true && decl.init && decl.id.type === \"Identifier\") {\n            const name = decl.id.name;\n\n            if (decl.init.type === \"ClassExpression\") {\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              classWithTopLevelSymbol.set(decl.init, fn);\n            } else if (parser.isPure(decl.init, decl.id.range[1])) {\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              declWithTopLevelSymbol.set(decl, fn);\n\n              if (!decl.init.type.endsWith(\"FunctionExpression\") && decl.init.type !== \"Literal\") {\n                pureDeclarators.add(decl);\n              }\n\n              return true;\n            }\n          }\n        }); // During real walking we set the TopLevelSymbol state to the assigned\n        // TopLevelSymbol by using the fill datastructures.\n        // In addition to tracking TopLevelSymbols, we sometimes need to\n        // add a PureExpressionDependency. This is needed to skip execution\n        // of pure expressions, even when they are not dropped due to\n        // minimizing. Otherwise symbols used there might not exist anymore\n        // as they are removed as unused by this optimization\n        // When we find a reference to a TopLevelSymbol, we register a\n        // TopLevelSymbol dependency from TopLevelSymbol in state to the\n        // referenced TopLevelSymbol. This way we get a graph of all\n        // TopLevelSymbols.\n        // The following hooks are called during walking:\n\n        parser.hooks.statement.tap(\"InnerGraphPlugin\", statement => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n\n          if (parser.scope.topLevelScope === true) {\n            InnerGraph.setTopLevelSymbol(parser.state, undefined);\n            const fn = statementWithTopLevelSymbol.get(statement);\n\n            if (fn) {\n              InnerGraph.setTopLevelSymbol(parser.state, fn);\n              const purePart = statementPurePart.get(statement);\n\n              if (purePart) {\n                InnerGraph.onUsage(parser.state, usedByExports => {\n                  switch (usedByExports) {\n                    case undefined:\n                    case true:\n                      return;\n\n                    default:\n                      {\n                        const dep = new PureExpressionDependency(purePart.range);\n                        dep.loc = statement.loc;\n                        dep.usedByExports = usedByExports;\n                        parser.state.module.addDependency(dep);\n                        break;\n                      }\n                  }\n                });\n              }\n            }\n          }\n        });\n        parser.hooks.classExtendsExpression.tap(\"InnerGraphPlugin\", (expr, statement) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n\n          if (parser.scope.topLevelScope === true) {\n            const fn = classWithTopLevelSymbol.get(statement);\n\n            if (fn && parser.isPure(expr, statement.id ? statement.id.range[1] : statement.range[0])) {\n              InnerGraph.setTopLevelSymbol(parser.state, fn);\n              onUsageSuper(expr);\n            }\n          }\n        });\n        parser.hooks.classBodyElement.tap(\"InnerGraphPlugin\", (element, classDefinition) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n\n          if (parser.scope.topLevelScope === true) {\n            const fn = classWithTopLevelSymbol.get(classDefinition);\n\n            if (fn) {\n              InnerGraph.setTopLevelSymbol(parser.state, undefined);\n            }\n          }\n        });\n        parser.hooks.classBodyValue.tap(\"InnerGraphPlugin\", (expression, element, classDefinition) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n\n          if (parser.scope.topLevelScope === true) {\n            const fn = classWithTopLevelSymbol.get(classDefinition);\n\n            if (fn) {\n              if (!element.static || parser.isPure(expression, element.key ? element.key.range[1] : element.range[0])) {\n                InnerGraph.setTopLevelSymbol(parser.state, fn);\n\n                if (element.type !== \"MethodDefinition\" && element.static) {\n                  InnerGraph.onUsage(parser.state, usedByExports => {\n                    switch (usedByExports) {\n                      case undefined:\n                      case true:\n                        return;\n\n                      default:\n                        {\n                          const dep = new PureExpressionDependency(expression.range);\n                          dep.loc = expression.loc;\n                          dep.usedByExports = usedByExports;\n                          parser.state.module.addDependency(dep);\n                          break;\n                        }\n                    }\n                  });\n                }\n              } else {\n                InnerGraph.setTopLevelSymbol(parser.state, undefined);\n              }\n            }\n          }\n        });\n        parser.hooks.declarator.tap(\"InnerGraphPlugin\", (decl, statement) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          const fn = declWithTopLevelSymbol.get(decl);\n\n          if (fn) {\n            InnerGraph.setTopLevelSymbol(parser.state, fn);\n\n            if (pureDeclarators.has(decl)) {\n              if (decl.init.type === \"ClassExpression\") {\n                if (decl.init.superClass) {\n                  onUsageSuper(decl.init.superClass);\n                }\n              } else {\n                InnerGraph.onUsage(parser.state, usedByExports => {\n                  switch (usedByExports) {\n                    case undefined:\n                    case true:\n                      return;\n\n                    default:\n                      {\n                        const dep = new PureExpressionDependency(decl.init.range);\n                        dep.loc = decl.loc;\n                        dep.usedByExports = usedByExports;\n                        parser.state.module.addDependency(dep);\n                        break;\n                      }\n                  }\n                });\n              }\n            }\n\n            parser.walkExpression(decl.init);\n            InnerGraph.setTopLevelSymbol(parser.state, undefined);\n            return true;\n          }\n        });\n        parser.hooks.expression.for(topLevelSymbolTag).tap(\"InnerGraphPlugin\", () => {\n          const topLevelSymbol =\n          /** @type {TopLevelSymbol} */\n          parser.currentTagData;\n          const currentTopLevelSymbol = InnerGraph.getTopLevelSymbol(parser.state);\n          InnerGraph.addUsage(parser.state, topLevelSymbol, currentTopLevelSymbol || true);\n        });\n        parser.hooks.assign.for(topLevelSymbolTag).tap(\"InnerGraphPlugin\", expr => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (expr.operator === \"=\") return true;\n        });\n      };\n\n      normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"InnerGraphPlugin\", handler);\n      normalModuleFactory.hooks.parser.for(\"javascript/esm\").tap(\"InnerGraphPlugin\", handler);\n      compilation.hooks.finishModules.tap(\"InnerGraphPlugin\", () => {\n        logger.timeAggregateEnd(\"infer dependency usage\");\n      });\n    });\n  }\n\n}\n\nmodule.exports = InnerGraphPlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/optimize/InnerGraphPlugin.js"],"names":["PureExpressionDependency","require","InnerGraph","topLevelSymbolTag","InnerGraphPlugin","apply","compiler","hooks","compilation","tap","normalModuleFactory","logger","getLogger","dependencyTemplates","set","Template","handler","parser","parserOptions","onUsageSuper","sup","onUsage","state","usedByExports","undefined","dep","range","loc","module","addDependency","program","enable","finish","isEnabled","time","inferDependencyUsage","timeAggregate","statementWithTopLevelSymbol","WeakMap","statementPurePart","classWithTopLevelSymbol","declWithTopLevelSymbol","pureDeclarators","WeakSet","preStatement","statement","scope","topLevelScope","type","name","id","fn","tagTopLevelSymbol","blockPreStatement","decl","declaration","isPure","endsWith","preDeclarator","init","add","setTopLevelSymbol","get","purePart","classExtendsExpression","expr","classBodyElement","element","classDefinition","classBodyValue","expression","static","key","declarator","has","superClass","walkExpression","for","topLevelSymbol","currentTagData","currentTopLevelSymbol","getTopLevelSymbol","addUsage","assign","operator","finishModules","timeAggregateEnd","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst PureExpressionDependency = require(\"../dependencies/PureExpressionDependency\");\nconst InnerGraph = require(\"./InnerGraph\");\n\n/** @typedef {import(\"estree\").ClassDeclaration} ClassDeclarationNode */\n/** @typedef {import(\"estree\").ClassExpression} ClassExpressionNode */\n/** @typedef {import(\"estree\").Node} Node */\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclaratorNode */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../dependencies/HarmonyImportSpecifierDependency\")} HarmonyImportSpecifierDependency */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"./InnerGraph\").InnerGraph} InnerGraph */\n/** @typedef {import(\"./InnerGraph\").TopLevelSymbol} TopLevelSymbol */\n\nconst { topLevelSymbolTag } = InnerGraph;\n\nclass InnerGraphPlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"InnerGraphPlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tconst logger = compilation.getLogger(\"webpack.InnerGraphPlugin\");\n\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tPureExpressionDependency,\n\t\t\t\t\tnew PureExpressionDependency.Template()\n\t\t\t\t);\n\n\t\t\t\t/**\n\t\t\t\t * @param {JavascriptParser} parser the parser\n\t\t\t\t * @param {Object} parserOptions options\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst handler = (parser, parserOptions) => {\n\t\t\t\t\tconst onUsageSuper = sup => {\n\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\n\t\t\t\t\t\t\tswitch (usedByExports) {\n\t\t\t\t\t\t\t\tcase undefined:\n\t\t\t\t\t\t\t\tcase true:\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(sup.range);\n\t\t\t\t\t\t\t\t\tdep.loc = sup.loc;\n\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\n\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\tparser.hooks.program.tap(\"InnerGraphPlugin\", () => {\n\t\t\t\t\t\tInnerGraph.enable(parser.state);\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.finish.tap(\"InnerGraphPlugin\", () => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\n\t\t\t\t\t\tlogger.time(\"infer dependency usage\");\n\t\t\t\t\t\tInnerGraph.inferDependencyUsage(parser.state);\n\t\t\t\t\t\tlogger.timeAggregate(\"infer dependency usage\");\n\t\t\t\t\t});\n\n\t\t\t\t\t// During prewalking the following datastructures are filled with\n\t\t\t\t\t// nodes that have a TopLevelSymbol assigned and\n\t\t\t\t\t// variables are tagged with the assigned TopLevelSymbol\n\n\t\t\t\t\t// We differ 3 types of nodes:\n\t\t\t\t\t// 1. full statements (export default, function declaration)\n\t\t\t\t\t// 2. classes (class declaration, class expression)\n\t\t\t\t\t// 3. variable declarators (const x = ...)\n\n\t\t\t\t\t/** @type {WeakMap<Node, TopLevelSymbol>} */\n\t\t\t\t\tconst statementWithTopLevelSymbol = new WeakMap();\n\t\t\t\t\t/** @type {WeakMap<Node, Node>} */\n\t\t\t\t\tconst statementPurePart = new WeakMap();\n\n\t\t\t\t\t/** @type {WeakMap<ClassExpressionNode | ClassDeclarationNode, TopLevelSymbol>} */\n\t\t\t\t\tconst classWithTopLevelSymbol = new WeakMap();\n\n\t\t\t\t\t/** @type {WeakMap<VariableDeclaratorNode, TopLevelSymbol>} */\n\t\t\t\t\tconst declWithTopLevelSymbol = new WeakMap();\n\t\t\t\t\t/** @type {WeakSet<VariableDeclaratorNode>} */\n\t\t\t\t\tconst pureDeclarators = new WeakSet();\n\n\t\t\t\t\t// The following hooks are used during prewalking:\n\n\t\t\t\t\tparser.hooks.preStatement.tap(\"InnerGraphPlugin\", statement => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\n\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\tif (statement.type === \"FunctionDeclaration\") {\n\t\t\t\t\t\t\t\tconst name = statement.id ? statement.id.name : \"*default*\";\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\tstatementWithTopLevelSymbol.set(statement, fn);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.blockPreStatement.tap(\"InnerGraphPlugin\", statement => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\n\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\tif (statement.type === \"ClassDeclaration\") {\n\t\t\t\t\t\t\t\tconst name = statement.id ? statement.id.name : \"*default*\";\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\tclassWithTopLevelSymbol.set(statement, fn);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (statement.type === \"ExportDefaultDeclaration\") {\n\t\t\t\t\t\t\t\tconst name = \"*default*\";\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\tconst decl = statement.declaration;\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tdecl.type === \"ClassExpression\" ||\n\t\t\t\t\t\t\t\t\tdecl.type === \"ClassDeclaration\"\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tclassWithTopLevelSymbol.set(decl, fn);\n\t\t\t\t\t\t\t\t} else if (parser.isPure(decl, statement.range[0])) {\n\t\t\t\t\t\t\t\t\tstatementWithTopLevelSymbol.set(statement, fn);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!decl.type.endsWith(\"FunctionExpression\") &&\n\t\t\t\t\t\t\t\t\t\t!decl.type.endsWith(\"Declaration\") &&\n\t\t\t\t\t\t\t\t\t\tdecl.type !== \"Literal\"\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tstatementPurePart.set(statement, decl);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.preDeclarator.tap(\n\t\t\t\t\t\t\"InnerGraphPlugin\",\n\t\t\t\t\t\t(decl, statement) => {\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tparser.scope.topLevelScope === true &&\n\t\t\t\t\t\t\t\tdecl.init &&\n\t\t\t\t\t\t\t\tdecl.id.type === \"Identifier\"\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst name = decl.id.name;\n\t\t\t\t\t\t\t\tif (decl.init.type === \"ClassExpression\") {\n\t\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\t\tclassWithTopLevelSymbol.set(decl.init, fn);\n\t\t\t\t\t\t\t\t} else if (parser.isPure(decl.init, decl.id.range[1])) {\n\t\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\t\tdeclWithTopLevelSymbol.set(decl, fn);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!decl.init.type.endsWith(\"FunctionExpression\") &&\n\t\t\t\t\t\t\t\t\t\tdecl.init.type !== \"Literal\"\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tpureDeclarators.add(decl);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\t// During real walking we set the TopLevelSymbol state to the assigned\n\t\t\t\t\t// TopLevelSymbol by using the fill datastructures.\n\n\t\t\t\t\t// In addition to tracking TopLevelSymbols, we sometimes need to\n\t\t\t\t\t// add a PureExpressionDependency. This is needed to skip execution\n\t\t\t\t\t// of pure expressions, even when they are not dropped due to\n\t\t\t\t\t// minimizing. Otherwise symbols used there might not exist anymore\n\t\t\t\t\t// as they are removed as unused by this optimization\n\n\t\t\t\t\t// When we find a reference to a TopLevelSymbol, we register a\n\t\t\t\t\t// TopLevelSymbol dependency from TopLevelSymbol in state to the\n\t\t\t\t\t// referenced TopLevelSymbol. This way we get a graph of all\n\t\t\t\t\t// TopLevelSymbols.\n\n\t\t\t\t\t// The following hooks are called during walking:\n\n\t\t\t\t\tparser.hooks.statement.tap(\"InnerGraphPlugin\", statement => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\n\n\t\t\t\t\t\t\tconst fn = statementWithTopLevelSymbol.get(statement);\n\t\t\t\t\t\t\tif (fn) {\n\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\n\t\t\t\t\t\t\t\tconst purePart = statementPurePart.get(statement);\n\t\t\t\t\t\t\t\tif (purePart) {\n\t\t\t\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\n\t\t\t\t\t\t\t\t\t\tswitch (usedByExports) {\n\t\t\t\t\t\t\t\t\t\t\tcase undefined:\n\t\t\t\t\t\t\t\t\t\t\tcase true:\n\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(\n\t\t\t\t\t\t\t\t\t\t\t\t\tpurePart.range\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tdep.loc = statement.loc;\n\t\t\t\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\n\t\t\t\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.classExtendsExpression.tap(\n\t\t\t\t\t\t\"InnerGraphPlugin\",\n\t\t\t\t\t\t(expr, statement) => {\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\t\tconst fn = classWithTopLevelSymbol.get(statement);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tfn &&\n\t\t\t\t\t\t\t\t\tparser.isPure(\n\t\t\t\t\t\t\t\t\t\texpr,\n\t\t\t\t\t\t\t\t\t\tstatement.id ? statement.id.range[1] : statement.range[0]\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\n\t\t\t\t\t\t\t\t\tonUsageSuper(expr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tparser.hooks.classBodyElement.tap(\n\t\t\t\t\t\t\"InnerGraphPlugin\",\n\t\t\t\t\t\t(element, classDefinition) => {\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\t\tconst fn = classWithTopLevelSymbol.get(classDefinition);\n\t\t\t\t\t\t\t\tif (fn) {\n\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tparser.hooks.classBodyValue.tap(\n\t\t\t\t\t\t\"InnerGraphPlugin\",\n\t\t\t\t\t\t(expression, element, classDefinition) => {\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\t\tconst fn = classWithTopLevelSymbol.get(classDefinition);\n\t\t\t\t\t\t\t\tif (fn) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!element.static ||\n\t\t\t\t\t\t\t\t\t\tparser.isPure(\n\t\t\t\t\t\t\t\t\t\t\texpression,\n\t\t\t\t\t\t\t\t\t\t\telement.key ? element.key.range[1] : element.range[0]\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\n\t\t\t\t\t\t\t\t\t\tif (element.type !== \"MethodDefinition\" && element.static) {\n\t\t\t\t\t\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\n\t\t\t\t\t\t\t\t\t\t\t\tswitch (usedByExports) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase undefined:\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase true:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\texpression.range\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdep.loc = expression.loc;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tparser.hooks.declarator.tap(\"InnerGraphPlugin\", (decl, statement) => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\tconst fn = declWithTopLevelSymbol.get(decl);\n\n\t\t\t\t\t\tif (fn) {\n\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\n\t\t\t\t\t\t\tif (pureDeclarators.has(decl)) {\n\t\t\t\t\t\t\t\tif (decl.init.type === \"ClassExpression\") {\n\t\t\t\t\t\t\t\t\tif (decl.init.superClass) {\n\t\t\t\t\t\t\t\t\t\tonUsageSuper(decl.init.superClass);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\n\t\t\t\t\t\t\t\t\t\tswitch (usedByExports) {\n\t\t\t\t\t\t\t\t\t\t\tcase undefined:\n\t\t\t\t\t\t\t\t\t\t\tcase true:\n\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(\n\t\t\t\t\t\t\t\t\t\t\t\t\tdecl.init.range\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tdep.loc = decl.loc;\n\t\t\t\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\n\t\t\t\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tparser.walkExpression(decl.init);\n\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.expression\n\t\t\t\t\t\t.for(topLevelSymbolTag)\n\t\t\t\t\t\t.tap(\"InnerGraphPlugin\", () => {\n\t\t\t\t\t\t\tconst topLevelSymbol = /** @type {TopLevelSymbol} */ (\n\t\t\t\t\t\t\t\tparser.currentTagData\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst currentTopLevelSymbol = InnerGraph.getTopLevelSymbol(\n\t\t\t\t\t\t\t\tparser.state\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tInnerGraph.addUsage(\n\t\t\t\t\t\t\t\tparser.state,\n\t\t\t\t\t\t\t\ttopLevelSymbol,\n\t\t\t\t\t\t\t\tcurrentTopLevelSymbol || true\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\tparser.hooks.assign\n\t\t\t\t\t\t.for(topLevelSymbolTag)\n\t\t\t\t\t\t.tap(\"InnerGraphPlugin\", expr => {\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\t\tif (expr.operator === \"=\") return true;\n\t\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/auto\")\n\t\t\t\t\t.tap(\"InnerGraphPlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/esm\")\n\t\t\t\t\t.tap(\"InnerGraphPlugin\", handler);\n\n\t\t\t\tcompilation.hooks.finishModules.tap(\"InnerGraphPlugin\", () => {\n\t\t\t\t\tlogger.timeAggregateEnd(\"infer dependency usage\");\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = InnerGraphPlugin;\n"]},"metadata":{},"sourceType":"script"}