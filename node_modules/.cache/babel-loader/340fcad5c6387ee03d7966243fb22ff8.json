{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  STAGE_ADVANCED\n} = require(\"../OptimizationStages\");\n\nconst {\n  intersect\n} = require(\"../util/SetHelpers\");\n\nconst {\n  compareModulesByIdentifier,\n  compareChunks\n} = require(\"../util/comparators\");\n\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\n\nconst identifierUtils = require(\"../util/identifier\");\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Module\")} Module */\n\n\nconst validate = createSchemaValidation(require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.check.js\"), () => require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\"), {\n  name: \"Aggressive Splitting Plugin\",\n  baseDataPath: \"options\"\n});\n\nconst moveModuleBetween = (chunkGraph, oldChunk, newChunk) => {\n  return module => {\n    chunkGraph.disconnectChunkAndModule(oldChunk, module);\n    chunkGraph.connectChunkAndModule(newChunk, module);\n  };\n};\n/**\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Chunk} chunk the chunk\n * @returns {function(Module): boolean} filter for entry module\n */\n\n\nconst isNotAEntryModule = (chunkGraph, chunk) => {\n  return module => {\n    return !chunkGraph.isEntryModuleInChunk(module, chunk);\n  };\n};\n/** @type {WeakSet<Chunk>} */\n\n\nconst recordedChunks = new WeakSet();\n\nclass AggressiveSplittingPlugin {\n  /**\n   * @param {AggressiveSplittingPluginOptions=} options options object\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    validate(options);\n    this.options = options;\n\n    if (typeof this.options.minSize !== \"number\") {\n      this.options.minSize = 30 * 1024;\n    }\n\n    if (typeof this.options.maxSize !== \"number\") {\n      this.options.maxSize = 50 * 1024;\n    }\n\n    if (typeof this.options.chunkOverhead !== \"number\") {\n      this.options.chunkOverhead = 0;\n    }\n\n    if (typeof this.options.entryChunkMultiplicator !== \"number\") {\n      this.options.entryChunkMultiplicator = 1;\n    }\n  }\n  /**\n   * @param {Chunk} chunk the chunk to test\n   * @returns {boolean} true if the chunk was recorded\n   */\n\n\n  static wasChunkRecorded(chunk) {\n    return recordedChunks.has(chunk);\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap(\"AggressiveSplittingPlugin\", compilation => {\n      let needAdditionalSeal = false;\n      let newSplits;\n      let fromAggressiveSplittingSet;\n      let chunkSplitDataMap;\n      compilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", () => {\n        newSplits = [];\n        fromAggressiveSplittingSet = new Set();\n        chunkSplitDataMap = new Map();\n      });\n      compilation.hooks.optimizeChunks.tap({\n        name: \"AggressiveSplittingPlugin\",\n        stage: STAGE_ADVANCED\n      }, chunks => {\n        const chunkGraph = compilation.chunkGraph; // Precompute stuff\n\n        const nameToModuleMap = new Map();\n        const moduleToNameMap = new Map();\n        const makePathsRelative = identifierUtils.makePathsRelative.bindContextCache(compiler.context, compiler.root);\n\n        for (const m of compilation.modules) {\n          const name = makePathsRelative(m.identifier());\n          nameToModuleMap.set(name, m);\n          moduleToNameMap.set(m, name);\n        } // Check used chunk ids\n\n\n        const usedIds = new Set();\n\n        for (const chunk of chunks) {\n          usedIds.add(chunk.id);\n        }\n\n        const recordedSplits = compilation.records && compilation.records.aggressiveSplits || [];\n        const usedSplits = newSplits ? recordedSplits.concat(newSplits) : recordedSplits;\n        const minSize = this.options.minSize;\n        const maxSize = this.options.maxSize;\n\n        const applySplit = splitData => {\n          // Cannot split if id is already taken\n          if (splitData.id !== undefined && usedIds.has(splitData.id)) {\n            return false;\n          } // Get module objects from names\n\n\n          const selectedModules = splitData.modules.map(name => nameToModuleMap.get(name)); // Does the modules exist at all?\n\n          if (!selectedModules.every(Boolean)) return false; // Check if size matches (faster than waiting for hash)\n\n          let size = 0;\n\n          for (const m of selectedModules) size += m.size();\n\n          if (size !== splitData.size) return false; // get chunks with all modules\n\n          const selectedChunks = intersect(selectedModules.map(m => new Set(chunkGraph.getModuleChunksIterable(m)))); // No relevant chunks found\n\n          if (selectedChunks.size === 0) return false; // The found chunk is already the split or similar\n\n          if (selectedChunks.size === 1 && chunkGraph.getNumberOfChunkModules(Array.from(selectedChunks)[0]) === selectedModules.length) {\n            const chunk = Array.from(selectedChunks)[0];\n            if (fromAggressiveSplittingSet.has(chunk)) return false;\n            fromAggressiveSplittingSet.add(chunk);\n            chunkSplitDataMap.set(chunk, splitData);\n            return true;\n          } // split the chunk into two parts\n\n\n          const newChunk = compilation.addChunk();\n          newChunk.chunkReason = \"aggressive splitted\";\n\n          for (const chunk of selectedChunks) {\n            selectedModules.forEach(moveModuleBetween(chunkGraph, chunk, newChunk));\n            chunk.split(newChunk);\n            chunk.name = null;\n          }\n\n          fromAggressiveSplittingSet.add(newChunk);\n          chunkSplitDataMap.set(newChunk, splitData);\n\n          if (splitData.id !== null && splitData.id !== undefined) {\n            newChunk.id = splitData.id;\n            newChunk.ids = [splitData.id];\n          }\n\n          return true;\n        }; // try to restore to recorded splitting\n\n\n        let changed = false;\n\n        for (let j = 0; j < usedSplits.length; j++) {\n          const splitData = usedSplits[j];\n          if (applySplit(splitData)) changed = true;\n        } // for any chunk which isn't splitted yet, split it and create a new entry\n        // start with the biggest chunk\n\n\n        const cmpFn = compareChunks(chunkGraph);\n        const sortedChunks = Array.from(chunks).sort((a, b) => {\n          const diff1 = chunkGraph.getChunkModulesSize(b) - chunkGraph.getChunkModulesSize(a);\n          if (diff1) return diff1;\n          const diff2 = chunkGraph.getNumberOfChunkModules(a) - chunkGraph.getNumberOfChunkModules(b);\n          if (diff2) return diff2;\n          return cmpFn(a, b);\n        });\n\n        for (const chunk of sortedChunks) {\n          if (fromAggressiveSplittingSet.has(chunk)) continue;\n          const size = chunkGraph.getChunkModulesSize(chunk);\n\n          if (size > maxSize && chunkGraph.getNumberOfChunkModules(chunk) > 1) {\n            const modules = chunkGraph.getOrderedChunkModules(chunk, compareModulesByIdentifier).filter(isNotAEntryModule(chunkGraph, chunk));\n            const selectedModules = [];\n            let selectedModulesSize = 0;\n\n            for (let k = 0; k < modules.length; k++) {\n              const module = modules[k];\n              const newSize = selectedModulesSize + module.size();\n\n              if (newSize > maxSize && selectedModulesSize >= minSize) {\n                break;\n              }\n\n              selectedModulesSize = newSize;\n              selectedModules.push(module);\n            }\n\n            if (selectedModules.length === 0) continue;\n            const splitData = {\n              modules: selectedModules.map(m => moduleToNameMap.get(m)).sort(),\n              size: selectedModulesSize\n            };\n\n            if (applySplit(splitData)) {\n              newSplits = (newSplits || []).concat(splitData);\n              changed = true;\n            }\n          }\n        }\n\n        if (changed) return true;\n      });\n      compilation.hooks.recordHash.tap(\"AggressiveSplittingPlugin\", records => {\n        // 4. save made splittings to records\n        const allSplits = new Set();\n        const invalidSplits = new Set(); // Check if some splittings are invalid\n        // We remove invalid splittings and try again\n\n        for (const chunk of compilation.chunks) {\n          const splitData = chunkSplitDataMap.get(chunk);\n\n          if (splitData !== undefined) {\n            if (splitData.hash && chunk.hash !== splitData.hash) {\n              // Split was successful, but hash doesn't equal\n              // We can throw away the split since it's useless now\n              invalidSplits.add(splitData);\n            }\n          }\n        }\n\n        if (invalidSplits.size > 0) {\n          records.aggressiveSplits = records.aggressiveSplits.filter(splitData => !invalidSplits.has(splitData));\n          needAdditionalSeal = true;\n        } else {\n          // set hash and id values on all (new) splittings\n          for (const chunk of compilation.chunks) {\n            const splitData = chunkSplitDataMap.get(chunk);\n\n            if (splitData !== undefined) {\n              splitData.hash = chunk.hash;\n              splitData.id = chunk.id;\n              allSplits.add(splitData); // set flag for stats\n\n              recordedChunks.add(chunk);\n            }\n          } // Also add all unused historical splits (after the used ones)\n          // They can still be used in some future compilation\n\n\n          const recordedSplits = compilation.records && compilation.records.aggressiveSplits;\n\n          if (recordedSplits) {\n            for (const splitData of recordedSplits) {\n              if (!invalidSplits.has(splitData)) allSplits.add(splitData);\n            }\n          } // record all splits\n\n\n          records.aggressiveSplits = Array.from(allSplits);\n          needAdditionalSeal = false;\n        }\n      });\n      compilation.hooks.needAdditionalSeal.tap(\"AggressiveSplittingPlugin\", () => {\n        if (needAdditionalSeal) {\n          needAdditionalSeal = false;\n          return true;\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = AggressiveSplittingPlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/optimize/AggressiveSplittingPlugin.js"],"names":["STAGE_ADVANCED","require","intersect","compareModulesByIdentifier","compareChunks","createSchemaValidation","identifierUtils","validate","name","baseDataPath","moveModuleBetween","chunkGraph","oldChunk","newChunk","module","disconnectChunkAndModule","connectChunkAndModule","isNotAEntryModule","chunk","isEntryModuleInChunk","recordedChunks","WeakSet","AggressiveSplittingPlugin","constructor","options","minSize","maxSize","chunkOverhead","entryChunkMultiplicator","wasChunkRecorded","has","apply","compiler","hooks","thisCompilation","tap","compilation","needAdditionalSeal","newSplits","fromAggressiveSplittingSet","chunkSplitDataMap","optimize","Set","Map","optimizeChunks","stage","chunks","nameToModuleMap","moduleToNameMap","makePathsRelative","bindContextCache","context","root","m","modules","identifier","set","usedIds","add","id","recordedSplits","records","aggressiveSplits","usedSplits","concat","applySplit","splitData","undefined","selectedModules","map","get","every","Boolean","size","selectedChunks","getModuleChunksIterable","getNumberOfChunkModules","Array","from","length","addChunk","chunkReason","forEach","split","ids","changed","j","cmpFn","sortedChunks","sort","a","b","diff1","getChunkModulesSize","diff2","getOrderedChunkModules","filter","selectedModulesSize","k","newSize","push","recordHash","allSplits","invalidSplits","hash","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { STAGE_ADVANCED } = require(\"../OptimizationStages\");\nconst { intersect } = require(\"../util/SetHelpers\");\nconst {\n\tcompareModulesByIdentifier,\n\tcompareChunks\n} = require(\"../util/comparators\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst identifierUtils = require(\"../util/identifier\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.check.js\"),\n\t() =>\n\t\trequire(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\"),\n\t{\n\t\tname: \"Aggressive Splitting Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\nconst moveModuleBetween = (chunkGraph, oldChunk, newChunk) => {\n\treturn module => {\n\t\tchunkGraph.disconnectChunkAndModule(oldChunk, module);\n\t\tchunkGraph.connectChunkAndModule(newChunk, module);\n\t};\n};\n\n/**\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Chunk} chunk the chunk\n * @returns {function(Module): boolean} filter for entry module\n */\nconst isNotAEntryModule = (chunkGraph, chunk) => {\n\treturn module => {\n\t\treturn !chunkGraph.isEntryModuleInChunk(module, chunk);\n\t};\n};\n\n/** @type {WeakSet<Chunk>} */\nconst recordedChunks = new WeakSet();\n\nclass AggressiveSplittingPlugin {\n\t/**\n\t * @param {AggressiveSplittingPluginOptions=} options options object\n\t */\n\tconstructor(options = {}) {\n\t\tvalidate(options);\n\n\t\tthis.options = options;\n\t\tif (typeof this.options.minSize !== \"number\") {\n\t\t\tthis.options.minSize = 30 * 1024;\n\t\t}\n\t\tif (typeof this.options.maxSize !== \"number\") {\n\t\t\tthis.options.maxSize = 50 * 1024;\n\t\t}\n\t\tif (typeof this.options.chunkOverhead !== \"number\") {\n\t\t\tthis.options.chunkOverhead = 0;\n\t\t}\n\t\tif (typeof this.options.entryChunkMultiplicator !== \"number\") {\n\t\t\tthis.options.entryChunkMultiplicator = 1;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk to test\n\t * @returns {boolean} true if the chunk was recorded\n\t */\n\tstatic wasChunkRecorded(chunk) {\n\t\treturn recordedChunks.has(chunk);\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.thisCompilation.tap(\n\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\tcompilation => {\n\t\t\t\tlet needAdditionalSeal = false;\n\t\t\t\tlet newSplits;\n\t\t\t\tlet fromAggressiveSplittingSet;\n\t\t\t\tlet chunkSplitDataMap;\n\t\t\t\tcompilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", () => {\n\t\t\t\t\tnewSplits = [];\n\t\t\t\t\tfromAggressiveSplittingSet = new Set();\n\t\t\t\t\tchunkSplitDataMap = new Map();\n\t\t\t\t});\n\t\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"AggressiveSplittingPlugin\",\n\t\t\t\t\t\tstage: STAGE_ADVANCED\n\t\t\t\t\t},\n\t\t\t\t\tchunks => {\n\t\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\t\t// Precompute stuff\n\t\t\t\t\t\tconst nameToModuleMap = new Map();\n\t\t\t\t\t\tconst moduleToNameMap = new Map();\n\t\t\t\t\t\tconst makePathsRelative =\n\t\t\t\t\t\t\tidentifierUtils.makePathsRelative.bindContextCache(\n\t\t\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\t\t\tcompiler.root\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tfor (const m of compilation.modules) {\n\t\t\t\t\t\t\tconst name = makePathsRelative(m.identifier());\n\t\t\t\t\t\t\tnameToModuleMap.set(name, m);\n\t\t\t\t\t\t\tmoduleToNameMap.set(m, name);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check used chunk ids\n\t\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\tusedIds.add(chunk.id);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst recordedSplits =\n\t\t\t\t\t\t\t(compilation.records && compilation.records.aggressiveSplits) ||\n\t\t\t\t\t\t\t[];\n\t\t\t\t\t\tconst usedSplits = newSplits\n\t\t\t\t\t\t\t? recordedSplits.concat(newSplits)\n\t\t\t\t\t\t\t: recordedSplits;\n\n\t\t\t\t\t\tconst minSize = this.options.minSize;\n\t\t\t\t\t\tconst maxSize = this.options.maxSize;\n\n\t\t\t\t\t\tconst applySplit = splitData => {\n\t\t\t\t\t\t\t// Cannot split if id is already taken\n\t\t\t\t\t\t\tif (splitData.id !== undefined && usedIds.has(splitData.id)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get module objects from names\n\t\t\t\t\t\t\tconst selectedModules = splitData.modules.map(name =>\n\t\t\t\t\t\t\t\tnameToModuleMap.get(name)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Does the modules exist at all?\n\t\t\t\t\t\t\tif (!selectedModules.every(Boolean)) return false;\n\n\t\t\t\t\t\t\t// Check if size matches (faster than waiting for hash)\n\t\t\t\t\t\t\tlet size = 0;\n\t\t\t\t\t\t\tfor (const m of selectedModules) size += m.size();\n\t\t\t\t\t\t\tif (size !== splitData.size) return false;\n\n\t\t\t\t\t\t\t// get chunks with all modules\n\t\t\t\t\t\t\tconst selectedChunks = intersect(\n\t\t\t\t\t\t\t\tselectedModules.map(\n\t\t\t\t\t\t\t\t\tm => new Set(chunkGraph.getModuleChunksIterable(m))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// No relevant chunks found\n\t\t\t\t\t\t\tif (selectedChunks.size === 0) return false;\n\n\t\t\t\t\t\t\t// The found chunk is already the split or similar\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tselectedChunks.size === 1 &&\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(\n\t\t\t\t\t\t\t\t\tArray.from(selectedChunks)[0]\n\t\t\t\t\t\t\t\t) === selectedModules.length\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst chunk = Array.from(selectedChunks)[0];\n\t\t\t\t\t\t\t\tif (fromAggressiveSplittingSet.has(chunk)) return false;\n\t\t\t\t\t\t\t\tfromAggressiveSplittingSet.add(chunk);\n\t\t\t\t\t\t\t\tchunkSplitDataMap.set(chunk, splitData);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// split the chunk into two parts\n\t\t\t\t\t\t\tconst newChunk = compilation.addChunk();\n\t\t\t\t\t\t\tnewChunk.chunkReason = \"aggressive splitted\";\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\tselectedModules.forEach(\n\t\t\t\t\t\t\t\t\tmoveModuleBetween(chunkGraph, chunk, newChunk)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tchunk.split(newChunk);\n\t\t\t\t\t\t\t\tchunk.name = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfromAggressiveSplittingSet.add(newChunk);\n\t\t\t\t\t\t\tchunkSplitDataMap.set(newChunk, splitData);\n\n\t\t\t\t\t\t\tif (splitData.id !== null && splitData.id !== undefined) {\n\t\t\t\t\t\t\t\tnewChunk.id = splitData.id;\n\t\t\t\t\t\t\t\tnewChunk.ids = [splitData.id];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// try to restore to recorded splitting\n\t\t\t\t\t\tlet changed = false;\n\t\t\t\t\t\tfor (let j = 0; j < usedSplits.length; j++) {\n\t\t\t\t\t\t\tconst splitData = usedSplits[j];\n\t\t\t\t\t\t\tif (applySplit(splitData)) changed = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// for any chunk which isn't splitted yet, split it and create a new entry\n\t\t\t\t\t\t// start with the biggest chunk\n\t\t\t\t\t\tconst cmpFn = compareChunks(chunkGraph);\n\t\t\t\t\t\tconst sortedChunks = Array.from(chunks).sort((a, b) => {\n\t\t\t\t\t\t\tconst diff1 =\n\t\t\t\t\t\t\t\tchunkGraph.getChunkModulesSize(b) -\n\t\t\t\t\t\t\t\tchunkGraph.getChunkModulesSize(a);\n\t\t\t\t\t\t\tif (diff1) return diff1;\n\t\t\t\t\t\t\tconst diff2 =\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(a) -\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(b);\n\t\t\t\t\t\t\tif (diff2) return diff2;\n\t\t\t\t\t\t\treturn cmpFn(a, b);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfor (const chunk of sortedChunks) {\n\t\t\t\t\t\t\tif (fromAggressiveSplittingSet.has(chunk)) continue;\n\t\t\t\t\t\t\tconst size = chunkGraph.getChunkModulesSize(chunk);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tsize > maxSize &&\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(chunk) > 1\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst modules = chunkGraph\n\t\t\t\t\t\t\t\t\t.getOrderedChunkModules(chunk, compareModulesByIdentifier)\n\t\t\t\t\t\t\t\t\t.filter(isNotAEntryModule(chunkGraph, chunk));\n\t\t\t\t\t\t\t\tconst selectedModules = [];\n\t\t\t\t\t\t\t\tlet selectedModulesSize = 0;\n\t\t\t\t\t\t\t\tfor (let k = 0; k < modules.length; k++) {\n\t\t\t\t\t\t\t\t\tconst module = modules[k];\n\t\t\t\t\t\t\t\t\tconst newSize = selectedModulesSize + module.size();\n\t\t\t\t\t\t\t\t\tif (newSize > maxSize && selectedModulesSize >= minSize) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tselectedModulesSize = newSize;\n\t\t\t\t\t\t\t\t\tselectedModules.push(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (selectedModules.length === 0) continue;\n\t\t\t\t\t\t\t\tconst splitData = {\n\t\t\t\t\t\t\t\t\tmodules: selectedModules\n\t\t\t\t\t\t\t\t\t\t.map(m => moduleToNameMap.get(m))\n\t\t\t\t\t\t\t\t\t\t.sort(),\n\t\t\t\t\t\t\t\t\tsize: selectedModulesSize\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tif (applySplit(splitData)) {\n\t\t\t\t\t\t\t\t\tnewSplits = (newSplits || []).concat(splitData);\n\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (changed) return true;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.recordHash.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\trecords => {\n\t\t\t\t\t\t// 4. save made splittings to records\n\t\t\t\t\t\tconst allSplits = new Set();\n\t\t\t\t\t\tconst invalidSplits = new Set();\n\n\t\t\t\t\t\t// Check if some splittings are invalid\n\t\t\t\t\t\t// We remove invalid splittings and try again\n\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\tconst splitData = chunkSplitDataMap.get(chunk);\n\t\t\t\t\t\t\tif (splitData !== undefined) {\n\t\t\t\t\t\t\t\tif (splitData.hash && chunk.hash !== splitData.hash) {\n\t\t\t\t\t\t\t\t\t// Split was successful, but hash doesn't equal\n\t\t\t\t\t\t\t\t\t// We can throw away the split since it's useless now\n\t\t\t\t\t\t\t\t\tinvalidSplits.add(splitData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (invalidSplits.size > 0) {\n\t\t\t\t\t\t\trecords.aggressiveSplits = records.aggressiveSplits.filter(\n\t\t\t\t\t\t\t\tsplitData => !invalidSplits.has(splitData)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tneedAdditionalSeal = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// set hash and id values on all (new) splittings\n\t\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\t\tconst splitData = chunkSplitDataMap.get(chunk);\n\t\t\t\t\t\t\t\tif (splitData !== undefined) {\n\t\t\t\t\t\t\t\t\tsplitData.hash = chunk.hash;\n\t\t\t\t\t\t\t\t\tsplitData.id = chunk.id;\n\t\t\t\t\t\t\t\t\tallSplits.add(splitData);\n\t\t\t\t\t\t\t\t\t// set flag for stats\n\t\t\t\t\t\t\t\t\trecordedChunks.add(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Also add all unused historical splits (after the used ones)\n\t\t\t\t\t\t\t// They can still be used in some future compilation\n\t\t\t\t\t\t\tconst recordedSplits =\n\t\t\t\t\t\t\t\tcompilation.records && compilation.records.aggressiveSplits;\n\t\t\t\t\t\t\tif (recordedSplits) {\n\t\t\t\t\t\t\t\tfor (const splitData of recordedSplits) {\n\t\t\t\t\t\t\t\t\tif (!invalidSplits.has(splitData)) allSplits.add(splitData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// record all splits\n\t\t\t\t\t\t\trecords.aggressiveSplits = Array.from(allSplits);\n\n\t\t\t\t\t\t\tneedAdditionalSeal = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.needAdditionalSeal.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\t() => {\n\t\t\t\t\t\tif (needAdditionalSeal) {\n\t\t\t\t\t\t\tneedAdditionalSeal = false;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = AggressiveSplittingPlugin;\n"]},"metadata":{},"sourceType":"script"}