{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/** @typedef {import(\"./Module\")} Module */\n\nconst MODULE_REFERENCE_REGEXP = /^__WEBPACK_MODULE_REFERENCE__(\\d+)_([\\da-f]+|ns)(_call)?(_directImport)?(?:_asiSafe(\\d))?__$/;\nconst DEFAULT_EXPORT = \"__WEBPACK_DEFAULT_EXPORT__\";\nconst NAMESPACE_OBJECT_EXPORT = \"__WEBPACK_NAMESPACE_OBJECT__\";\n/**\n * @typedef {Object} ExternalModuleInfo\n * @property {number} index\n * @property {Module} module\n */\n\n/**\n * @typedef {Object} ConcatenatedModuleInfo\n * @property {number} index\n * @property {Module} module\n * @property {Map<string, string>} exportMap mapping from export name to symbol\n * @property {Map<string, string>} rawExportMap mapping from export name to symbol\n * @property {string=} namespaceExportSymbol\n */\n\n/** @typedef {ConcatenatedModuleInfo | ExternalModuleInfo} ModuleInfo */\n\n/**\n * @typedef {Object} ModuleReferenceOptions\n * @property {string[]} ids the properties/exports of the module\n * @property {boolean} call true, when this referenced export is called\n * @property {boolean} directImport true, when this referenced export is directly imported (not via property access)\n * @property {boolean | undefined} asiSafe if the position is ASI safe or unknown\n */\n\nclass ConcatenationScope {\n  /**\n   * @param {ModuleInfo[] | Map<Module, ModuleInfo>} modulesMap all module info by module\n   * @param {ConcatenatedModuleInfo} currentModule the current module info\n   */\n  constructor(modulesMap, currentModule) {\n    this._currentModule = currentModule;\n\n    if (Array.isArray(modulesMap)) {\n      const map = new Map();\n\n      for (const info of modulesMap) {\n        map.set(info.module, info);\n      }\n\n      modulesMap = map;\n    }\n\n    this._modulesMap = modulesMap;\n  }\n  /**\n   * @param {Module} module the referenced module\n   * @returns {boolean} true, when it's in the scope\n   */\n\n\n  isModuleInScope(module) {\n    return this._modulesMap.has(module);\n  }\n  /**\n   *\n   * @param {string} exportName name of the export\n   * @param {string} symbol identifier of the export in source code\n   */\n\n\n  registerExport(exportName, symbol) {\n    if (!this._currentModule.exportMap) {\n      this._currentModule.exportMap = new Map();\n    }\n\n    if (!this._currentModule.exportMap.has(exportName)) {\n      this._currentModule.exportMap.set(exportName, symbol);\n    }\n  }\n  /**\n   *\n   * @param {string} exportName name of the export\n   * @param {string} expression expression to be used\n   */\n\n\n  registerRawExport(exportName, expression) {\n    if (!this._currentModule.rawExportMap) {\n      this._currentModule.rawExportMap = new Map();\n    }\n\n    if (!this._currentModule.rawExportMap.has(exportName)) {\n      this._currentModule.rawExportMap.set(exportName, expression);\n    }\n  }\n  /**\n   * @param {string} symbol identifier of the export in source code\n   */\n\n\n  registerNamespaceExport(symbol) {\n    this._currentModule.namespaceExportSymbol = symbol;\n  }\n  /**\n   *\n   * @param {Module} module the referenced module\n   * @param {Partial<ModuleReferenceOptions>} options options\n   * @returns {string} the reference as identifier\n   */\n\n\n  createModuleReference(module, _ref) {\n    let {\n      ids = undefined,\n      call = false,\n      directImport = false,\n      asiSafe = false\n    } = _ref;\n\n    const info = this._modulesMap.get(module);\n\n    const callFlag = call ? \"_call\" : \"\";\n    const directImportFlag = directImport ? \"_directImport\" : \"\";\n    const asiSafeFlag = asiSafe ? \"_asiSafe1\" : asiSafe === false ? \"_asiSafe0\" : \"\";\n    const exportData = ids ? Buffer.from(JSON.stringify(ids), \"utf-8\").toString(\"hex\") : \"ns\"; // a \"._\" is appended to allow \"delete ...\", which would cause a SyntaxError in strict mode\n\n    return `__WEBPACK_MODULE_REFERENCE__${info.index}_${exportData}${callFlag}${directImportFlag}${asiSafeFlag}__._`;\n  }\n  /**\n   * @param {string} name the identifier\n   * @returns {boolean} true, when it's an module reference\n   */\n\n\n  static isModuleReference(name) {\n    return MODULE_REFERENCE_REGEXP.test(name);\n  }\n  /**\n   * @param {string} name the identifier\n   * @returns {ModuleReferenceOptions & { index: number }} parsed options and index\n   */\n\n\n  static matchModuleReference(name) {\n    const match = MODULE_REFERENCE_REGEXP.exec(name);\n    if (!match) return null;\n    const index = +match[1];\n    const asiSafe = match[5];\n    return {\n      index,\n      ids: match[2] === \"ns\" ? [] : JSON.parse(Buffer.from(match[2], \"hex\").toString(\"utf-8\")),\n      call: !!match[3],\n      directImport: !!match[4],\n      asiSafe: asiSafe ? asiSafe === \"1\" : undefined\n    };\n  }\n\n}\n\nConcatenationScope.DEFAULT_EXPORT = DEFAULT_EXPORT;\nConcatenationScope.NAMESPACE_OBJECT_EXPORT = NAMESPACE_OBJECT_EXPORT;\nmodule.exports = ConcatenationScope;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/ConcatenationScope.js"],"names":["MODULE_REFERENCE_REGEXP","DEFAULT_EXPORT","NAMESPACE_OBJECT_EXPORT","ConcatenationScope","constructor","modulesMap","currentModule","_currentModule","Array","isArray","map","Map","info","set","module","_modulesMap","isModuleInScope","has","registerExport","exportName","symbol","exportMap","registerRawExport","expression","rawExportMap","registerNamespaceExport","namespaceExportSymbol","createModuleReference","ids","undefined","call","directImport","asiSafe","get","callFlag","directImportFlag","asiSafeFlag","exportData","Buffer","from","JSON","stringify","toString","index","isModuleReference","name","test","matchModuleReference","match","exec","parse","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @typedef {import(\"./Module\")} Module */\n\nconst MODULE_REFERENCE_REGEXP =\n\t/^__WEBPACK_MODULE_REFERENCE__(\\d+)_([\\da-f]+|ns)(_call)?(_directImport)?(?:_asiSafe(\\d))?__$/;\n\nconst DEFAULT_EXPORT = \"__WEBPACK_DEFAULT_EXPORT__\";\nconst NAMESPACE_OBJECT_EXPORT = \"__WEBPACK_NAMESPACE_OBJECT__\";\n\n/**\n * @typedef {Object} ExternalModuleInfo\n * @property {number} index\n * @property {Module} module\n */\n\n/**\n * @typedef {Object} ConcatenatedModuleInfo\n * @property {number} index\n * @property {Module} module\n * @property {Map<string, string>} exportMap mapping from export name to symbol\n * @property {Map<string, string>} rawExportMap mapping from export name to symbol\n * @property {string=} namespaceExportSymbol\n */\n\n/** @typedef {ConcatenatedModuleInfo | ExternalModuleInfo} ModuleInfo */\n\n/**\n * @typedef {Object} ModuleReferenceOptions\n * @property {string[]} ids the properties/exports of the module\n * @property {boolean} call true, when this referenced export is called\n * @property {boolean} directImport true, when this referenced export is directly imported (not via property access)\n * @property {boolean | undefined} asiSafe if the position is ASI safe or unknown\n */\n\nclass ConcatenationScope {\n\t/**\n\t * @param {ModuleInfo[] | Map<Module, ModuleInfo>} modulesMap all module info by module\n\t * @param {ConcatenatedModuleInfo} currentModule the current module info\n\t */\n\tconstructor(modulesMap, currentModule) {\n\t\tthis._currentModule = currentModule;\n\t\tif (Array.isArray(modulesMap)) {\n\t\t\tconst map = new Map();\n\t\t\tfor (const info of modulesMap) {\n\t\t\t\tmap.set(info.module, info);\n\t\t\t}\n\t\t\tmodulesMap = map;\n\t\t}\n\t\tthis._modulesMap = modulesMap;\n\t}\n\n\t/**\n\t * @param {Module} module the referenced module\n\t * @returns {boolean} true, when it's in the scope\n\t */\n\tisModuleInScope(module) {\n\t\treturn this._modulesMap.has(module);\n\t}\n\n\t/**\n\t *\n\t * @param {string} exportName name of the export\n\t * @param {string} symbol identifier of the export in source code\n\t */\n\tregisterExport(exportName, symbol) {\n\t\tif (!this._currentModule.exportMap) {\n\t\t\tthis._currentModule.exportMap = new Map();\n\t\t}\n\t\tif (!this._currentModule.exportMap.has(exportName)) {\n\t\t\tthis._currentModule.exportMap.set(exportName, symbol);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param {string} exportName name of the export\n\t * @param {string} expression expression to be used\n\t */\n\tregisterRawExport(exportName, expression) {\n\t\tif (!this._currentModule.rawExportMap) {\n\t\t\tthis._currentModule.rawExportMap = new Map();\n\t\t}\n\t\tif (!this._currentModule.rawExportMap.has(exportName)) {\n\t\t\tthis._currentModule.rawExportMap.set(exportName, expression);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} symbol identifier of the export in source code\n\t */\n\tregisterNamespaceExport(symbol) {\n\t\tthis._currentModule.namespaceExportSymbol = symbol;\n\t}\n\n\t/**\n\t *\n\t * @param {Module} module the referenced module\n\t * @param {Partial<ModuleReferenceOptions>} options options\n\t * @returns {string} the reference as identifier\n\t */\n\tcreateModuleReference(\n\t\tmodule,\n\t\t{ ids = undefined, call = false, directImport = false, asiSafe = false }\n\t) {\n\t\tconst info = this._modulesMap.get(module);\n\t\tconst callFlag = call ? \"_call\" : \"\";\n\t\tconst directImportFlag = directImport ? \"_directImport\" : \"\";\n\t\tconst asiSafeFlag = asiSafe\n\t\t\t? \"_asiSafe1\"\n\t\t\t: asiSafe === false\n\t\t\t? \"_asiSafe0\"\n\t\t\t: \"\";\n\t\tconst exportData = ids\n\t\t\t? Buffer.from(JSON.stringify(ids), \"utf-8\").toString(\"hex\")\n\t\t\t: \"ns\";\n\t\t// a \"._\" is appended to allow \"delete ...\", which would cause a SyntaxError in strict mode\n\t\treturn `__WEBPACK_MODULE_REFERENCE__${info.index}_${exportData}${callFlag}${directImportFlag}${asiSafeFlag}__._`;\n\t}\n\n\t/**\n\t * @param {string} name the identifier\n\t * @returns {boolean} true, when it's an module reference\n\t */\n\tstatic isModuleReference(name) {\n\t\treturn MODULE_REFERENCE_REGEXP.test(name);\n\t}\n\n\t/**\n\t * @param {string} name the identifier\n\t * @returns {ModuleReferenceOptions & { index: number }} parsed options and index\n\t */\n\tstatic matchModuleReference(name) {\n\t\tconst match = MODULE_REFERENCE_REGEXP.exec(name);\n\t\tif (!match) return null;\n\t\tconst index = +match[1];\n\t\tconst asiSafe = match[5];\n\t\treturn {\n\t\t\tindex,\n\t\t\tids:\n\t\t\t\tmatch[2] === \"ns\"\n\t\t\t\t\t? []\n\t\t\t\t\t: JSON.parse(Buffer.from(match[2], \"hex\").toString(\"utf-8\")),\n\t\t\tcall: !!match[3],\n\t\t\tdirectImport: !!match[4],\n\t\t\tasiSafe: asiSafe ? asiSafe === \"1\" : undefined\n\t\t};\n\t}\n}\n\nConcatenationScope.DEFAULT_EXPORT = DEFAULT_EXPORT;\nConcatenationScope.NAMESPACE_OBJECT_EXPORT = NAMESPACE_OBJECT_EXPORT;\n\nmodule.exports = ConcatenationScope;\n"]},"metadata":{},"sourceType":"script"}