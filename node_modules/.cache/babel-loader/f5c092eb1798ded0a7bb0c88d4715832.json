{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  HookMap,\n  SyncWaterfallHook,\n  SyncBailHook\n} = require(\"tapable\");\n/** @template T @typedef {import(\"tapable\").AsArray<T>} AsArray<T> */\n\n/** @typedef {import(\"tapable\").Hook} Hook */\n\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsAsset} StatsAsset */\n\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsChunk} StatsChunk */\n\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsChunkGroup} StatsChunkGroup */\n\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsCompilation} StatsCompilation */\n\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsModule} StatsModule */\n\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsModuleReason} StatsModuleReason */\n\n/**\n * @typedef {Object} PrintedElement\n * @property {string} element\n * @property {string} content\n */\n\n/**\n * @typedef {Object} KnownStatsPrinterContext\n * @property {string=} type\n * @property {StatsCompilation=} compilation\n * @property {StatsChunkGroup=} chunkGroup\n * @property {StatsAsset=} asset\n * @property {StatsModule=} module\n * @property {StatsChunk=} chunk\n * @property {StatsModuleReason=} moduleReason\n * @property {(str: string) => string=} bold\n * @property {(str: string) => string=} yellow\n * @property {(str: string) => string=} red\n * @property {(str: string) => string=} green\n * @property {(str: string) => string=} magenta\n * @property {(str: string) => string=} cyan\n * @property {(file: string, oversize?: boolean) => string=} formatFilename\n * @property {(id: string) => string=} formatModuleId\n * @property {(id: string, direction?: \"parent\"|\"child\"|\"sibling\") => string=} formatChunkId\n * @property {(size: number) => string=} formatSize\n * @property {(dateTime: number) => string=} formatDateTime\n * @property {(flag: string) => string=} formatFlag\n * @property {(time: number, boldQuantity?: boolean) => string=} formatTime\n * @property {string=} chunkGroupKind\n */\n\n/** @typedef {KnownStatsPrinterContext & Record<string, any>} StatsPrinterContext */\n\n\nclass StatsPrinter {\n  constructor() {\n    this.hooks = Object.freeze({\n      /** @type {HookMap<SyncBailHook<[string[], StatsPrinterContext], true>>} */\n      sortElements: new HookMap(() => new SyncBailHook([\"elements\", \"context\"])),\n\n      /** @type {HookMap<SyncBailHook<[PrintedElement[], StatsPrinterContext], string>>} */\n      printElements: new HookMap(() => new SyncBailHook([\"printedElements\", \"context\"])),\n\n      /** @type {HookMap<SyncBailHook<[any[], StatsPrinterContext], true>>} */\n      sortItems: new HookMap(() => new SyncBailHook([\"items\", \"context\"])),\n\n      /** @type {HookMap<SyncBailHook<[any, StatsPrinterContext], string>>} */\n      getItemName: new HookMap(() => new SyncBailHook([\"item\", \"context\"])),\n\n      /** @type {HookMap<SyncBailHook<[string[], StatsPrinterContext], string>>} */\n      printItems: new HookMap(() => new SyncBailHook([\"printedItems\", \"context\"])),\n\n      /** @type {HookMap<SyncBailHook<[{}, StatsPrinterContext], string>>} */\n      print: new HookMap(() => new SyncBailHook([\"object\", \"context\"])),\n\n      /** @type {HookMap<SyncWaterfallHook<[string, StatsPrinterContext]>>} */\n      result: new HookMap(() => new SyncWaterfallHook([\"result\", \"context\"]))\n    });\n    /** @type {Map<HookMap<Hook>, Map<string, Hook[]>>} */\n\n    this._levelHookCache = new Map();\n    this._inPrint = false;\n  }\n  /**\n   * get all level hooks\n   * @private\n   * @template {Hook} T\n   * @param {HookMap<T>} hookMap HookMap\n   * @param {string} type type\n   * @returns {T[]} hooks\n   */\n\n\n  _getAllLevelHooks(hookMap, type) {\n    let cache =\n    /** @type {Map<string, T[]>} */\n    this._levelHookCache.get(hookMap);\n\n    if (cache === undefined) {\n      cache = new Map();\n\n      this._levelHookCache.set(hookMap, cache);\n    }\n\n    const cacheEntry = cache.get(type);\n\n    if (cacheEntry !== undefined) {\n      return cacheEntry;\n    }\n    /** @type {T[]} */\n\n\n    const hooks = [];\n    const typeParts = type.split(\".\");\n\n    for (let i = 0; i < typeParts.length; i++) {\n      const hook = hookMap.get(typeParts.slice(i).join(\".\"));\n\n      if (hook) {\n        hooks.push(hook);\n      }\n    }\n\n    cache.set(type, hooks);\n    return hooks;\n  }\n  /**\n   * Run `fn` for each level\n   * @private\n   * @template T\n   * @template R\n   * @param {HookMap<SyncBailHook<T, R>>} hookMap HookMap\n   * @param {string} type type\n   * @param {(hook: SyncBailHook<T, R>) => R} fn function\n   * @returns {R} result of `fn`\n   */\n\n\n  _forEachLevel(hookMap, type, fn) {\n    for (const hook of this._getAllLevelHooks(hookMap, type)) {\n      const result = fn(hook);\n      if (result !== undefined) return result;\n    }\n  }\n  /**\n   * Run `fn` for each level\n   * @private\n   * @template T\n   * @param {HookMap<SyncWaterfallHook<T>>} hookMap HookMap\n   * @param {string} type type\n   * @param {AsArray<T>[0]} data data\n   * @param {(hook: SyncWaterfallHook<T>, data: AsArray<T>[0]) => AsArray<T>[0]} fn function\n   * @returns {AsArray<T>[0]} result of `fn`\n   */\n\n\n  _forEachLevelWaterfall(hookMap, type, data, fn) {\n    for (const hook of this._getAllLevelHooks(hookMap, type)) {\n      data = fn(hook, data);\n    }\n\n    return data;\n  }\n  /**\n   * @param {string} type The type\n   * @param {Object} object Object to print\n   * @param {Object=} baseContext The base context\n   * @returns {string} printed result\n   */\n\n\n  print(type, object, baseContext) {\n    if (this._inPrint) {\n      return this._print(type, object, baseContext);\n    } else {\n      try {\n        this._inPrint = true;\n        return this._print(type, object, baseContext);\n      } finally {\n        this._levelHookCache.clear();\n\n        this._inPrint = false;\n      }\n    }\n  }\n  /**\n   * @private\n   * @param {string} type type\n   * @param {Object} object object\n   * @param {Object=} baseContext context\n   * @returns {string} printed result\n   */\n\n\n  _print(type, object, baseContext) {\n    const context = { ...baseContext,\n      type,\n      [type]: object\n    };\n\n    let printResult = this._forEachLevel(this.hooks.print, type, hook => hook.call(object, context));\n\n    if (printResult === undefined) {\n      if (Array.isArray(object)) {\n        const sortedItems = object.slice();\n\n        this._forEachLevel(this.hooks.sortItems, type, h => h.call(sortedItems, context));\n\n        const printedItems = sortedItems.map((item, i) => {\n          const itemContext = { ...context,\n            _index: i\n          };\n\n          const itemName = this._forEachLevel(this.hooks.getItemName, `${type}[]`, h => h.call(item, itemContext));\n\n          if (itemName) itemContext[itemName] = item;\n          return this.print(itemName ? `${type}[].${itemName}` : `${type}[]`, item, itemContext);\n        });\n        printResult = this._forEachLevel(this.hooks.printItems, type, h => h.call(printedItems, context));\n\n        if (printResult === undefined) {\n          const result = printedItems.filter(Boolean);\n          if (result.length > 0) printResult = result.join(\"\\n\");\n        }\n      } else if (object !== null && typeof object === \"object\") {\n        const elements = Object.keys(object).filter(key => object[key] !== undefined);\n\n        this._forEachLevel(this.hooks.sortElements, type, h => h.call(elements, context));\n\n        const printedElements = elements.map(element => {\n          const content = this.print(`${type}.${element}`, object[element], { ...context,\n            _parent: object,\n            _element: element,\n            [element]: object[element]\n          });\n          return {\n            element,\n            content\n          };\n        });\n        printResult = this._forEachLevel(this.hooks.printElements, type, h => h.call(printedElements, context));\n\n        if (printResult === undefined) {\n          const result = printedElements.map(e => e.content).filter(Boolean);\n          if (result.length > 0) printResult = result.join(\"\\n\");\n        }\n      }\n    }\n\n    return this._forEachLevelWaterfall(this.hooks.result, type, printResult, (h, r) => h.call(r, context));\n  }\n\n}\n\nmodule.exports = StatsPrinter;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/stats/StatsPrinter.js"],"names":["HookMap","SyncWaterfallHook","SyncBailHook","require","StatsPrinter","constructor","hooks","Object","freeze","sortElements","printElements","sortItems","getItemName","printItems","print","result","_levelHookCache","Map","_inPrint","_getAllLevelHooks","hookMap","type","cache","get","undefined","set","cacheEntry","typeParts","split","i","length","hook","slice","join","push","_forEachLevel","fn","_forEachLevelWaterfall","data","object","baseContext","_print","clear","context","printResult","call","Array","isArray","sortedItems","h","printedItems","map","item","itemContext","_index","itemName","filter","Boolean","elements","keys","key","printedElements","element","content","_parent","_element","e","r","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { HookMap, SyncWaterfallHook, SyncBailHook } = require(\"tapable\");\n\n/** @template T @typedef {import(\"tapable\").AsArray<T>} AsArray<T> */\n/** @typedef {import(\"tapable\").Hook} Hook */\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsAsset} StatsAsset */\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsChunk} StatsChunk */\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsChunkGroup} StatsChunkGroup */\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsCompilation} StatsCompilation */\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsModule} StatsModule */\n/** @typedef {import(\"./DefaultStatsFactoryPlugin\").StatsModuleReason} StatsModuleReason */\n\n/**\n * @typedef {Object} PrintedElement\n * @property {string} element\n * @property {string} content\n */\n\n/**\n * @typedef {Object} KnownStatsPrinterContext\n * @property {string=} type\n * @property {StatsCompilation=} compilation\n * @property {StatsChunkGroup=} chunkGroup\n * @property {StatsAsset=} asset\n * @property {StatsModule=} module\n * @property {StatsChunk=} chunk\n * @property {StatsModuleReason=} moduleReason\n * @property {(str: string) => string=} bold\n * @property {(str: string) => string=} yellow\n * @property {(str: string) => string=} red\n * @property {(str: string) => string=} green\n * @property {(str: string) => string=} magenta\n * @property {(str: string) => string=} cyan\n * @property {(file: string, oversize?: boolean) => string=} formatFilename\n * @property {(id: string) => string=} formatModuleId\n * @property {(id: string, direction?: \"parent\"|\"child\"|\"sibling\") => string=} formatChunkId\n * @property {(size: number) => string=} formatSize\n * @property {(dateTime: number) => string=} formatDateTime\n * @property {(flag: string) => string=} formatFlag\n * @property {(time: number, boldQuantity?: boolean) => string=} formatTime\n * @property {string=} chunkGroupKind\n */\n\n/** @typedef {KnownStatsPrinterContext & Record<string, any>} StatsPrinterContext */\n\nclass StatsPrinter {\n\tconstructor() {\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {HookMap<SyncBailHook<[string[], StatsPrinterContext], true>>} */\n\t\t\tsortElements: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"elements\", \"context\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[PrintedElement[], StatsPrinterContext], string>>} */\n\t\t\tprintElements: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"printedElements\", \"context\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[any[], StatsPrinterContext], true>>} */\n\t\t\tsortItems: new HookMap(() => new SyncBailHook([\"items\", \"context\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[any, StatsPrinterContext], string>>} */\n\t\t\tgetItemName: new HookMap(() => new SyncBailHook([\"item\", \"context\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[string[], StatsPrinterContext], string>>} */\n\t\t\tprintItems: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"printedItems\", \"context\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[{}, StatsPrinterContext], string>>} */\n\t\t\tprint: new HookMap(() => new SyncBailHook([\"object\", \"context\"])),\n\t\t\t/** @type {HookMap<SyncWaterfallHook<[string, StatsPrinterContext]>>} */\n\t\t\tresult: new HookMap(() => new SyncWaterfallHook([\"result\", \"context\"]))\n\t\t});\n\t\t/** @type {Map<HookMap<Hook>, Map<string, Hook[]>>} */\n\t\tthis._levelHookCache = new Map();\n\t\tthis._inPrint = false;\n\t}\n\n\t/**\n\t * get all level hooks\n\t * @private\n\t * @template {Hook} T\n\t * @param {HookMap<T>} hookMap HookMap\n\t * @param {string} type type\n\t * @returns {T[]} hooks\n\t */\n\t_getAllLevelHooks(hookMap, type) {\n\t\tlet cache = /** @type {Map<string, T[]>} */ (\n\t\t\tthis._levelHookCache.get(hookMap)\n\t\t);\n\t\tif (cache === undefined) {\n\t\t\tcache = new Map();\n\t\t\tthis._levelHookCache.set(hookMap, cache);\n\t\t}\n\t\tconst cacheEntry = cache.get(type);\n\t\tif (cacheEntry !== undefined) {\n\t\t\treturn cacheEntry;\n\t\t}\n\t\t/** @type {T[]} */\n\t\tconst hooks = [];\n\t\tconst typeParts = type.split(\".\");\n\t\tfor (let i = 0; i < typeParts.length; i++) {\n\t\t\tconst hook = hookMap.get(typeParts.slice(i).join(\".\"));\n\t\t\tif (hook) {\n\t\t\t\thooks.push(hook);\n\t\t\t}\n\t\t}\n\t\tcache.set(type, hooks);\n\t\treturn hooks;\n\t}\n\n\t/**\n\t * Run `fn` for each level\n\t * @private\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap HookMap\n\t * @param {string} type type\n\t * @param {(hook: SyncBailHook<T, R>) => R} fn function\n\t * @returns {R} result of `fn`\n\t */\n\t_forEachLevel(hookMap, type, fn) {\n\t\tfor (const hook of this._getAllLevelHooks(hookMap, type)) {\n\t\t\tconst result = fn(hook);\n\t\t\tif (result !== undefined) return result;\n\t\t}\n\t}\n\n\t/**\n\t * Run `fn` for each level\n\t * @private\n\t * @template T\n\t * @param {HookMap<SyncWaterfallHook<T>>} hookMap HookMap\n\t * @param {string} type type\n\t * @param {AsArray<T>[0]} data data\n\t * @param {(hook: SyncWaterfallHook<T>, data: AsArray<T>[0]) => AsArray<T>[0]} fn function\n\t * @returns {AsArray<T>[0]} result of `fn`\n\t */\n\t_forEachLevelWaterfall(hookMap, type, data, fn) {\n\t\tfor (const hook of this._getAllLevelHooks(hookMap, type)) {\n\t\t\tdata = fn(hook, data);\n\t\t}\n\t\treturn data;\n\t}\n\n\t/**\n\t * @param {string} type The type\n\t * @param {Object} object Object to print\n\t * @param {Object=} baseContext The base context\n\t * @returns {string} printed result\n\t */\n\tprint(type, object, baseContext) {\n\t\tif (this._inPrint) {\n\t\t\treturn this._print(type, object, baseContext);\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tthis._inPrint = true;\n\t\t\t\treturn this._print(type, object, baseContext);\n\t\t\t} finally {\n\t\t\t\tthis._levelHookCache.clear();\n\t\t\t\tthis._inPrint = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * @param {string} type type\n\t * @param {Object} object object\n\t * @param {Object=} baseContext context\n\t * @returns {string} printed result\n\t */\n\t_print(type, object, baseContext) {\n\t\tconst context = {\n\t\t\t...baseContext,\n\t\t\ttype,\n\t\t\t[type]: object\n\t\t};\n\n\t\tlet printResult = this._forEachLevel(this.hooks.print, type, hook =>\n\t\t\thook.call(object, context)\n\t\t);\n\t\tif (printResult === undefined) {\n\t\t\tif (Array.isArray(object)) {\n\t\t\t\tconst sortedItems = object.slice();\n\t\t\t\tthis._forEachLevel(this.hooks.sortItems, type, h =>\n\t\t\t\t\th.call(sortedItems, context)\n\t\t\t\t);\n\t\t\t\tconst printedItems = sortedItems.map((item, i) => {\n\t\t\t\t\tconst itemContext = {\n\t\t\t\t\t\t...context,\n\t\t\t\t\t\t_index: i\n\t\t\t\t\t};\n\t\t\t\t\tconst itemName = this._forEachLevel(\n\t\t\t\t\t\tthis.hooks.getItemName,\n\t\t\t\t\t\t`${type}[]`,\n\t\t\t\t\t\th => h.call(item, itemContext)\n\t\t\t\t\t);\n\t\t\t\t\tif (itemName) itemContext[itemName] = item;\n\t\t\t\t\treturn this.print(\n\t\t\t\t\t\titemName ? `${type}[].${itemName}` : `${type}[]`,\n\t\t\t\t\t\titem,\n\t\t\t\t\t\titemContext\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t\tprintResult = this._forEachLevel(this.hooks.printItems, type, h =>\n\t\t\t\t\th.call(printedItems, context)\n\t\t\t\t);\n\t\t\t\tif (printResult === undefined) {\n\t\t\t\t\tconst result = printedItems.filter(Boolean);\n\t\t\t\t\tif (result.length > 0) printResult = result.join(\"\\n\");\n\t\t\t\t}\n\t\t\t} else if (object !== null && typeof object === \"object\") {\n\t\t\t\tconst elements = Object.keys(object).filter(\n\t\t\t\t\tkey => object[key] !== undefined\n\t\t\t\t);\n\t\t\t\tthis._forEachLevel(this.hooks.sortElements, type, h =>\n\t\t\t\t\th.call(elements, context)\n\t\t\t\t);\n\t\t\t\tconst printedElements = elements.map(element => {\n\t\t\t\t\tconst content = this.print(`${type}.${element}`, object[element], {\n\t\t\t\t\t\t...context,\n\t\t\t\t\t\t_parent: object,\n\t\t\t\t\t\t_element: element,\n\t\t\t\t\t\t[element]: object[element]\n\t\t\t\t\t});\n\t\t\t\t\treturn { element, content };\n\t\t\t\t});\n\t\t\t\tprintResult = this._forEachLevel(this.hooks.printElements, type, h =>\n\t\t\t\t\th.call(printedElements, context)\n\t\t\t\t);\n\t\t\t\tif (printResult === undefined) {\n\t\t\t\t\tconst result = printedElements.map(e => e.content).filter(Boolean);\n\t\t\t\t\tif (result.length > 0) printResult = result.join(\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this._forEachLevelWaterfall(\n\t\t\tthis.hooks.result,\n\t\t\ttype,\n\t\t\tprintResult,\n\t\t\t(h, r) => h.call(r, context)\n\t\t);\n\t}\n}\nmodule.exports = StatsPrinter;\n"]},"metadata":{},"sourceType":"script"}