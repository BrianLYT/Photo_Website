{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  compareRuntime\n} = require(\"./runtime\");\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"../Dependency\").DependencyLocation} DependencyLocation */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n\n/** @template T @typedef {function(T, T): -1|0|1} Comparator */\n\n/** @template TArg @template T @typedef {function(TArg, T, T): -1|0|1} RawParameterizedComparator */\n\n/** @template TArg @template T @typedef {function(TArg): Comparator<T>} ParameterizedComparator */\n\n/**\n * @template T\n * @param {RawParameterizedComparator<any, T>} fn comparator with argument\n * @returns {ParameterizedComparator<any, T>} comparator\n */\n\n\nconst createCachedParameterizedComparator = fn => {\n  /** @type {WeakMap<object, Comparator<T>>} */\n  const map = new WeakMap();\n  return arg => {\n    const cachedResult = map.get(arg);\n    if (cachedResult !== undefined) return cachedResult;\n    /**\n     * @param {T} a first item\n     * @param {T} b second item\n     * @returns {-1|0|1} compare result\n     */\n\n    const result = fn.bind(null, arg);\n    map.set(arg, result);\n    return result;\n  };\n};\n/**\n * @param {Chunk} a chunk\n * @param {Chunk} b chunk\n * @returns {-1|0|1} compare result\n */\n\n\nexports.compareChunksById = (a, b) => {\n  return compareIds(a.id, b.id);\n};\n/**\n * @param {Module} a module\n * @param {Module} b module\n * @returns {-1|0|1} compare result\n */\n\n\nexports.compareModulesByIdentifier = (a, b) => {\n  return compareIds(a.identifier(), b.identifier());\n};\n/**\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Module} a module\n * @param {Module} b module\n * @returns {-1|0|1} compare result\n */\n\n\nconst compareModulesById = (chunkGraph, a, b) => {\n  return compareIds(chunkGraph.getModuleId(a), chunkGraph.getModuleId(b));\n};\n/** @type {ParameterizedComparator<ChunkGraph, Module>} */\n\n\nexports.compareModulesById = createCachedParameterizedComparator(compareModulesById);\n/**\n * @param {number} a number\n * @param {number} b number\n * @returns {-1|0|1} compare result\n */\n\nconst compareNumbers = (a, b) => {\n  if (typeof a !== typeof b) {\n    return typeof a < typeof b ? -1 : 1;\n  }\n\n  if (a < b) return -1;\n  if (a > b) return 1;\n  return 0;\n};\n\nexports.compareNumbers = compareNumbers;\n/**\n * @param {string} a string\n * @param {string} b string\n * @returns {-1|0|1} compare result\n */\n\nconst compareStringsNumeric = (a, b) => {\n  const partsA = a.split(/(\\d+)/);\n  const partsB = b.split(/(\\d+)/);\n  const len = Math.min(partsA.length, partsB.length);\n\n  for (let i = 0; i < len; i++) {\n    const pA = partsA[i];\n    const pB = partsB[i];\n\n    if (i % 2 === 0) {\n      if (pA.length > pB.length) {\n        if (pA.slice(0, pB.length) > pB) return 1;\n        return -1;\n      } else if (pB.length > pA.length) {\n        if (pB.slice(0, pA.length) > pA) return -1;\n        return 1;\n      } else {\n        if (pA < pB) return -1;\n        if (pA > pB) return 1;\n      }\n    } else {\n      const nA = +pA;\n      const nB = +pB;\n      if (nA < nB) return -1;\n      if (nA > nB) return 1;\n    }\n  }\n\n  if (partsB.length < partsA.length) return 1;\n  if (partsB.length > partsA.length) return -1;\n  return 0;\n};\n\nexports.compareStringsNumeric = compareStringsNumeric;\n/**\n * @param {ModuleGraph} moduleGraph the module graph\n * @param {Module} a module\n * @param {Module} b module\n * @returns {-1|0|1} compare result\n */\n\nconst compareModulesByPostOrderIndexOrIdentifier = (moduleGraph, a, b) => {\n  const cmp = compareNumbers(moduleGraph.getPostOrderIndex(a), moduleGraph.getPostOrderIndex(b));\n  if (cmp !== 0) return cmp;\n  return compareIds(a.identifier(), b.identifier());\n};\n/** @type {ParameterizedComparator<ModuleGraph, Module>} */\n\n\nexports.compareModulesByPostOrderIndexOrIdentifier = createCachedParameterizedComparator(compareModulesByPostOrderIndexOrIdentifier);\n/**\n * @param {ModuleGraph} moduleGraph the module graph\n * @param {Module} a module\n * @param {Module} b module\n * @returns {-1|0|1} compare result\n */\n\nconst compareModulesByPreOrderIndexOrIdentifier = (moduleGraph, a, b) => {\n  const cmp = compareNumbers(moduleGraph.getPreOrderIndex(a), moduleGraph.getPreOrderIndex(b));\n  if (cmp !== 0) return cmp;\n  return compareIds(a.identifier(), b.identifier());\n};\n/** @type {ParameterizedComparator<ModuleGraph, Module>} */\n\n\nexports.compareModulesByPreOrderIndexOrIdentifier = createCachedParameterizedComparator(compareModulesByPreOrderIndexOrIdentifier);\n/**\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Module} a module\n * @param {Module} b module\n * @returns {-1|0|1} compare result\n */\n\nconst compareModulesByIdOrIdentifier = (chunkGraph, a, b) => {\n  const cmp = compareIds(chunkGraph.getModuleId(a), chunkGraph.getModuleId(b));\n  if (cmp !== 0) return cmp;\n  return compareIds(a.identifier(), b.identifier());\n};\n/** @type {ParameterizedComparator<ChunkGraph, Module>} */\n\n\nexports.compareModulesByIdOrIdentifier = createCachedParameterizedComparator(compareModulesByIdOrIdentifier);\n/**\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Chunk} a chunk\n * @param {Chunk} b chunk\n * @returns {-1|0|1} compare result\n */\n\nconst compareChunks = (chunkGraph, a, b) => {\n  return chunkGraph.compareChunks(a, b);\n};\n/** @type {ParameterizedComparator<ChunkGraph, Chunk>} */\n\n\nexports.compareChunks = createCachedParameterizedComparator(compareChunks);\n/**\n * @param {string|number} a first id\n * @param {string|number} b second id\n * @returns {-1|0|1} compare result\n */\n\nconst compareIds = (a, b) => {\n  if (typeof a !== typeof b) {\n    return typeof a < typeof b ? -1 : 1;\n  }\n\n  if (a < b) return -1;\n  if (a > b) return 1;\n  return 0;\n};\n\nexports.compareIds = compareIds;\n/**\n * @param {string} a first string\n * @param {string} b second string\n * @returns {-1|0|1} compare result\n */\n\nconst compareStrings = (a, b) => {\n  if (a < b) return -1;\n  if (a > b) return 1;\n  return 0;\n};\n\nexports.compareStrings = compareStrings;\n/**\n * @param {ChunkGroup} a first chunk group\n * @param {ChunkGroup} b second chunk group\n * @returns {-1|0|1} compare result\n */\n\nconst compareChunkGroupsByIndex = (a, b) => {\n  return a.index < b.index ? -1 : 1;\n};\n\nexports.compareChunkGroupsByIndex = compareChunkGroupsByIndex;\n/**\n * @template K1 {Object}\n * @template K2\n * @template T\n */\n\nclass TwoKeyWeakMap {\n  constructor() {\n    /** @private @type {WeakMap<any, WeakMap<any, T>>} */\n    this._map = new WeakMap();\n  }\n  /**\n   * @param {K1} key1 first key\n   * @param {K2} key2 second key\n   * @returns {T | undefined} value\n   */\n\n\n  get(key1, key2) {\n    const childMap = this._map.get(key1);\n\n    if (childMap === undefined) {\n      return undefined;\n    }\n\n    return childMap.get(key2);\n  }\n  /**\n   * @param {K1} key1 first key\n   * @param {K2} key2 second key\n   * @param {T | undefined} value new value\n   * @returns {void}\n   */\n\n\n  set(key1, key2, value) {\n    let childMap = this._map.get(key1);\n\n    if (childMap === undefined) {\n      childMap = new WeakMap();\n\n      this._map.set(key1, childMap);\n    }\n\n    childMap.set(key2, value);\n  }\n\n}\n/** @type {TwoKeyWeakMap<Comparator<any>, Comparator<any>, Comparator<any>>}} */\n\n\nconst concatComparatorsCache = new TwoKeyWeakMap();\n/**\n * @template T\n * @param {Comparator<T>} c1 comparator\n * @param {Comparator<T>} c2 comparator\n * @param {Comparator<T>[]} cRest comparators\n * @returns {Comparator<T>} comparator\n */\n\nconst concatComparators = function (c1, c2) {\n  for (var _len = arguments.length, cRest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    cRest[_key - 2] = arguments[_key];\n  }\n\n  if (cRest.length > 0) {\n    const [c3, ...cRest2] = cRest;\n    return concatComparators(c1, concatComparators(c2, c3, ...cRest2));\n  }\n\n  const cacheEntry =\n  /** @type {Comparator<T>} */\n  concatComparatorsCache.get(c1, c2);\n  if (cacheEntry !== undefined) return cacheEntry;\n  /**\n   * @param {T} a first value\n   * @param {T} b second value\n   * @returns {-1|0|1} compare result\n   */\n\n  const result = (a, b) => {\n    const res = c1(a, b);\n    if (res !== 0) return res;\n    return c2(a, b);\n  };\n\n  concatComparatorsCache.set(c1, c2, result);\n  return result;\n};\n\nexports.concatComparators = concatComparators;\n/** @template A, B @typedef {(input: A) => B} Selector */\n\n/** @type {TwoKeyWeakMap<Selector<any, any>, Comparator<any>, Comparator<any>>}} */\n\nconst compareSelectCache = new TwoKeyWeakMap();\n/**\n * @template T\n * @template R\n * @param {Selector<T, R>} getter getter for value\n * @param {Comparator<R>} comparator comparator\n * @returns {Comparator<T>} comparator\n */\n\nconst compareSelect = (getter, comparator) => {\n  const cacheEntry = compareSelectCache.get(getter, comparator);\n  if (cacheEntry !== undefined) return cacheEntry;\n  /**\n   * @param {T} a first value\n   * @param {T} b second value\n   * @returns {-1|0|1} compare result\n   */\n\n  const result = (a, b) => {\n    const aValue = getter(a);\n    const bValue = getter(b);\n\n    if (aValue !== undefined && aValue !== null) {\n      if (bValue !== undefined && bValue !== null) {\n        return comparator(aValue, bValue);\n      }\n\n      return -1;\n    } else {\n      if (bValue !== undefined && bValue !== null) {\n        return 1;\n      }\n\n      return 0;\n    }\n  };\n\n  compareSelectCache.set(getter, comparator, result);\n  return result;\n};\n\nexports.compareSelect = compareSelect;\n/** @type {WeakMap<Comparator<any>, Comparator<Iterable<any>>>} */\n\nconst compareIteratorsCache = new WeakMap();\n/**\n * @template T\n * @param {Comparator<T>} elementComparator comparator for elements\n * @returns {Comparator<Iterable<T>>} comparator for iterables of elements\n */\n\nconst compareIterables = elementComparator => {\n  const cacheEntry = compareIteratorsCache.get(elementComparator);\n  if (cacheEntry !== undefined) return cacheEntry;\n  /**\n   * @param {Iterable<T>} a first value\n   * @param {Iterable<T>} b second value\n   * @returns {-1|0|1} compare result\n   */\n\n  const result = (a, b) => {\n    const aI = a[Symbol.iterator]();\n    const bI = b[Symbol.iterator](); // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      const aItem = aI.next();\n      const bItem = bI.next();\n\n      if (aItem.done) {\n        return bItem.done ? 0 : -1;\n      } else if (bItem.done) {\n        return 1;\n      }\n\n      const res = elementComparator(aItem.value, bItem.value);\n      if (res !== 0) return res;\n    }\n  };\n\n  compareIteratorsCache.set(elementComparator, result);\n  return result;\n};\n\nexports.compareIterables = compareIterables; // TODO this is no longer needed when minimum node.js version is >= 12\n// since these versions ship with a stable sort function\n\n/**\n * @template T\n * @param {Iterable<T>} iterable original ordered list\n * @returns {Comparator<T>} comparator\n */\n\nexports.keepOriginalOrder = iterable => {\n  /** @type {Map<T, number>} */\n  const map = new Map();\n  let i = 0;\n\n  for (const item of iterable) {\n    map.set(item, i++);\n  }\n\n  return (a, b) => compareNumbers(map.get(a), map.get(b));\n};\n/**\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @returns {Comparator<Chunk>} comparator\n */\n\n\nexports.compareChunksNatural = chunkGraph => {\n  const cmpFn = exports.compareModulesById(chunkGraph);\n  const cmpIterableFn = compareIterables(cmpFn);\n  return concatComparators(compareSelect(chunk => chunk.name, compareIds), compareSelect(chunk => chunk.runtime, compareRuntime), compareSelect(\n  /**\n   * @param {Chunk} chunk a chunk\n   * @returns {Iterable<Module>} modules\n   */\n  chunk => chunkGraph.getOrderedChunkModulesIterable(chunk, cmpFn), cmpIterableFn));\n};\n/**\n * Compare two locations\n * @param {DependencyLocation} a A location node\n * @param {DependencyLocation} b A location node\n * @returns {-1|0|1} sorting comparator value\n */\n\n\nexports.compareLocations = (a, b) => {\n  let isObjectA = typeof a === \"object\" && a !== null;\n  let isObjectB = typeof b === \"object\" && b !== null;\n\n  if (!isObjectA || !isObjectB) {\n    if (isObjectA) return 1;\n    if (isObjectB) return -1;\n    return 0;\n  }\n\n  if (\"start\" in a) {\n    if (\"start\" in b) {\n      const ap = a.start;\n      const bp = b.start;\n      if (ap.line < bp.line) return -1;\n      if (ap.line > bp.line) return 1;\n      if (ap.column < bp.column) return -1;\n      if (ap.column > bp.column) return 1;\n    } else return -1;\n  } else if (\"start\" in b) return 1;\n\n  if (\"name\" in a) {\n    if (\"name\" in b) {\n      if (a.name < b.name) return -1;\n      if (a.name > b.name) return 1;\n    } else return -1;\n  } else if (\"name\" in b) return 1;\n\n  if (\"index\" in a) {\n    if (\"index\" in b) {\n      if (a.index < b.index) return -1;\n      if (a.index > b.index) return 1;\n    } else return -1;\n  } else if (\"index\" in b) return 1;\n\n  return 0;\n};","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/util/comparators.js"],"names":["compareRuntime","require","createCachedParameterizedComparator","fn","map","WeakMap","arg","cachedResult","get","undefined","result","bind","set","exports","compareChunksById","a","b","compareIds","id","compareModulesByIdentifier","identifier","compareModulesById","chunkGraph","getModuleId","compareNumbers","compareStringsNumeric","partsA","split","partsB","len","Math","min","length","i","pA","pB","slice","nA","nB","compareModulesByPostOrderIndexOrIdentifier","moduleGraph","cmp","getPostOrderIndex","compareModulesByPreOrderIndexOrIdentifier","getPreOrderIndex","compareModulesByIdOrIdentifier","compareChunks","compareStrings","compareChunkGroupsByIndex","index","TwoKeyWeakMap","constructor","_map","key1","key2","childMap","value","concatComparatorsCache","concatComparators","c1","c2","cRest","c3","cRest2","cacheEntry","res","compareSelectCache","compareSelect","getter","comparator","aValue","bValue","compareIteratorsCache","compareIterables","elementComparator","aI","Symbol","iterator","bI","aItem","next","bItem","done","keepOriginalOrder","iterable","Map","item","compareChunksNatural","cmpFn","cmpIterableFn","chunk","name","runtime","getOrderedChunkModulesIterable","compareLocations","isObjectA","isObjectB","ap","start","bp","line","column"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { compareRuntime } = require(\"./runtime\");\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"../Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n\n/** @template T @typedef {function(T, T): -1|0|1} Comparator */\n/** @template TArg @template T @typedef {function(TArg, T, T): -1|0|1} RawParameterizedComparator */\n/** @template TArg @template T @typedef {function(TArg): Comparator<T>} ParameterizedComparator */\n\n/**\n * @template T\n * @param {RawParameterizedComparator<any, T>} fn comparator with argument\n * @returns {ParameterizedComparator<any, T>} comparator\n */\nconst createCachedParameterizedComparator = fn => {\n\t/** @type {WeakMap<object, Comparator<T>>} */\n\tconst map = new WeakMap();\n\treturn arg => {\n\t\tconst cachedResult = map.get(arg);\n\t\tif (cachedResult !== undefined) return cachedResult;\n\t\t/**\n\t\t * @param {T} a first item\n\t\t * @param {T} b second item\n\t\t * @returns {-1|0|1} compare result\n\t\t */\n\t\tconst result = fn.bind(null, arg);\n\t\tmap.set(arg, result);\n\t\treturn result;\n\t};\n};\n\n/**\n * @param {Chunk} a chunk\n * @param {Chunk} b chunk\n * @returns {-1|0|1} compare result\n */\nexports.compareChunksById = (a, b) => {\n\treturn compareIds(a.id, b.id);\n};\n\n/**\n * @param {Module} a module\n * @param {Module} b module\n * @returns {-1|0|1} compare result\n */\nexports.compareModulesByIdentifier = (a, b) => {\n\treturn compareIds(a.identifier(), b.identifier());\n};\n\n/**\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Module} a module\n * @param {Module} b module\n * @returns {-1|0|1} compare result\n */\nconst compareModulesById = (chunkGraph, a, b) => {\n\treturn compareIds(chunkGraph.getModuleId(a), chunkGraph.getModuleId(b));\n};\n/** @type {ParameterizedComparator<ChunkGraph, Module>} */\nexports.compareModulesById =\n\tcreateCachedParameterizedComparator(compareModulesById);\n\n/**\n * @param {number} a number\n * @param {number} b number\n * @returns {-1|0|1} compare result\n */\nconst compareNumbers = (a, b) => {\n\tif (typeof a !== typeof b) {\n\t\treturn typeof a < typeof b ? -1 : 1;\n\t}\n\tif (a < b) return -1;\n\tif (a > b) return 1;\n\treturn 0;\n};\nexports.compareNumbers = compareNumbers;\n\n/**\n * @param {string} a string\n * @param {string} b string\n * @returns {-1|0|1} compare result\n */\nconst compareStringsNumeric = (a, b) => {\n\tconst partsA = a.split(/(\\d+)/);\n\tconst partsB = b.split(/(\\d+)/);\n\tconst len = Math.min(partsA.length, partsB.length);\n\tfor (let i = 0; i < len; i++) {\n\t\tconst pA = partsA[i];\n\t\tconst pB = partsB[i];\n\t\tif (i % 2 === 0) {\n\t\t\tif (pA.length > pB.length) {\n\t\t\t\tif (pA.slice(0, pB.length) > pB) return 1;\n\t\t\t\treturn -1;\n\t\t\t} else if (pB.length > pA.length) {\n\t\t\t\tif (pB.slice(0, pA.length) > pA) return -1;\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\tif (pA < pB) return -1;\n\t\t\t\tif (pA > pB) return 1;\n\t\t\t}\n\t\t} else {\n\t\t\tconst nA = +pA;\n\t\t\tconst nB = +pB;\n\t\t\tif (nA < nB) return -1;\n\t\t\tif (nA > nB) return 1;\n\t\t}\n\t}\n\tif (partsB.length < partsA.length) return 1;\n\tif (partsB.length > partsA.length) return -1;\n\treturn 0;\n};\nexports.compareStringsNumeric = compareStringsNumeric;\n\n/**\n * @param {ModuleGraph} moduleGraph the module graph\n * @param {Module} a module\n * @param {Module} b module\n * @returns {-1|0|1} compare result\n */\nconst compareModulesByPostOrderIndexOrIdentifier = (moduleGraph, a, b) => {\n\tconst cmp = compareNumbers(\n\t\tmoduleGraph.getPostOrderIndex(a),\n\t\tmoduleGraph.getPostOrderIndex(b)\n\t);\n\tif (cmp !== 0) return cmp;\n\treturn compareIds(a.identifier(), b.identifier());\n};\n/** @type {ParameterizedComparator<ModuleGraph, Module>} */\nexports.compareModulesByPostOrderIndexOrIdentifier =\n\tcreateCachedParameterizedComparator(\n\t\tcompareModulesByPostOrderIndexOrIdentifier\n\t);\n\n/**\n * @param {ModuleGraph} moduleGraph the module graph\n * @param {Module} a module\n * @param {Module} b module\n * @returns {-1|0|1} compare result\n */\nconst compareModulesByPreOrderIndexOrIdentifier = (moduleGraph, a, b) => {\n\tconst cmp = compareNumbers(\n\t\tmoduleGraph.getPreOrderIndex(a),\n\t\tmoduleGraph.getPreOrderIndex(b)\n\t);\n\tif (cmp !== 0) return cmp;\n\treturn compareIds(a.identifier(), b.identifier());\n};\n/** @type {ParameterizedComparator<ModuleGraph, Module>} */\nexports.compareModulesByPreOrderIndexOrIdentifier =\n\tcreateCachedParameterizedComparator(\n\t\tcompareModulesByPreOrderIndexOrIdentifier\n\t);\n\n/**\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Module} a module\n * @param {Module} b module\n * @returns {-1|0|1} compare result\n */\nconst compareModulesByIdOrIdentifier = (chunkGraph, a, b) => {\n\tconst cmp = compareIds(chunkGraph.getModuleId(a), chunkGraph.getModuleId(b));\n\tif (cmp !== 0) return cmp;\n\treturn compareIds(a.identifier(), b.identifier());\n};\n/** @type {ParameterizedComparator<ChunkGraph, Module>} */\nexports.compareModulesByIdOrIdentifier = createCachedParameterizedComparator(\n\tcompareModulesByIdOrIdentifier\n);\n\n/**\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Chunk} a chunk\n * @param {Chunk} b chunk\n * @returns {-1|0|1} compare result\n */\nconst compareChunks = (chunkGraph, a, b) => {\n\treturn chunkGraph.compareChunks(a, b);\n};\n/** @type {ParameterizedComparator<ChunkGraph, Chunk>} */\nexports.compareChunks = createCachedParameterizedComparator(compareChunks);\n\n/**\n * @param {string|number} a first id\n * @param {string|number} b second id\n * @returns {-1|0|1} compare result\n */\nconst compareIds = (a, b) => {\n\tif (typeof a !== typeof b) {\n\t\treturn typeof a < typeof b ? -1 : 1;\n\t}\n\tif (a < b) return -1;\n\tif (a > b) return 1;\n\treturn 0;\n};\n\nexports.compareIds = compareIds;\n\n/**\n * @param {string} a first string\n * @param {string} b second string\n * @returns {-1|0|1} compare result\n */\nconst compareStrings = (a, b) => {\n\tif (a < b) return -1;\n\tif (a > b) return 1;\n\treturn 0;\n};\n\nexports.compareStrings = compareStrings;\n\n/**\n * @param {ChunkGroup} a first chunk group\n * @param {ChunkGroup} b second chunk group\n * @returns {-1|0|1} compare result\n */\nconst compareChunkGroupsByIndex = (a, b) => {\n\treturn a.index < b.index ? -1 : 1;\n};\n\nexports.compareChunkGroupsByIndex = compareChunkGroupsByIndex;\n\n/**\n * @template K1 {Object}\n * @template K2\n * @template T\n */\nclass TwoKeyWeakMap {\n\tconstructor() {\n\t\t/** @private @type {WeakMap<any, WeakMap<any, T>>} */\n\t\tthis._map = new WeakMap();\n\t}\n\n\t/**\n\t * @param {K1} key1 first key\n\t * @param {K2} key2 second key\n\t * @returns {T | undefined} value\n\t */\n\tget(key1, key2) {\n\t\tconst childMap = this._map.get(key1);\n\t\tif (childMap === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn childMap.get(key2);\n\t}\n\n\t/**\n\t * @param {K1} key1 first key\n\t * @param {K2} key2 second key\n\t * @param {T | undefined} value new value\n\t * @returns {void}\n\t */\n\tset(key1, key2, value) {\n\t\tlet childMap = this._map.get(key1);\n\t\tif (childMap === undefined) {\n\t\t\tchildMap = new WeakMap();\n\t\t\tthis._map.set(key1, childMap);\n\t\t}\n\t\tchildMap.set(key2, value);\n\t}\n}\n\n/** @type {TwoKeyWeakMap<Comparator<any>, Comparator<any>, Comparator<any>>}} */\nconst concatComparatorsCache = new TwoKeyWeakMap();\n\n/**\n * @template T\n * @param {Comparator<T>} c1 comparator\n * @param {Comparator<T>} c2 comparator\n * @param {Comparator<T>[]} cRest comparators\n * @returns {Comparator<T>} comparator\n */\nconst concatComparators = (c1, c2, ...cRest) => {\n\tif (cRest.length > 0) {\n\t\tconst [c3, ...cRest2] = cRest;\n\t\treturn concatComparators(c1, concatComparators(c2, c3, ...cRest2));\n\t}\n\tconst cacheEntry = /** @type {Comparator<T>} */ (\n\t\tconcatComparatorsCache.get(c1, c2)\n\t);\n\tif (cacheEntry !== undefined) return cacheEntry;\n\t/**\n\t * @param {T} a first value\n\t * @param {T} b second value\n\t * @returns {-1|0|1} compare result\n\t */\n\tconst result = (a, b) => {\n\t\tconst res = c1(a, b);\n\t\tif (res !== 0) return res;\n\t\treturn c2(a, b);\n\t};\n\tconcatComparatorsCache.set(c1, c2, result);\n\treturn result;\n};\nexports.concatComparators = concatComparators;\n\n/** @template A, B @typedef {(input: A) => B} Selector */\n\n/** @type {TwoKeyWeakMap<Selector<any, any>, Comparator<any>, Comparator<any>>}} */\nconst compareSelectCache = new TwoKeyWeakMap();\n\n/**\n * @template T\n * @template R\n * @param {Selector<T, R>} getter getter for value\n * @param {Comparator<R>} comparator comparator\n * @returns {Comparator<T>} comparator\n */\nconst compareSelect = (getter, comparator) => {\n\tconst cacheEntry = compareSelectCache.get(getter, comparator);\n\tif (cacheEntry !== undefined) return cacheEntry;\n\t/**\n\t * @param {T} a first value\n\t * @param {T} b second value\n\t * @returns {-1|0|1} compare result\n\t */\n\tconst result = (a, b) => {\n\t\tconst aValue = getter(a);\n\t\tconst bValue = getter(b);\n\t\tif (aValue !== undefined && aValue !== null) {\n\t\t\tif (bValue !== undefined && bValue !== null) {\n\t\t\t\treturn comparator(aValue, bValue);\n\t\t\t}\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tif (bValue !== undefined && bValue !== null) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t};\n\tcompareSelectCache.set(getter, comparator, result);\n\treturn result;\n};\nexports.compareSelect = compareSelect;\n\n/** @type {WeakMap<Comparator<any>, Comparator<Iterable<any>>>} */\nconst compareIteratorsCache = new WeakMap();\n\n/**\n * @template T\n * @param {Comparator<T>} elementComparator comparator for elements\n * @returns {Comparator<Iterable<T>>} comparator for iterables of elements\n */\nconst compareIterables = elementComparator => {\n\tconst cacheEntry = compareIteratorsCache.get(elementComparator);\n\tif (cacheEntry !== undefined) return cacheEntry;\n\t/**\n\t * @param {Iterable<T>} a first value\n\t * @param {Iterable<T>} b second value\n\t * @returns {-1|0|1} compare result\n\t */\n\tconst result = (a, b) => {\n\t\tconst aI = a[Symbol.iterator]();\n\t\tconst bI = b[Symbol.iterator]();\n\t\t// eslint-disable-next-line no-constant-condition\n\t\twhile (true) {\n\t\t\tconst aItem = aI.next();\n\t\t\tconst bItem = bI.next();\n\t\t\tif (aItem.done) {\n\t\t\t\treturn bItem.done ? 0 : -1;\n\t\t\t} else if (bItem.done) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tconst res = elementComparator(aItem.value, bItem.value);\n\t\t\tif (res !== 0) return res;\n\t\t}\n\t};\n\tcompareIteratorsCache.set(elementComparator, result);\n\treturn result;\n};\nexports.compareIterables = compareIterables;\n\n// TODO this is no longer needed when minimum node.js version is >= 12\n// since these versions ship with a stable sort function\n/**\n * @template T\n * @param {Iterable<T>} iterable original ordered list\n * @returns {Comparator<T>} comparator\n */\nexports.keepOriginalOrder = iterable => {\n\t/** @type {Map<T, number>} */\n\tconst map = new Map();\n\tlet i = 0;\n\tfor (const item of iterable) {\n\t\tmap.set(item, i++);\n\t}\n\treturn (a, b) => compareNumbers(map.get(a), map.get(b));\n};\n\n/**\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @returns {Comparator<Chunk>} comparator\n */\nexports.compareChunksNatural = chunkGraph => {\n\tconst cmpFn = exports.compareModulesById(chunkGraph);\n\tconst cmpIterableFn = compareIterables(cmpFn);\n\treturn concatComparators(\n\t\tcompareSelect(chunk => chunk.name, compareIds),\n\t\tcompareSelect(chunk => chunk.runtime, compareRuntime),\n\t\tcompareSelect(\n\t\t\t/**\n\t\t\t * @param {Chunk} chunk a chunk\n\t\t\t * @returns {Iterable<Module>} modules\n\t\t\t */\n\t\t\tchunk => chunkGraph.getOrderedChunkModulesIterable(chunk, cmpFn),\n\t\t\tcmpIterableFn\n\t\t)\n\t);\n};\n\n/**\n * Compare two locations\n * @param {DependencyLocation} a A location node\n * @param {DependencyLocation} b A location node\n * @returns {-1|0|1} sorting comparator value\n */\nexports.compareLocations = (a, b) => {\n\tlet isObjectA = typeof a === \"object\" && a !== null;\n\tlet isObjectB = typeof b === \"object\" && b !== null;\n\tif (!isObjectA || !isObjectB) {\n\t\tif (isObjectA) return 1;\n\t\tif (isObjectB) return -1;\n\t\treturn 0;\n\t}\n\tif (\"start\" in a) {\n\t\tif (\"start\" in b) {\n\t\t\tconst ap = a.start;\n\t\t\tconst bp = b.start;\n\t\t\tif (ap.line < bp.line) return -1;\n\t\t\tif (ap.line > bp.line) return 1;\n\t\t\tif (ap.column < bp.column) return -1;\n\t\t\tif (ap.column > bp.column) return 1;\n\t\t} else return -1;\n\t} else if (\"start\" in b) return 1;\n\tif (\"name\" in a) {\n\t\tif (\"name\" in b) {\n\t\t\tif (a.name < b.name) return -1;\n\t\t\tif (a.name > b.name) return 1;\n\t\t} else return -1;\n\t} else if (\"name\" in b) return 1;\n\tif (\"index\" in a) {\n\t\tif (\"index\" in b) {\n\t\t\tif (a.index < b.index) return -1;\n\t\t\tif (a.index > b.index) return 1;\n\t\t} else return -1;\n\t} else if (\"index\" in b) return 1;\n\treturn 0;\n};\n"]},"metadata":{},"sourceType":"script"}