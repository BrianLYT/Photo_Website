{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst quoteMeta = str => {\n  return str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\nconst toSimpleString = str => {\n  if (`${+str}` === str) {\n    return str;\n  }\n\n  return JSON.stringify(str);\n};\n/**\n * @param {Record<string|number, boolean>} map value map\n * @returns {boolean|(function(string): string)} true/false, when unconditionally true/false, or a template function to determine the value at runtime\n */\n\n\nconst compileBooleanMatcher = map => {\n  const positiveItems = Object.keys(map).filter(i => map[i]);\n  const negativeItems = Object.keys(map).filter(i => !map[i]);\n  if (positiveItems.length === 0) return false;\n  if (negativeItems.length === 0) return true;\n  return compileBooleanMatcherFromLists(positiveItems, negativeItems);\n};\n/**\n * @param {string[]} positiveItems positive items\n * @param {string[]} negativeItems negative items\n * @returns {function(string): string} a template function to determine the value at runtime\n */\n\n\nconst compileBooleanMatcherFromLists = (positiveItems, negativeItems) => {\n  if (positiveItems.length === 0) return () => \"false\";\n  if (negativeItems.length === 0) return () => \"true\";\n  if (positiveItems.length === 1) return value => `${toSimpleString(positiveItems[0])} == ${value}`;\n  if (negativeItems.length === 1) return value => `${toSimpleString(negativeItems[0])} != ${value}`;\n  const positiveRegexp = itemsToRegexp(positiveItems);\n  const negativeRegexp = itemsToRegexp(negativeItems);\n\n  if (positiveRegexp.length <= negativeRegexp.length) {\n    return value => `/^${positiveRegexp}$/.test(${value})`;\n  } else {\n    return value => `!/^${negativeRegexp}$/.test(${value})`;\n  }\n};\n\nconst popCommonItems = (itemsSet, getKey, condition) => {\n  const map = new Map();\n\n  for (const item of itemsSet) {\n    const key = getKey(item);\n\n    if (key) {\n      let list = map.get(key);\n\n      if (list === undefined) {\n        list = [];\n        map.set(key, list);\n      }\n\n      list.push(item);\n    }\n  }\n\n  const result = [];\n\n  for (const list of map.values()) {\n    if (condition(list)) {\n      for (const item of list) {\n        itemsSet.delete(item);\n      }\n\n      result.push(list);\n    }\n  }\n\n  return result;\n};\n\nconst getCommonPrefix = items => {\n  let prefix = items[0];\n\n  for (let i = 1; i < items.length; i++) {\n    const item = items[i];\n\n    for (let p = 0; p < prefix.length; p++) {\n      if (item[p] !== prefix[p]) {\n        prefix = prefix.slice(0, p);\n        break;\n      }\n    }\n  }\n\n  return prefix;\n};\n\nconst getCommonSuffix = items => {\n  let suffix = items[0];\n\n  for (let i = 1; i < items.length; i++) {\n    const item = items[i];\n\n    for (let p = item.length - 1, s = suffix.length - 1; s >= 0; p--, s--) {\n      if (item[p] !== suffix[s]) {\n        suffix = suffix.slice(s + 1);\n        break;\n      }\n    }\n  }\n\n  return suffix;\n};\n\nconst itemsToRegexp = itemsArr => {\n  if (itemsArr.length === 1) {\n    return quoteMeta(itemsArr[0]);\n  }\n\n  const finishedItems = []; // merge single char items: (a|b|c|d|ef) => ([abcd]|ef)\n\n  let countOfSingleCharItems = 0;\n\n  for (const item of itemsArr) {\n    if (item.length === 1) {\n      countOfSingleCharItems++;\n    }\n  } // special case for only single char items\n\n\n  if (countOfSingleCharItems === itemsArr.length) {\n    return `[${quoteMeta(itemsArr.sort().join(\"\"))}]`;\n  }\n\n  const items = new Set(itemsArr.sort());\n\n  if (countOfSingleCharItems > 2) {\n    let singleCharItems = \"\";\n\n    for (const item of items) {\n      if (item.length === 1) {\n        singleCharItems += item;\n        items.delete(item);\n      }\n    }\n\n    finishedItems.push(`[${quoteMeta(singleCharItems)}]`);\n  } // special case for 2 items with common prefix/suffix\n\n\n  if (finishedItems.length === 0 && items.size === 2) {\n    const prefix = getCommonPrefix(itemsArr);\n    const suffix = getCommonSuffix(itemsArr.map(item => item.slice(prefix.length)));\n\n    if (prefix.length > 0 || suffix.length > 0) {\n      return `${quoteMeta(prefix)}${itemsToRegexp(itemsArr.map(i => i.slice(prefix.length, -suffix.length || undefined)))}${quoteMeta(suffix)}`;\n    }\n  } // special case for 2 items with common suffix\n\n\n  if (finishedItems.length === 0 && items.size === 2) {\n    const it = items[Symbol.iterator]();\n    const a = it.next().value;\n    const b = it.next().value;\n\n    if (a.length > 0 && b.length > 0 && a.slice(-1) === b.slice(-1)) {\n      return `${itemsToRegexp([a.slice(0, -1), b.slice(0, -1)])}${quoteMeta(a.slice(-1))}`;\n    }\n  } // find common prefix: (a1|a2|a3|a4|b5) => (a(1|2|3|4)|b5)\n\n\n  const prefixed = popCommonItems(items, item => item.length >= 1 ? item[0] : false, list => {\n    if (list.length >= 3) return true;\n    if (list.length <= 1) return false;\n    return list[0][1] === list[1][1];\n  });\n\n  for (const prefixedItems of prefixed) {\n    const prefix = getCommonPrefix(prefixedItems);\n    finishedItems.push(`${quoteMeta(prefix)}${itemsToRegexp(prefixedItems.map(i => i.slice(prefix.length)))}`);\n  } // find common suffix: (a1|b1|c1|d1|e2) => ((a|b|c|d)1|e2)\n\n\n  const suffixed = popCommonItems(items, item => item.length >= 1 ? item.slice(-1) : false, list => {\n    if (list.length >= 3) return true;\n    if (list.length <= 1) return false;\n    return list[0].slice(-2) === list[1].slice(-2);\n  });\n\n  for (const suffixedItems of suffixed) {\n    const suffix = getCommonSuffix(suffixedItems);\n    finishedItems.push(`${itemsToRegexp(suffixedItems.map(i => i.slice(0, -suffix.length)))}${quoteMeta(suffix)}`);\n  } // TODO further optimize regexp, i. e.\n  // use ranges: (1|2|3|4|a) => [1-4a]\n\n\n  const conditional = finishedItems.concat(Array.from(items, quoteMeta));\n  if (conditional.length === 1) return conditional[0];\n  return `(${conditional.join(\"|\")})`;\n};\n\ncompileBooleanMatcher.fromLists = compileBooleanMatcherFromLists;\ncompileBooleanMatcher.itemsToRegexp = itemsToRegexp;\nmodule.exports = compileBooleanMatcher;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/util/compileBooleanMatcher.js"],"names":["quoteMeta","str","replace","toSimpleString","JSON","stringify","compileBooleanMatcher","map","positiveItems","Object","keys","filter","i","negativeItems","length","compileBooleanMatcherFromLists","value","positiveRegexp","itemsToRegexp","negativeRegexp","popCommonItems","itemsSet","getKey","condition","Map","item","key","list","get","undefined","set","push","result","values","delete","getCommonPrefix","items","prefix","p","slice","getCommonSuffix","suffix","s","itemsArr","finishedItems","countOfSingleCharItems","sort","join","Set","singleCharItems","size","it","Symbol","iterator","a","next","b","prefixed","prefixedItems","suffixed","suffixedItems","conditional","concat","Array","from","fromLists","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst quoteMeta = str => {\n\treturn str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\nconst toSimpleString = str => {\n\tif (`${+str}` === str) {\n\t\treturn str;\n\t}\n\treturn JSON.stringify(str);\n};\n\n/**\n * @param {Record<string|number, boolean>} map value map\n * @returns {boolean|(function(string): string)} true/false, when unconditionally true/false, or a template function to determine the value at runtime\n */\nconst compileBooleanMatcher = map => {\n\tconst positiveItems = Object.keys(map).filter(i => map[i]);\n\tconst negativeItems = Object.keys(map).filter(i => !map[i]);\n\tif (positiveItems.length === 0) return false;\n\tif (negativeItems.length === 0) return true;\n\treturn compileBooleanMatcherFromLists(positiveItems, negativeItems);\n};\n\n/**\n * @param {string[]} positiveItems positive items\n * @param {string[]} negativeItems negative items\n * @returns {function(string): string} a template function to determine the value at runtime\n */\nconst compileBooleanMatcherFromLists = (positiveItems, negativeItems) => {\n\tif (positiveItems.length === 0) return () => \"false\";\n\tif (negativeItems.length === 0) return () => \"true\";\n\tif (positiveItems.length === 1)\n\t\treturn value => `${toSimpleString(positiveItems[0])} == ${value}`;\n\tif (negativeItems.length === 1)\n\t\treturn value => `${toSimpleString(negativeItems[0])} != ${value}`;\n\tconst positiveRegexp = itemsToRegexp(positiveItems);\n\tconst negativeRegexp = itemsToRegexp(negativeItems);\n\tif (positiveRegexp.length <= negativeRegexp.length) {\n\t\treturn value => `/^${positiveRegexp}$/.test(${value})`;\n\t} else {\n\t\treturn value => `!/^${negativeRegexp}$/.test(${value})`;\n\t}\n};\n\nconst popCommonItems = (itemsSet, getKey, condition) => {\n\tconst map = new Map();\n\tfor (const item of itemsSet) {\n\t\tconst key = getKey(item);\n\t\tif (key) {\n\t\t\tlet list = map.get(key);\n\t\t\tif (list === undefined) {\n\t\t\t\tlist = [];\n\t\t\t\tmap.set(key, list);\n\t\t\t}\n\t\t\tlist.push(item);\n\t\t}\n\t}\n\tconst result = [];\n\tfor (const list of map.values()) {\n\t\tif (condition(list)) {\n\t\t\tfor (const item of list) {\n\t\t\t\titemsSet.delete(item);\n\t\t\t}\n\t\t\tresult.push(list);\n\t\t}\n\t}\n\treturn result;\n};\n\nconst getCommonPrefix = items => {\n\tlet prefix = items[0];\n\tfor (let i = 1; i < items.length; i++) {\n\t\tconst item = items[i];\n\t\tfor (let p = 0; p < prefix.length; p++) {\n\t\t\tif (item[p] !== prefix[p]) {\n\t\t\t\tprefix = prefix.slice(0, p);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn prefix;\n};\n\nconst getCommonSuffix = items => {\n\tlet suffix = items[0];\n\tfor (let i = 1; i < items.length; i++) {\n\t\tconst item = items[i];\n\t\tfor (let p = item.length - 1, s = suffix.length - 1; s >= 0; p--, s--) {\n\t\t\tif (item[p] !== suffix[s]) {\n\t\t\t\tsuffix = suffix.slice(s + 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn suffix;\n};\n\nconst itemsToRegexp = itemsArr => {\n\tif (itemsArr.length === 1) {\n\t\treturn quoteMeta(itemsArr[0]);\n\t}\n\tconst finishedItems = [];\n\n\t// merge single char items: (a|b|c|d|ef) => ([abcd]|ef)\n\tlet countOfSingleCharItems = 0;\n\tfor (const item of itemsArr) {\n\t\tif (item.length === 1) {\n\t\t\tcountOfSingleCharItems++;\n\t\t}\n\t}\n\t// special case for only single char items\n\tif (countOfSingleCharItems === itemsArr.length) {\n\t\treturn `[${quoteMeta(itemsArr.sort().join(\"\"))}]`;\n\t}\n\tconst items = new Set(itemsArr.sort());\n\tif (countOfSingleCharItems > 2) {\n\t\tlet singleCharItems = \"\";\n\t\tfor (const item of items) {\n\t\t\tif (item.length === 1) {\n\t\t\t\tsingleCharItems += item;\n\t\t\t\titems.delete(item);\n\t\t\t}\n\t\t}\n\t\tfinishedItems.push(`[${quoteMeta(singleCharItems)}]`);\n\t}\n\n\t// special case for 2 items with common prefix/suffix\n\tif (finishedItems.length === 0 && items.size === 2) {\n\t\tconst prefix = getCommonPrefix(itemsArr);\n\t\tconst suffix = getCommonSuffix(\n\t\t\titemsArr.map(item => item.slice(prefix.length))\n\t\t);\n\t\tif (prefix.length > 0 || suffix.length > 0) {\n\t\t\treturn `${quoteMeta(prefix)}${itemsToRegexp(\n\t\t\t\titemsArr.map(i => i.slice(prefix.length, -suffix.length || undefined))\n\t\t\t)}${quoteMeta(suffix)}`;\n\t\t}\n\t}\n\n\t// special case for 2 items with common suffix\n\tif (finishedItems.length === 0 && items.size === 2) {\n\t\tconst it = items[Symbol.iterator]();\n\t\tconst a = it.next().value;\n\t\tconst b = it.next().value;\n\t\tif (a.length > 0 && b.length > 0 && a.slice(-1) === b.slice(-1)) {\n\t\t\treturn `${itemsToRegexp([a.slice(0, -1), b.slice(0, -1)])}${quoteMeta(\n\t\t\t\ta.slice(-1)\n\t\t\t)}`;\n\t\t}\n\t}\n\n\t// find common prefix: (a1|a2|a3|a4|b5) => (a(1|2|3|4)|b5)\n\tconst prefixed = popCommonItems(\n\t\titems,\n\t\titem => (item.length >= 1 ? item[0] : false),\n\t\tlist => {\n\t\t\tif (list.length >= 3) return true;\n\t\t\tif (list.length <= 1) return false;\n\t\t\treturn list[0][1] === list[1][1];\n\t\t}\n\t);\n\tfor (const prefixedItems of prefixed) {\n\t\tconst prefix = getCommonPrefix(prefixedItems);\n\t\tfinishedItems.push(\n\t\t\t`${quoteMeta(prefix)}${itemsToRegexp(\n\t\t\t\tprefixedItems.map(i => i.slice(prefix.length))\n\t\t\t)}`\n\t\t);\n\t}\n\n\t// find common suffix: (a1|b1|c1|d1|e2) => ((a|b|c|d)1|e2)\n\tconst suffixed = popCommonItems(\n\t\titems,\n\t\titem => (item.length >= 1 ? item.slice(-1) : false),\n\t\tlist => {\n\t\t\tif (list.length >= 3) return true;\n\t\t\tif (list.length <= 1) return false;\n\t\t\treturn list[0].slice(-2) === list[1].slice(-2);\n\t\t}\n\t);\n\tfor (const suffixedItems of suffixed) {\n\t\tconst suffix = getCommonSuffix(suffixedItems);\n\t\tfinishedItems.push(\n\t\t\t`${itemsToRegexp(\n\t\t\t\tsuffixedItems.map(i => i.slice(0, -suffix.length))\n\t\t\t)}${quoteMeta(suffix)}`\n\t\t);\n\t}\n\n\t// TODO further optimize regexp, i. e.\n\t// use ranges: (1|2|3|4|a) => [1-4a]\n\tconst conditional = finishedItems.concat(Array.from(items, quoteMeta));\n\tif (conditional.length === 1) return conditional[0];\n\treturn `(${conditional.join(\"|\")})`;\n};\n\ncompileBooleanMatcher.fromLists = compileBooleanMatcherFromLists;\ncompileBooleanMatcher.itemsToRegexp = itemsToRegexp;\nmodule.exports = compileBooleanMatcher;\n"]},"metadata":{},"sourceType":"script"}