{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\"; // Simulations show these probabilities for a single change\n// 93.1% that one group is invalidated\n// 4.8% that two groups are invalidated\n// 1.1% that 3 groups are invalidated\n// 0.1% that 4 or more groups are invalidated\n//\n// And these for removing/adding 10 lexically adjacent files\n// 64.5% that one group is invalidated\n// 24.8% that two groups are invalidated\n// 7.8% that 3 groups are invalidated\n// 2.7% that 4 or more groups are invalidated\n//\n// And these for removing/adding 3 random files\n// 0% that one group is invalidated\n// 3.7% that two groups are invalidated\n// 80.8% that 3 groups are invalidated\n// 12.3% that 4 groups are invalidated\n// 3.2% that 5 or more groups are invalidated\n\n/**\n *\n * @param {string} a key\n * @param {string} b key\n * @returns {number} the similarity as number\n */\n\nconst similarity = (a, b) => {\n  const l = Math.min(a.length, b.length);\n  let dist = 0;\n\n  for (let i = 0; i < l; i++) {\n    const ca = a.charCodeAt(i);\n    const cb = b.charCodeAt(i);\n    dist += Math.max(0, 10 - Math.abs(ca - cb));\n  }\n\n  return dist;\n};\n/**\n * @param {string} a key\n * @param {string} b key\n * @param {Set<string>} usedNames set of already used names\n * @returns {string} the common part and a single char for the difference\n */\n\n\nconst getName = (a, b, usedNames) => {\n  const l = Math.min(a.length, b.length);\n  let i = 0;\n\n  while (i < l) {\n    if (a.charCodeAt(i) !== b.charCodeAt(i)) {\n      i++;\n      break;\n    }\n\n    i++;\n  }\n\n  while (i < l) {\n    const name = a.slice(0, i);\n    const lowerName = name.toLowerCase();\n\n    if (!usedNames.has(lowerName)) {\n      usedNames.add(lowerName);\n      return name;\n    }\n\n    i++;\n  } // names always contain a hash, so this is always unique\n  // we don't need to check usedNames nor add it\n\n\n  return a;\n};\n/**\n * @param {Record<string, number>} total total size\n * @param {Record<string, number>} size single size\n * @returns {void}\n */\n\n\nconst addSizeTo = (total, size) => {\n  for (const key of Object.keys(size)) {\n    total[key] = (total[key] || 0) + size[key];\n  }\n};\n/**\n * @param {Record<string, number>} total total size\n * @param {Record<string, number>} size single size\n * @returns {void}\n */\n\n\nconst subtractSizeFrom = (total, size) => {\n  for (const key of Object.keys(size)) {\n    total[key] -= size[key];\n  }\n};\n/**\n * @param {Iterable<Node>} nodes some nodes\n * @returns {Record<string, number>} total size\n */\n\n\nconst sumSize = nodes => {\n  const sum = Object.create(null);\n\n  for (const node of nodes) {\n    addSizeTo(sum, node.size);\n  }\n\n  return sum;\n};\n\nconst isTooBig = (size, maxSize) => {\n  for (const key of Object.keys(size)) {\n    const s = size[key];\n    if (s === 0) continue;\n    const maxSizeValue = maxSize[key];\n\n    if (typeof maxSizeValue === \"number\") {\n      if (s > maxSizeValue) return true;\n    }\n  }\n\n  return false;\n};\n\nconst isTooSmall = (size, minSize) => {\n  for (const key of Object.keys(size)) {\n    const s = size[key];\n    if (s === 0) continue;\n    const minSizeValue = minSize[key];\n\n    if (typeof minSizeValue === \"number\") {\n      if (s < minSizeValue) return true;\n    }\n  }\n\n  return false;\n};\n\nconst getTooSmallTypes = (size, minSize) => {\n  const types = new Set();\n\n  for (const key of Object.keys(size)) {\n    const s = size[key];\n    if (s === 0) continue;\n    const minSizeValue = minSize[key];\n\n    if (typeof minSizeValue === \"number\") {\n      if (s < minSizeValue) types.add(key);\n    }\n  }\n\n  return types;\n};\n\nconst getNumberOfMatchingSizeTypes = (size, types) => {\n  let i = 0;\n\n  for (const key of Object.keys(size)) {\n    if (size[key] !== 0 && types.has(key)) i++;\n  }\n\n  return i;\n};\n\nconst selectiveSizeSum = (size, types) => {\n  let sum = 0;\n\n  for (const key of Object.keys(size)) {\n    if (size[key] !== 0 && types.has(key)) sum += size[key];\n  }\n\n  return sum;\n};\n/**\n * @template T\n */\n\n\nclass Node {\n  /**\n   * @param {T} item item\n   * @param {string} key key\n   * @param {Record<string, number>} size size\n   */\n  constructor(item, key, size) {\n    this.item = item;\n    this.key = key;\n    this.size = size;\n  }\n\n}\n/**\n * @template T\n */\n\n\nclass Group {\n  /**\n   * @param {Node<T>[]} nodes nodes\n   * @param {number[]} similarities similarities between the nodes (length = nodes.length - 1)\n   * @param {Record<string, number>=} size size of the group\n   */\n  constructor(nodes, similarities, size) {\n    this.nodes = nodes;\n    this.similarities = similarities;\n    this.size = size || sumSize(nodes);\n    /** @type {string} */\n\n    this.key = undefined;\n  }\n  /**\n   * @param {function(Node): boolean} filter filter function\n   * @returns {Node[]} removed nodes\n   */\n\n\n  popNodes(filter) {\n    const newNodes = [];\n    const newSimilarities = [];\n    const resultNodes = [];\n    let lastNode;\n\n    for (let i = 0; i < this.nodes.length; i++) {\n      const node = this.nodes[i];\n\n      if (filter(node)) {\n        resultNodes.push(node);\n      } else {\n        if (newNodes.length > 0) {\n          newSimilarities.push(lastNode === this.nodes[i - 1] ? this.similarities[i - 1] : similarity(lastNode.key, node.key));\n        }\n\n        newNodes.push(node);\n        lastNode = node;\n      }\n    }\n\n    if (resultNodes.length === this.nodes.length) return undefined;\n    this.nodes = newNodes;\n    this.similarities = newSimilarities;\n    this.size = sumSize(newNodes);\n    return resultNodes;\n  }\n\n}\n/**\n * @param {Iterable<Node>} nodes nodes\n * @returns {number[]} similarities\n */\n\n\nconst getSimilarities = nodes => {\n  // calculate similarities between lexically adjacent nodes\n\n  /** @type {number[]} */\n  const similarities = [];\n  let last = undefined;\n\n  for (const node of nodes) {\n    if (last !== undefined) {\n      similarities.push(similarity(last.key, node.key));\n    }\n\n    last = node;\n  }\n\n  return similarities;\n};\n/**\n * @template T\n * @typedef {Object} GroupedItems<T>\n * @property {string} key\n * @property {T[]} items\n * @property {Record<string, number>} size\n */\n\n/**\n * @template T\n * @typedef {Object} Options\n * @property {Record<string, number>} maxSize maximum size of a group\n * @property {Record<string, number>} minSize minimum size of a group (preferred over maximum size)\n * @property {Iterable<T>} items a list of items\n * @property {function(T): Record<string, number>} getSize function to get size of an item\n * @property {function(T): string} getKey function to get the key of an item\n */\n\n/**\n * @template T\n * @param {Options<T>} options options object\n * @returns {GroupedItems<T>[]} grouped items\n */\n\n\nmodule.exports = _ref => {\n  let {\n    maxSize,\n    minSize,\n    items,\n    getSize,\n    getKey\n  } = _ref;\n\n  /** @type {Group<T>[]} */\n  const result = [];\n  const nodes = Array.from(items, item => new Node(item, getKey(item), getSize(item)));\n  /** @type {Node<T>[]} */\n\n  const initialNodes = []; // lexically ordering of keys\n\n  nodes.sort((a, b) => {\n    if (a.key < b.key) return -1;\n    if (a.key > b.key) return 1;\n    return 0;\n  }); // return nodes bigger than maxSize directly as group\n  // But make sure that minSize is not violated\n\n  for (const node of nodes) {\n    if (isTooBig(node.size, maxSize) && !isTooSmall(node.size, minSize)) {\n      result.push(new Group([node], []));\n    } else {\n      initialNodes.push(node);\n    }\n  }\n\n  if (initialNodes.length > 0) {\n    const initialGroup = new Group(initialNodes, getSimilarities(initialNodes));\n\n    const removeProblematicNodes = function (group) {\n      let consideredSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : group.size;\n      const problemTypes = getTooSmallTypes(consideredSize, minSize);\n\n      if (problemTypes.size > 0) {\n        // We hit an edge case where the working set is already smaller than minSize\n        // We merge problematic nodes with the smallest result node to keep minSize intact\n        const problemNodes = group.popNodes(n => getNumberOfMatchingSizeTypes(n.size, problemTypes) > 0);\n        if (problemNodes === undefined) return false; // Only merge it with result nodes that have the problematic size type\n\n        const possibleResultGroups = result.filter(n => getNumberOfMatchingSizeTypes(n.size, problemTypes) > 0);\n\n        if (possibleResultGroups.length > 0) {\n          const bestGroup = possibleResultGroups.reduce((min, group) => {\n            const minMatches = getNumberOfMatchingSizeTypes(min, problemTypes);\n            const groupMatches = getNumberOfMatchingSizeTypes(group, problemTypes);\n            if (minMatches !== groupMatches) return minMatches < groupMatches ? group : min;\n            if (selectiveSizeSum(min.size, problemTypes) > selectiveSizeSum(group.size, problemTypes)) return group;\n            return min;\n          });\n\n          for (const node of problemNodes) bestGroup.nodes.push(node);\n\n          bestGroup.nodes.sort((a, b) => {\n            if (a.key < b.key) return -1;\n            if (a.key > b.key) return 1;\n            return 0;\n          });\n        } else {\n          // There are no other nodes with the same size types\n          // We create a new group and have to accept that it's smaller than minSize\n          result.push(new Group(problemNodes, null));\n        }\n\n        return true;\n      } else {\n        return false;\n      }\n    };\n\n    if (initialGroup.nodes.length > 0) {\n      const queue = [initialGroup];\n\n      while (queue.length) {\n        const group = queue.pop(); // only groups bigger than maxSize need to be splitted\n\n        if (!isTooBig(group.size, maxSize)) {\n          result.push(group);\n          continue;\n        } // If the group is already too small\n        // we try to work only with the unproblematic nodes\n\n\n        if (removeProblematicNodes(group)) {\n          // This changed something, so we try this group again\n          queue.push(group);\n          continue;\n        } // find unsplittable area from left and right\n        // going minSize from left and right\n        // at least one node need to be included otherwise we get stuck\n\n\n        let left = 1;\n        let leftSize = Object.create(null);\n        addSizeTo(leftSize, group.nodes[0].size);\n\n        while (left < group.nodes.length && isTooSmall(leftSize, minSize)) {\n          addSizeTo(leftSize, group.nodes[left].size);\n          left++;\n        }\n\n        let right = group.nodes.length - 2;\n        let rightSize = Object.create(null);\n        addSizeTo(rightSize, group.nodes[group.nodes.length - 1].size);\n\n        while (right >= 0 && isTooSmall(rightSize, minSize)) {\n          addSizeTo(rightSize, group.nodes[right].size);\n          right--;\n        } //      left v   v right\n        // [ O O O ] O O O [ O O O ]\n        // ^^^^^^^^^ leftSize\n        //       rightSize ^^^^^^^^^\n        // leftSize > minSize\n        // rightSize > minSize\n        // Perfect split: [ O O O ] [ O O O ]\n        //                right === left - 1\n\n\n        if (left - 1 > right) {\n          // We try to remove some problematic nodes to \"fix\" that\n          let prevSize;\n\n          if (right < group.nodes.length - left) {\n            subtractSizeFrom(rightSize, group.nodes[right + 1].size);\n            prevSize = rightSize;\n          } else {\n            subtractSizeFrom(leftSize, group.nodes[left - 1].size);\n            prevSize = leftSize;\n          }\n\n          if (removeProblematicNodes(group, prevSize)) {\n            // This changed something, so we try this group again\n            queue.push(group);\n            continue;\n          } // can't split group while holding minSize\n          // because minSize is preferred of maxSize we return\n          // the problematic nodes as result here even while it's too big\n          // To avoid this make sure maxSize > minSize * 3\n\n\n          result.push(group);\n          continue;\n        }\n\n        if (left <= right) {\n          // when there is a area between left and right\n          // we look for best split point\n          // we split at the minimum similarity\n          // here key space is separated the most\n          // But we also need to make sure to not create too small groups\n          let best = -1;\n          let bestSimilarity = Infinity;\n          let pos = left;\n          let rightSize = sumSize(group.nodes.slice(pos)); //       pos v   v right\n          // [ O O O ] O O O [ O O O ]\n          // ^^^^^^^^^ leftSize\n          // rightSize ^^^^^^^^^^^^^^^\n\n          while (pos <= right + 1) {\n            const similarity = group.similarities[pos - 1];\n\n            if (similarity < bestSimilarity && !isTooSmall(leftSize, minSize) && !isTooSmall(rightSize, minSize)) {\n              best = pos;\n              bestSimilarity = similarity;\n            }\n\n            addSizeTo(leftSize, group.nodes[pos].size);\n            subtractSizeFrom(rightSize, group.nodes[pos].size);\n            pos++;\n          }\n\n          if (best < 0) {\n            // This can't happen\n            // but if that assumption is wrong\n            // fallback to a big group\n            result.push(group);\n            continue;\n          }\n\n          left = best;\n          right = best - 1;\n        } // create two new groups for left and right area\n        // and queue them up\n\n\n        const rightNodes = [group.nodes[right + 1]];\n        /** @type {number[]} */\n\n        const rightSimilarities = [];\n\n        for (let i = right + 2; i < group.nodes.length; i++) {\n          rightSimilarities.push(group.similarities[i - 1]);\n          rightNodes.push(group.nodes[i]);\n        }\n\n        queue.push(new Group(rightNodes, rightSimilarities));\n        const leftNodes = [group.nodes[0]];\n        /** @type {number[]} */\n\n        const leftSimilarities = [];\n\n        for (let i = 1; i < left; i++) {\n          leftSimilarities.push(group.similarities[i - 1]);\n          leftNodes.push(group.nodes[i]);\n        }\n\n        queue.push(new Group(leftNodes, leftSimilarities));\n      }\n    }\n  } // lexically ordering\n\n\n  result.sort((a, b) => {\n    if (a.nodes[0].key < b.nodes[0].key) return -1;\n    if (a.nodes[0].key > b.nodes[0].key) return 1;\n    return 0;\n  }); // give every group a name\n\n  const usedNames = new Set();\n\n  for (let i = 0; i < result.length; i++) {\n    const group = result[i];\n\n    if (group.nodes.length === 1) {\n      group.key = group.nodes[0].key;\n    } else {\n      const first = group.nodes[0];\n      const last = group.nodes[group.nodes.length - 1];\n      const name = getName(first.key, last.key, usedNames);\n      group.key = name;\n    }\n  } // return the results\n\n\n  return result.map(group => {\n    /** @type {GroupedItems<T>} */\n    return {\n      key: group.key,\n      items: group.nodes.map(node => node.item),\n      size: group.size\n    };\n  });\n};","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/util/deterministicGrouping.js"],"names":["similarity","a","b","l","Math","min","length","dist","i","ca","charCodeAt","cb","max","abs","getName","usedNames","name","slice","lowerName","toLowerCase","has","add","addSizeTo","total","size","key","Object","keys","subtractSizeFrom","sumSize","nodes","sum","create","node","isTooBig","maxSize","s","maxSizeValue","isTooSmall","minSize","minSizeValue","getTooSmallTypes","types","Set","getNumberOfMatchingSizeTypes","selectiveSizeSum","Node","constructor","item","Group","similarities","undefined","popNodes","filter","newNodes","newSimilarities","resultNodes","lastNode","push","getSimilarities","last","module","exports","items","getSize","getKey","result","Array","from","initialNodes","sort","initialGroup","removeProblematicNodes","group","consideredSize","problemTypes","problemNodes","n","possibleResultGroups","bestGroup","reduce","minMatches","groupMatches","queue","pop","left","leftSize","right","rightSize","prevSize","best","bestSimilarity","Infinity","pos","rightNodes","rightSimilarities","leftNodes","leftSimilarities","first","map"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n// Simulations show these probabilities for a single change\n// 93.1% that one group is invalidated\n// 4.8% that two groups are invalidated\n// 1.1% that 3 groups are invalidated\n// 0.1% that 4 or more groups are invalidated\n//\n// And these for removing/adding 10 lexically adjacent files\n// 64.5% that one group is invalidated\n// 24.8% that two groups are invalidated\n// 7.8% that 3 groups are invalidated\n// 2.7% that 4 or more groups are invalidated\n//\n// And these for removing/adding 3 random files\n// 0% that one group is invalidated\n// 3.7% that two groups are invalidated\n// 80.8% that 3 groups are invalidated\n// 12.3% that 4 groups are invalidated\n// 3.2% that 5 or more groups are invalidated\n\n/**\n *\n * @param {string} a key\n * @param {string} b key\n * @returns {number} the similarity as number\n */\nconst similarity = (a, b) => {\n\tconst l = Math.min(a.length, b.length);\n\tlet dist = 0;\n\tfor (let i = 0; i < l; i++) {\n\t\tconst ca = a.charCodeAt(i);\n\t\tconst cb = b.charCodeAt(i);\n\t\tdist += Math.max(0, 10 - Math.abs(ca - cb));\n\t}\n\treturn dist;\n};\n\n/**\n * @param {string} a key\n * @param {string} b key\n * @param {Set<string>} usedNames set of already used names\n * @returns {string} the common part and a single char for the difference\n */\nconst getName = (a, b, usedNames) => {\n\tconst l = Math.min(a.length, b.length);\n\tlet i = 0;\n\twhile (i < l) {\n\t\tif (a.charCodeAt(i) !== b.charCodeAt(i)) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\twhile (i < l) {\n\t\tconst name = a.slice(0, i);\n\t\tconst lowerName = name.toLowerCase();\n\t\tif (!usedNames.has(lowerName)) {\n\t\t\tusedNames.add(lowerName);\n\t\t\treturn name;\n\t\t}\n\t\ti++;\n\t}\n\t// names always contain a hash, so this is always unique\n\t// we don't need to check usedNames nor add it\n\treturn a;\n};\n\n/**\n * @param {Record<string, number>} total total size\n * @param {Record<string, number>} size single size\n * @returns {void}\n */\nconst addSizeTo = (total, size) => {\n\tfor (const key of Object.keys(size)) {\n\t\ttotal[key] = (total[key] || 0) + size[key];\n\t}\n};\n\n/**\n * @param {Record<string, number>} total total size\n * @param {Record<string, number>} size single size\n * @returns {void}\n */\nconst subtractSizeFrom = (total, size) => {\n\tfor (const key of Object.keys(size)) {\n\t\ttotal[key] -= size[key];\n\t}\n};\n\n/**\n * @param {Iterable<Node>} nodes some nodes\n * @returns {Record<string, number>} total size\n */\nconst sumSize = nodes => {\n\tconst sum = Object.create(null);\n\tfor (const node of nodes) {\n\t\taddSizeTo(sum, node.size);\n\t}\n\treturn sum;\n};\n\nconst isTooBig = (size, maxSize) => {\n\tfor (const key of Object.keys(size)) {\n\t\tconst s = size[key];\n\t\tif (s === 0) continue;\n\t\tconst maxSizeValue = maxSize[key];\n\t\tif (typeof maxSizeValue === \"number\") {\n\t\t\tif (s > maxSizeValue) return true;\n\t\t}\n\t}\n\treturn false;\n};\n\nconst isTooSmall = (size, minSize) => {\n\tfor (const key of Object.keys(size)) {\n\t\tconst s = size[key];\n\t\tif (s === 0) continue;\n\t\tconst minSizeValue = minSize[key];\n\t\tif (typeof minSizeValue === \"number\") {\n\t\t\tif (s < minSizeValue) return true;\n\t\t}\n\t}\n\treturn false;\n};\n\nconst getTooSmallTypes = (size, minSize) => {\n\tconst types = new Set();\n\tfor (const key of Object.keys(size)) {\n\t\tconst s = size[key];\n\t\tif (s === 0) continue;\n\t\tconst minSizeValue = minSize[key];\n\t\tif (typeof minSizeValue === \"number\") {\n\t\t\tif (s < minSizeValue) types.add(key);\n\t\t}\n\t}\n\treturn types;\n};\n\nconst getNumberOfMatchingSizeTypes = (size, types) => {\n\tlet i = 0;\n\tfor (const key of Object.keys(size)) {\n\t\tif (size[key] !== 0 && types.has(key)) i++;\n\t}\n\treturn i;\n};\n\nconst selectiveSizeSum = (size, types) => {\n\tlet sum = 0;\n\tfor (const key of Object.keys(size)) {\n\t\tif (size[key] !== 0 && types.has(key)) sum += size[key];\n\t}\n\treturn sum;\n};\n\n/**\n * @template T\n */\nclass Node {\n\t/**\n\t * @param {T} item item\n\t * @param {string} key key\n\t * @param {Record<string, number>} size size\n\t */\n\tconstructor(item, key, size) {\n\t\tthis.item = item;\n\t\tthis.key = key;\n\t\tthis.size = size;\n\t}\n}\n\n/**\n * @template T\n */\nclass Group {\n\t/**\n\t * @param {Node<T>[]} nodes nodes\n\t * @param {number[]} similarities similarities between the nodes (length = nodes.length - 1)\n\t * @param {Record<string, number>=} size size of the group\n\t */\n\tconstructor(nodes, similarities, size) {\n\t\tthis.nodes = nodes;\n\t\tthis.similarities = similarities;\n\t\tthis.size = size || sumSize(nodes);\n\t\t/** @type {string} */\n\t\tthis.key = undefined;\n\t}\n\n\t/**\n\t * @param {function(Node): boolean} filter filter function\n\t * @returns {Node[]} removed nodes\n\t */\n\tpopNodes(filter) {\n\t\tconst newNodes = [];\n\t\tconst newSimilarities = [];\n\t\tconst resultNodes = [];\n\t\tlet lastNode;\n\t\tfor (let i = 0; i < this.nodes.length; i++) {\n\t\t\tconst node = this.nodes[i];\n\t\t\tif (filter(node)) {\n\t\t\t\tresultNodes.push(node);\n\t\t\t} else {\n\t\t\t\tif (newNodes.length > 0) {\n\t\t\t\t\tnewSimilarities.push(\n\t\t\t\t\t\tlastNode === this.nodes[i - 1]\n\t\t\t\t\t\t\t? this.similarities[i - 1]\n\t\t\t\t\t\t\t: similarity(lastNode.key, node.key)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tnewNodes.push(node);\n\t\t\t\tlastNode = node;\n\t\t\t}\n\t\t}\n\t\tif (resultNodes.length === this.nodes.length) return undefined;\n\t\tthis.nodes = newNodes;\n\t\tthis.similarities = newSimilarities;\n\t\tthis.size = sumSize(newNodes);\n\t\treturn resultNodes;\n\t}\n}\n\n/**\n * @param {Iterable<Node>} nodes nodes\n * @returns {number[]} similarities\n */\nconst getSimilarities = nodes => {\n\t// calculate similarities between lexically adjacent nodes\n\t/** @type {number[]} */\n\tconst similarities = [];\n\tlet last = undefined;\n\tfor (const node of nodes) {\n\t\tif (last !== undefined) {\n\t\t\tsimilarities.push(similarity(last.key, node.key));\n\t\t}\n\t\tlast = node;\n\t}\n\treturn similarities;\n};\n\n/**\n * @template T\n * @typedef {Object} GroupedItems<T>\n * @property {string} key\n * @property {T[]} items\n * @property {Record<string, number>} size\n */\n\n/**\n * @template T\n * @typedef {Object} Options\n * @property {Record<string, number>} maxSize maximum size of a group\n * @property {Record<string, number>} minSize minimum size of a group (preferred over maximum size)\n * @property {Iterable<T>} items a list of items\n * @property {function(T): Record<string, number>} getSize function to get size of an item\n * @property {function(T): string} getKey function to get the key of an item\n */\n\n/**\n * @template T\n * @param {Options<T>} options options object\n * @returns {GroupedItems<T>[]} grouped items\n */\nmodule.exports = ({ maxSize, minSize, items, getSize, getKey }) => {\n\t/** @type {Group<T>[]} */\n\tconst result = [];\n\n\tconst nodes = Array.from(\n\t\titems,\n\t\titem => new Node(item, getKey(item), getSize(item))\n\t);\n\n\t/** @type {Node<T>[]} */\n\tconst initialNodes = [];\n\n\t// lexically ordering of keys\n\tnodes.sort((a, b) => {\n\t\tif (a.key < b.key) return -1;\n\t\tif (a.key > b.key) return 1;\n\t\treturn 0;\n\t});\n\n\t// return nodes bigger than maxSize directly as group\n\t// But make sure that minSize is not violated\n\tfor (const node of nodes) {\n\t\tif (isTooBig(node.size, maxSize) && !isTooSmall(node.size, minSize)) {\n\t\t\tresult.push(new Group([node], []));\n\t\t} else {\n\t\t\tinitialNodes.push(node);\n\t\t}\n\t}\n\n\tif (initialNodes.length > 0) {\n\t\tconst initialGroup = new Group(initialNodes, getSimilarities(initialNodes));\n\n\t\tconst removeProblematicNodes = (group, consideredSize = group.size) => {\n\t\t\tconst problemTypes = getTooSmallTypes(consideredSize, minSize);\n\t\t\tif (problemTypes.size > 0) {\n\t\t\t\t// We hit an edge case where the working set is already smaller than minSize\n\t\t\t\t// We merge problematic nodes with the smallest result node to keep minSize intact\n\t\t\t\tconst problemNodes = group.popNodes(\n\t\t\t\t\tn => getNumberOfMatchingSizeTypes(n.size, problemTypes) > 0\n\t\t\t\t);\n\t\t\t\tif (problemNodes === undefined) return false;\n\t\t\t\t// Only merge it with result nodes that have the problematic size type\n\t\t\t\tconst possibleResultGroups = result.filter(\n\t\t\t\t\tn => getNumberOfMatchingSizeTypes(n.size, problemTypes) > 0\n\t\t\t\t);\n\t\t\t\tif (possibleResultGroups.length > 0) {\n\t\t\t\t\tconst bestGroup = possibleResultGroups.reduce((min, group) => {\n\t\t\t\t\t\tconst minMatches = getNumberOfMatchingSizeTypes(min, problemTypes);\n\t\t\t\t\t\tconst groupMatches = getNumberOfMatchingSizeTypes(\n\t\t\t\t\t\t\tgroup,\n\t\t\t\t\t\t\tproblemTypes\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (minMatches !== groupMatches)\n\t\t\t\t\t\t\treturn minMatches < groupMatches ? group : min;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tselectiveSizeSum(min.size, problemTypes) >\n\t\t\t\t\t\t\tselectiveSizeSum(group.size, problemTypes)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\treturn group;\n\t\t\t\t\t\treturn min;\n\t\t\t\t\t});\n\t\t\t\t\tfor (const node of problemNodes) bestGroup.nodes.push(node);\n\t\t\t\t\tbestGroup.nodes.sort((a, b) => {\n\t\t\t\t\t\tif (a.key < b.key) return -1;\n\t\t\t\t\t\tif (a.key > b.key) return 1;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// There are no other nodes with the same size types\n\t\t\t\t\t// We create a new group and have to accept that it's smaller than minSize\n\t\t\t\t\tresult.push(new Group(problemNodes, null));\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\n\t\tif (initialGroup.nodes.length > 0) {\n\t\t\tconst queue = [initialGroup];\n\n\t\t\twhile (queue.length) {\n\t\t\t\tconst group = queue.pop();\n\t\t\t\t// only groups bigger than maxSize need to be splitted\n\t\t\t\tif (!isTooBig(group.size, maxSize)) {\n\t\t\t\t\tresult.push(group);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// If the group is already too small\n\t\t\t\t// we try to work only with the unproblematic nodes\n\t\t\t\tif (removeProblematicNodes(group)) {\n\t\t\t\t\t// This changed something, so we try this group again\n\t\t\t\t\tqueue.push(group);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// find unsplittable area from left and right\n\t\t\t\t// going minSize from left and right\n\t\t\t\t// at least one node need to be included otherwise we get stuck\n\t\t\t\tlet left = 1;\n\t\t\t\tlet leftSize = Object.create(null);\n\t\t\t\taddSizeTo(leftSize, group.nodes[0].size);\n\t\t\t\twhile (left < group.nodes.length && isTooSmall(leftSize, minSize)) {\n\t\t\t\t\taddSizeTo(leftSize, group.nodes[left].size);\n\t\t\t\t\tleft++;\n\t\t\t\t}\n\t\t\t\tlet right = group.nodes.length - 2;\n\t\t\t\tlet rightSize = Object.create(null);\n\t\t\t\taddSizeTo(rightSize, group.nodes[group.nodes.length - 1].size);\n\t\t\t\twhile (right >= 0 && isTooSmall(rightSize, minSize)) {\n\t\t\t\t\taddSizeTo(rightSize, group.nodes[right].size);\n\t\t\t\t\tright--;\n\t\t\t\t}\n\n\t\t\t\t//      left v   v right\n\t\t\t\t// [ O O O ] O O O [ O O O ]\n\t\t\t\t// ^^^^^^^^^ leftSize\n\t\t\t\t//       rightSize ^^^^^^^^^\n\t\t\t\t// leftSize > minSize\n\t\t\t\t// rightSize > minSize\n\n\t\t\t\t// Perfect split: [ O O O ] [ O O O ]\n\t\t\t\t//                right === left - 1\n\n\t\t\t\tif (left - 1 > right) {\n\t\t\t\t\t// We try to remove some problematic nodes to \"fix\" that\n\t\t\t\t\tlet prevSize;\n\t\t\t\t\tif (right < group.nodes.length - left) {\n\t\t\t\t\t\tsubtractSizeFrom(rightSize, group.nodes[right + 1].size);\n\t\t\t\t\t\tprevSize = rightSize;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsubtractSizeFrom(leftSize, group.nodes[left - 1].size);\n\t\t\t\t\t\tprevSize = leftSize;\n\t\t\t\t\t}\n\t\t\t\t\tif (removeProblematicNodes(group, prevSize)) {\n\t\t\t\t\t\t// This changed something, so we try this group again\n\t\t\t\t\t\tqueue.push(group);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// can't split group while holding minSize\n\t\t\t\t\t// because minSize is preferred of maxSize we return\n\t\t\t\t\t// the problematic nodes as result here even while it's too big\n\t\t\t\t\t// To avoid this make sure maxSize > minSize * 3\n\t\t\t\t\tresult.push(group);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (left <= right) {\n\t\t\t\t\t// when there is a area between left and right\n\t\t\t\t\t// we look for best split point\n\t\t\t\t\t// we split at the minimum similarity\n\t\t\t\t\t// here key space is separated the most\n\t\t\t\t\t// But we also need to make sure to not create too small groups\n\t\t\t\t\tlet best = -1;\n\t\t\t\t\tlet bestSimilarity = Infinity;\n\t\t\t\t\tlet pos = left;\n\t\t\t\t\tlet rightSize = sumSize(group.nodes.slice(pos));\n\n\t\t\t\t\t//       pos v   v right\n\t\t\t\t\t// [ O O O ] O O O [ O O O ]\n\t\t\t\t\t// ^^^^^^^^^ leftSize\n\t\t\t\t\t// rightSize ^^^^^^^^^^^^^^^\n\n\t\t\t\t\twhile (pos <= right + 1) {\n\t\t\t\t\t\tconst similarity = group.similarities[pos - 1];\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tsimilarity < bestSimilarity &&\n\t\t\t\t\t\t\t!isTooSmall(leftSize, minSize) &&\n\t\t\t\t\t\t\t!isTooSmall(rightSize, minSize)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tbest = pos;\n\t\t\t\t\t\t\tbestSimilarity = similarity;\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddSizeTo(leftSize, group.nodes[pos].size);\n\t\t\t\t\t\tsubtractSizeFrom(rightSize, group.nodes[pos].size);\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t}\n\t\t\t\t\tif (best < 0) {\n\t\t\t\t\t\t// This can't happen\n\t\t\t\t\t\t// but if that assumption is wrong\n\t\t\t\t\t\t// fallback to a big group\n\t\t\t\t\t\tresult.push(group);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tleft = best;\n\t\t\t\t\tright = best - 1;\n\t\t\t\t}\n\n\t\t\t\t// create two new groups for left and right area\n\t\t\t\t// and queue them up\n\t\t\t\tconst rightNodes = [group.nodes[right + 1]];\n\t\t\t\t/** @type {number[]} */\n\t\t\t\tconst rightSimilarities = [];\n\t\t\t\tfor (let i = right + 2; i < group.nodes.length; i++) {\n\t\t\t\t\trightSimilarities.push(group.similarities[i - 1]);\n\t\t\t\t\trightNodes.push(group.nodes[i]);\n\t\t\t\t}\n\t\t\t\tqueue.push(new Group(rightNodes, rightSimilarities));\n\n\t\t\t\tconst leftNodes = [group.nodes[0]];\n\t\t\t\t/** @type {number[]} */\n\t\t\t\tconst leftSimilarities = [];\n\t\t\t\tfor (let i = 1; i < left; i++) {\n\t\t\t\t\tleftSimilarities.push(group.similarities[i - 1]);\n\t\t\t\t\tleftNodes.push(group.nodes[i]);\n\t\t\t\t}\n\t\t\t\tqueue.push(new Group(leftNodes, leftSimilarities));\n\t\t\t}\n\t\t}\n\t}\n\n\t// lexically ordering\n\tresult.sort((a, b) => {\n\t\tif (a.nodes[0].key < b.nodes[0].key) return -1;\n\t\tif (a.nodes[0].key > b.nodes[0].key) return 1;\n\t\treturn 0;\n\t});\n\n\t// give every group a name\n\tconst usedNames = new Set();\n\tfor (let i = 0; i < result.length; i++) {\n\t\tconst group = result[i];\n\t\tif (group.nodes.length === 1) {\n\t\t\tgroup.key = group.nodes[0].key;\n\t\t} else {\n\t\t\tconst first = group.nodes[0];\n\t\t\tconst last = group.nodes[group.nodes.length - 1];\n\t\t\tconst name = getName(first.key, last.key, usedNames);\n\t\t\tgroup.key = name;\n\t\t}\n\t}\n\n\t// return the results\n\treturn result.map(group => {\n\t\t/** @type {GroupedItems<T>} */\n\t\treturn {\n\t\t\tkey: group.key,\n\t\t\titems: group.nodes.map(node => node.item),\n\t\t\tsize: group.size\n\t\t};\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}