{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  compareModulesByPreOrderIndexOrIdentifier\n} = require(\"../util/comparators\");\n\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\n\nconst createHash = require(\"../util/createHash\");\n\nconst {\n  getUsedModuleIdsAndModules,\n  getFullModuleName\n} = require(\"./IdHelpers\");\n/** @typedef {import(\"../../declarations/plugins/HashedModuleIdsPlugin\").HashedModuleIdsPluginOptions} HashedModuleIdsPluginOptions */\n\n\nconst validate = createSchemaValidation(require(\"../../schemas/plugins/HashedModuleIdsPlugin.check.js\"), () => require(\"../../schemas/plugins/HashedModuleIdsPlugin.json\"), {\n  name: \"Hashed Module Ids Plugin\",\n  baseDataPath: \"options\"\n});\n\nclass HashedModuleIdsPlugin {\n  /**\n   * @param {HashedModuleIdsPluginOptions=} options options object\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    validate(options);\n    /** @type {HashedModuleIdsPluginOptions} */\n\n    this.options = {\n      context: null,\n      hashFunction: \"md4\",\n      hashDigest: \"base64\",\n      hashDigestLength: 4,\n      ...options\n    };\n  }\n\n  apply(compiler) {\n    const options = this.options;\n    compiler.hooks.compilation.tap(\"HashedModuleIdsPlugin\", compilation => {\n      compilation.hooks.moduleIds.tap(\"HashedModuleIdsPlugin\", () => {\n        const chunkGraph = compilation.chunkGraph;\n        const context = this.options.context ? this.options.context : compiler.context;\n        const [usedIds, modules] = getUsedModuleIdsAndModules(compilation);\n        const modulesInNaturalOrder = modules.sort(compareModulesByPreOrderIndexOrIdentifier(compilation.moduleGraph));\n\n        for (const module of modulesInNaturalOrder) {\n          const ident = getFullModuleName(module, context, compiler.root);\n          const hash = createHash(options.hashFunction);\n          hash.update(ident || \"\");\n          const hashId =\n          /** @type {string} */\n          hash.digest(options.hashDigest);\n          let len = options.hashDigestLength;\n\n          while (usedIds.has(hashId.substr(0, len))) len++;\n\n          const moduleId = hashId.substr(0, len);\n          chunkGraph.setModuleId(module, moduleId);\n          usedIds.add(moduleId);\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = HashedModuleIdsPlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/ids/HashedModuleIdsPlugin.js"],"names":["compareModulesByPreOrderIndexOrIdentifier","require","createSchemaValidation","createHash","getUsedModuleIdsAndModules","getFullModuleName","validate","name","baseDataPath","HashedModuleIdsPlugin","constructor","options","context","hashFunction","hashDigest","hashDigestLength","apply","compiler","hooks","compilation","tap","moduleIds","chunkGraph","usedIds","modules","modulesInNaturalOrder","sort","moduleGraph","module","ident","root","hash","update","hashId","digest","len","has","substr","moduleId","setModuleId","add","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAM;AACLA,EAAAA;AADK,IAEFC,OAAO,CAAC,qBAAD,CAFX;;AAGA,MAAMC,sBAAsB,GAAGD,OAAO,CAAC,kCAAD,CAAtC;;AACA,MAAME,UAAU,GAAGF,OAAO,CAAC,oBAAD,CAA1B;;AACA,MAAM;AACLG,EAAAA,0BADK;AAELC,EAAAA;AAFK,IAGFJ,OAAO,CAAC,aAAD,CAHX;AAKA;;;AAEA,MAAMK,QAAQ,GAAGJ,sBAAsB,CACtCD,OAAO,CAAC,sDAAD,CAD+B,EAEtC,MAAMA,OAAO,CAAC,kDAAD,CAFyB,EAGtC;AACCM,EAAAA,IAAI,EAAE,0BADP;AAECC,EAAAA,YAAY,EAAE;AAFf,CAHsC,CAAvC;;AASA,MAAMC,qBAAN,CAA4B;AAC3B;AACD;AACA;AACCC,EAAAA,WAAW,GAAe;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AACzBL,IAAAA,QAAQ,CAACK,OAAD,CAAR;AAEA;;AACA,SAAKA,OAAL,GAAe;AACdC,MAAAA,OAAO,EAAE,IADK;AAEdC,MAAAA,YAAY,EAAE,KAFA;AAGdC,MAAAA,UAAU,EAAE,QAHE;AAIdC,MAAAA,gBAAgB,EAAE,CAJJ;AAKd,SAAGJ;AALW,KAAf;AAOA;;AAEDK,EAAAA,KAAK,CAACC,QAAD,EAAW;AACf,UAAMN,OAAO,GAAG,KAAKA,OAArB;AACAM,IAAAA,QAAQ,CAACC,KAAT,CAAeC,WAAf,CAA2BC,GAA3B,CAA+B,uBAA/B,EAAwDD,WAAW,IAAI;AACtEA,MAAAA,WAAW,CAACD,KAAZ,CAAkBG,SAAlB,CAA4BD,GAA5B,CAAgC,uBAAhC,EAAyD,MAAM;AAC9D,cAAME,UAAU,GAAGH,WAAW,CAACG,UAA/B;AACA,cAAMV,OAAO,GAAG,KAAKD,OAAL,CAAaC,OAAb,GACb,KAAKD,OAAL,CAAaC,OADA,GAEbK,QAAQ,CAACL,OAFZ;AAIA,cAAM,CAACW,OAAD,EAAUC,OAAV,IAAqBpB,0BAA0B,CAACe,WAAD,CAArD;AACA,cAAMM,qBAAqB,GAAGD,OAAO,CAACE,IAAR,CAC7B1B,yCAAyC,CAACmB,WAAW,CAACQ,WAAb,CADZ,CAA9B;;AAGA,aAAK,MAAMC,MAAX,IAAqBH,qBAArB,EAA4C;AAC3C,gBAAMI,KAAK,GAAGxB,iBAAiB,CAACuB,MAAD,EAAShB,OAAT,EAAkBK,QAAQ,CAACa,IAA3B,CAA/B;AACA,gBAAMC,IAAI,GAAG5B,UAAU,CAACQ,OAAO,CAACE,YAAT,CAAvB;AACAkB,UAAAA,IAAI,CAACC,MAAL,CAAYH,KAAK,IAAI,EAArB;AACA,gBAAMI,MAAM;AAAG;AACdF,UAAAA,IAAI,CAACG,MAAL,CAAYvB,OAAO,CAACG,UAApB,CADD;AAGA,cAAIqB,GAAG,GAAGxB,OAAO,CAACI,gBAAlB;;AACA,iBAAOQ,OAAO,CAACa,GAAR,CAAYH,MAAM,CAACI,MAAP,CAAc,CAAd,EAAiBF,GAAjB,CAAZ,CAAP,EAA2CA,GAAG;;AAC9C,gBAAMG,QAAQ,GAAGL,MAAM,CAACI,MAAP,CAAc,CAAd,EAAiBF,GAAjB,CAAjB;AACAb,UAAAA,UAAU,CAACiB,WAAX,CAAuBX,MAAvB,EAA+BU,QAA/B;AACAf,UAAAA,OAAO,CAACiB,GAAR,CAAYF,QAAZ;AACA;AACD,OAvBD;AAwBA,KAzBD;AA0BA;;AA7C0B;;AAgD5BV,MAAM,CAACa,OAAP,GAAiBhC,qBAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n\tcompareModulesByPreOrderIndexOrIdentifier\n} = require(\"../util/comparators\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst createHash = require(\"../util/createHash\");\nconst {\n\tgetUsedModuleIdsAndModules,\n\tgetFullModuleName\n} = require(\"./IdHelpers\");\n\n/** @typedef {import(\"../../declarations/plugins/HashedModuleIdsPlugin\").HashedModuleIdsPluginOptions} HashedModuleIdsPluginOptions */\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/HashedModuleIdsPlugin.check.js\"),\n\t() => require(\"../../schemas/plugins/HashedModuleIdsPlugin.json\"),\n\t{\n\t\tname: \"Hashed Module Ids Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\nclass HashedModuleIdsPlugin {\n\t/**\n\t * @param {HashedModuleIdsPluginOptions=} options options object\n\t */\n\tconstructor(options = {}) {\n\t\tvalidate(options);\n\n\t\t/** @type {HashedModuleIdsPluginOptions} */\n\t\tthis.options = {\n\t\t\tcontext: null,\n\t\t\thashFunction: \"md4\",\n\t\t\thashDigest: \"base64\",\n\t\t\thashDigestLength: 4,\n\t\t\t...options\n\t\t};\n\t}\n\n\tapply(compiler) {\n\t\tconst options = this.options;\n\t\tcompiler.hooks.compilation.tap(\"HashedModuleIdsPlugin\", compilation => {\n\t\t\tcompilation.hooks.moduleIds.tap(\"HashedModuleIdsPlugin\", () => {\n\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\tconst context = this.options.context\n\t\t\t\t\t? this.options.context\n\t\t\t\t\t: compiler.context;\n\n\t\t\t\tconst [usedIds, modules] = getUsedModuleIdsAndModules(compilation);\n\t\t\t\tconst modulesInNaturalOrder = modules.sort(\n\t\t\t\t\tcompareModulesByPreOrderIndexOrIdentifier(compilation.moduleGraph)\n\t\t\t\t);\n\t\t\t\tfor (const module of modulesInNaturalOrder) {\n\t\t\t\t\tconst ident = getFullModuleName(module, context, compiler.root);\n\t\t\t\t\tconst hash = createHash(options.hashFunction);\n\t\t\t\t\thash.update(ident || \"\");\n\t\t\t\t\tconst hashId = /** @type {string} */ (\n\t\t\t\t\t\thash.digest(options.hashDigest)\n\t\t\t\t\t);\n\t\t\t\t\tlet len = options.hashDigestLength;\n\t\t\t\t\twhile (usedIds.has(hashId.substr(0, len))) len++;\n\t\t\t\t\tconst moduleId = hashId.substr(0, len);\n\t\t\t\t\tchunkGraph.setModuleId(module, moduleId);\n\t\t\t\t\tusedIds.add(moduleId);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n\nmodule.exports = HashedModuleIdsPlugin;\n"]},"metadata":{},"sourceType":"script"}