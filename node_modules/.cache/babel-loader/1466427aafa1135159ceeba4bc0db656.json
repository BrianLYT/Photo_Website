{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\n\nconst ChunkGraph = require(\"../ChunkGraph\");\n\nconst ModuleGraph = require(\"../ModuleGraph\");\n\nconst {\n  STAGE_DEFAULT\n} = require(\"../OptimizationStages\");\n\nconst HarmonyImportDependency = require(\"../dependencies/HarmonyImportDependency\");\n\nconst {\n  compareModulesByIdentifier\n} = require(\"../util/comparators\");\n\nconst {\n  intersectRuntime,\n  mergeRuntimeOwned,\n  filterRuntime,\n  runtimeToString,\n  mergeRuntime\n} = require(\"../util/runtime\");\n\nconst ConcatenatedModule = require(\"./ConcatenatedModule\");\n/** @typedef {import(\"../Compilation\")} Compilation */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../RequestShortener\")} RequestShortener */\n\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {Object} Statistics\n * @property {number} cached\n * @property {number} alreadyInConfig\n * @property {number} invalidModule\n * @property {number} incorrectChunks\n * @property {number} incorrectDependency\n * @property {number} incorrectModuleDependency\n * @property {number} incorrectChunksOfImporter\n * @property {number} incorrectRuntimeCondition\n * @property {number} importerFailed\n * @property {number} added\n */\n\n\nconst formatBailoutReason = msg => {\n  return \"ModuleConcatenation bailout: \" + msg;\n};\n\nclass ModuleConcatenationPlugin {\n  constructor(options) {\n    if (typeof options !== \"object\") options = {};\n    this.options = options;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const {\n      _backCompat: backCompat\n    } = compiler;\n    compiler.hooks.compilation.tap(\"ModuleConcatenationPlugin\", compilation => {\n      const moduleGraph = compilation.moduleGraph;\n      const bailoutReasonMap = new Map();\n\n      const setBailoutReason = (module, reason) => {\n        setInnerBailoutReason(module, reason);\n        moduleGraph.getOptimizationBailout(module).push(typeof reason === \"function\" ? rs => formatBailoutReason(reason(rs)) : formatBailoutReason(reason));\n      };\n\n      const setInnerBailoutReason = (module, reason) => {\n        bailoutReasonMap.set(module, reason);\n      };\n\n      const getInnerBailoutReason = (module, requestShortener) => {\n        const reason = bailoutReasonMap.get(module);\n        if (typeof reason === \"function\") return reason(requestShortener);\n        return reason;\n      };\n\n      const formatBailoutWarning = (module, problem) => requestShortener => {\n        if (typeof problem === \"function\") {\n          return formatBailoutReason(`Cannot concat with ${module.readableIdentifier(requestShortener)}: ${problem(requestShortener)}`);\n        }\n\n        const reason = getInnerBailoutReason(module, requestShortener);\n        const reasonWithPrefix = reason ? `: ${reason}` : \"\";\n\n        if (module === problem) {\n          return formatBailoutReason(`Cannot concat with ${module.readableIdentifier(requestShortener)}${reasonWithPrefix}`);\n        } else {\n          return formatBailoutReason(`Cannot concat with ${module.readableIdentifier(requestShortener)} because of ${problem.readableIdentifier(requestShortener)}${reasonWithPrefix}`);\n        }\n      };\n\n      compilation.hooks.optimizeChunkModules.tapAsync({\n        name: \"ModuleConcatenationPlugin\",\n        stage: STAGE_DEFAULT\n      }, (allChunks, modules, callback) => {\n        const logger = compilation.getLogger(\"webpack.ModuleConcatenationPlugin\");\n        const {\n          chunkGraph,\n          moduleGraph\n        } = compilation;\n        const relevantModules = [];\n        const possibleInners = new Set();\n        const context = {\n          chunkGraph,\n          moduleGraph\n        };\n        logger.time(\"select relevant modules\");\n\n        for (const module of modules) {\n          let canBeRoot = true;\n          let canBeInner = true;\n          const bailoutReason = module.getConcatenationBailoutReason(context);\n\n          if (bailoutReason) {\n            setBailoutReason(module, bailoutReason);\n            continue;\n          } // Must not be an async module\n\n\n          if (moduleGraph.isAsync(module)) {\n            setBailoutReason(module, `Module is async`);\n            continue;\n          } // Must be in strict mode\n\n\n          if (!module.buildInfo.strict) {\n            setBailoutReason(module, `Module is not in strict mode`);\n            continue;\n          } // Module must be in any chunk (we don't want to do useless work)\n\n\n          if (chunkGraph.getNumberOfModuleChunks(module) === 0) {\n            setBailoutReason(module, \"Module is not in any chunk\");\n            continue;\n          } // Exports must be known (and not dynamic)\n\n\n          const exportsInfo = moduleGraph.getExportsInfo(module);\n          const relevantExports = exportsInfo.getRelevantExports(undefined);\n          const unknownReexports = relevantExports.filter(exportInfo => {\n            return exportInfo.isReexport() && !exportInfo.getTarget(moduleGraph);\n          });\n\n          if (unknownReexports.length > 0) {\n            setBailoutReason(module, `Reexports in this module do not have a static target (${Array.from(unknownReexports, exportInfo => `${exportInfo.name || \"other exports\"}: ${exportInfo.getUsedInfo()}`).join(\", \")})`);\n            continue;\n          } // Root modules must have a static list of exports\n\n\n          const unknownProvidedExports = relevantExports.filter(exportInfo => {\n            return exportInfo.provided !== true;\n          });\n\n          if (unknownProvidedExports.length > 0) {\n            setBailoutReason(module, `List of module exports is dynamic (${Array.from(unknownProvidedExports, exportInfo => `${exportInfo.name || \"other exports\"}: ${exportInfo.getProvidedInfo()} and ${exportInfo.getUsedInfo()}`).join(\", \")})`);\n            canBeRoot = false;\n          } // Module must not be an entry point\n\n\n          if (chunkGraph.isEntryModule(module)) {\n            setInnerBailoutReason(module, \"Module is an entry point\");\n            canBeInner = false;\n          }\n\n          if (canBeRoot) relevantModules.push(module);\n          if (canBeInner) possibleInners.add(module);\n        }\n\n        logger.timeEnd(\"select relevant modules\");\n        logger.debug(`${relevantModules.length} potential root modules, ${possibleInners.size} potential inner modules`); // sort by depth\n        // modules with lower depth are more likely suited as roots\n        // this improves performance, because modules already selected as inner are skipped\n\n        logger.time(\"sort relevant modules\");\n        relevantModules.sort((a, b) => {\n          return moduleGraph.getDepth(a) - moduleGraph.getDepth(b);\n        });\n        logger.timeEnd(\"sort relevant modules\");\n        /** @type {Statistics} */\n\n        const stats = {\n          cached: 0,\n          alreadyInConfig: 0,\n          invalidModule: 0,\n          incorrectChunks: 0,\n          incorrectDependency: 0,\n          incorrectModuleDependency: 0,\n          incorrectChunksOfImporter: 0,\n          incorrectRuntimeCondition: 0,\n          importerFailed: 0,\n          added: 0\n        };\n        let statsCandidates = 0;\n        let statsSizeSum = 0;\n        let statsEmptyConfigurations = 0;\n        logger.time(\"find modules to concatenate\");\n        const concatConfigurations = [];\n        const usedAsInner = new Set();\n\n        for (const currentRoot of relevantModules) {\n          // when used by another configuration as inner:\n          // the other configuration is better and we can skip this one\n          // TODO reconsider that when it's only used in a different runtime\n          if (usedAsInner.has(currentRoot)) continue;\n          let chunkRuntime = undefined;\n\n          for (const r of chunkGraph.getModuleRuntimes(currentRoot)) {\n            chunkRuntime = mergeRuntimeOwned(chunkRuntime, r);\n          }\n\n          const exportsInfo = moduleGraph.getExportsInfo(currentRoot);\n          const filteredRuntime = filterRuntime(chunkRuntime, r => exportsInfo.isModuleUsed(r));\n          const activeRuntime = filteredRuntime === true ? chunkRuntime : filteredRuntime === false ? undefined : filteredRuntime; // create a configuration with the root\n\n          const currentConfiguration = new ConcatConfiguration(currentRoot, activeRuntime); // cache failures to add modules\n\n          const failureCache = new Map(); // potential optional import candidates\n\n          /** @type {Set<Module>} */\n\n          const candidates = new Set(); // try to add all imports\n\n          for (const imp of this._getImports(compilation, currentRoot, activeRuntime)) {\n            candidates.add(imp);\n          }\n\n          for (const imp of candidates) {\n            const impCandidates = new Set();\n\n            const problem = this._tryToAdd(compilation, currentConfiguration, imp, chunkRuntime, activeRuntime, possibleInners, impCandidates, failureCache, chunkGraph, true, stats);\n\n            if (problem) {\n              failureCache.set(imp, problem);\n              currentConfiguration.addWarning(imp, problem);\n            } else {\n              for (const c of impCandidates) {\n                candidates.add(c);\n              }\n            }\n          }\n\n          statsCandidates += candidates.size;\n\n          if (!currentConfiguration.isEmpty()) {\n            const modules = currentConfiguration.getModules();\n            statsSizeSum += modules.size;\n            concatConfigurations.push(currentConfiguration);\n\n            for (const module of modules) {\n              if (module !== currentConfiguration.rootModule) {\n                usedAsInner.add(module);\n              }\n            }\n          } else {\n            statsEmptyConfigurations++;\n            const optimizationBailouts = moduleGraph.getOptimizationBailout(currentRoot);\n\n            for (const warning of currentConfiguration.getWarningsSorted()) {\n              optimizationBailouts.push(formatBailoutWarning(warning[0], warning[1]));\n            }\n          }\n        }\n\n        logger.timeEnd(\"find modules to concatenate\");\n        logger.debug(`${concatConfigurations.length} successful concat configurations (avg size: ${statsSizeSum / concatConfigurations.length}), ${statsEmptyConfigurations} bailed out completely`);\n        logger.debug(`${statsCandidates} candidates were considered for adding (${stats.cached} cached failure, ${stats.alreadyInConfig} already in config, ${stats.invalidModule} invalid module, ${stats.incorrectChunks} incorrect chunks, ${stats.incorrectDependency} incorrect dependency, ${stats.incorrectChunksOfImporter} incorrect chunks of importer, ${stats.incorrectModuleDependency} incorrect module dependency, ${stats.incorrectRuntimeCondition} incorrect runtime condition, ${stats.importerFailed} importer failed, ${stats.added} added)`); // HACK: Sort configurations by length and start with the longest one\n        // to get the biggest groups possible. Used modules are marked with usedModules\n        // TODO: Allow to reuse existing configuration while trying to add dependencies.\n        // This would improve performance. O(n^2) -> O(n)\n\n        logger.time(`sort concat configurations`);\n        concatConfigurations.sort((a, b) => {\n          return b.modules.size - a.modules.size;\n        });\n        logger.timeEnd(`sort concat configurations`);\n        const usedModules = new Set();\n        logger.time(\"create concatenated modules\");\n        asyncLib.each(concatConfigurations, (concatConfiguration, callback) => {\n          const rootModule = concatConfiguration.rootModule; // Avoid overlapping configurations\n          // TODO: remove this when todo above is fixed\n\n          if (usedModules.has(rootModule)) return callback();\n          const modules = concatConfiguration.getModules();\n\n          for (const m of modules) {\n            usedModules.add(m);\n          } // Create a new ConcatenatedModule\n\n\n          let newModule = ConcatenatedModule.create(rootModule, modules, concatConfiguration.runtime, compiler.root, compilation.outputOptions.hashFunction);\n\n          const build = () => {\n            newModule.build(compiler.options, compilation, null, null, err => {\n              if (err) {\n                if (!err.module) {\n                  err.module = newModule;\n                }\n\n                return callback(err);\n              }\n\n              integrate();\n            });\n          };\n\n          const integrate = () => {\n            if (backCompat) {\n              ChunkGraph.setChunkGraphForModule(newModule, chunkGraph);\n              ModuleGraph.setModuleGraphForModule(newModule, moduleGraph);\n            }\n\n            for (const warning of concatConfiguration.getWarningsSorted()) {\n              moduleGraph.getOptimizationBailout(newModule).push(formatBailoutWarning(warning[0], warning[1]));\n            }\n\n            moduleGraph.cloneModuleAttributes(rootModule, newModule);\n\n            for (const m of modules) {\n              // add to builtModules when one of the included modules was built\n              if (compilation.builtModules.has(m)) {\n                compilation.builtModules.add(newModule);\n              }\n\n              if (m !== rootModule) {\n                // attach external references to the concatenated module too\n                moduleGraph.copyOutgoingModuleConnections(m, newModule, c => {\n                  return c.originModule === m && !(c.dependency instanceof HarmonyImportDependency && modules.has(c.module));\n                }); // remove module from chunk\n\n                for (const chunk of chunkGraph.getModuleChunksIterable(rootModule)) {\n                  chunkGraph.disconnectChunkAndModule(chunk, m);\n                }\n              }\n            }\n\n            compilation.modules.delete(rootModule);\n            ChunkGraph.clearChunkGraphForModule(rootModule);\n            ModuleGraph.clearModuleGraphForModule(rootModule); // remove module from chunk\n\n            chunkGraph.replaceModule(rootModule, newModule); // replace module references with the concatenated module\n\n            moduleGraph.moveModuleConnections(rootModule, newModule, c => {\n              const otherModule = c.module === rootModule ? c.originModule : c.module;\n              const innerConnection = c.dependency instanceof HarmonyImportDependency && modules.has(otherModule);\n              return !innerConnection;\n            }); // add concatenated module to the compilation\n\n            compilation.modules.add(newModule);\n            callback();\n          };\n\n          build();\n        }, err => {\n          logger.timeEnd(\"create concatenated modules\");\n          process.nextTick(callback.bind(null, err));\n        });\n      });\n    });\n  }\n  /**\n   * @param {Compilation} compilation the compilation\n   * @param {Module} module the module to be added\n   * @param {RuntimeSpec} runtime the runtime scope\n   * @returns {Set<Module>} the imported modules\n   */\n\n\n  _getImports(compilation, module, runtime) {\n    const moduleGraph = compilation.moduleGraph;\n    const set = new Set();\n\n    for (const dep of module.dependencies) {\n      // Get reference info only for harmony Dependencies\n      if (!(dep instanceof HarmonyImportDependency)) continue;\n      const connection = moduleGraph.getConnection(dep); // Reference is valid and has a module\n\n      if (!connection || !connection.module || !connection.isTargetActive(runtime)) {\n        continue;\n      }\n\n      const importedNames = compilation.getDependencyReferencedExports(dep, undefined);\n\n      if (importedNames.every(i => Array.isArray(i) ? i.length > 0 : i.name.length > 0) || Array.isArray(moduleGraph.getProvidedExports(module))) {\n        set.add(connection.module);\n      }\n    }\n\n    return set;\n  }\n  /**\n   * @param {Compilation} compilation webpack compilation\n   * @param {ConcatConfiguration} config concat configuration (will be modified when added)\n   * @param {Module} module the module to be added\n   * @param {RuntimeSpec} runtime the runtime scope of the generated code\n   * @param {RuntimeSpec} activeRuntime the runtime scope of the root module\n   * @param {Set<Module>} possibleModules modules that are candidates\n   * @param {Set<Module>} candidates list of potential candidates (will be added to)\n   * @param {Map<Module, Module | function(RequestShortener): string>} failureCache cache for problematic modules to be more performant\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @param {boolean} avoidMutateOnFailure avoid mutating the config when adding fails\n   * @param {Statistics} statistics gathering metrics\n   * @returns {Module | function(RequestShortener): string} the problematic module\n   */\n\n\n  _tryToAdd(compilation, config, module, runtime, activeRuntime, possibleModules, candidates, failureCache, chunkGraph, avoidMutateOnFailure, statistics) {\n    const cacheEntry = failureCache.get(module);\n\n    if (cacheEntry) {\n      statistics.cached++;\n      return cacheEntry;\n    } // Already added?\n\n\n    if (config.has(module)) {\n      statistics.alreadyInConfig++;\n      return null;\n    } // Not possible to add?\n\n\n    if (!possibleModules.has(module)) {\n      statistics.invalidModule++;\n      failureCache.set(module, module); // cache failures for performance\n\n      return module;\n    } // Module must be in the correct chunks\n\n\n    const missingChunks = Array.from(chunkGraph.getModuleChunksIterable(config.rootModule)).filter(chunk => !chunkGraph.isModuleInChunk(module, chunk));\n\n    if (missingChunks.length > 0) {\n      const problem = requestShortener => {\n        const missingChunksList = Array.from(new Set(missingChunks.map(chunk => chunk.name || \"unnamed chunk(s)\"))).sort();\n        const chunks = Array.from(new Set(Array.from(chunkGraph.getModuleChunksIterable(module)).map(chunk => chunk.name || \"unnamed chunk(s)\"))).sort();\n        return `Module ${module.readableIdentifier(requestShortener)} is not in the same chunk(s) (expected in chunk(s) ${missingChunksList.join(\", \")}, module is in chunk(s) ${chunks.join(\", \")})`;\n      };\n\n      statistics.incorrectChunks++;\n      failureCache.set(module, problem); // cache failures for performance\n\n      return problem;\n    }\n\n    const moduleGraph = compilation.moduleGraph;\n    const incomingConnections = moduleGraph.getIncomingConnectionsByOriginModule(module);\n    const incomingConnectionsFromNonModules = incomingConnections.get(null) || incomingConnections.get(undefined);\n\n    if (incomingConnectionsFromNonModules) {\n      const activeNonModulesConnections = incomingConnectionsFromNonModules.filter(connection => {\n        // We are not interested in inactive connections\n        // or connections without dependency\n        return connection.isActive(runtime) || connection.dependency;\n      });\n\n      if (activeNonModulesConnections.length > 0) {\n        const problem = requestShortener => {\n          const importingExplanations = new Set(activeNonModulesConnections.map(c => c.explanation).filter(Boolean));\n          const explanations = Array.from(importingExplanations).sort();\n          return `Module ${module.readableIdentifier(requestShortener)} is referenced ${explanations.length > 0 ? `by: ${explanations.join(\", \")}` : \"in an unsupported way\"}`;\n        };\n\n        statistics.incorrectDependency++;\n        failureCache.set(module, problem); // cache failures for performance\n\n        return problem;\n      }\n    }\n    /** @type {Map<Module, readonly ModuleGraph.ModuleGraphConnection[]>} */\n\n\n    const incomingConnectionsFromModules = new Map();\n\n    for (const [originModule, connections] of incomingConnections) {\n      if (originModule) {\n        // Ignore connection from orphan modules\n        if (chunkGraph.getNumberOfModuleChunks(originModule) === 0) continue; // We don't care for connections from other runtimes\n\n        let originRuntime = undefined;\n\n        for (const r of chunkGraph.getModuleRuntimes(originModule)) {\n          originRuntime = mergeRuntimeOwned(originRuntime, r);\n        }\n\n        if (!intersectRuntime(runtime, originRuntime)) continue; // We are not interested in inactive connections\n\n        const activeConnections = connections.filter(connection => connection.isActive(runtime));\n        if (activeConnections.length > 0) incomingConnectionsFromModules.set(originModule, activeConnections);\n      }\n    }\n\n    const incomingModules = Array.from(incomingConnectionsFromModules.keys()); // Module must be in the same chunks like the referencing module\n\n    const otherChunkModules = incomingModules.filter(originModule => {\n      for (const chunk of chunkGraph.getModuleChunksIterable(config.rootModule)) {\n        if (!chunkGraph.isModuleInChunk(originModule, chunk)) {\n          return true;\n        }\n      }\n\n      return false;\n    });\n\n    if (otherChunkModules.length > 0) {\n      const problem = requestShortener => {\n        const names = otherChunkModules.map(m => m.readableIdentifier(requestShortener)).sort();\n        return `Module ${module.readableIdentifier(requestShortener)} is referenced from different chunks by these modules: ${names.join(\", \")}`;\n      };\n\n      statistics.incorrectChunksOfImporter++;\n      failureCache.set(module, problem); // cache failures for performance\n\n      return problem;\n    }\n    /** @type {Map<Module, readonly ModuleGraph.ModuleGraphConnection[]>} */\n\n\n    const nonHarmonyConnections = new Map();\n\n    for (const [originModule, connections] of incomingConnectionsFromModules) {\n      const selected = connections.filter(connection => !connection.dependency || !(connection.dependency instanceof HarmonyImportDependency));\n      if (selected.length > 0) nonHarmonyConnections.set(originModule, connections);\n    }\n\n    if (nonHarmonyConnections.size > 0) {\n      const problem = requestShortener => {\n        const names = Array.from(nonHarmonyConnections).map(_ref => {\n          let [originModule, connections] = _ref;\n          return `${originModule.readableIdentifier(requestShortener)} (referenced with ${Array.from(new Set(connections.map(c => c.dependency && c.dependency.type).filter(Boolean))).sort().join(\", \")})`;\n        }).sort();\n        return `Module ${module.readableIdentifier(requestShortener)} is referenced from these modules with unsupported syntax: ${names.join(\", \")}`;\n      };\n\n      statistics.incorrectModuleDependency++;\n      failureCache.set(module, problem); // cache failures for performance\n\n      return problem;\n    }\n\n    if (runtime !== undefined && typeof runtime !== \"string\") {\n      // Module must be consistently referenced in the same runtimes\n\n      /** @type {{ originModule: Module, runtimeCondition: RuntimeSpec }[]} */\n      const otherRuntimeConnections = [];\n\n      outer: for (const [originModule, connections] of incomingConnectionsFromModules) {\n        /** @type {false | RuntimeSpec} */\n        let currentRuntimeCondition = false;\n\n        for (const connection of connections) {\n          const runtimeCondition = filterRuntime(runtime, runtime => {\n            return connection.isTargetActive(runtime);\n          });\n          if (runtimeCondition === false) continue;\n          if (runtimeCondition === true) continue outer;\n\n          if (currentRuntimeCondition !== false) {\n            currentRuntimeCondition = mergeRuntime(currentRuntimeCondition, runtimeCondition);\n          } else {\n            currentRuntimeCondition = runtimeCondition;\n          }\n        }\n\n        if (currentRuntimeCondition !== false) {\n          otherRuntimeConnections.push({\n            originModule,\n            runtimeCondition: currentRuntimeCondition\n          });\n        }\n      }\n\n      if (otherRuntimeConnections.length > 0) {\n        const problem = requestShortener => {\n          return `Module ${module.readableIdentifier(requestShortener)} is runtime-dependent referenced by these modules: ${Array.from(otherRuntimeConnections, _ref2 => {\n            let {\n              originModule,\n              runtimeCondition\n            } = _ref2;\n            return `${originModule.readableIdentifier(requestShortener)} (expected runtime ${runtimeToString(runtime)}, module is only referenced in ${runtimeToString(\n            /** @type {RuntimeSpec} */\n            runtimeCondition)})`;\n          }).join(\", \")}`;\n        };\n\n        statistics.incorrectRuntimeCondition++;\n        failureCache.set(module, problem); // cache failures for performance\n\n        return problem;\n      }\n    }\n\n    let backup;\n\n    if (avoidMutateOnFailure) {\n      backup = config.snapshot();\n    } // Add the module\n\n\n    config.add(module);\n    incomingModules.sort(compareModulesByIdentifier); // Every module which depends on the added module must be in the configuration too.\n\n    for (const originModule of incomingModules) {\n      const problem = this._tryToAdd(compilation, config, originModule, runtime, activeRuntime, possibleModules, candidates, failureCache, chunkGraph, false, statistics);\n\n      if (problem) {\n        if (backup !== undefined) config.rollback(backup);\n        statistics.importerFailed++;\n        failureCache.set(module, problem); // cache failures for performance\n\n        return problem;\n      }\n    } // Add imports to possible candidates list\n\n\n    for (const imp of this._getImports(compilation, module, runtime)) {\n      candidates.add(imp);\n    }\n\n    statistics.added++;\n    return null;\n  }\n\n}\n\nclass ConcatConfiguration {\n  /**\n   * @param {Module} rootModule the root module\n   * @param {RuntimeSpec} runtime the runtime\n   */\n  constructor(rootModule, runtime) {\n    this.rootModule = rootModule;\n    this.runtime = runtime;\n    /** @type {Set<Module>} */\n\n    this.modules = new Set();\n    this.modules.add(rootModule);\n    /** @type {Map<Module, Module | function(RequestShortener): string>} */\n\n    this.warnings = new Map();\n  }\n\n  add(module) {\n    this.modules.add(module);\n  }\n\n  has(module) {\n    return this.modules.has(module);\n  }\n\n  isEmpty() {\n    return this.modules.size === 1;\n  }\n\n  addWarning(module, problem) {\n    this.warnings.set(module, problem);\n  }\n\n  getWarningsSorted() {\n    return new Map(Array.from(this.warnings).sort((a, b) => {\n      const ai = a[0].identifier();\n      const bi = b[0].identifier();\n      if (ai < bi) return -1;\n      if (ai > bi) return 1;\n      return 0;\n    }));\n  }\n  /**\n   * @returns {Set<Module>} modules as set\n   */\n\n\n  getModules() {\n    return this.modules;\n  }\n\n  snapshot() {\n    return this.modules.size;\n  }\n\n  rollback(snapshot) {\n    const modules = this.modules;\n\n    for (const m of modules) {\n      if (snapshot === 0) {\n        modules.delete(m);\n      } else {\n        snapshot--;\n      }\n    }\n  }\n\n}\n\nmodule.exports = ModuleConcatenationPlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/optimize/ModuleConcatenationPlugin.js"],"names":["asyncLib","require","ChunkGraph","ModuleGraph","STAGE_DEFAULT","HarmonyImportDependency","compareModulesByIdentifier","intersectRuntime","mergeRuntimeOwned","filterRuntime","runtimeToString","mergeRuntime","ConcatenatedModule","formatBailoutReason","msg","ModuleConcatenationPlugin","constructor","options","apply","compiler","_backCompat","backCompat","hooks","compilation","tap","moduleGraph","bailoutReasonMap","Map","setBailoutReason","module","reason","setInnerBailoutReason","getOptimizationBailout","push","rs","set","getInnerBailoutReason","requestShortener","get","formatBailoutWarning","problem","readableIdentifier","reasonWithPrefix","optimizeChunkModules","tapAsync","name","stage","allChunks","modules","callback","logger","getLogger","chunkGraph","relevantModules","possibleInners","Set","context","time","canBeRoot","canBeInner","bailoutReason","getConcatenationBailoutReason","isAsync","buildInfo","strict","getNumberOfModuleChunks","exportsInfo","getExportsInfo","relevantExports","getRelevantExports","undefined","unknownReexports","filter","exportInfo","isReexport","getTarget","length","Array","from","getUsedInfo","join","unknownProvidedExports","provided","getProvidedInfo","isEntryModule","add","timeEnd","debug","size","sort","a","b","getDepth","stats","cached","alreadyInConfig","invalidModule","incorrectChunks","incorrectDependency","incorrectModuleDependency","incorrectChunksOfImporter","incorrectRuntimeCondition","importerFailed","added","statsCandidates","statsSizeSum","statsEmptyConfigurations","concatConfigurations","usedAsInner","currentRoot","has","chunkRuntime","r","getModuleRuntimes","filteredRuntime","isModuleUsed","activeRuntime","currentConfiguration","ConcatConfiguration","failureCache","candidates","imp","_getImports","impCandidates","_tryToAdd","addWarning","c","isEmpty","getModules","rootModule","optimizationBailouts","warning","getWarningsSorted","usedModules","each","concatConfiguration","m","newModule","create","runtime","root","outputOptions","hashFunction","build","err","integrate","setChunkGraphForModule","setModuleGraphForModule","cloneModuleAttributes","builtModules","copyOutgoingModuleConnections","originModule","dependency","chunk","getModuleChunksIterable","disconnectChunkAndModule","delete","clearChunkGraphForModule","clearModuleGraphForModule","replaceModule","moveModuleConnections","otherModule","innerConnection","process","nextTick","bind","dep","dependencies","connection","getConnection","isTargetActive","importedNames","getDependencyReferencedExports","every","i","isArray","getProvidedExports","config","possibleModules","avoidMutateOnFailure","statistics","cacheEntry","missingChunks","isModuleInChunk","missingChunksList","map","chunks","incomingConnections","getIncomingConnectionsByOriginModule","incomingConnectionsFromNonModules","activeNonModulesConnections","isActive","importingExplanations","explanation","Boolean","explanations","incomingConnectionsFromModules","connections","originRuntime","activeConnections","incomingModules","keys","otherChunkModules","names","nonHarmonyConnections","selected","type","otherRuntimeConnections","outer","currentRuntimeCondition","runtimeCondition","backup","snapshot","rollback","warnings","ai","identifier","bi","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst ChunkGraph = require(\"../ChunkGraph\");\nconst ModuleGraph = require(\"../ModuleGraph\");\nconst { STAGE_DEFAULT } = require(\"../OptimizationStages\");\nconst HarmonyImportDependency = require(\"../dependencies/HarmonyImportDependency\");\nconst { compareModulesByIdentifier } = require(\"../util/comparators\");\nconst {\n\tintersectRuntime,\n\tmergeRuntimeOwned,\n\tfilterRuntime,\n\truntimeToString,\n\tmergeRuntime\n} = require(\"../util/runtime\");\nconst ConcatenatedModule = require(\"./ConcatenatedModule\");\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../RequestShortener\")} RequestShortener */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {Object} Statistics\n * @property {number} cached\n * @property {number} alreadyInConfig\n * @property {number} invalidModule\n * @property {number} incorrectChunks\n * @property {number} incorrectDependency\n * @property {number} incorrectModuleDependency\n * @property {number} incorrectChunksOfImporter\n * @property {number} incorrectRuntimeCondition\n * @property {number} importerFailed\n * @property {number} added\n */\n\nconst formatBailoutReason = msg => {\n\treturn \"ModuleConcatenation bailout: \" + msg;\n};\n\nclass ModuleConcatenationPlugin {\n\tconstructor(options) {\n\t\tif (typeof options !== \"object\") options = {};\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst { _backCompat: backCompat } = compiler;\n\t\tcompiler.hooks.compilation.tap(\"ModuleConcatenationPlugin\", compilation => {\n\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\tconst bailoutReasonMap = new Map();\n\n\t\t\tconst setBailoutReason = (module, reason) => {\n\t\t\t\tsetInnerBailoutReason(module, reason);\n\t\t\t\tmoduleGraph\n\t\t\t\t\t.getOptimizationBailout(module)\n\t\t\t\t\t.push(\n\t\t\t\t\t\ttypeof reason === \"function\"\n\t\t\t\t\t\t\t? rs => formatBailoutReason(reason(rs))\n\t\t\t\t\t\t\t: formatBailoutReason(reason)\n\t\t\t\t\t);\n\t\t\t};\n\n\t\t\tconst setInnerBailoutReason = (module, reason) => {\n\t\t\t\tbailoutReasonMap.set(module, reason);\n\t\t\t};\n\n\t\t\tconst getInnerBailoutReason = (module, requestShortener) => {\n\t\t\t\tconst reason = bailoutReasonMap.get(module);\n\t\t\t\tif (typeof reason === \"function\") return reason(requestShortener);\n\t\t\t\treturn reason;\n\t\t\t};\n\n\t\t\tconst formatBailoutWarning = (module, problem) => requestShortener => {\n\t\t\t\tif (typeof problem === \"function\") {\n\t\t\t\t\treturn formatBailoutReason(\n\t\t\t\t\t\t`Cannot concat with ${module.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)}: ${problem(requestShortener)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst reason = getInnerBailoutReason(module, requestShortener);\n\t\t\t\tconst reasonWithPrefix = reason ? `: ${reason}` : \"\";\n\t\t\t\tif (module === problem) {\n\t\t\t\t\treturn formatBailoutReason(\n\t\t\t\t\t\t`Cannot concat with ${module.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)}${reasonWithPrefix}`\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\treturn formatBailoutReason(\n\t\t\t\t\t\t`Cannot concat with ${module.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)} because of ${problem.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)}${reasonWithPrefix}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tcompilation.hooks.optimizeChunkModules.tapAsync(\n\t\t\t\t{\n\t\t\t\t\tname: \"ModuleConcatenationPlugin\",\n\t\t\t\t\tstage: STAGE_DEFAULT\n\t\t\t\t},\n\t\t\t\t(allChunks, modules, callback) => {\n\t\t\t\t\tconst logger = compilation.getLogger(\n\t\t\t\t\t\t\"webpack.ModuleConcatenationPlugin\"\n\t\t\t\t\t);\n\t\t\t\t\tconst { chunkGraph, moduleGraph } = compilation;\n\t\t\t\t\tconst relevantModules = [];\n\t\t\t\t\tconst possibleInners = new Set();\n\t\t\t\t\tconst context = {\n\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\tmoduleGraph\n\t\t\t\t\t};\n\t\t\t\t\tlogger.time(\"select relevant modules\");\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\tlet canBeRoot = true;\n\t\t\t\t\t\tlet canBeInner = true;\n\n\t\t\t\t\t\tconst bailoutReason = module.getConcatenationBailoutReason(context);\n\t\t\t\t\t\tif (bailoutReason) {\n\t\t\t\t\t\t\tsetBailoutReason(module, bailoutReason);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Must not be an async module\n\t\t\t\t\t\tif (moduleGraph.isAsync(module)) {\n\t\t\t\t\t\t\tsetBailoutReason(module, `Module is async`);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Must be in strict mode\n\t\t\t\t\t\tif (!module.buildInfo.strict) {\n\t\t\t\t\t\t\tsetBailoutReason(module, `Module is not in strict mode`);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Module must be in any chunk (we don't want to do useless work)\n\t\t\t\t\t\tif (chunkGraph.getNumberOfModuleChunks(module) === 0) {\n\t\t\t\t\t\t\tsetBailoutReason(module, \"Module is not in any chunk\");\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Exports must be known (and not dynamic)\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\tconst relevantExports = exportsInfo.getRelevantExports(undefined);\n\t\t\t\t\t\tconst unknownReexports = relevantExports.filter(exportInfo => {\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\texportInfo.isReexport() && !exportInfo.getTarget(moduleGraph)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (unknownReexports.length > 0) {\n\t\t\t\t\t\t\tsetBailoutReason(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t`Reexports in this module do not have a static target (${Array.from(\n\t\t\t\t\t\t\t\t\tunknownReexports,\n\t\t\t\t\t\t\t\t\texportInfo =>\n\t\t\t\t\t\t\t\t\t\t`${\n\t\t\t\t\t\t\t\t\t\t\texportInfo.name || \"other exports\"\n\t\t\t\t\t\t\t\t\t\t}: ${exportInfo.getUsedInfo()}`\n\t\t\t\t\t\t\t\t).join(\", \")})`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Root modules must have a static list of exports\n\t\t\t\t\t\tconst unknownProvidedExports = relevantExports.filter(\n\t\t\t\t\t\t\texportInfo => {\n\t\t\t\t\t\t\t\treturn exportInfo.provided !== true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (unknownProvidedExports.length > 0) {\n\t\t\t\t\t\t\tsetBailoutReason(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t`List of module exports is dynamic (${Array.from(\n\t\t\t\t\t\t\t\t\tunknownProvidedExports,\n\t\t\t\t\t\t\t\t\texportInfo =>\n\t\t\t\t\t\t\t\t\t\t`${\n\t\t\t\t\t\t\t\t\t\t\texportInfo.name || \"other exports\"\n\t\t\t\t\t\t\t\t\t\t}: ${exportInfo.getProvidedInfo()} and ${exportInfo.getUsedInfo()}`\n\t\t\t\t\t\t\t\t).join(\", \")})`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcanBeRoot = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Module must not be an entry point\n\t\t\t\t\t\tif (chunkGraph.isEntryModule(module)) {\n\t\t\t\t\t\t\tsetInnerBailoutReason(module, \"Module is an entry point\");\n\t\t\t\t\t\t\tcanBeInner = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (canBeRoot) relevantModules.push(module);\n\t\t\t\t\t\tif (canBeInner) possibleInners.add(module);\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"select relevant modules\");\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t`${relevantModules.length} potential root modules, ${possibleInners.size} potential inner modules`\n\t\t\t\t\t);\n\t\t\t\t\t// sort by depth\n\t\t\t\t\t// modules with lower depth are more likely suited as roots\n\t\t\t\t\t// this improves performance, because modules already selected as inner are skipped\n\t\t\t\t\tlogger.time(\"sort relevant modules\");\n\t\t\t\t\trelevantModules.sort((a, b) => {\n\t\t\t\t\t\treturn moduleGraph.getDepth(a) - moduleGraph.getDepth(b);\n\t\t\t\t\t});\n\t\t\t\t\tlogger.timeEnd(\"sort relevant modules\");\n\n\t\t\t\t\t/** @type {Statistics} */\n\t\t\t\t\tconst stats = {\n\t\t\t\t\t\tcached: 0,\n\t\t\t\t\t\talreadyInConfig: 0,\n\t\t\t\t\t\tinvalidModule: 0,\n\t\t\t\t\t\tincorrectChunks: 0,\n\t\t\t\t\t\tincorrectDependency: 0,\n\t\t\t\t\t\tincorrectModuleDependency: 0,\n\t\t\t\t\t\tincorrectChunksOfImporter: 0,\n\t\t\t\t\t\tincorrectRuntimeCondition: 0,\n\t\t\t\t\t\timporterFailed: 0,\n\t\t\t\t\t\tadded: 0\n\t\t\t\t\t};\n\t\t\t\t\tlet statsCandidates = 0;\n\t\t\t\t\tlet statsSizeSum = 0;\n\t\t\t\t\tlet statsEmptyConfigurations = 0;\n\n\t\t\t\t\tlogger.time(\"find modules to concatenate\");\n\t\t\t\t\tconst concatConfigurations = [];\n\t\t\t\t\tconst usedAsInner = new Set();\n\t\t\t\t\tfor (const currentRoot of relevantModules) {\n\t\t\t\t\t\t// when used by another configuration as inner:\n\t\t\t\t\t\t// the other configuration is better and we can skip this one\n\t\t\t\t\t\t// TODO reconsider that when it's only used in a different runtime\n\t\t\t\t\t\tif (usedAsInner.has(currentRoot)) continue;\n\n\t\t\t\t\t\tlet chunkRuntime = undefined;\n\t\t\t\t\t\tfor (const r of chunkGraph.getModuleRuntimes(currentRoot)) {\n\t\t\t\t\t\t\tchunkRuntime = mergeRuntimeOwned(chunkRuntime, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(currentRoot);\n\t\t\t\t\t\tconst filteredRuntime = filterRuntime(chunkRuntime, r =>\n\t\t\t\t\t\t\texportsInfo.isModuleUsed(r)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst activeRuntime =\n\t\t\t\t\t\t\tfilteredRuntime === true\n\t\t\t\t\t\t\t\t? chunkRuntime\n\t\t\t\t\t\t\t\t: filteredRuntime === false\n\t\t\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t\t\t: filteredRuntime;\n\n\t\t\t\t\t\t// create a configuration with the root\n\t\t\t\t\t\tconst currentConfiguration = new ConcatConfiguration(\n\t\t\t\t\t\t\tcurrentRoot,\n\t\t\t\t\t\t\tactiveRuntime\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// cache failures to add modules\n\t\t\t\t\t\tconst failureCache = new Map();\n\n\t\t\t\t\t\t// potential optional import candidates\n\t\t\t\t\t\t/** @type {Set<Module>} */\n\t\t\t\t\t\tconst candidates = new Set();\n\n\t\t\t\t\t\t// try to add all imports\n\t\t\t\t\t\tfor (const imp of this._getImports(\n\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\tcurrentRoot,\n\t\t\t\t\t\t\tactiveRuntime\n\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\tcandidates.add(imp);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (const imp of candidates) {\n\t\t\t\t\t\t\tconst impCandidates = new Set();\n\t\t\t\t\t\t\tconst problem = this._tryToAdd(\n\t\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\t\tcurrentConfiguration,\n\t\t\t\t\t\t\t\timp,\n\t\t\t\t\t\t\t\tchunkRuntime,\n\t\t\t\t\t\t\t\tactiveRuntime,\n\t\t\t\t\t\t\t\tpossibleInners,\n\t\t\t\t\t\t\t\timpCandidates,\n\t\t\t\t\t\t\t\tfailureCache,\n\t\t\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tstats\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (problem) {\n\t\t\t\t\t\t\t\tfailureCache.set(imp, problem);\n\t\t\t\t\t\t\t\tcurrentConfiguration.addWarning(imp, problem);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const c of impCandidates) {\n\t\t\t\t\t\t\t\t\tcandidates.add(c);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstatsCandidates += candidates.size;\n\t\t\t\t\t\tif (!currentConfiguration.isEmpty()) {\n\t\t\t\t\t\t\tconst modules = currentConfiguration.getModules();\n\t\t\t\t\t\t\tstatsSizeSum += modules.size;\n\t\t\t\t\t\t\tconcatConfigurations.push(currentConfiguration);\n\t\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\t\tif (module !== currentConfiguration.rootModule) {\n\t\t\t\t\t\t\t\t\tusedAsInner.add(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstatsEmptyConfigurations++;\n\t\t\t\t\t\t\tconst optimizationBailouts =\n\t\t\t\t\t\t\t\tmoduleGraph.getOptimizationBailout(currentRoot);\n\t\t\t\t\t\t\tfor (const warning of currentConfiguration.getWarningsSorted()) {\n\t\t\t\t\t\t\t\toptimizationBailouts.push(\n\t\t\t\t\t\t\t\t\tformatBailoutWarning(warning[0], warning[1])\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"find modules to concatenate\");\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t`${\n\t\t\t\t\t\t\tconcatConfigurations.length\n\t\t\t\t\t\t} successful concat configurations (avg size: ${\n\t\t\t\t\t\t\tstatsSizeSum / concatConfigurations.length\n\t\t\t\t\t\t}), ${statsEmptyConfigurations} bailed out completely`\n\t\t\t\t\t);\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t`${statsCandidates} candidates were considered for adding (${stats.cached} cached failure, ${stats.alreadyInConfig} already in config, ${stats.invalidModule} invalid module, ${stats.incorrectChunks} incorrect chunks, ${stats.incorrectDependency} incorrect dependency, ${stats.incorrectChunksOfImporter} incorrect chunks of importer, ${stats.incorrectModuleDependency} incorrect module dependency, ${stats.incorrectRuntimeCondition} incorrect runtime condition, ${stats.importerFailed} importer failed, ${stats.added} added)`\n\t\t\t\t\t);\n\t\t\t\t\t// HACK: Sort configurations by length and start with the longest one\n\t\t\t\t\t// to get the biggest groups possible. Used modules are marked with usedModules\n\t\t\t\t\t// TODO: Allow to reuse existing configuration while trying to add dependencies.\n\t\t\t\t\t// This would improve performance. O(n^2) -> O(n)\n\t\t\t\t\tlogger.time(`sort concat configurations`);\n\t\t\t\t\tconcatConfigurations.sort((a, b) => {\n\t\t\t\t\t\treturn b.modules.size - a.modules.size;\n\t\t\t\t\t});\n\t\t\t\t\tlogger.timeEnd(`sort concat configurations`);\n\t\t\t\t\tconst usedModules = new Set();\n\n\t\t\t\t\tlogger.time(\"create concatenated modules\");\n\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\tconcatConfigurations,\n\t\t\t\t\t\t(concatConfiguration, callback) => {\n\t\t\t\t\t\t\tconst rootModule = concatConfiguration.rootModule;\n\n\t\t\t\t\t\t\t// Avoid overlapping configurations\n\t\t\t\t\t\t\t// TODO: remove this when todo above is fixed\n\t\t\t\t\t\t\tif (usedModules.has(rootModule)) return callback();\n\t\t\t\t\t\t\tconst modules = concatConfiguration.getModules();\n\t\t\t\t\t\t\tfor (const m of modules) {\n\t\t\t\t\t\t\t\tusedModules.add(m);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Create a new ConcatenatedModule\n\t\t\t\t\t\t\tlet newModule = ConcatenatedModule.create(\n\t\t\t\t\t\t\t\trootModule,\n\t\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t\tconcatConfiguration.runtime,\n\t\t\t\t\t\t\t\tcompiler.root,\n\t\t\t\t\t\t\t\tcompilation.outputOptions.hashFunction\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tconst build = () => {\n\t\t\t\t\t\t\t\tnewModule.build(\n\t\t\t\t\t\t\t\t\tcompiler.options,\n\t\t\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tif (!err.module) {\n\t\t\t\t\t\t\t\t\t\t\t\terr.module = newModule;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tintegrate();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tconst integrate = () => {\n\t\t\t\t\t\t\t\tif (backCompat) {\n\t\t\t\t\t\t\t\t\tChunkGraph.setChunkGraphForModule(newModule, chunkGraph);\n\t\t\t\t\t\t\t\t\tModuleGraph.setModuleGraphForModule(newModule, moduleGraph);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tfor (const warning of concatConfiguration.getWarningsSorted()) {\n\t\t\t\t\t\t\t\t\tmoduleGraph\n\t\t\t\t\t\t\t\t\t\t.getOptimizationBailout(newModule)\n\t\t\t\t\t\t\t\t\t\t.push(formatBailoutWarning(warning[0], warning[1]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmoduleGraph.cloneModuleAttributes(rootModule, newModule);\n\t\t\t\t\t\t\t\tfor (const m of modules) {\n\t\t\t\t\t\t\t\t\t// add to builtModules when one of the included modules was built\n\t\t\t\t\t\t\t\t\tif (compilation.builtModules.has(m)) {\n\t\t\t\t\t\t\t\t\t\tcompilation.builtModules.add(newModule);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (m !== rootModule) {\n\t\t\t\t\t\t\t\t\t\t// attach external references to the concatenated module too\n\t\t\t\t\t\t\t\t\t\tmoduleGraph.copyOutgoingModuleConnections(\n\t\t\t\t\t\t\t\t\t\t\tm,\n\t\t\t\t\t\t\t\t\t\t\tnewModule,\n\t\t\t\t\t\t\t\t\t\t\tc => {\n\t\t\t\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t\t\t\tc.originModule === m &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t!(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tc.dependency instanceof HarmonyImportDependency &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodules.has(c.module)\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t// remove module from chunk\n\t\t\t\t\t\t\t\t\t\tfor (const chunk of chunkGraph.getModuleChunksIterable(\n\t\t\t\t\t\t\t\t\t\t\trootModule\n\t\t\t\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, m);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcompilation.modules.delete(rootModule);\n\t\t\t\t\t\t\t\tChunkGraph.clearChunkGraphForModule(rootModule);\n\t\t\t\t\t\t\t\tModuleGraph.clearModuleGraphForModule(rootModule);\n\n\t\t\t\t\t\t\t\t// remove module from chunk\n\t\t\t\t\t\t\t\tchunkGraph.replaceModule(rootModule, newModule);\n\t\t\t\t\t\t\t\t// replace module references with the concatenated module\n\t\t\t\t\t\t\t\tmoduleGraph.moveModuleConnections(rootModule, newModule, c => {\n\t\t\t\t\t\t\t\t\tconst otherModule =\n\t\t\t\t\t\t\t\t\t\tc.module === rootModule ? c.originModule : c.module;\n\t\t\t\t\t\t\t\t\tconst innerConnection =\n\t\t\t\t\t\t\t\t\t\tc.dependency instanceof HarmonyImportDependency &&\n\t\t\t\t\t\t\t\t\t\tmodules.has(otherModule);\n\t\t\t\t\t\t\t\t\treturn !innerConnection;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t// add concatenated module to the compilation\n\t\t\t\t\t\t\t\tcompilation.modules.add(newModule);\n\n\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tbuild();\n\t\t\t\t\t\t},\n\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\tlogger.timeEnd(\"create concatenated modules\");\n\t\t\t\t\t\t\tprocess.nextTick(callback.bind(null, err));\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @param {Module} module the module to be added\n\t * @param {RuntimeSpec} runtime the runtime scope\n\t * @returns {Set<Module>} the imported modules\n\t */\n\t_getImports(compilation, module, runtime) {\n\t\tconst moduleGraph = compilation.moduleGraph;\n\t\tconst set = new Set();\n\t\tfor (const dep of module.dependencies) {\n\t\t\t// Get reference info only for harmony Dependencies\n\t\t\tif (!(dep instanceof HarmonyImportDependency)) continue;\n\n\t\t\tconst connection = moduleGraph.getConnection(dep);\n\t\t\t// Reference is valid and has a module\n\t\t\tif (\n\t\t\t\t!connection ||\n\t\t\t\t!connection.module ||\n\t\t\t\t!connection.isTargetActive(runtime)\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst importedNames = compilation.getDependencyReferencedExports(\n\t\t\t\tdep,\n\t\t\t\tundefined\n\t\t\t);\n\n\t\t\tif (\n\t\t\t\timportedNames.every(i =>\n\t\t\t\t\tArray.isArray(i) ? i.length > 0 : i.name.length > 0\n\t\t\t\t) ||\n\t\t\t\tArray.isArray(moduleGraph.getProvidedExports(module))\n\t\t\t) {\n\t\t\t\tset.add(connection.module);\n\t\t\t}\n\t\t}\n\t\treturn set;\n\t}\n\n\t/**\n\t * @param {Compilation} compilation webpack compilation\n\t * @param {ConcatConfiguration} config concat configuration (will be modified when added)\n\t * @param {Module} module the module to be added\n\t * @param {RuntimeSpec} runtime the runtime scope of the generated code\n\t * @param {RuntimeSpec} activeRuntime the runtime scope of the root module\n\t * @param {Set<Module>} possibleModules modules that are candidates\n\t * @param {Set<Module>} candidates list of potential candidates (will be added to)\n\t * @param {Map<Module, Module | function(RequestShortener): string>} failureCache cache for problematic modules to be more performant\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {boolean} avoidMutateOnFailure avoid mutating the config when adding fails\n\t * @param {Statistics} statistics gathering metrics\n\t * @returns {Module | function(RequestShortener): string} the problematic module\n\t */\n\t_tryToAdd(\n\t\tcompilation,\n\t\tconfig,\n\t\tmodule,\n\t\truntime,\n\t\tactiveRuntime,\n\t\tpossibleModules,\n\t\tcandidates,\n\t\tfailureCache,\n\t\tchunkGraph,\n\t\tavoidMutateOnFailure,\n\t\tstatistics\n\t) {\n\t\tconst cacheEntry = failureCache.get(module);\n\t\tif (cacheEntry) {\n\t\t\tstatistics.cached++;\n\t\t\treturn cacheEntry;\n\t\t}\n\n\t\t// Already added?\n\t\tif (config.has(module)) {\n\t\t\tstatistics.alreadyInConfig++;\n\t\t\treturn null;\n\t\t}\n\n\t\t// Not possible to add?\n\t\tif (!possibleModules.has(module)) {\n\t\t\tstatistics.invalidModule++;\n\t\t\tfailureCache.set(module, module); // cache failures for performance\n\t\t\treturn module;\n\t\t}\n\n\t\t// Module must be in the correct chunks\n\t\tconst missingChunks = Array.from(\n\t\t\tchunkGraph.getModuleChunksIterable(config.rootModule)\n\t\t).filter(chunk => !chunkGraph.isModuleInChunk(module, chunk));\n\t\tif (missingChunks.length > 0) {\n\t\t\tconst problem = requestShortener => {\n\t\t\t\tconst missingChunksList = Array.from(\n\t\t\t\t\tnew Set(missingChunks.map(chunk => chunk.name || \"unnamed chunk(s)\"))\n\t\t\t\t).sort();\n\t\t\t\tconst chunks = Array.from(\n\t\t\t\t\tnew Set(\n\t\t\t\t\t\tArray.from(chunkGraph.getModuleChunksIterable(module)).map(\n\t\t\t\t\t\t\tchunk => chunk.name || \"unnamed chunk(s)\"\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t).sort();\n\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\trequestShortener\n\t\t\t\t)} is not in the same chunk(s) (expected in chunk(s) ${missingChunksList.join(\n\t\t\t\t\t\", \"\n\t\t\t\t)}, module is in chunk(s) ${chunks.join(\", \")})`;\n\t\t\t};\n\t\t\tstatistics.incorrectChunks++;\n\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\treturn problem;\n\t\t}\n\n\t\tconst moduleGraph = compilation.moduleGraph;\n\n\t\tconst incomingConnections =\n\t\t\tmoduleGraph.getIncomingConnectionsByOriginModule(module);\n\n\t\tconst incomingConnectionsFromNonModules =\n\t\t\tincomingConnections.get(null) || incomingConnections.get(undefined);\n\t\tif (incomingConnectionsFromNonModules) {\n\t\t\tconst activeNonModulesConnections =\n\t\t\t\tincomingConnectionsFromNonModules.filter(connection => {\n\t\t\t\t\t// We are not interested in inactive connections\n\t\t\t\t\t// or connections without dependency\n\t\t\t\t\treturn connection.isActive(runtime) || connection.dependency;\n\t\t\t\t});\n\t\t\tif (activeNonModulesConnections.length > 0) {\n\t\t\t\tconst problem = requestShortener => {\n\t\t\t\t\tconst importingExplanations = new Set(\n\t\t\t\t\t\tactiveNonModulesConnections.map(c => c.explanation).filter(Boolean)\n\t\t\t\t\t);\n\t\t\t\t\tconst explanations = Array.from(importingExplanations).sort();\n\t\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\t\trequestShortener\n\t\t\t\t\t)} is referenced ${\n\t\t\t\t\t\texplanations.length > 0\n\t\t\t\t\t\t\t? `by: ${explanations.join(\", \")}`\n\t\t\t\t\t\t\t: \"in an unsupported way\"\n\t\t\t\t\t}`;\n\t\t\t\t};\n\t\t\t\tstatistics.incorrectDependency++;\n\t\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\t\treturn problem;\n\t\t\t}\n\t\t}\n\n\t\t/** @type {Map<Module, readonly ModuleGraph.ModuleGraphConnection[]>} */\n\t\tconst incomingConnectionsFromModules = new Map();\n\t\tfor (const [originModule, connections] of incomingConnections) {\n\t\t\tif (originModule) {\n\t\t\t\t// Ignore connection from orphan modules\n\t\t\t\tif (chunkGraph.getNumberOfModuleChunks(originModule) === 0) continue;\n\n\t\t\t\t// We don't care for connections from other runtimes\n\t\t\t\tlet originRuntime = undefined;\n\t\t\t\tfor (const r of chunkGraph.getModuleRuntimes(originModule)) {\n\t\t\t\t\toriginRuntime = mergeRuntimeOwned(originRuntime, r);\n\t\t\t\t}\n\n\t\t\t\tif (!intersectRuntime(runtime, originRuntime)) continue;\n\n\t\t\t\t// We are not interested in inactive connections\n\t\t\t\tconst activeConnections = connections.filter(connection =>\n\t\t\t\t\tconnection.isActive(runtime)\n\t\t\t\t);\n\t\t\t\tif (activeConnections.length > 0)\n\t\t\t\t\tincomingConnectionsFromModules.set(originModule, activeConnections);\n\t\t\t}\n\t\t}\n\n\t\tconst incomingModules = Array.from(incomingConnectionsFromModules.keys());\n\n\t\t// Module must be in the same chunks like the referencing module\n\t\tconst otherChunkModules = incomingModules.filter(originModule => {\n\t\t\tfor (const chunk of chunkGraph.getModuleChunksIterable(\n\t\t\t\tconfig.rootModule\n\t\t\t)) {\n\t\t\t\tif (!chunkGraph.isModuleInChunk(originModule, chunk)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t\tif (otherChunkModules.length > 0) {\n\t\t\tconst problem = requestShortener => {\n\t\t\t\tconst names = otherChunkModules\n\t\t\t\t\t.map(m => m.readableIdentifier(requestShortener))\n\t\t\t\t\t.sort();\n\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\trequestShortener\n\t\t\t\t)} is referenced from different chunks by these modules: ${names.join(\n\t\t\t\t\t\", \"\n\t\t\t\t)}`;\n\t\t\t};\n\t\t\tstatistics.incorrectChunksOfImporter++;\n\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\treturn problem;\n\t\t}\n\n\t\t/** @type {Map<Module, readonly ModuleGraph.ModuleGraphConnection[]>} */\n\t\tconst nonHarmonyConnections = new Map();\n\t\tfor (const [originModule, connections] of incomingConnectionsFromModules) {\n\t\t\tconst selected = connections.filter(\n\t\t\t\tconnection =>\n\t\t\t\t\t!connection.dependency ||\n\t\t\t\t\t!(connection.dependency instanceof HarmonyImportDependency)\n\t\t\t);\n\t\t\tif (selected.length > 0)\n\t\t\t\tnonHarmonyConnections.set(originModule, connections);\n\t\t}\n\t\tif (nonHarmonyConnections.size > 0) {\n\t\t\tconst problem = requestShortener => {\n\t\t\t\tconst names = Array.from(nonHarmonyConnections)\n\t\t\t\t\t.map(([originModule, connections]) => {\n\t\t\t\t\t\treturn `${originModule.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)} (referenced with ${Array.from(\n\t\t\t\t\t\t\tnew Set(\n\t\t\t\t\t\t\t\tconnections\n\t\t\t\t\t\t\t\t\t.map(c => c.dependency && c.dependency.type)\n\t\t\t\t\t\t\t\t\t.filter(Boolean)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.sort()\n\t\t\t\t\t\t\t.join(\", \")})`;\n\t\t\t\t\t})\n\t\t\t\t\t.sort();\n\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\trequestShortener\n\t\t\t\t)} is referenced from these modules with unsupported syntax: ${names.join(\n\t\t\t\t\t\", \"\n\t\t\t\t)}`;\n\t\t\t};\n\t\t\tstatistics.incorrectModuleDependency++;\n\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\treturn problem;\n\t\t}\n\n\t\tif (runtime !== undefined && typeof runtime !== \"string\") {\n\t\t\t// Module must be consistently referenced in the same runtimes\n\t\t\t/** @type {{ originModule: Module, runtimeCondition: RuntimeSpec }[]} */\n\t\t\tconst otherRuntimeConnections = [];\n\t\t\touter: for (const [\n\t\t\t\toriginModule,\n\t\t\t\tconnections\n\t\t\t] of incomingConnectionsFromModules) {\n\t\t\t\t/** @type {false | RuntimeSpec} */\n\t\t\t\tlet currentRuntimeCondition = false;\n\t\t\t\tfor (const connection of connections) {\n\t\t\t\t\tconst runtimeCondition = filterRuntime(runtime, runtime => {\n\t\t\t\t\t\treturn connection.isTargetActive(runtime);\n\t\t\t\t\t});\n\t\t\t\t\tif (runtimeCondition === false) continue;\n\t\t\t\t\tif (runtimeCondition === true) continue outer;\n\t\t\t\t\tif (currentRuntimeCondition !== false) {\n\t\t\t\t\t\tcurrentRuntimeCondition = mergeRuntime(\n\t\t\t\t\t\t\tcurrentRuntimeCondition,\n\t\t\t\t\t\t\truntimeCondition\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentRuntimeCondition = runtimeCondition;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentRuntimeCondition !== false) {\n\t\t\t\t\totherRuntimeConnections.push({\n\t\t\t\t\t\toriginModule,\n\t\t\t\t\t\truntimeCondition: currentRuntimeCondition\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (otherRuntimeConnections.length > 0) {\n\t\t\t\tconst problem = requestShortener => {\n\t\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\t\trequestShortener\n\t\t\t\t\t)} is runtime-dependent referenced by these modules: ${Array.from(\n\t\t\t\t\t\totherRuntimeConnections,\n\t\t\t\t\t\t({ originModule, runtimeCondition }) =>\n\t\t\t\t\t\t\t`${originModule.readableIdentifier(\n\t\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t\t)} (expected runtime ${runtimeToString(\n\t\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t\t)}, module is only referenced in ${runtimeToString(\n\t\t\t\t\t\t\t\t/** @type {RuntimeSpec} */ (runtimeCondition)\n\t\t\t\t\t\t\t)})`\n\t\t\t\t\t).join(\", \")}`;\n\t\t\t\t};\n\t\t\t\tstatistics.incorrectRuntimeCondition++;\n\t\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\t\treturn problem;\n\t\t\t}\n\t\t}\n\n\t\tlet backup;\n\t\tif (avoidMutateOnFailure) {\n\t\t\tbackup = config.snapshot();\n\t\t}\n\n\t\t// Add the module\n\t\tconfig.add(module);\n\n\t\tincomingModules.sort(compareModulesByIdentifier);\n\n\t\t// Every module which depends on the added module must be in the configuration too.\n\t\tfor (const originModule of incomingModules) {\n\t\t\tconst problem = this._tryToAdd(\n\t\t\t\tcompilation,\n\t\t\t\tconfig,\n\t\t\t\toriginModule,\n\t\t\t\truntime,\n\t\t\t\tactiveRuntime,\n\t\t\t\tpossibleModules,\n\t\t\t\tcandidates,\n\t\t\t\tfailureCache,\n\t\t\t\tchunkGraph,\n\t\t\t\tfalse,\n\t\t\t\tstatistics\n\t\t\t);\n\t\t\tif (problem) {\n\t\t\t\tif (backup !== undefined) config.rollback(backup);\n\t\t\t\tstatistics.importerFailed++;\n\t\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\t\treturn problem;\n\t\t\t}\n\t\t}\n\n\t\t// Add imports to possible candidates list\n\t\tfor (const imp of this._getImports(compilation, module, runtime)) {\n\t\t\tcandidates.add(imp);\n\t\t}\n\t\tstatistics.added++;\n\t\treturn null;\n\t}\n}\n\nclass ConcatConfiguration {\n\t/**\n\t * @param {Module} rootModule the root module\n\t * @param {RuntimeSpec} runtime the runtime\n\t */\n\tconstructor(rootModule, runtime) {\n\t\tthis.rootModule = rootModule;\n\t\tthis.runtime = runtime;\n\t\t/** @type {Set<Module>} */\n\t\tthis.modules = new Set();\n\t\tthis.modules.add(rootModule);\n\t\t/** @type {Map<Module, Module | function(RequestShortener): string>} */\n\t\tthis.warnings = new Map();\n\t}\n\n\tadd(module) {\n\t\tthis.modules.add(module);\n\t}\n\n\thas(module) {\n\t\treturn this.modules.has(module);\n\t}\n\n\tisEmpty() {\n\t\treturn this.modules.size === 1;\n\t}\n\n\taddWarning(module, problem) {\n\t\tthis.warnings.set(module, problem);\n\t}\n\n\tgetWarningsSorted() {\n\t\treturn new Map(\n\t\t\tArray.from(this.warnings).sort((a, b) => {\n\t\t\t\tconst ai = a[0].identifier();\n\t\t\t\tconst bi = b[0].identifier();\n\t\t\t\tif (ai < bi) return -1;\n\t\t\t\tif (ai > bi) return 1;\n\t\t\t\treturn 0;\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * @returns {Set<Module>} modules as set\n\t */\n\tgetModules() {\n\t\treturn this.modules;\n\t}\n\n\tsnapshot() {\n\t\treturn this.modules.size;\n\t}\n\n\trollback(snapshot) {\n\t\tconst modules = this.modules;\n\t\tfor (const m of modules) {\n\t\t\tif (snapshot === 0) {\n\t\t\t\tmodules.delete(m);\n\t\t\t} else {\n\t\t\t\tsnapshot--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nmodule.exports = ModuleConcatenationPlugin;\n"]},"metadata":{},"sourceType":"script"}