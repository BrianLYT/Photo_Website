{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  equals\n} = require(\"./util/ArrayHelpers\");\n\nconst SortableSet = require(\"./util/SortableSet\");\n\nconst makeSerializable = require(\"./util/makeSerializable\");\n\nconst {\n  forEachRuntime\n} = require(\"./util/runtime\");\n/** @typedef {import(\"./Dependency\").RuntimeSpec} RuntimeSpec */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n\n/** @typedef {import(\"./ModuleGraphConnection\")} ModuleGraphConnection */\n\n/** @typedef {import(\"./util/Hash\")} Hash */\n\n/** @typedef {typeof UsageState.OnlyPropertiesUsed | typeof UsageState.NoInfo | typeof UsageState.Unknown | typeof UsageState.Used} RuntimeUsageStateType */\n\n/** @typedef {typeof UsageState.Unused | RuntimeUsageStateType} UsageStateType */\n\n\nconst UsageState = Object.freeze({\n  Unused:\n  /** @type {0} */\n  0,\n  OnlyPropertiesUsed:\n  /** @type {1} */\n  1,\n  NoInfo:\n  /** @type {2} */\n  2,\n  Unknown:\n  /** @type {3} */\n  3,\n  Used:\n  /** @type {4} */\n  4\n});\n\nconst RETURNS_TRUE = () => true;\n\nconst CIRCULAR = Symbol(\"circular target\");\n\nclass RestoreProvidedData {\n  constructor(exports, otherProvided, otherCanMangleProvide, otherTerminalBinding) {\n    this.exports = exports;\n    this.otherProvided = otherProvided;\n    this.otherCanMangleProvide = otherCanMangleProvide;\n    this.otherTerminalBinding = otherTerminalBinding;\n  }\n\n  serialize(_ref) {\n    let {\n      write\n    } = _ref;\n    write(this.exports);\n    write(this.otherProvided);\n    write(this.otherCanMangleProvide);\n    write(this.otherTerminalBinding);\n  }\n\n  static deserialize(_ref2) {\n    let {\n      read\n    } = _ref2;\n    return new RestoreProvidedData(read(), read(), read(), read());\n  }\n\n}\n\nmakeSerializable(RestoreProvidedData, \"webpack/lib/ModuleGraph\", \"RestoreProvidedData\");\n\nclass ExportsInfo {\n  constructor() {\n    /** @type {Map<string, ExportInfo>} */\n    this._exports = new Map();\n    this._otherExportsInfo = new ExportInfo(null);\n    this._sideEffectsOnlyInfo = new ExportInfo(\"*side effects only*\");\n    this._exportsAreOrdered = false;\n    /** @type {ExportsInfo=} */\n\n    this._redirectTo = undefined;\n  }\n  /**\n   * @returns {Iterable<ExportInfo>} all owned exports in any order\n   */\n\n\n  get ownedExports() {\n    return this._exports.values();\n  }\n  /**\n   * @returns {Iterable<ExportInfo>} all owned exports in order\n   */\n\n\n  get orderedOwnedExports() {\n    if (!this._exportsAreOrdered) {\n      this._sortExports();\n    }\n\n    return this._exports.values();\n  }\n  /**\n   * @returns {Iterable<ExportInfo>} all exports in any order\n   */\n\n\n  get exports() {\n    if (this._redirectTo !== undefined) {\n      const map = new Map(this._redirectTo._exports);\n\n      for (const [key, value] of this._exports) {\n        map.set(key, value);\n      }\n\n      return map.values();\n    }\n\n    return this._exports.values();\n  }\n  /**\n   * @returns {Iterable<ExportInfo>} all exports in order\n   */\n\n\n  get orderedExports() {\n    if (!this._exportsAreOrdered) {\n      this._sortExports();\n    }\n\n    if (this._redirectTo !== undefined) {\n      const map = new Map(Array.from(this._redirectTo.orderedExports, item => [item.name, item]));\n\n      for (const [key, value] of this._exports) {\n        map.set(key, value);\n      } // sorting should be pretty fast as map contains\n      // a lot of presorted items\n\n\n      this._sortExportsMap(map);\n\n      return map.values();\n    }\n\n    return this._exports.values();\n  }\n  /**\n   * @returns {ExportInfo} the export info of unlisted exports\n   */\n\n\n  get otherExportsInfo() {\n    if (this._redirectTo !== undefined) return this._redirectTo.otherExportsInfo;\n    return this._otherExportsInfo;\n  }\n\n  _sortExportsMap(exports) {\n    if (exports.size > 1) {\n      const namesInOrder = [];\n\n      for (const entry of exports.values()) {\n        namesInOrder.push(entry.name);\n      }\n\n      namesInOrder.sort();\n      let i = 0;\n\n      for (const entry of exports.values()) {\n        const name = namesInOrder[i];\n        if (entry.name !== name) break;\n        i++;\n      }\n\n      for (; i < namesInOrder.length; i++) {\n        const name = namesInOrder[i];\n        const correctEntry = exports.get(name);\n        exports.delete(name);\n        exports.set(name, correctEntry);\n      }\n    }\n  }\n\n  _sortExports() {\n    this._sortExportsMap(this._exports);\n\n    this._exportsAreOrdered = true;\n  }\n\n  setRedirectNamedTo(exportsInfo) {\n    if (this._redirectTo === exportsInfo) return false;\n    this._redirectTo = exportsInfo;\n    return true;\n  }\n\n  setHasProvideInfo() {\n    for (const exportInfo of this._exports.values()) {\n      if (exportInfo.provided === undefined) {\n        exportInfo.provided = false;\n      }\n\n      if (exportInfo.canMangleProvide === undefined) {\n        exportInfo.canMangleProvide = true;\n      }\n    }\n\n    if (this._redirectTo !== undefined) {\n      this._redirectTo.setHasProvideInfo();\n    } else {\n      if (this._otherExportsInfo.provided === undefined) {\n        this._otherExportsInfo.provided = false;\n      }\n\n      if (this._otherExportsInfo.canMangleProvide === undefined) {\n        this._otherExportsInfo.canMangleProvide = true;\n      }\n    }\n  }\n\n  setHasUseInfo() {\n    for (const exportInfo of this._exports.values()) {\n      exportInfo.setHasUseInfo();\n    }\n\n    this._sideEffectsOnlyInfo.setHasUseInfo();\n\n    if (this._redirectTo !== undefined) {\n      this._redirectTo.setHasUseInfo();\n    } else {\n      this._otherExportsInfo.setHasUseInfo();\n\n      if (this._otherExportsInfo.canMangleUse === undefined) {\n        this._otherExportsInfo.canMangleUse = true;\n      }\n    }\n  }\n  /**\n   * @param {string} name export name\n   * @returns {ExportInfo} export info for this name\n   */\n\n\n  getOwnExportInfo(name) {\n    const info = this._exports.get(name);\n\n    if (info !== undefined) return info;\n    const newInfo = new ExportInfo(name, this._otherExportsInfo);\n\n    this._exports.set(name, newInfo);\n\n    this._exportsAreOrdered = false;\n    return newInfo;\n  }\n  /**\n   * @param {string} name export name\n   * @returns {ExportInfo} export info for this name\n   */\n\n\n  getExportInfo(name) {\n    const info = this._exports.get(name);\n\n    if (info !== undefined) return info;\n    if (this._redirectTo !== undefined) return this._redirectTo.getExportInfo(name);\n    const newInfo = new ExportInfo(name, this._otherExportsInfo);\n\n    this._exports.set(name, newInfo);\n\n    this._exportsAreOrdered = false;\n    return newInfo;\n  }\n  /**\n   * @param {string} name export name\n   * @returns {ExportInfo} export info for this name\n   */\n\n\n  getReadOnlyExportInfo(name) {\n    const info = this._exports.get(name);\n\n    if (info !== undefined) return info;\n    if (this._redirectTo !== undefined) return this._redirectTo.getReadOnlyExportInfo(name);\n    return this._otherExportsInfo;\n  }\n  /**\n   * @param {string[]} name export name\n   * @returns {ExportInfo | undefined} export info for this name\n   */\n\n\n  getReadOnlyExportInfoRecursive(name) {\n    const exportInfo = this.getReadOnlyExportInfo(name[0]);\n    if (name.length === 1) return exportInfo;\n    if (!exportInfo.exportsInfo) return undefined;\n    return exportInfo.exportsInfo.getReadOnlyExportInfoRecursive(name.slice(1));\n  }\n  /**\n   * @param {string[]=} name the export name\n   * @returns {ExportsInfo | undefined} the nested exports info\n   */\n\n\n  getNestedExportsInfo(name) {\n    if (Array.isArray(name) && name.length > 0) {\n      const info = this.getReadOnlyExportInfo(name[0]);\n      if (!info.exportsInfo) return undefined;\n      return info.exportsInfo.getNestedExportsInfo(name.slice(1));\n    }\n\n    return this;\n  }\n  /**\n   * @param {boolean=} canMangle true, if exports can still be mangled (defaults to false)\n   * @param {Set<string>=} excludeExports list of unaffected exports\n   * @param {any=} targetKey use this as key for the target\n   * @param {ModuleGraphConnection=} targetModule set this module as target\n   * @param {number=} priority priority\n   * @returns {boolean} true, if this call changed something\n   */\n\n\n  setUnknownExportsProvided(canMangle, excludeExports, targetKey, targetModule, priority) {\n    let changed = false;\n\n    if (excludeExports) {\n      for (const name of excludeExports) {\n        // Make sure these entries exist, so they can get different info\n        this.getExportInfo(name);\n      }\n    }\n\n    for (const exportInfo of this._exports.values()) {\n      if (!canMangle && exportInfo.canMangleProvide !== false) {\n        exportInfo.canMangleProvide = false;\n        changed = true;\n      }\n\n      if (excludeExports && excludeExports.has(exportInfo.name)) continue;\n\n      if (exportInfo.provided !== true && exportInfo.provided !== null) {\n        exportInfo.provided = null;\n        changed = true;\n      }\n\n      if (targetKey) {\n        exportInfo.setTarget(targetKey, targetModule, [exportInfo.name], -1);\n      }\n    }\n\n    if (this._redirectTo !== undefined) {\n      if (this._redirectTo.setUnknownExportsProvided(canMangle, excludeExports, targetKey, targetModule, priority)) {\n        changed = true;\n      }\n    } else {\n      if (this._otherExportsInfo.provided !== true && this._otherExportsInfo.provided !== null) {\n        this._otherExportsInfo.provided = null;\n        changed = true;\n      }\n\n      if (!canMangle && this._otherExportsInfo.canMangleProvide !== false) {\n        this._otherExportsInfo.canMangleProvide = false;\n        changed = true;\n      }\n\n      if (targetKey) {\n        this._otherExportsInfo.setTarget(targetKey, targetModule, undefined, priority);\n      }\n    }\n\n    return changed;\n  }\n  /**\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {boolean} true, when something changed\n   */\n\n\n  setUsedInUnknownWay(runtime) {\n    let changed = false;\n\n    for (const exportInfo of this._exports.values()) {\n      if (exportInfo.setUsedInUnknownWay(runtime)) {\n        changed = true;\n      }\n    }\n\n    if (this._redirectTo !== undefined) {\n      if (this._redirectTo.setUsedInUnknownWay(runtime)) {\n        changed = true;\n      }\n    } else {\n      if (this._otherExportsInfo.setUsedConditionally(used => used < UsageState.Unknown, UsageState.Unknown, runtime)) {\n        changed = true;\n      }\n\n      if (this._otherExportsInfo.canMangleUse !== false) {\n        this._otherExportsInfo.canMangleUse = false;\n        changed = true;\n      }\n    }\n\n    return changed;\n  }\n  /**\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {boolean} true, when something changed\n   */\n\n\n  setUsedWithoutInfo(runtime) {\n    let changed = false;\n\n    for (const exportInfo of this._exports.values()) {\n      if (exportInfo.setUsedWithoutInfo(runtime)) {\n        changed = true;\n      }\n    }\n\n    if (this._redirectTo !== undefined) {\n      if (this._redirectTo.setUsedWithoutInfo(runtime)) {\n        changed = true;\n      }\n    } else {\n      if (this._otherExportsInfo.setUsed(UsageState.NoInfo, runtime)) {\n        changed = true;\n      }\n\n      if (this._otherExportsInfo.canMangleUse !== false) {\n        this._otherExportsInfo.canMangleUse = false;\n        changed = true;\n      }\n    }\n\n    return changed;\n  }\n  /**\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {boolean} true, when something changed\n   */\n\n\n  setAllKnownExportsUsed(runtime) {\n    let changed = false;\n\n    for (const exportInfo of this._exports.values()) {\n      if (!exportInfo.provided) continue;\n\n      if (exportInfo.setUsed(UsageState.Used, runtime)) {\n        changed = true;\n      }\n    }\n\n    return changed;\n  }\n  /**\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {boolean} true, when something changed\n   */\n\n\n  setUsedForSideEffectsOnly(runtime) {\n    return this._sideEffectsOnlyInfo.setUsedConditionally(used => used === UsageState.Unused, UsageState.Used, runtime);\n  }\n  /**\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {boolean} true, when the module exports are used in any way\n   */\n\n\n  isUsed(runtime) {\n    if (this._redirectTo !== undefined) {\n      if (this._redirectTo.isUsed(runtime)) {\n        return true;\n      }\n    } else {\n      if (this._otherExportsInfo.getUsed(runtime) !== UsageState.Unused) {\n        return true;\n      }\n    }\n\n    for (const exportInfo of this._exports.values()) {\n      if (exportInfo.getUsed(runtime) !== UsageState.Unused) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {boolean} true, when the module is used in any way\n   */\n\n\n  isModuleUsed(runtime) {\n    if (this.isUsed(runtime)) return true;\n    if (this._sideEffectsOnlyInfo.getUsed(runtime) !== UsageState.Unused) return true;\n    return false;\n  }\n  /**\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {SortableSet<string> | boolean | null} set of used exports, or true (when namespace object is used), or false (when unused), or null (when unknown)\n   */\n\n\n  getUsedExports(runtime) {\n    if (!this._redirectTo !== undefined) {\n      switch (this._otherExportsInfo.getUsed(runtime)) {\n        case UsageState.NoInfo:\n          return null;\n\n        case UsageState.Unknown:\n        case UsageState.OnlyPropertiesUsed:\n        case UsageState.Used:\n          return true;\n      }\n    }\n\n    const array = [];\n    if (!this._exportsAreOrdered) this._sortExports();\n\n    for (const exportInfo of this._exports.values()) {\n      switch (exportInfo.getUsed(runtime)) {\n        case UsageState.NoInfo:\n          return null;\n\n        case UsageState.Unknown:\n          return true;\n\n        case UsageState.OnlyPropertiesUsed:\n        case UsageState.Used:\n          array.push(exportInfo.name);\n      }\n    }\n\n    if (this._redirectTo !== undefined) {\n      const inner = this._redirectTo.getUsedExports(runtime);\n\n      if (inner === null) return null;\n      if (inner === true) return true;\n\n      if (inner !== false) {\n        for (const item of inner) {\n          array.push(item);\n        }\n      }\n    }\n\n    if (array.length === 0) {\n      switch (this._sideEffectsOnlyInfo.getUsed(runtime)) {\n        case UsageState.NoInfo:\n          return null;\n\n        case UsageState.Unused:\n          return false;\n      }\n    }\n\n    return new SortableSet(array);\n  }\n  /**\n   * @returns {null | true | string[]} list of exports when known\n   */\n\n\n  getProvidedExports() {\n    if (!this._redirectTo !== undefined) {\n      switch (this._otherExportsInfo.provided) {\n        case undefined:\n          return null;\n\n        case null:\n          return true;\n\n        case true:\n          return true;\n      }\n    }\n\n    const array = [];\n    if (!this._exportsAreOrdered) this._sortExports();\n\n    for (const exportInfo of this._exports.values()) {\n      switch (exportInfo.provided) {\n        case undefined:\n          return null;\n\n        case null:\n          return true;\n\n        case true:\n          array.push(exportInfo.name);\n      }\n    }\n\n    if (this._redirectTo !== undefined) {\n      const inner = this._redirectTo.getProvidedExports();\n\n      if (inner === null) return null;\n      if (inner === true) return true;\n\n      for (const item of inner) {\n        if (!array.includes(item)) {\n          array.push(item);\n        }\n      }\n    }\n\n    return array;\n  }\n  /**\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {ExportInfo[]} exports that are relevant (not unused and potential provided)\n   */\n\n\n  getRelevantExports(runtime) {\n    const list = [];\n\n    for (const exportInfo of this._exports.values()) {\n      const used = exportInfo.getUsed(runtime);\n      if (used === UsageState.Unused) continue;\n      if (exportInfo.provided === false) continue;\n      list.push(exportInfo);\n    }\n\n    if (this._redirectTo !== undefined) {\n      for (const exportInfo of this._redirectTo.getRelevantExports(runtime)) {\n        if (!this._exports.has(exportInfo.name)) list.push(exportInfo);\n      }\n    }\n\n    if (this._otherExportsInfo.provided !== false && this._otherExportsInfo.getUsed(runtime) !== UsageState.Unused) {\n      list.push(this._otherExportsInfo);\n    }\n\n    return list;\n  }\n  /**\n   * @param {string | string[]} name the name of the export\n   * @returns {boolean | undefined | null} if the export is provided\n   */\n\n\n  isExportProvided(name) {\n    if (Array.isArray(name)) {\n      const info = this.getReadOnlyExportInfo(name[0]);\n\n      if (info.exportsInfo && name.length > 1) {\n        return info.exportsInfo.isExportProvided(name.slice(1));\n      }\n\n      return info.provided;\n    }\n\n    const info = this.getReadOnlyExportInfo(name);\n    return info.provided;\n  }\n  /**\n   * @param {RuntimeSpec} runtime runtime\n   * @returns {string} key representing the usage\n   */\n\n\n  getUsageKey(runtime) {\n    const key = [];\n\n    if (this._redirectTo !== undefined) {\n      key.push(this._redirectTo.getUsageKey(runtime));\n    } else {\n      key.push(this._otherExportsInfo.getUsed(runtime));\n    }\n\n    key.push(this._sideEffectsOnlyInfo.getUsed(runtime));\n\n    for (const exportInfo of this.orderedOwnedExports) {\n      key.push(exportInfo.getUsed(runtime));\n    }\n\n    return key.join(\"|\");\n  }\n  /**\n   * @param {RuntimeSpec} runtimeA first runtime\n   * @param {RuntimeSpec} runtimeB second runtime\n   * @returns {boolean} true, when equally used\n   */\n\n\n  isEquallyUsed(runtimeA, runtimeB) {\n    if (this._redirectTo !== undefined) {\n      if (!this._redirectTo.isEquallyUsed(runtimeA, runtimeB)) return false;\n    } else {\n      if (this._otherExportsInfo.getUsed(runtimeA) !== this._otherExportsInfo.getUsed(runtimeB)) {\n        return false;\n      }\n    }\n\n    if (this._sideEffectsOnlyInfo.getUsed(runtimeA) !== this._sideEffectsOnlyInfo.getUsed(runtimeB)) {\n      return false;\n    }\n\n    for (const exportInfo of this.ownedExports) {\n      if (exportInfo.getUsed(runtimeA) !== exportInfo.getUsed(runtimeB)) return false;\n    }\n\n    return true;\n  }\n  /**\n   * @param {string | string[]} name export name\n   * @param {RuntimeSpec} runtime check usage for this runtime only\n   * @returns {UsageStateType} usage status\n   */\n\n\n  getUsed(name, runtime) {\n    if (Array.isArray(name)) {\n      if (name.length === 0) return this.otherExportsInfo.getUsed(runtime);\n      let info = this.getReadOnlyExportInfo(name[0]);\n\n      if (info.exportsInfo && name.length > 1) {\n        return info.exportsInfo.getUsed(name.slice(1), runtime);\n      }\n\n      return info.getUsed(runtime);\n    }\n\n    let info = this.getReadOnlyExportInfo(name);\n    return info.getUsed(runtime);\n  }\n  /**\n   * @param {string | string[]} name the export name\n   * @param {RuntimeSpec} runtime check usage for this runtime only\n   * @returns {string | string[] | false} the used name\n   */\n\n\n  getUsedName(name, runtime) {\n    if (Array.isArray(name)) {\n      // TODO improve this\n      if (name.length === 0) {\n        if (!this.isUsed(runtime)) return false;\n        return name;\n      }\n\n      let info = this.getReadOnlyExportInfo(name[0]);\n      const x = info.getUsedName(name[0], runtime);\n      if (x === false) return false;\n      const arr = x === name[0] && name.length === 1 ? name : [x];\n\n      if (name.length === 1) {\n        return arr;\n      }\n\n      if (info.exportsInfo && info.getUsed(runtime) === UsageState.OnlyPropertiesUsed) {\n        const nested = info.exportsInfo.getUsedName(name.slice(1), runtime);\n        if (!nested) return false;\n        return arr.concat(nested);\n      } else {\n        return arr.concat(name.slice(1));\n      }\n    } else {\n      let info = this.getReadOnlyExportInfo(name);\n      const usedName = info.getUsedName(name, runtime);\n      return usedName;\n    }\n  }\n  /**\n   * @param {Hash} hash the hash\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {void}\n   */\n\n\n  updateHash(hash, runtime) {\n    this._updateHash(hash, runtime, new Set());\n  }\n  /**\n   * @param {Hash} hash the hash\n   * @param {RuntimeSpec} runtime the runtime\n   * @param {Set<ExportsInfo>} alreadyVisitedExportsInfo for circular references\n   * @returns {void}\n   */\n\n\n  _updateHash(hash, runtime, alreadyVisitedExportsInfo) {\n    const set = new Set(alreadyVisitedExportsInfo);\n    set.add(this);\n\n    for (const exportInfo of this.orderedExports) {\n      if (exportInfo.hasInfo(this._otherExportsInfo, runtime)) {\n        exportInfo._updateHash(hash, runtime, set);\n      }\n    }\n\n    this._sideEffectsOnlyInfo._updateHash(hash, runtime, set);\n\n    this._otherExportsInfo._updateHash(hash, runtime, set);\n\n    if (this._redirectTo !== undefined) {\n      this._redirectTo._updateHash(hash, runtime, set);\n    }\n  }\n\n  getRestoreProvidedData() {\n    const otherProvided = this._otherExportsInfo.provided;\n    const otherCanMangleProvide = this._otherExportsInfo.canMangleProvide;\n    const otherTerminalBinding = this._otherExportsInfo.terminalBinding;\n    const exports = [];\n\n    for (const exportInfo of this.orderedExports) {\n      if (exportInfo.provided !== otherProvided || exportInfo.canMangleProvide !== otherCanMangleProvide || exportInfo.terminalBinding !== otherTerminalBinding || exportInfo.exportsInfoOwned) {\n        exports.push({\n          name: exportInfo.name,\n          provided: exportInfo.provided,\n          canMangleProvide: exportInfo.canMangleProvide,\n          terminalBinding: exportInfo.terminalBinding,\n          exportsInfo: exportInfo.exportsInfoOwned ? exportInfo.exportsInfo.getRestoreProvidedData() : undefined\n        });\n      }\n    }\n\n    return new RestoreProvidedData(exports, otherProvided, otherCanMangleProvide, otherTerminalBinding);\n  }\n\n  restoreProvided(_ref3) {\n    let {\n      otherProvided,\n      otherCanMangleProvide,\n      otherTerminalBinding,\n      exports\n    } = _ref3;\n    let wasEmpty = true;\n\n    for (const exportInfo of this._exports.values()) {\n      wasEmpty = false;\n      exportInfo.provided = otherProvided;\n      exportInfo.canMangleProvide = otherCanMangleProvide;\n      exportInfo.terminalBinding = otherTerminalBinding;\n    }\n\n    this._otherExportsInfo.provided = otherProvided;\n    this._otherExportsInfo.canMangleProvide = otherCanMangleProvide;\n    this._otherExportsInfo.terminalBinding = otherTerminalBinding;\n\n    for (const exp of exports) {\n      const exportInfo = this.getExportInfo(exp.name);\n      exportInfo.provided = exp.provided;\n      exportInfo.canMangleProvide = exp.canMangleProvide;\n      exportInfo.terminalBinding = exp.terminalBinding;\n\n      if (exp.exportsInfo) {\n        const exportsInfo = exportInfo.createNestedExportsInfo();\n        exportsInfo.restoreProvided(exp.exportsInfo);\n      }\n    }\n\n    if (wasEmpty) this._exportsAreOrdered = true;\n  }\n\n}\n\nclass ExportInfo {\n  /**\n   * @param {string} name the original name of the export\n   * @param {ExportInfo=} initFrom init values from this ExportInfo\n   */\n  constructor(name, initFrom) {\n    /** @type {string} */\n    this.name = name;\n    /** @private @type {string | null} */\n\n    this._usedName = initFrom ? initFrom._usedName : null;\n    /** @private @type {UsageStateType} */\n\n    this._globalUsed = initFrom ? initFrom._globalUsed : undefined;\n    /** @private @type {Map<string, RuntimeUsageStateType>} */\n\n    this._usedInRuntime = initFrom && initFrom._usedInRuntime ? new Map(initFrom._usedInRuntime) : undefined;\n    /** @private @type {boolean} */\n\n    this._hasUseInRuntimeInfo = initFrom ? initFrom._hasUseInRuntimeInfo : false;\n    /**\n     * true: it is provided\n     * false: it is not provided\n     * null: only the runtime knows if it is provided\n     * undefined: it was not determined if it is provided\n     * @type {boolean | null | undefined}\n     */\n\n    this.provided = initFrom ? initFrom.provided : undefined;\n    /**\n     * is the export a terminal binding that should be checked for export star conflicts\n     * @type {boolean}\n     */\n\n    this.terminalBinding = initFrom ? initFrom.terminalBinding : false;\n    /**\n     * true: it can be mangled\n     * false: is can not be mangled\n     * undefined: it was not determined if it can be mangled\n     * @type {boolean | undefined}\n     */\n\n    this.canMangleProvide = initFrom ? initFrom.canMangleProvide : undefined;\n    /**\n     * true: it can be mangled\n     * false: is can not be mangled\n     * undefined: it was not determined if it can be mangled\n     * @type {boolean | undefined}\n     */\n\n    this.canMangleUse = initFrom ? initFrom.canMangleUse : undefined;\n    /** @type {boolean} */\n\n    this.exportsInfoOwned = false;\n    /** @type {ExportsInfo=} */\n\n    this.exportsInfo = undefined;\n    /** @type {Map<any, { connection: ModuleGraphConnection | null, export: string[], priority: number }>=} */\n\n    this._target = undefined;\n\n    if (initFrom && initFrom._target) {\n      this._target = new Map();\n\n      for (const [key, value] of initFrom._target) {\n        this._target.set(key, {\n          connection: value.connection,\n          export: value.export || [name],\n          priority: value.priority\n        });\n      }\n    }\n    /** @type {Map<any, { connection: ModuleGraphConnection | null, export: string[], priority: number }>=} */\n\n\n    this._maxTarget = undefined;\n  } // TODO webpack 5 remove\n\n  /** @private */\n\n\n  get used() {\n    throw new Error(\"REMOVED\");\n  }\n  /** @private */\n\n\n  get usedName() {\n    throw new Error(\"REMOVED\");\n  }\n  /**\n   * @private\n   * @param {*} v v\n   */\n\n\n  set used(v) {\n    throw new Error(\"REMOVED\");\n  }\n  /**\n   * @private\n   * @param {*} v v\n   */\n\n\n  set usedName(v) {\n    throw new Error(\"REMOVED\");\n  }\n\n  get canMangle() {\n    switch (this.canMangleProvide) {\n      case undefined:\n        return this.canMangleUse === false ? false : undefined;\n\n      case false:\n        return false;\n\n      case true:\n        switch (this.canMangleUse) {\n          case undefined:\n            return undefined;\n\n          case false:\n            return false;\n\n          case true:\n            return true;\n        }\n\n    }\n\n    throw new Error(`Unexpected flags for canMangle ${this.canMangleProvide} ${this.canMangleUse}`);\n  }\n  /**\n   * @param {RuntimeSpec} runtime only apply to this runtime\n   * @returns {boolean} true, when something changed\n   */\n\n\n  setUsedInUnknownWay(runtime) {\n    let changed = false;\n\n    if (this.setUsedConditionally(used => used < UsageState.Unknown, UsageState.Unknown, runtime)) {\n      changed = true;\n    }\n\n    if (this.canMangleUse !== false) {\n      this.canMangleUse = false;\n      changed = true;\n    }\n\n    return changed;\n  }\n  /**\n   * @param {RuntimeSpec} runtime only apply to this runtime\n   * @returns {boolean} true, when something changed\n   */\n\n\n  setUsedWithoutInfo(runtime) {\n    let changed = false;\n\n    if (this.setUsed(UsageState.NoInfo, runtime)) {\n      changed = true;\n    }\n\n    if (this.canMangleUse !== false) {\n      this.canMangleUse = false;\n      changed = true;\n    }\n\n    return changed;\n  }\n\n  setHasUseInfo() {\n    if (!this._hasUseInRuntimeInfo) {\n      this._hasUseInRuntimeInfo = true;\n    }\n\n    if (this.canMangleUse === undefined) {\n      this.canMangleUse = true;\n    }\n\n    if (this.exportsInfoOwned) {\n      this.exportsInfo.setHasUseInfo();\n    }\n  }\n  /**\n   * @param {function(UsageStateType): boolean} condition compare with old value\n   * @param {UsageStateType} newValue set when condition is true\n   * @param {RuntimeSpec} runtime only apply to this runtime\n   * @returns {boolean} true when something has changed\n   */\n\n\n  setUsedConditionally(condition, newValue, runtime) {\n    if (runtime === undefined) {\n      if (this._globalUsed === undefined) {\n        this._globalUsed = newValue;\n        return true;\n      } else {\n        if (this._globalUsed !== newValue && condition(this._globalUsed)) {\n          this._globalUsed = newValue;\n          return true;\n        }\n      }\n    } else if (this._usedInRuntime === undefined) {\n      if (newValue !== UsageState.Unused && condition(UsageState.Unused)) {\n        this._usedInRuntime = new Map();\n        forEachRuntime(runtime, runtime => this._usedInRuntime.set(runtime, newValue));\n        return true;\n      }\n    } else {\n      let changed = false;\n      forEachRuntime(runtime, runtime => {\n        /** @type {UsageStateType} */\n        let oldValue = this._usedInRuntime.get(runtime);\n\n        if (oldValue === undefined) oldValue = UsageState.Unused;\n\n        if (newValue !== oldValue && condition(oldValue)) {\n          if (newValue === UsageState.Unused) {\n            this._usedInRuntime.delete(runtime);\n          } else {\n            this._usedInRuntime.set(runtime, newValue);\n          }\n\n          changed = true;\n        }\n      });\n\n      if (changed) {\n        if (this._usedInRuntime.size === 0) this._usedInRuntime = undefined;\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * @param {UsageStateType} newValue new value of the used state\n   * @param {RuntimeSpec} runtime only apply to this runtime\n   * @returns {boolean} true when something has changed\n   */\n\n\n  setUsed(newValue, runtime) {\n    if (runtime === undefined) {\n      if (this._globalUsed !== newValue) {\n        this._globalUsed = newValue;\n        return true;\n      }\n    } else if (this._usedInRuntime === undefined) {\n      if (newValue !== UsageState.Unused) {\n        this._usedInRuntime = new Map();\n        forEachRuntime(runtime, runtime => this._usedInRuntime.set(runtime, newValue));\n        return true;\n      }\n    } else {\n      let changed = false;\n      forEachRuntime(runtime, runtime => {\n        /** @type {UsageStateType} */\n        let oldValue = this._usedInRuntime.get(runtime);\n\n        if (oldValue === undefined) oldValue = UsageState.Unused;\n\n        if (newValue !== oldValue) {\n          if (newValue === UsageState.Unused) {\n            this._usedInRuntime.delete(runtime);\n          } else {\n            this._usedInRuntime.set(runtime, newValue);\n          }\n\n          changed = true;\n        }\n      });\n\n      if (changed) {\n        if (this._usedInRuntime.size === 0) this._usedInRuntime = undefined;\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * @param {any} key the key\n   * @returns {boolean} true, if something has changed\n   */\n\n\n  unsetTarget(key) {\n    if (!this._target) return false;\n\n    if (this._target.delete(key)) {\n      this._maxTarget = undefined;\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * @param {any} key the key\n   * @param {ModuleGraphConnection} connection the target module if a single one\n   * @param {string[]=} exportName the exported name\n   * @param {number=} priority priority\n   * @returns {boolean} true, if something has changed\n   */\n\n\n  setTarget(key, connection, exportName) {\n    let priority = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    if (exportName) exportName = [...exportName];\n\n    if (!this._target) {\n      this._target = new Map();\n\n      this._target.set(key, {\n        connection,\n        export: exportName,\n        priority\n      });\n\n      return true;\n    }\n\n    const oldTarget = this._target.get(key);\n\n    if (!oldTarget) {\n      if (oldTarget === null && !connection) return false;\n\n      this._target.set(key, {\n        connection,\n        export: exportName,\n        priority\n      });\n\n      this._maxTarget = undefined;\n      return true;\n    }\n\n    if (oldTarget.connection !== connection || oldTarget.priority !== priority || (exportName ? !oldTarget.export || !equals(oldTarget.export, exportName) : oldTarget.export)) {\n      oldTarget.connection = connection;\n      oldTarget.export = exportName;\n      oldTarget.priority = priority;\n      this._maxTarget = undefined;\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * @param {RuntimeSpec} runtime for this runtime\n   * @returns {UsageStateType} usage state\n   */\n\n\n  getUsed(runtime) {\n    if (!this._hasUseInRuntimeInfo) return UsageState.NoInfo;\n    if (this._globalUsed !== undefined) return this._globalUsed;\n\n    if (this._usedInRuntime === undefined) {\n      return UsageState.Unused;\n    } else if (typeof runtime === \"string\") {\n      const value = this._usedInRuntime.get(runtime);\n\n      return value === undefined ? UsageState.Unused : value;\n    } else if (runtime === undefined) {\n      /** @type {UsageStateType} */\n      let max = UsageState.Unused;\n\n      for (const value of this._usedInRuntime.values()) {\n        if (value === UsageState.Used) {\n          return UsageState.Used;\n        }\n\n        if (max < value) max = value;\n      }\n\n      return max;\n    } else {\n      /** @type {UsageStateType} */\n      let max = UsageState.Unused;\n\n      for (const item of runtime) {\n        const value = this._usedInRuntime.get(item);\n\n        if (value !== undefined) {\n          if (value === UsageState.Used) {\n            return UsageState.Used;\n          }\n\n          if (max < value) max = value;\n        }\n      }\n\n      return max;\n    }\n  }\n  /**\n   * get used name\n   * @param {string | undefined} fallbackName fallback name for used exports with no name\n   * @param {RuntimeSpec} runtime check usage for this runtime only\n   * @returns {string | false} used name\n   */\n\n\n  getUsedName(fallbackName, runtime) {\n    if (this._hasUseInRuntimeInfo) {\n      if (this._globalUsed !== undefined) {\n        if (this._globalUsed === UsageState.Unused) return false;\n      } else {\n        if (this._usedInRuntime === undefined) return false;\n\n        if (typeof runtime === \"string\") {\n          if (!this._usedInRuntime.has(runtime)) {\n            return false;\n          }\n        } else if (runtime !== undefined) {\n          if (Array.from(runtime).every(runtime => !this._usedInRuntime.has(runtime))) {\n            return false;\n          }\n        }\n      }\n    }\n\n    if (this._usedName !== null) return this._usedName;\n    return this.name || fallbackName;\n  }\n  /**\n   * @returns {boolean} true, when a mangled name of this export is set\n   */\n\n\n  hasUsedName() {\n    return this._usedName !== null;\n  }\n  /**\n   * Sets the mangled name of this export\n   * @param {string} name the new name\n   * @returns {void}\n   */\n\n\n  setUsedName(name) {\n    this._usedName = name;\n  }\n  /**\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @param {function({ module: Module, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\n   * @returns {ExportInfo | ExportsInfo | undefined} the terminal binding export(s) info if known\n   */\n\n\n  getTerminalBinding(moduleGraph) {\n    let resolveTargetFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : RETURNS_TRUE;\n    if (this.terminalBinding) return this;\n    const target = this.getTarget(moduleGraph, resolveTargetFilter);\n    if (!target) return undefined;\n    const exportsInfo = moduleGraph.getExportsInfo(target.module);\n    if (!target.export) return exportsInfo;\n    return exportsInfo.getReadOnlyExportInfoRecursive(target.export);\n  }\n\n  isReexport() {\n    return !this.terminalBinding && this._target && this._target.size > 0;\n  }\n\n  _getMaxTarget() {\n    if (this._maxTarget !== undefined) return this._maxTarget;\n    if (this._target.size <= 1) return this._maxTarget = this._target;\n    let maxPriority = -Infinity;\n    let minPriority = Infinity;\n\n    for (const {\n      priority\n    } of this._target.values()) {\n      if (maxPriority < priority) maxPriority = priority;\n      if (minPriority > priority) minPriority = priority;\n    } // This should be very common\n\n\n    if (maxPriority === minPriority) return this._maxTarget = this._target; // This is an edge case\n\n    const map = new Map();\n\n    for (const [key, value] of this._target) {\n      if (maxPriority === value.priority) {\n        map.set(key, value);\n      }\n    }\n\n    this._maxTarget = map;\n    return map;\n  }\n  /**\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @param {function(Module): boolean} validTargetModuleFilter a valid target module\n   * @returns {{ module: Module, export: string[] | undefined } | undefined | false} the target, undefined when there is no target, false when no target is valid\n   */\n\n\n  findTarget(moduleGraph, validTargetModuleFilter) {\n    return this._findTarget(moduleGraph, validTargetModuleFilter, new Set());\n  }\n  /**\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @param {function(Module): boolean} validTargetModuleFilter a valid target module\n   * @param {Set<ExportInfo> | undefined} alreadyVisited set of already visited export info to avoid circular references\n   * @returns {{ module: Module, export: string[] | undefined } | undefined | false} the target, undefined when there is no target, false when no target is valid\n   */\n\n\n  _findTarget(moduleGraph, validTargetModuleFilter, alreadyVisited) {\n    if (!this._target || this._target.size === 0) return undefined;\n\n    let rawTarget = this._getMaxTarget().values().next().value;\n\n    if (!rawTarget) return undefined;\n    /** @type {{ module: Module, export: string[] | undefined }} */\n\n    let target = {\n      module: rawTarget.connection.module,\n      export: rawTarget.export\n    };\n\n    for (;;) {\n      if (validTargetModuleFilter(target.module)) return target;\n      const exportsInfo = moduleGraph.getExportsInfo(target.module);\n      const exportInfo = exportsInfo.getExportInfo(target.export[0]);\n      if (alreadyVisited.has(exportInfo)) return null;\n\n      const newTarget = exportInfo._findTarget(moduleGraph, validTargetModuleFilter, alreadyVisited);\n\n      if (!newTarget) return false;\n\n      if (target.export.length === 1) {\n        target = newTarget;\n      } else {\n        target = {\n          module: newTarget.module,\n          export: newTarget.export ? newTarget.export.concat(target.export.slice(1)) : target.export.slice(1)\n        };\n      }\n    }\n  }\n  /**\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @param {function({ module: Module, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\n   * @returns {{ module: Module, export: string[] | undefined } | undefined} the target\n   */\n\n\n  getTarget(moduleGraph) {\n    let resolveTargetFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : RETURNS_TRUE;\n\n    const result = this._getTarget(moduleGraph, resolveTargetFilter, undefined);\n\n    if (result === CIRCULAR) return undefined;\n    return result;\n  }\n  /**\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @param {function({ module: Module, connection: ModuleGraphConnection, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\n   * @param {Set<ExportInfo> | undefined} alreadyVisited set of already visited export info to avoid circular references\n   * @returns {{ module: Module, connection: ModuleGraphConnection, export: string[] | undefined } | CIRCULAR | undefined} the target\n   */\n\n\n  _getTarget(moduleGraph, resolveTargetFilter, alreadyVisited) {\n    /**\n     * @param {{ connection: ModuleGraphConnection, export: string[] | undefined } | null} inputTarget unresolved target\n     * @param {Set<ExportInfo>} alreadyVisited set of already visited export info to avoid circular references\n     * @returns {{ module: Module, connection: ModuleGraphConnection, export: string[] | undefined } | CIRCULAR | null} resolved target\n     */\n    const resolveTarget = (inputTarget, alreadyVisited) => {\n      if (!inputTarget) return null;\n\n      if (!inputTarget.export) {\n        return {\n          module: inputTarget.connection.module,\n          connection: inputTarget.connection,\n          export: undefined\n        };\n      }\n      /** @type {{ module: Module, connection: ModuleGraphConnection, export: string[] | undefined }} */\n\n\n      let target = {\n        module: inputTarget.connection.module,\n        connection: inputTarget.connection,\n        export: inputTarget.export\n      };\n      if (!resolveTargetFilter(target)) return target;\n      let alreadyVisitedOwned = false;\n\n      for (;;) {\n        const exportsInfo = moduleGraph.getExportsInfo(target.module);\n        const exportInfo = exportsInfo.getExportInfo(target.export[0]);\n        if (!exportInfo) return target;\n        if (alreadyVisited.has(exportInfo)) return CIRCULAR;\n\n        const newTarget = exportInfo._getTarget(moduleGraph, resolveTargetFilter, alreadyVisited);\n\n        if (newTarget === CIRCULAR) return CIRCULAR;\n        if (!newTarget) return target;\n\n        if (target.export.length === 1) {\n          target = newTarget;\n          if (!target.export) return target;\n        } else {\n          target = {\n            module: newTarget.module,\n            connection: newTarget.connection,\n            export: newTarget.export ? newTarget.export.concat(target.export.slice(1)) : target.export.slice(1)\n          };\n        }\n\n        if (!resolveTargetFilter(target)) return target;\n\n        if (!alreadyVisitedOwned) {\n          alreadyVisited = new Set(alreadyVisited);\n          alreadyVisitedOwned = true;\n        }\n\n        alreadyVisited.add(exportInfo);\n      }\n    };\n\n    if (!this._target || this._target.size === 0) return undefined;\n    if (alreadyVisited && alreadyVisited.has(this)) return CIRCULAR;\n    const newAlreadyVisited = new Set(alreadyVisited);\n    newAlreadyVisited.add(this);\n\n    const values = this._getMaxTarget().values();\n\n    const target = resolveTarget(values.next().value, newAlreadyVisited);\n    if (target === CIRCULAR) return CIRCULAR;\n    if (target === null) return undefined;\n    let result = values.next();\n\n    while (!result.done) {\n      const t = resolveTarget(result.value, newAlreadyVisited);\n      if (t === CIRCULAR) return CIRCULAR;\n      if (t === null) return undefined;\n      if (t.module !== target.module) return undefined;\n      if (!t.export !== !target.export) return undefined;\n      if (target.export && !equals(t.export, target.export)) return undefined;\n      result = values.next();\n    }\n\n    return target;\n  }\n  /**\n   * Move the target forward as long resolveTargetFilter is fulfilled\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @param {function({ module: Module, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\n   * @param {function({ module: Module, export: string[] | undefined }): ModuleGraphConnection=} updateOriginalConnection updates the original connection instead of using the target connection\n   * @returns {{ module: Module, export: string[] | undefined } | undefined} the resolved target when moved\n   */\n\n\n  moveTarget(moduleGraph, resolveTargetFilter, updateOriginalConnection) {\n    const target = this._getTarget(moduleGraph, resolveTargetFilter, undefined);\n\n    if (target === CIRCULAR) return undefined;\n    if (!target) return undefined;\n\n    const originalTarget = this._getMaxTarget().values().next().value;\n\n    if (originalTarget.connection === target.connection && originalTarget.export === target.export) {\n      return undefined;\n    }\n\n    this._target.clear();\n\n    this._target.set(undefined, {\n      connection: updateOriginalConnection ? updateOriginalConnection(target) : target.connection,\n      export: target.export,\n      priority: 0\n    });\n\n    return target;\n  }\n\n  createNestedExportsInfo() {\n    if (this.exportsInfoOwned) return this.exportsInfo;\n    this.exportsInfoOwned = true;\n    const oldExportsInfo = this.exportsInfo;\n    this.exportsInfo = new ExportsInfo();\n    this.exportsInfo.setHasProvideInfo();\n\n    if (oldExportsInfo) {\n      this.exportsInfo.setRedirectNamedTo(oldExportsInfo);\n    }\n\n    return this.exportsInfo;\n  }\n\n  getNestedExportsInfo() {\n    return this.exportsInfo;\n  }\n\n  hasInfo(baseInfo, runtime) {\n    return this._usedName && this._usedName !== this.name || this.provided || this.terminalBinding || this.getUsed(runtime) !== baseInfo.getUsed(runtime);\n  }\n\n  updateHash(hash, runtime) {\n    this._updateHash(hash, runtime, new Set());\n  }\n\n  _updateHash(hash, runtime, alreadyVisitedExportsInfo) {\n    hash.update(`${this._usedName || this.name}${this.getUsed(runtime)}${this.provided}${this.terminalBinding}`);\n\n    if (this.exportsInfo && !alreadyVisitedExportsInfo.has(this.exportsInfo)) {\n      this.exportsInfo._updateHash(hash, runtime, alreadyVisitedExportsInfo);\n    }\n  }\n\n  getUsedInfo() {\n    if (this._globalUsed !== undefined) {\n      switch (this._globalUsed) {\n        case UsageState.Unused:\n          return \"unused\";\n\n        case UsageState.NoInfo:\n          return \"no usage info\";\n\n        case UsageState.Unknown:\n          return \"maybe used (runtime-defined)\";\n\n        case UsageState.Used:\n          return \"used\";\n\n        case UsageState.OnlyPropertiesUsed:\n          return \"only properties used\";\n      }\n    } else if (this._usedInRuntime !== undefined) {\n      /** @type {Map<RuntimeUsageStateType, string[]>} */\n      const map = new Map();\n\n      for (const [runtime, used] of this._usedInRuntime) {\n        const list = map.get(used);\n        if (list !== undefined) list.push(runtime);else map.set(used, [runtime]);\n      }\n\n      const specificInfo = Array.from(map, _ref4 => {\n        let [used, runtimes] = _ref4;\n\n        switch (used) {\n          case UsageState.NoInfo:\n            return `no usage info in ${runtimes.join(\", \")}`;\n\n          case UsageState.Unknown:\n            return `maybe used in ${runtimes.join(\", \")} (runtime-defined)`;\n\n          case UsageState.Used:\n            return `used in ${runtimes.join(\", \")}`;\n\n          case UsageState.OnlyPropertiesUsed:\n            return `only properties used in ${runtimes.join(\", \")}`;\n        }\n      });\n\n      if (specificInfo.length > 0) {\n        return specificInfo.join(\"; \");\n      }\n    }\n\n    return this._hasUseInRuntimeInfo ? \"unused\" : \"no usage info\";\n  }\n\n  getProvidedInfo() {\n    switch (this.provided) {\n      case undefined:\n        return \"no provided info\";\n\n      case null:\n        return \"maybe provided (runtime-defined)\";\n\n      case true:\n        return \"provided\";\n\n      case false:\n        return \"not provided\";\n    }\n  }\n\n  getRenameInfo() {\n    if (this._usedName !== null && this._usedName !== this.name) {\n      return `renamed to ${JSON.stringify(this._usedName).slice(1, -1)}`;\n    }\n\n    switch (this.canMangleProvide) {\n      case undefined:\n        switch (this.canMangleUse) {\n          case undefined:\n            return \"missing provision and use info prevents renaming\";\n\n          case false:\n            return \"usage prevents renaming (no provision info)\";\n\n          case true:\n            return \"missing provision info prevents renaming\";\n        }\n\n        break;\n\n      case true:\n        switch (this.canMangleUse) {\n          case undefined:\n            return \"missing usage info prevents renaming\";\n\n          case false:\n            return \"usage prevents renaming\";\n\n          case true:\n            return \"could be renamed\";\n        }\n\n        break;\n\n      case false:\n        switch (this.canMangleUse) {\n          case undefined:\n            return \"provision prevents renaming (no use info)\";\n\n          case false:\n            return \"usage and provision prevents renaming\";\n\n          case true:\n            return \"provision prevents renaming\";\n        }\n\n        break;\n    }\n\n    throw new Error(`Unexpected flags for getRenameInfo ${this.canMangleProvide} ${this.canMangleUse}`);\n  }\n\n}\n\nmodule.exports = ExportsInfo;\nmodule.exports.ExportInfo = ExportInfo;\nmodule.exports.UsageState = UsageState;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/ExportsInfo.js"],"names":["equals","require","SortableSet","makeSerializable","forEachRuntime","UsageState","Object","freeze","Unused","OnlyPropertiesUsed","NoInfo","Unknown","Used","RETURNS_TRUE","CIRCULAR","Symbol","RestoreProvidedData","constructor","exports","otherProvided","otherCanMangleProvide","otherTerminalBinding","serialize","write","deserialize","read","ExportsInfo","_exports","Map","_otherExportsInfo","ExportInfo","_sideEffectsOnlyInfo","_exportsAreOrdered","_redirectTo","undefined","ownedExports","values","orderedOwnedExports","_sortExports","map","key","value","set","orderedExports","Array","from","item","name","_sortExportsMap","otherExportsInfo","size","namesInOrder","entry","push","sort","i","length","correctEntry","get","delete","setRedirectNamedTo","exportsInfo","setHasProvideInfo","exportInfo","provided","canMangleProvide","setHasUseInfo","canMangleUse","getOwnExportInfo","info","newInfo","getExportInfo","getReadOnlyExportInfo","getReadOnlyExportInfoRecursive","slice","getNestedExportsInfo","isArray","setUnknownExportsProvided","canMangle","excludeExports","targetKey","targetModule","priority","changed","has","setTarget","setUsedInUnknownWay","runtime","setUsedConditionally","used","setUsedWithoutInfo","setUsed","setAllKnownExportsUsed","setUsedForSideEffectsOnly","isUsed","getUsed","isModuleUsed","getUsedExports","array","inner","getProvidedExports","includes","getRelevantExports","list","isExportProvided","getUsageKey","join","isEquallyUsed","runtimeA","runtimeB","getUsedName","x","arr","nested","concat","usedName","updateHash","hash","_updateHash","Set","alreadyVisitedExportsInfo","add","hasInfo","getRestoreProvidedData","terminalBinding","exportsInfoOwned","restoreProvided","wasEmpty","exp","createNestedExportsInfo","initFrom","_usedName","_globalUsed","_usedInRuntime","_hasUseInRuntimeInfo","_target","connection","export","_maxTarget","Error","v","condition","newValue","oldValue","unsetTarget","exportName","oldTarget","max","fallbackName","every","hasUsedName","setUsedName","getTerminalBinding","moduleGraph","resolveTargetFilter","target","getTarget","getExportsInfo","module","isReexport","_getMaxTarget","maxPriority","Infinity","minPriority","findTarget","validTargetModuleFilter","_findTarget","alreadyVisited","rawTarget","next","newTarget","result","_getTarget","resolveTarget","inputTarget","alreadyVisitedOwned","newAlreadyVisited","done","t","moveTarget","updateOriginalConnection","originalTarget","clear","oldExportsInfo","baseInfo","update","getUsedInfo","specificInfo","runtimes","getProvidedInfo","getRenameInfo","JSON","stringify"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { equals } = require(\"./util/ArrayHelpers\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst makeSerializable = require(\"./util/makeSerializable\");\nconst { forEachRuntime } = require(\"./util/runtime\");\n\n/** @typedef {import(\"./Dependency\").RuntimeSpec} RuntimeSpec */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./ModuleGraphConnection\")} ModuleGraphConnection */\n/** @typedef {import(\"./util/Hash\")} Hash */\n\n/** @typedef {typeof UsageState.OnlyPropertiesUsed | typeof UsageState.NoInfo | typeof UsageState.Unknown | typeof UsageState.Used} RuntimeUsageStateType */\n/** @typedef {typeof UsageState.Unused | RuntimeUsageStateType} UsageStateType */\n\nconst UsageState = Object.freeze({\n\tUnused: /** @type {0} */ (0),\n\tOnlyPropertiesUsed: /** @type {1} */ (1),\n\tNoInfo: /** @type {2} */ (2),\n\tUnknown: /** @type {3} */ (3),\n\tUsed: /** @type {4} */ (4)\n});\n\nconst RETURNS_TRUE = () => true;\n\nconst CIRCULAR = Symbol(\"circular target\");\n\nclass RestoreProvidedData {\n\tconstructor(\n\t\texports,\n\t\totherProvided,\n\t\totherCanMangleProvide,\n\t\totherTerminalBinding\n\t) {\n\t\tthis.exports = exports;\n\t\tthis.otherProvided = otherProvided;\n\t\tthis.otherCanMangleProvide = otherCanMangleProvide;\n\t\tthis.otherTerminalBinding = otherTerminalBinding;\n\t}\n\n\tserialize({ write }) {\n\t\twrite(this.exports);\n\t\twrite(this.otherProvided);\n\t\twrite(this.otherCanMangleProvide);\n\t\twrite(this.otherTerminalBinding);\n\t}\n\n\tstatic deserialize({ read }) {\n\t\treturn new RestoreProvidedData(read(), read(), read(), read());\n\t}\n}\n\nmakeSerializable(\n\tRestoreProvidedData,\n\t\"webpack/lib/ModuleGraph\",\n\t\"RestoreProvidedData\"\n);\n\nclass ExportsInfo {\n\tconstructor() {\n\t\t/** @type {Map<string, ExportInfo>} */\n\t\tthis._exports = new Map();\n\t\tthis._otherExportsInfo = new ExportInfo(null);\n\t\tthis._sideEffectsOnlyInfo = new ExportInfo(\"*side effects only*\");\n\t\tthis._exportsAreOrdered = false;\n\t\t/** @type {ExportsInfo=} */\n\t\tthis._redirectTo = undefined;\n\t}\n\n\t/**\n\t * @returns {Iterable<ExportInfo>} all owned exports in any order\n\t */\n\tget ownedExports() {\n\t\treturn this._exports.values();\n\t}\n\n\t/**\n\t * @returns {Iterable<ExportInfo>} all owned exports in order\n\t */\n\tget orderedOwnedExports() {\n\t\tif (!this._exportsAreOrdered) {\n\t\t\tthis._sortExports();\n\t\t}\n\t\treturn this._exports.values();\n\t}\n\n\t/**\n\t * @returns {Iterable<ExportInfo>} all exports in any order\n\t */\n\tget exports() {\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tconst map = new Map(this._redirectTo._exports);\n\t\t\tfor (const [key, value] of this._exports) {\n\t\t\t\tmap.set(key, value);\n\t\t\t}\n\t\t\treturn map.values();\n\t\t}\n\t\treturn this._exports.values();\n\t}\n\n\t/**\n\t * @returns {Iterable<ExportInfo>} all exports in order\n\t */\n\tget orderedExports() {\n\t\tif (!this._exportsAreOrdered) {\n\t\t\tthis._sortExports();\n\t\t}\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tconst map = new Map(\n\t\t\t\tArray.from(this._redirectTo.orderedExports, item => [item.name, item])\n\t\t\t);\n\t\t\tfor (const [key, value] of this._exports) {\n\t\t\t\tmap.set(key, value);\n\t\t\t}\n\t\t\t// sorting should be pretty fast as map contains\n\t\t\t// a lot of presorted items\n\t\t\tthis._sortExportsMap(map);\n\t\t\treturn map.values();\n\t\t}\n\t\treturn this._exports.values();\n\t}\n\n\t/**\n\t * @returns {ExportInfo} the export info of unlisted exports\n\t */\n\tget otherExportsInfo() {\n\t\tif (this._redirectTo !== undefined)\n\t\t\treturn this._redirectTo.otherExportsInfo;\n\t\treturn this._otherExportsInfo;\n\t}\n\n\t_sortExportsMap(exports) {\n\t\tif (exports.size > 1) {\n\t\t\tconst namesInOrder = [];\n\t\t\tfor (const entry of exports.values()) {\n\t\t\t\tnamesInOrder.push(entry.name);\n\t\t\t}\n\t\t\tnamesInOrder.sort();\n\t\t\tlet i = 0;\n\t\t\tfor (const entry of exports.values()) {\n\t\t\t\tconst name = namesInOrder[i];\n\t\t\t\tif (entry.name !== name) break;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tfor (; i < namesInOrder.length; i++) {\n\t\t\t\tconst name = namesInOrder[i];\n\t\t\t\tconst correctEntry = exports.get(name);\n\t\t\t\texports.delete(name);\n\t\t\t\texports.set(name, correctEntry);\n\t\t\t}\n\t\t}\n\t}\n\n\t_sortExports() {\n\t\tthis._sortExportsMap(this._exports);\n\t\tthis._exportsAreOrdered = true;\n\t}\n\n\tsetRedirectNamedTo(exportsInfo) {\n\t\tif (this._redirectTo === exportsInfo) return false;\n\t\tthis._redirectTo = exportsInfo;\n\t\treturn true;\n\t}\n\n\tsetHasProvideInfo() {\n\t\tfor (const exportInfo of this._exports.values()) {\n\t\t\tif (exportInfo.provided === undefined) {\n\t\t\t\texportInfo.provided = false;\n\t\t\t}\n\t\t\tif (exportInfo.canMangleProvide === undefined) {\n\t\t\t\texportInfo.canMangleProvide = true;\n\t\t\t}\n\t\t}\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tthis._redirectTo.setHasProvideInfo();\n\t\t} else {\n\t\t\tif (this._otherExportsInfo.provided === undefined) {\n\t\t\t\tthis._otherExportsInfo.provided = false;\n\t\t\t}\n\t\t\tif (this._otherExportsInfo.canMangleProvide === undefined) {\n\t\t\t\tthis._otherExportsInfo.canMangleProvide = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tsetHasUseInfo() {\n\t\tfor (const exportInfo of this._exports.values()) {\n\t\t\texportInfo.setHasUseInfo();\n\t\t}\n\t\tthis._sideEffectsOnlyInfo.setHasUseInfo();\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tthis._redirectTo.setHasUseInfo();\n\t\t} else {\n\t\t\tthis._otherExportsInfo.setHasUseInfo();\n\t\t\tif (this._otherExportsInfo.canMangleUse === undefined) {\n\t\t\t\tthis._otherExportsInfo.canMangleUse = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} name export name\n\t * @returns {ExportInfo} export info for this name\n\t */\n\tgetOwnExportInfo(name) {\n\t\tconst info = this._exports.get(name);\n\t\tif (info !== undefined) return info;\n\t\tconst newInfo = new ExportInfo(name, this._otherExportsInfo);\n\t\tthis._exports.set(name, newInfo);\n\t\tthis._exportsAreOrdered = false;\n\t\treturn newInfo;\n\t}\n\n\t/**\n\t * @param {string} name export name\n\t * @returns {ExportInfo} export info for this name\n\t */\n\tgetExportInfo(name) {\n\t\tconst info = this._exports.get(name);\n\t\tif (info !== undefined) return info;\n\t\tif (this._redirectTo !== undefined)\n\t\t\treturn this._redirectTo.getExportInfo(name);\n\t\tconst newInfo = new ExportInfo(name, this._otherExportsInfo);\n\t\tthis._exports.set(name, newInfo);\n\t\tthis._exportsAreOrdered = false;\n\t\treturn newInfo;\n\t}\n\n\t/**\n\t * @param {string} name export name\n\t * @returns {ExportInfo} export info for this name\n\t */\n\tgetReadOnlyExportInfo(name) {\n\t\tconst info = this._exports.get(name);\n\t\tif (info !== undefined) return info;\n\t\tif (this._redirectTo !== undefined)\n\t\t\treturn this._redirectTo.getReadOnlyExportInfo(name);\n\t\treturn this._otherExportsInfo;\n\t}\n\n\t/**\n\t * @param {string[]} name export name\n\t * @returns {ExportInfo | undefined} export info for this name\n\t */\n\tgetReadOnlyExportInfoRecursive(name) {\n\t\tconst exportInfo = this.getReadOnlyExportInfo(name[0]);\n\t\tif (name.length === 1) return exportInfo;\n\t\tif (!exportInfo.exportsInfo) return undefined;\n\t\treturn exportInfo.exportsInfo.getReadOnlyExportInfoRecursive(name.slice(1));\n\t}\n\n\t/**\n\t * @param {string[]=} name the export name\n\t * @returns {ExportsInfo | undefined} the nested exports info\n\t */\n\tgetNestedExportsInfo(name) {\n\t\tif (Array.isArray(name) && name.length > 0) {\n\t\t\tconst info = this.getReadOnlyExportInfo(name[0]);\n\t\t\tif (!info.exportsInfo) return undefined;\n\t\t\treturn info.exportsInfo.getNestedExportsInfo(name.slice(1));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {boolean=} canMangle true, if exports can still be mangled (defaults to false)\n\t * @param {Set<string>=} excludeExports list of unaffected exports\n\t * @param {any=} targetKey use this as key for the target\n\t * @param {ModuleGraphConnection=} targetModule set this module as target\n\t * @param {number=} priority priority\n\t * @returns {boolean} true, if this call changed something\n\t */\n\tsetUnknownExportsProvided(\n\t\tcanMangle,\n\t\texcludeExports,\n\t\ttargetKey,\n\t\ttargetModule,\n\t\tpriority\n\t) {\n\t\tlet changed = false;\n\t\tif (excludeExports) {\n\t\t\tfor (const name of excludeExports) {\n\t\t\t\t// Make sure these entries exist, so they can get different info\n\t\t\t\tthis.getExportInfo(name);\n\t\t\t}\n\t\t}\n\t\tfor (const exportInfo of this._exports.values()) {\n\t\t\tif (!canMangle && exportInfo.canMangleProvide !== false) {\n\t\t\t\texportInfo.canMangleProvide = false;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (excludeExports && excludeExports.has(exportInfo.name)) continue;\n\t\t\tif (exportInfo.provided !== true && exportInfo.provided !== null) {\n\t\t\t\texportInfo.provided = null;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (targetKey) {\n\t\t\t\texportInfo.setTarget(targetKey, targetModule, [exportInfo.name], -1);\n\t\t\t}\n\t\t}\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tif (\n\t\t\t\tthis._redirectTo.setUnknownExportsProvided(\n\t\t\t\t\tcanMangle,\n\t\t\t\t\texcludeExports,\n\t\t\t\t\ttargetKey,\n\t\t\t\t\ttargetModule,\n\t\t\t\t\tpriority\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (\n\t\t\t\tthis._otherExportsInfo.provided !== true &&\n\t\t\t\tthis._otherExportsInfo.provided !== null\n\t\t\t) {\n\t\t\t\tthis._otherExportsInfo.provided = null;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (!canMangle && this._otherExportsInfo.canMangleProvide !== false) {\n\t\t\t\tthis._otherExportsInfo.canMangleProvide = false;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (targetKey) {\n\t\t\t\tthis._otherExportsInfo.setTarget(\n\t\t\t\t\ttargetKey,\n\t\t\t\t\ttargetModule,\n\t\t\t\t\tundefined,\n\t\t\t\t\tpriority\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn changed;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {boolean} true, when something changed\n\t */\n\tsetUsedInUnknownWay(runtime) {\n\t\tlet changed = false;\n\t\tfor (const exportInfo of this._exports.values()) {\n\t\t\tif (exportInfo.setUsedInUnknownWay(runtime)) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tif (this._redirectTo.setUsedInUnknownWay(runtime)) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (\n\t\t\t\tthis._otherExportsInfo.setUsedConditionally(\n\t\t\t\t\tused => used < UsageState.Unknown,\n\t\t\t\t\tUsageState.Unknown,\n\t\t\t\t\truntime\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (this._otherExportsInfo.canMangleUse !== false) {\n\t\t\t\tthis._otherExportsInfo.canMangleUse = false;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\t\treturn changed;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {boolean} true, when something changed\n\t */\n\tsetUsedWithoutInfo(runtime) {\n\t\tlet changed = false;\n\t\tfor (const exportInfo of this._exports.values()) {\n\t\t\tif (exportInfo.setUsedWithoutInfo(runtime)) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tif (this._redirectTo.setUsedWithoutInfo(runtime)) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (this._otherExportsInfo.setUsed(UsageState.NoInfo, runtime)) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (this._otherExportsInfo.canMangleUse !== false) {\n\t\t\t\tthis._otherExportsInfo.canMangleUse = false;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\t\treturn changed;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {boolean} true, when something changed\n\t */\n\tsetAllKnownExportsUsed(runtime) {\n\t\tlet changed = false;\n\t\tfor (const exportInfo of this._exports.values()) {\n\t\t\tif (!exportInfo.provided) continue;\n\t\t\tif (exportInfo.setUsed(UsageState.Used, runtime)) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\t\treturn changed;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {boolean} true, when something changed\n\t */\n\tsetUsedForSideEffectsOnly(runtime) {\n\t\treturn this._sideEffectsOnlyInfo.setUsedConditionally(\n\t\t\tused => used === UsageState.Unused,\n\t\t\tUsageState.Used,\n\t\t\truntime\n\t\t);\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {boolean} true, when the module exports are used in any way\n\t */\n\tisUsed(runtime) {\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tif (this._redirectTo.isUsed(runtime)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (this._otherExportsInfo.getUsed(runtime) !== UsageState.Unused) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tfor (const exportInfo of this._exports.values()) {\n\t\t\tif (exportInfo.getUsed(runtime) !== UsageState.Unused) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {boolean} true, when the module is used in any way\n\t */\n\tisModuleUsed(runtime) {\n\t\tif (this.isUsed(runtime)) return true;\n\t\tif (this._sideEffectsOnlyInfo.getUsed(runtime) !== UsageState.Unused)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {SortableSet<string> | boolean | null} set of used exports, or true (when namespace object is used), or false (when unused), or null (when unknown)\n\t */\n\tgetUsedExports(runtime) {\n\t\tif (!this._redirectTo !== undefined) {\n\t\t\tswitch (this._otherExportsInfo.getUsed(runtime)) {\n\t\t\t\tcase UsageState.NoInfo:\n\t\t\t\t\treturn null;\n\t\t\t\tcase UsageState.Unknown:\n\t\t\t\tcase UsageState.OnlyPropertiesUsed:\n\t\t\t\tcase UsageState.Used:\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tconst array = [];\n\t\tif (!this._exportsAreOrdered) this._sortExports();\n\t\tfor (const exportInfo of this._exports.values()) {\n\t\t\tswitch (exportInfo.getUsed(runtime)) {\n\t\t\t\tcase UsageState.NoInfo:\n\t\t\t\t\treturn null;\n\t\t\t\tcase UsageState.Unknown:\n\t\t\t\t\treturn true;\n\t\t\t\tcase UsageState.OnlyPropertiesUsed:\n\t\t\t\tcase UsageState.Used:\n\t\t\t\t\tarray.push(exportInfo.name);\n\t\t\t}\n\t\t}\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tconst inner = this._redirectTo.getUsedExports(runtime);\n\t\t\tif (inner === null) return null;\n\t\t\tif (inner === true) return true;\n\t\t\tif (inner !== false) {\n\t\t\t\tfor (const item of inner) {\n\t\t\t\t\tarray.push(item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (array.length === 0) {\n\t\t\tswitch (this._sideEffectsOnlyInfo.getUsed(runtime)) {\n\t\t\t\tcase UsageState.NoInfo:\n\t\t\t\t\treturn null;\n\t\t\t\tcase UsageState.Unused:\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn new SortableSet(array);\n\t}\n\n\t/**\n\t * @returns {null | true | string[]} list of exports when known\n\t */\n\tgetProvidedExports() {\n\t\tif (!this._redirectTo !== undefined) {\n\t\t\tswitch (this._otherExportsInfo.provided) {\n\t\t\t\tcase undefined:\n\t\t\t\t\treturn null;\n\t\t\t\tcase null:\n\t\t\t\t\treturn true;\n\t\t\t\tcase true:\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tconst array = [];\n\t\tif (!this._exportsAreOrdered) this._sortExports();\n\t\tfor (const exportInfo of this._exports.values()) {\n\t\t\tswitch (exportInfo.provided) {\n\t\t\t\tcase undefined:\n\t\t\t\t\treturn null;\n\t\t\t\tcase null:\n\t\t\t\t\treturn true;\n\t\t\t\tcase true:\n\t\t\t\t\tarray.push(exportInfo.name);\n\t\t\t}\n\t\t}\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tconst inner = this._redirectTo.getProvidedExports();\n\t\t\tif (inner === null) return null;\n\t\t\tif (inner === true) return true;\n\t\t\tfor (const item of inner) {\n\t\t\t\tif (!array.includes(item)) {\n\t\t\t\t\tarray.push(item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn array;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {ExportInfo[]} exports that are relevant (not unused and potential provided)\n\t */\n\tgetRelevantExports(runtime) {\n\t\tconst list = [];\n\t\tfor (const exportInfo of this._exports.values()) {\n\t\t\tconst used = exportInfo.getUsed(runtime);\n\t\t\tif (used === UsageState.Unused) continue;\n\t\t\tif (exportInfo.provided === false) continue;\n\t\t\tlist.push(exportInfo);\n\t\t}\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tfor (const exportInfo of this._redirectTo.getRelevantExports(runtime)) {\n\t\t\t\tif (!this._exports.has(exportInfo.name)) list.push(exportInfo);\n\t\t\t}\n\t\t}\n\t\tif (\n\t\t\tthis._otherExportsInfo.provided !== false &&\n\t\t\tthis._otherExportsInfo.getUsed(runtime) !== UsageState.Unused\n\t\t) {\n\t\t\tlist.push(this._otherExportsInfo);\n\t\t}\n\t\treturn list;\n\t}\n\n\t/**\n\t * @param {string | string[]} name the name of the export\n\t * @returns {boolean | undefined | null} if the export is provided\n\t */\n\tisExportProvided(name) {\n\t\tif (Array.isArray(name)) {\n\t\t\tconst info = this.getReadOnlyExportInfo(name[0]);\n\t\t\tif (info.exportsInfo && name.length > 1) {\n\t\t\t\treturn info.exportsInfo.isExportProvided(name.slice(1));\n\t\t\t}\n\t\t\treturn info.provided;\n\t\t}\n\t\tconst info = this.getReadOnlyExportInfo(name);\n\t\treturn info.provided;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime runtime\n\t * @returns {string} key representing the usage\n\t */\n\tgetUsageKey(runtime) {\n\t\tconst key = [];\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tkey.push(this._redirectTo.getUsageKey(runtime));\n\t\t} else {\n\t\t\tkey.push(this._otherExportsInfo.getUsed(runtime));\n\t\t}\n\t\tkey.push(this._sideEffectsOnlyInfo.getUsed(runtime));\n\t\tfor (const exportInfo of this.orderedOwnedExports) {\n\t\t\tkey.push(exportInfo.getUsed(runtime));\n\t\t}\n\t\treturn key.join(\"|\");\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtimeA first runtime\n\t * @param {RuntimeSpec} runtimeB second runtime\n\t * @returns {boolean} true, when equally used\n\t */\n\tisEquallyUsed(runtimeA, runtimeB) {\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tif (!this._redirectTo.isEquallyUsed(runtimeA, runtimeB)) return false;\n\t\t} else {\n\t\t\tif (\n\t\t\t\tthis._otherExportsInfo.getUsed(runtimeA) !==\n\t\t\t\tthis._otherExportsInfo.getUsed(runtimeB)\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (\n\t\t\tthis._sideEffectsOnlyInfo.getUsed(runtimeA) !==\n\t\t\tthis._sideEffectsOnlyInfo.getUsed(runtimeB)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (const exportInfo of this.ownedExports) {\n\t\t\tif (exportInfo.getUsed(runtimeA) !== exportInfo.getUsed(runtimeB))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {string | string[]} name export name\n\t * @param {RuntimeSpec} runtime check usage for this runtime only\n\t * @returns {UsageStateType} usage status\n\t */\n\tgetUsed(name, runtime) {\n\t\tif (Array.isArray(name)) {\n\t\t\tif (name.length === 0) return this.otherExportsInfo.getUsed(runtime);\n\t\t\tlet info = this.getReadOnlyExportInfo(name[0]);\n\t\t\tif (info.exportsInfo && name.length > 1) {\n\t\t\t\treturn info.exportsInfo.getUsed(name.slice(1), runtime);\n\t\t\t}\n\t\t\treturn info.getUsed(runtime);\n\t\t}\n\t\tlet info = this.getReadOnlyExportInfo(name);\n\t\treturn info.getUsed(runtime);\n\t}\n\n\t/**\n\t * @param {string | string[]} name the export name\n\t * @param {RuntimeSpec} runtime check usage for this runtime only\n\t * @returns {string | string[] | false} the used name\n\t */\n\tgetUsedName(name, runtime) {\n\t\tif (Array.isArray(name)) {\n\t\t\t// TODO improve this\n\t\t\tif (name.length === 0) {\n\t\t\t\tif (!this.isUsed(runtime)) return false;\n\t\t\t\treturn name;\n\t\t\t}\n\t\t\tlet info = this.getReadOnlyExportInfo(name[0]);\n\t\t\tconst x = info.getUsedName(name[0], runtime);\n\t\t\tif (x === false) return false;\n\t\t\tconst arr = x === name[0] && name.length === 1 ? name : [x];\n\t\t\tif (name.length === 1) {\n\t\t\t\treturn arr;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tinfo.exportsInfo &&\n\t\t\t\tinfo.getUsed(runtime) === UsageState.OnlyPropertiesUsed\n\t\t\t) {\n\t\t\t\tconst nested = info.exportsInfo.getUsedName(name.slice(1), runtime);\n\t\t\t\tif (!nested) return false;\n\t\t\t\treturn arr.concat(nested);\n\t\t\t} else {\n\t\t\t\treturn arr.concat(name.slice(1));\n\t\t\t}\n\t\t} else {\n\t\t\tlet info = this.getReadOnlyExportInfo(name);\n\t\t\tconst usedName = info.getUsedName(name, runtime);\n\t\t\treturn usedName;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Hash} hash the hash\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {void}\n\t */\n\tupdateHash(hash, runtime) {\n\t\tthis._updateHash(hash, runtime, new Set());\n\t}\n\n\t/**\n\t * @param {Hash} hash the hash\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {Set<ExportsInfo>} alreadyVisitedExportsInfo for circular references\n\t * @returns {void}\n\t */\n\t_updateHash(hash, runtime, alreadyVisitedExportsInfo) {\n\t\tconst set = new Set(alreadyVisitedExportsInfo);\n\t\tset.add(this);\n\t\tfor (const exportInfo of this.orderedExports) {\n\t\t\tif (exportInfo.hasInfo(this._otherExportsInfo, runtime)) {\n\t\t\t\texportInfo._updateHash(hash, runtime, set);\n\t\t\t}\n\t\t}\n\t\tthis._sideEffectsOnlyInfo._updateHash(hash, runtime, set);\n\t\tthis._otherExportsInfo._updateHash(hash, runtime, set);\n\t\tif (this._redirectTo !== undefined) {\n\t\t\tthis._redirectTo._updateHash(hash, runtime, set);\n\t\t}\n\t}\n\n\tgetRestoreProvidedData() {\n\t\tconst otherProvided = this._otherExportsInfo.provided;\n\t\tconst otherCanMangleProvide = this._otherExportsInfo.canMangleProvide;\n\t\tconst otherTerminalBinding = this._otherExportsInfo.terminalBinding;\n\t\tconst exports = [];\n\t\tfor (const exportInfo of this.orderedExports) {\n\t\t\tif (\n\t\t\t\texportInfo.provided !== otherProvided ||\n\t\t\t\texportInfo.canMangleProvide !== otherCanMangleProvide ||\n\t\t\t\texportInfo.terminalBinding !== otherTerminalBinding ||\n\t\t\t\texportInfo.exportsInfoOwned\n\t\t\t) {\n\t\t\t\texports.push({\n\t\t\t\t\tname: exportInfo.name,\n\t\t\t\t\tprovided: exportInfo.provided,\n\t\t\t\t\tcanMangleProvide: exportInfo.canMangleProvide,\n\t\t\t\t\tterminalBinding: exportInfo.terminalBinding,\n\t\t\t\t\texportsInfo: exportInfo.exportsInfoOwned\n\t\t\t\t\t\t? exportInfo.exportsInfo.getRestoreProvidedData()\n\t\t\t\t\t\t: undefined\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn new RestoreProvidedData(\n\t\t\texports,\n\t\t\totherProvided,\n\t\t\totherCanMangleProvide,\n\t\t\totherTerminalBinding\n\t\t);\n\t}\n\n\trestoreProvided({\n\t\totherProvided,\n\t\totherCanMangleProvide,\n\t\totherTerminalBinding,\n\t\texports\n\t}) {\n\t\tlet wasEmpty = true;\n\t\tfor (const exportInfo of this._exports.values()) {\n\t\t\twasEmpty = false;\n\t\t\texportInfo.provided = otherProvided;\n\t\t\texportInfo.canMangleProvide = otherCanMangleProvide;\n\t\t\texportInfo.terminalBinding = otherTerminalBinding;\n\t\t}\n\t\tthis._otherExportsInfo.provided = otherProvided;\n\t\tthis._otherExportsInfo.canMangleProvide = otherCanMangleProvide;\n\t\tthis._otherExportsInfo.terminalBinding = otherTerminalBinding;\n\t\tfor (const exp of exports) {\n\t\t\tconst exportInfo = this.getExportInfo(exp.name);\n\t\t\texportInfo.provided = exp.provided;\n\t\t\texportInfo.canMangleProvide = exp.canMangleProvide;\n\t\t\texportInfo.terminalBinding = exp.terminalBinding;\n\t\t\tif (exp.exportsInfo) {\n\t\t\t\tconst exportsInfo = exportInfo.createNestedExportsInfo();\n\t\t\t\texportsInfo.restoreProvided(exp.exportsInfo);\n\t\t\t}\n\t\t}\n\t\tif (wasEmpty) this._exportsAreOrdered = true;\n\t}\n}\n\nclass ExportInfo {\n\t/**\n\t * @param {string} name the original name of the export\n\t * @param {ExportInfo=} initFrom init values from this ExportInfo\n\t */\n\tconstructor(name, initFrom) {\n\t\t/** @type {string} */\n\t\tthis.name = name;\n\t\t/** @private @type {string | null} */\n\t\tthis._usedName = initFrom ? initFrom._usedName : null;\n\t\t/** @private @type {UsageStateType} */\n\t\tthis._globalUsed = initFrom ? initFrom._globalUsed : undefined;\n\t\t/** @private @type {Map<string, RuntimeUsageStateType>} */\n\t\tthis._usedInRuntime =\n\t\t\tinitFrom && initFrom._usedInRuntime\n\t\t\t\t? new Map(initFrom._usedInRuntime)\n\t\t\t\t: undefined;\n\t\t/** @private @type {boolean} */\n\t\tthis._hasUseInRuntimeInfo = initFrom\n\t\t\t? initFrom._hasUseInRuntimeInfo\n\t\t\t: false;\n\t\t/**\n\t\t * true: it is provided\n\t\t * false: it is not provided\n\t\t * null: only the runtime knows if it is provided\n\t\t * undefined: it was not determined if it is provided\n\t\t * @type {boolean | null | undefined}\n\t\t */\n\t\tthis.provided = initFrom ? initFrom.provided : undefined;\n\t\t/**\n\t\t * is the export a terminal binding that should be checked for export star conflicts\n\t\t * @type {boolean}\n\t\t */\n\t\tthis.terminalBinding = initFrom ? initFrom.terminalBinding : false;\n\t\t/**\n\t\t * true: it can be mangled\n\t\t * false: is can not be mangled\n\t\t * undefined: it was not determined if it can be mangled\n\t\t * @type {boolean | undefined}\n\t\t */\n\t\tthis.canMangleProvide = initFrom ? initFrom.canMangleProvide : undefined;\n\t\t/**\n\t\t * true: it can be mangled\n\t\t * false: is can not be mangled\n\t\t * undefined: it was not determined if it can be mangled\n\t\t * @type {boolean | undefined}\n\t\t */\n\t\tthis.canMangleUse = initFrom ? initFrom.canMangleUse : undefined;\n\t\t/** @type {boolean} */\n\t\tthis.exportsInfoOwned = false;\n\t\t/** @type {ExportsInfo=} */\n\t\tthis.exportsInfo = undefined;\n\t\t/** @type {Map<any, { connection: ModuleGraphConnection | null, export: string[], priority: number }>=} */\n\t\tthis._target = undefined;\n\t\tif (initFrom && initFrom._target) {\n\t\t\tthis._target = new Map();\n\t\t\tfor (const [key, value] of initFrom._target) {\n\t\t\t\tthis._target.set(key, {\n\t\t\t\t\tconnection: value.connection,\n\t\t\t\t\texport: value.export || [name],\n\t\t\t\t\tpriority: value.priority\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t/** @type {Map<any, { connection: ModuleGraphConnection | null, export: string[], priority: number }>=} */\n\t\tthis._maxTarget = undefined;\n\t}\n\n\t// TODO webpack 5 remove\n\t/** @private */\n\tget used() {\n\t\tthrow new Error(\"REMOVED\");\n\t}\n\t/** @private */\n\tget usedName() {\n\t\tthrow new Error(\"REMOVED\");\n\t}\n\t/**\n\t * @private\n\t * @param {*} v v\n\t */\n\tset used(v) {\n\t\tthrow new Error(\"REMOVED\");\n\t}\n\t/**\n\t * @private\n\t * @param {*} v v\n\t */\n\tset usedName(v) {\n\t\tthrow new Error(\"REMOVED\");\n\t}\n\n\tget canMangle() {\n\t\tswitch (this.canMangleProvide) {\n\t\t\tcase undefined:\n\t\t\t\treturn this.canMangleUse === false ? false : undefined;\n\t\t\tcase false:\n\t\t\t\treturn false;\n\t\t\tcase true:\n\t\t\t\tswitch (this.canMangleUse) {\n\t\t\t\t\tcase undefined:\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\tcase false:\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tcase true:\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t}\n\t\tthrow new Error(\n\t\t\t`Unexpected flags for canMangle ${this.canMangleProvide} ${this.canMangleUse}`\n\t\t);\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime only apply to this runtime\n\t * @returns {boolean} true, when something changed\n\t */\n\tsetUsedInUnknownWay(runtime) {\n\t\tlet changed = false;\n\t\tif (\n\t\t\tthis.setUsedConditionally(\n\t\t\t\tused => used < UsageState.Unknown,\n\t\t\t\tUsageState.Unknown,\n\t\t\t\truntime\n\t\t\t)\n\t\t) {\n\t\t\tchanged = true;\n\t\t}\n\t\tif (this.canMangleUse !== false) {\n\t\t\tthis.canMangleUse = false;\n\t\t\tchanged = true;\n\t\t}\n\t\treturn changed;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime only apply to this runtime\n\t * @returns {boolean} true, when something changed\n\t */\n\tsetUsedWithoutInfo(runtime) {\n\t\tlet changed = false;\n\t\tif (this.setUsed(UsageState.NoInfo, runtime)) {\n\t\t\tchanged = true;\n\t\t}\n\t\tif (this.canMangleUse !== false) {\n\t\t\tthis.canMangleUse = false;\n\t\t\tchanged = true;\n\t\t}\n\t\treturn changed;\n\t}\n\n\tsetHasUseInfo() {\n\t\tif (!this._hasUseInRuntimeInfo) {\n\t\t\tthis._hasUseInRuntimeInfo = true;\n\t\t}\n\t\tif (this.canMangleUse === undefined) {\n\t\t\tthis.canMangleUse = true;\n\t\t}\n\t\tif (this.exportsInfoOwned) {\n\t\t\tthis.exportsInfo.setHasUseInfo();\n\t\t}\n\t}\n\n\t/**\n\t * @param {function(UsageStateType): boolean} condition compare with old value\n\t * @param {UsageStateType} newValue set when condition is true\n\t * @param {RuntimeSpec} runtime only apply to this runtime\n\t * @returns {boolean} true when something has changed\n\t */\n\tsetUsedConditionally(condition, newValue, runtime) {\n\t\tif (runtime === undefined) {\n\t\t\tif (this._globalUsed === undefined) {\n\t\t\t\tthis._globalUsed = newValue;\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tif (this._globalUsed !== newValue && condition(this._globalUsed)) {\n\t\t\t\t\tthis._globalUsed = newValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this._usedInRuntime === undefined) {\n\t\t\tif (newValue !== UsageState.Unused && condition(UsageState.Unused)) {\n\t\t\t\tthis._usedInRuntime = new Map();\n\t\t\t\tforEachRuntime(runtime, runtime =>\n\t\t\t\t\tthis._usedInRuntime.set(runtime, newValue)\n\t\t\t\t);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tlet changed = false;\n\t\t\tforEachRuntime(runtime, runtime => {\n\t\t\t\t/** @type {UsageStateType} */\n\t\t\t\tlet oldValue = this._usedInRuntime.get(runtime);\n\t\t\t\tif (oldValue === undefined) oldValue = UsageState.Unused;\n\t\t\t\tif (newValue !== oldValue && condition(oldValue)) {\n\t\t\t\t\tif (newValue === UsageState.Unused) {\n\t\t\t\t\t\tthis._usedInRuntime.delete(runtime);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._usedInRuntime.set(runtime, newValue);\n\t\t\t\t\t}\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (changed) {\n\t\t\t\tif (this._usedInRuntime.size === 0) this._usedInRuntime = undefined;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {UsageStateType} newValue new value of the used state\n\t * @param {RuntimeSpec} runtime only apply to this runtime\n\t * @returns {boolean} true when something has changed\n\t */\n\tsetUsed(newValue, runtime) {\n\t\tif (runtime === undefined) {\n\t\t\tif (this._globalUsed !== newValue) {\n\t\t\t\tthis._globalUsed = newValue;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (this._usedInRuntime === undefined) {\n\t\t\tif (newValue !== UsageState.Unused) {\n\t\t\t\tthis._usedInRuntime = new Map();\n\t\t\t\tforEachRuntime(runtime, runtime =>\n\t\t\t\t\tthis._usedInRuntime.set(runtime, newValue)\n\t\t\t\t);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tlet changed = false;\n\t\t\tforEachRuntime(runtime, runtime => {\n\t\t\t\t/** @type {UsageStateType} */\n\t\t\t\tlet oldValue = this._usedInRuntime.get(runtime);\n\t\t\t\tif (oldValue === undefined) oldValue = UsageState.Unused;\n\t\t\t\tif (newValue !== oldValue) {\n\t\t\t\t\tif (newValue === UsageState.Unused) {\n\t\t\t\t\t\tthis._usedInRuntime.delete(runtime);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._usedInRuntime.set(runtime, newValue);\n\t\t\t\t\t}\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (changed) {\n\t\t\t\tif (this._usedInRuntime.size === 0) this._usedInRuntime = undefined;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {any} key the key\n\t * @returns {boolean} true, if something has changed\n\t */\n\tunsetTarget(key) {\n\t\tif (!this._target) return false;\n\t\tif (this._target.delete(key)) {\n\t\t\tthis._maxTarget = undefined;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {any} key the key\n\t * @param {ModuleGraphConnection} connection the target module if a single one\n\t * @param {string[]=} exportName the exported name\n\t * @param {number=} priority priority\n\t * @returns {boolean} true, if something has changed\n\t */\n\tsetTarget(key, connection, exportName, priority = 0) {\n\t\tif (exportName) exportName = [...exportName];\n\t\tif (!this._target) {\n\t\t\tthis._target = new Map();\n\t\t\tthis._target.set(key, { connection, export: exportName, priority });\n\t\t\treturn true;\n\t\t}\n\t\tconst oldTarget = this._target.get(key);\n\t\tif (!oldTarget) {\n\t\t\tif (oldTarget === null && !connection) return false;\n\t\t\tthis._target.set(key, { connection, export: exportName, priority });\n\t\t\tthis._maxTarget = undefined;\n\t\t\treturn true;\n\t\t}\n\t\tif (\n\t\t\toldTarget.connection !== connection ||\n\t\t\toldTarget.priority !== priority ||\n\t\t\t(exportName\n\t\t\t\t? !oldTarget.export || !equals(oldTarget.export, exportName)\n\t\t\t\t: oldTarget.export)\n\t\t) {\n\t\t\toldTarget.connection = connection;\n\t\t\toldTarget.export = exportName;\n\t\t\toldTarget.priority = priority;\n\t\t\tthis._maxTarget = undefined;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime for this runtime\n\t * @returns {UsageStateType} usage state\n\t */\n\tgetUsed(runtime) {\n\t\tif (!this._hasUseInRuntimeInfo) return UsageState.NoInfo;\n\t\tif (this._globalUsed !== undefined) return this._globalUsed;\n\t\tif (this._usedInRuntime === undefined) {\n\t\t\treturn UsageState.Unused;\n\t\t} else if (typeof runtime === \"string\") {\n\t\t\tconst value = this._usedInRuntime.get(runtime);\n\t\t\treturn value === undefined ? UsageState.Unused : value;\n\t\t} else if (runtime === undefined) {\n\t\t\t/** @type {UsageStateType} */\n\t\t\tlet max = UsageState.Unused;\n\t\t\tfor (const value of this._usedInRuntime.values()) {\n\t\t\t\tif (value === UsageState.Used) {\n\t\t\t\t\treturn UsageState.Used;\n\t\t\t\t}\n\t\t\t\tif (max < value) max = value;\n\t\t\t}\n\t\t\treturn max;\n\t\t} else {\n\t\t\t/** @type {UsageStateType} */\n\t\t\tlet max = UsageState.Unused;\n\t\t\tfor (const item of runtime) {\n\t\t\t\tconst value = this._usedInRuntime.get(item);\n\t\t\t\tif (value !== undefined) {\n\t\t\t\t\tif (value === UsageState.Used) {\n\t\t\t\t\t\treturn UsageState.Used;\n\t\t\t\t\t}\n\t\t\t\t\tif (max < value) max = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn max;\n\t\t}\n\t}\n\n\t/**\n\t * get used name\n\t * @param {string | undefined} fallbackName fallback name for used exports with no name\n\t * @param {RuntimeSpec} runtime check usage for this runtime only\n\t * @returns {string | false} used name\n\t */\n\tgetUsedName(fallbackName, runtime) {\n\t\tif (this._hasUseInRuntimeInfo) {\n\t\t\tif (this._globalUsed !== undefined) {\n\t\t\t\tif (this._globalUsed === UsageState.Unused) return false;\n\t\t\t} else {\n\t\t\t\tif (this._usedInRuntime === undefined) return false;\n\t\t\t\tif (typeof runtime === \"string\") {\n\t\t\t\t\tif (!this._usedInRuntime.has(runtime)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} else if (runtime !== undefined) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tArray.from(runtime).every(\n\t\t\t\t\t\t\truntime => !this._usedInRuntime.has(runtime)\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this._usedName !== null) return this._usedName;\n\t\treturn this.name || fallbackName;\n\t}\n\n\t/**\n\t * @returns {boolean} true, when a mangled name of this export is set\n\t */\n\thasUsedName() {\n\t\treturn this._usedName !== null;\n\t}\n\n\t/**\n\t * Sets the mangled name of this export\n\t * @param {string} name the new name\n\t * @returns {void}\n\t */\n\tsetUsedName(name) {\n\t\tthis._usedName = name;\n\t}\n\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {function({ module: Module, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\n\t * @returns {ExportInfo | ExportsInfo | undefined} the terminal binding export(s) info if known\n\t */\n\tgetTerminalBinding(moduleGraph, resolveTargetFilter = RETURNS_TRUE) {\n\t\tif (this.terminalBinding) return this;\n\t\tconst target = this.getTarget(moduleGraph, resolveTargetFilter);\n\t\tif (!target) return undefined;\n\t\tconst exportsInfo = moduleGraph.getExportsInfo(target.module);\n\t\tif (!target.export) return exportsInfo;\n\t\treturn exportsInfo.getReadOnlyExportInfoRecursive(target.export);\n\t}\n\n\tisReexport() {\n\t\treturn !this.terminalBinding && this._target && this._target.size > 0;\n\t}\n\n\t_getMaxTarget() {\n\t\tif (this._maxTarget !== undefined) return this._maxTarget;\n\t\tif (this._target.size <= 1) return (this._maxTarget = this._target);\n\t\tlet maxPriority = -Infinity;\n\t\tlet minPriority = Infinity;\n\t\tfor (const { priority } of this._target.values()) {\n\t\t\tif (maxPriority < priority) maxPriority = priority;\n\t\t\tif (minPriority > priority) minPriority = priority;\n\t\t}\n\t\t// This should be very common\n\t\tif (maxPriority === minPriority) return (this._maxTarget = this._target);\n\n\t\t// This is an edge case\n\t\tconst map = new Map();\n\t\tfor (const [key, value] of this._target) {\n\t\t\tif (maxPriority === value.priority) {\n\t\t\t\tmap.set(key, value);\n\t\t\t}\n\t\t}\n\t\tthis._maxTarget = map;\n\t\treturn map;\n\t}\n\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {function(Module): boolean} validTargetModuleFilter a valid target module\n\t * @returns {{ module: Module, export: string[] | undefined } | undefined | false} the target, undefined when there is no target, false when no target is valid\n\t */\n\tfindTarget(moduleGraph, validTargetModuleFilter) {\n\t\treturn this._findTarget(moduleGraph, validTargetModuleFilter, new Set());\n\t}\n\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {function(Module): boolean} validTargetModuleFilter a valid target module\n\t * @param {Set<ExportInfo> | undefined} alreadyVisited set of already visited export info to avoid circular references\n\t * @returns {{ module: Module, export: string[] | undefined } | undefined | false} the target, undefined when there is no target, false when no target is valid\n\t */\n\t_findTarget(moduleGraph, validTargetModuleFilter, alreadyVisited) {\n\t\tif (!this._target || this._target.size === 0) return undefined;\n\t\tlet rawTarget = this._getMaxTarget().values().next().value;\n\t\tif (!rawTarget) return undefined;\n\t\t/** @type {{ module: Module, export: string[] | undefined }} */\n\t\tlet target = {\n\t\t\tmodule: rawTarget.connection.module,\n\t\t\texport: rawTarget.export\n\t\t};\n\t\tfor (;;) {\n\t\t\tif (validTargetModuleFilter(target.module)) return target;\n\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(target.module);\n\t\t\tconst exportInfo = exportsInfo.getExportInfo(target.export[0]);\n\t\t\tif (alreadyVisited.has(exportInfo)) return null;\n\t\t\tconst newTarget = exportInfo._findTarget(\n\t\t\t\tmoduleGraph,\n\t\t\t\tvalidTargetModuleFilter,\n\t\t\t\talreadyVisited\n\t\t\t);\n\t\t\tif (!newTarget) return false;\n\t\t\tif (target.export.length === 1) {\n\t\t\t\ttarget = newTarget;\n\t\t\t} else {\n\t\t\t\ttarget = {\n\t\t\t\t\tmodule: newTarget.module,\n\t\t\t\t\texport: newTarget.export\n\t\t\t\t\t\t? newTarget.export.concat(target.export.slice(1))\n\t\t\t\t\t\t: target.export.slice(1)\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {function({ module: Module, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\n\t * @returns {{ module: Module, export: string[] | undefined } | undefined} the target\n\t */\n\tgetTarget(moduleGraph, resolveTargetFilter = RETURNS_TRUE) {\n\t\tconst result = this._getTarget(moduleGraph, resolveTargetFilter, undefined);\n\t\tif (result === CIRCULAR) return undefined;\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {function({ module: Module, connection: ModuleGraphConnection, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\n\t * @param {Set<ExportInfo> | undefined} alreadyVisited set of already visited export info to avoid circular references\n\t * @returns {{ module: Module, connection: ModuleGraphConnection, export: string[] | undefined } | CIRCULAR | undefined} the target\n\t */\n\t_getTarget(moduleGraph, resolveTargetFilter, alreadyVisited) {\n\t\t/**\n\t\t * @param {{ connection: ModuleGraphConnection, export: string[] | undefined } | null} inputTarget unresolved target\n\t\t * @param {Set<ExportInfo>} alreadyVisited set of already visited export info to avoid circular references\n\t\t * @returns {{ module: Module, connection: ModuleGraphConnection, export: string[] | undefined } | CIRCULAR | null} resolved target\n\t\t */\n\t\tconst resolveTarget = (inputTarget, alreadyVisited) => {\n\t\t\tif (!inputTarget) return null;\n\t\t\tif (!inputTarget.export) {\n\t\t\t\treturn {\n\t\t\t\t\tmodule: inputTarget.connection.module,\n\t\t\t\t\tconnection: inputTarget.connection,\n\t\t\t\t\texport: undefined\n\t\t\t\t};\n\t\t\t}\n\t\t\t/** @type {{ module: Module, connection: ModuleGraphConnection, export: string[] | undefined }} */\n\t\t\tlet target = {\n\t\t\t\tmodule: inputTarget.connection.module,\n\t\t\t\tconnection: inputTarget.connection,\n\t\t\t\texport: inputTarget.export\n\t\t\t};\n\t\t\tif (!resolveTargetFilter(target)) return target;\n\t\t\tlet alreadyVisitedOwned = false;\n\t\t\tfor (;;) {\n\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(target.module);\n\t\t\t\tconst exportInfo = exportsInfo.getExportInfo(target.export[0]);\n\t\t\t\tif (!exportInfo) return target;\n\t\t\t\tif (alreadyVisited.has(exportInfo)) return CIRCULAR;\n\t\t\t\tconst newTarget = exportInfo._getTarget(\n\t\t\t\t\tmoduleGraph,\n\t\t\t\t\tresolveTargetFilter,\n\t\t\t\t\talreadyVisited\n\t\t\t\t);\n\t\t\t\tif (newTarget === CIRCULAR) return CIRCULAR;\n\t\t\t\tif (!newTarget) return target;\n\t\t\t\tif (target.export.length === 1) {\n\t\t\t\t\ttarget = newTarget;\n\t\t\t\t\tif (!target.export) return target;\n\t\t\t\t} else {\n\t\t\t\t\ttarget = {\n\t\t\t\t\t\tmodule: newTarget.module,\n\t\t\t\t\t\tconnection: newTarget.connection,\n\t\t\t\t\t\texport: newTarget.export\n\t\t\t\t\t\t\t? newTarget.export.concat(target.export.slice(1))\n\t\t\t\t\t\t\t: target.export.slice(1)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (!resolveTargetFilter(target)) return target;\n\t\t\t\tif (!alreadyVisitedOwned) {\n\t\t\t\t\talreadyVisited = new Set(alreadyVisited);\n\t\t\t\t\talreadyVisitedOwned = true;\n\t\t\t\t}\n\t\t\t\talreadyVisited.add(exportInfo);\n\t\t\t}\n\t\t};\n\n\t\tif (!this._target || this._target.size === 0) return undefined;\n\t\tif (alreadyVisited && alreadyVisited.has(this)) return CIRCULAR;\n\t\tconst newAlreadyVisited = new Set(alreadyVisited);\n\t\tnewAlreadyVisited.add(this);\n\t\tconst values = this._getMaxTarget().values();\n\t\tconst target = resolveTarget(values.next().value, newAlreadyVisited);\n\t\tif (target === CIRCULAR) return CIRCULAR;\n\t\tif (target === null) return undefined;\n\t\tlet result = values.next();\n\t\twhile (!result.done) {\n\t\t\tconst t = resolveTarget(result.value, newAlreadyVisited);\n\t\t\tif (t === CIRCULAR) return CIRCULAR;\n\t\t\tif (t === null) return undefined;\n\t\t\tif (t.module !== target.module) return undefined;\n\t\t\tif (!t.export !== !target.export) return undefined;\n\t\t\tif (target.export && !equals(t.export, target.export)) return undefined;\n\t\t\tresult = values.next();\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * Move the target forward as long resolveTargetFilter is fulfilled\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {function({ module: Module, export: string[] | undefined }): boolean} resolveTargetFilter filter function to further resolve target\n\t * @param {function({ module: Module, export: string[] | undefined }): ModuleGraphConnection=} updateOriginalConnection updates the original connection instead of using the target connection\n\t * @returns {{ module: Module, export: string[] | undefined } | undefined} the resolved target when moved\n\t */\n\tmoveTarget(moduleGraph, resolveTargetFilter, updateOriginalConnection) {\n\t\tconst target = this._getTarget(moduleGraph, resolveTargetFilter, undefined);\n\t\tif (target === CIRCULAR) return undefined;\n\t\tif (!target) return undefined;\n\t\tconst originalTarget = this._getMaxTarget().values().next().value;\n\t\tif (\n\t\t\toriginalTarget.connection === target.connection &&\n\t\t\toriginalTarget.export === target.export\n\t\t) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis._target.clear();\n\t\tthis._target.set(undefined, {\n\t\t\tconnection: updateOriginalConnection\n\t\t\t\t? updateOriginalConnection(target)\n\t\t\t\t: target.connection,\n\t\t\texport: target.export,\n\t\t\tpriority: 0\n\t\t});\n\t\treturn target;\n\t}\n\n\tcreateNestedExportsInfo() {\n\t\tif (this.exportsInfoOwned) return this.exportsInfo;\n\t\tthis.exportsInfoOwned = true;\n\t\tconst oldExportsInfo = this.exportsInfo;\n\t\tthis.exportsInfo = new ExportsInfo();\n\t\tthis.exportsInfo.setHasProvideInfo();\n\t\tif (oldExportsInfo) {\n\t\t\tthis.exportsInfo.setRedirectNamedTo(oldExportsInfo);\n\t\t}\n\t\treturn this.exportsInfo;\n\t}\n\n\tgetNestedExportsInfo() {\n\t\treturn this.exportsInfo;\n\t}\n\n\thasInfo(baseInfo, runtime) {\n\t\treturn (\n\t\t\t(this._usedName && this._usedName !== this.name) ||\n\t\t\tthis.provided ||\n\t\t\tthis.terminalBinding ||\n\t\t\tthis.getUsed(runtime) !== baseInfo.getUsed(runtime)\n\t\t);\n\t}\n\n\tupdateHash(hash, runtime) {\n\t\tthis._updateHash(hash, runtime, new Set());\n\t}\n\n\t_updateHash(hash, runtime, alreadyVisitedExportsInfo) {\n\t\thash.update(\n\t\t\t`${this._usedName || this.name}${this.getUsed(runtime)}${this.provided}${\n\t\t\t\tthis.terminalBinding\n\t\t\t}`\n\t\t);\n\t\tif (this.exportsInfo && !alreadyVisitedExportsInfo.has(this.exportsInfo)) {\n\t\t\tthis.exportsInfo._updateHash(hash, runtime, alreadyVisitedExportsInfo);\n\t\t}\n\t}\n\n\tgetUsedInfo() {\n\t\tif (this._globalUsed !== undefined) {\n\t\t\tswitch (this._globalUsed) {\n\t\t\t\tcase UsageState.Unused:\n\t\t\t\t\treturn \"unused\";\n\t\t\t\tcase UsageState.NoInfo:\n\t\t\t\t\treturn \"no usage info\";\n\t\t\t\tcase UsageState.Unknown:\n\t\t\t\t\treturn \"maybe used (runtime-defined)\";\n\t\t\t\tcase UsageState.Used:\n\t\t\t\t\treturn \"used\";\n\t\t\t\tcase UsageState.OnlyPropertiesUsed:\n\t\t\t\t\treturn \"only properties used\";\n\t\t\t}\n\t\t} else if (this._usedInRuntime !== undefined) {\n\t\t\t/** @type {Map<RuntimeUsageStateType, string[]>} */\n\t\t\tconst map = new Map();\n\t\t\tfor (const [runtime, used] of this._usedInRuntime) {\n\t\t\t\tconst list = map.get(used);\n\t\t\t\tif (list !== undefined) list.push(runtime);\n\t\t\t\telse map.set(used, [runtime]);\n\t\t\t}\n\t\t\tconst specificInfo = Array.from(map, ([used, runtimes]) => {\n\t\t\t\tswitch (used) {\n\t\t\t\t\tcase UsageState.NoInfo:\n\t\t\t\t\t\treturn `no usage info in ${runtimes.join(\", \")}`;\n\t\t\t\t\tcase UsageState.Unknown:\n\t\t\t\t\t\treturn `maybe used in ${runtimes.join(\", \")} (runtime-defined)`;\n\t\t\t\t\tcase UsageState.Used:\n\t\t\t\t\t\treturn `used in ${runtimes.join(\", \")}`;\n\t\t\t\t\tcase UsageState.OnlyPropertiesUsed:\n\t\t\t\t\t\treturn `only properties used in ${runtimes.join(\", \")}`;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (specificInfo.length > 0) {\n\t\t\t\treturn specificInfo.join(\"; \");\n\t\t\t}\n\t\t}\n\t\treturn this._hasUseInRuntimeInfo ? \"unused\" : \"no usage info\";\n\t}\n\n\tgetProvidedInfo() {\n\t\tswitch (this.provided) {\n\t\t\tcase undefined:\n\t\t\t\treturn \"no provided info\";\n\t\t\tcase null:\n\t\t\t\treturn \"maybe provided (runtime-defined)\";\n\t\t\tcase true:\n\t\t\t\treturn \"provided\";\n\t\t\tcase false:\n\t\t\t\treturn \"not provided\";\n\t\t}\n\t}\n\n\tgetRenameInfo() {\n\t\tif (this._usedName !== null && this._usedName !== this.name) {\n\t\t\treturn `renamed to ${JSON.stringify(this._usedName).slice(1, -1)}`;\n\t\t}\n\t\tswitch (this.canMangleProvide) {\n\t\t\tcase undefined:\n\t\t\t\tswitch (this.canMangleUse) {\n\t\t\t\t\tcase undefined:\n\t\t\t\t\t\treturn \"missing provision and use info prevents renaming\";\n\t\t\t\t\tcase false:\n\t\t\t\t\t\treturn \"usage prevents renaming (no provision info)\";\n\t\t\t\t\tcase true:\n\t\t\t\t\t\treturn \"missing provision info prevents renaming\";\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase true:\n\t\t\t\tswitch (this.canMangleUse) {\n\t\t\t\t\tcase undefined:\n\t\t\t\t\t\treturn \"missing usage info prevents renaming\";\n\t\t\t\t\tcase false:\n\t\t\t\t\t\treturn \"usage prevents renaming\";\n\t\t\t\t\tcase true:\n\t\t\t\t\t\treturn \"could be renamed\";\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase false:\n\t\t\t\tswitch (this.canMangleUse) {\n\t\t\t\t\tcase undefined:\n\t\t\t\t\t\treturn \"provision prevents renaming (no use info)\";\n\t\t\t\t\tcase false:\n\t\t\t\t\t\treturn \"usage and provision prevents renaming\";\n\t\t\t\t\tcase true:\n\t\t\t\t\t\treturn \"provision prevents renaming\";\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tthrow new Error(\n\t\t\t`Unexpected flags for getRenameInfo ${this.canMangleProvide} ${this.canMangleUse}`\n\t\t);\n\t}\n}\n\nmodule.exports = ExportsInfo;\nmodule.exports.ExportInfo = ExportInfo;\nmodule.exports.UsageState = UsageState;\n"]},"metadata":{},"sourceType":"script"}