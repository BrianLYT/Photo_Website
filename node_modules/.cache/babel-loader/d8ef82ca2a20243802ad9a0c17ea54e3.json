{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst NO_MARKER = 0;\nconst IN_PROGRESS_MARKER = 1;\nconst DONE_MARKER = 2;\nconst DONE_MAYBE_ROOT_CYCLE_MARKER = 3;\nconst DONE_AND_ROOT_MARKER = 4;\n/**\n * @template T\n */\n\nclass Node {\n  /**\n   * @param {T} item the value of the node\n   */\n  constructor(item) {\n    this.item = item;\n    /** @type {Set<Node<T>>} */\n\n    this.dependencies = new Set();\n    this.marker = NO_MARKER;\n    /** @type {Cycle<T> | undefined} */\n\n    this.cycle = undefined;\n    this.incoming = 0;\n  }\n\n}\n/**\n * @template T\n */\n\n\nclass Cycle {\n  constructor() {\n    /** @type {Set<Node<T>>} */\n    this.nodes = new Set();\n  }\n\n}\n/**\n * @template T\n * @typedef {Object} StackEntry\n * @property {Node<T>} node\n * @property {Node<T>[]} openEdges\n */\n\n/**\n * @template T\n * @param {Iterable<T>} items list of items\n * @param {function(T): Iterable<T>} getDependencies function to get dependencies of an item (items that are not in list are ignored)\n * @returns {Iterable<T>} graph roots of the items\n */\n\n\nmodule.exports = (items, getDependencies) => {\n  /** @type {Map<T, Node<T>>} */\n  const itemToNode = new Map();\n\n  for (const item of items) {\n    const node = new Node(item);\n    itemToNode.set(item, node);\n  } // early exit when there is only a single item\n\n\n  if (itemToNode.size <= 1) return items; // grab all the dependencies\n\n  for (const node of itemToNode.values()) {\n    for (const dep of getDependencies(node.item)) {\n      const depNode = itemToNode.get(dep);\n\n      if (depNode !== undefined) {\n        node.dependencies.add(depNode);\n      }\n    }\n  } // Set of current root modules\n  // items will be removed if a new reference to it has been found\n\n  /** @type {Set<Node<T>>} */\n\n\n  const roots = new Set(); // Set of current cycles without references to it\n  // cycles will be removed if a new reference to it has been found\n  // that is not part of the cycle\n\n  /** @type {Set<Cycle<T>>} */\n\n  const rootCycles = new Set(); // For all non-marked nodes\n\n  for (const selectedNode of itemToNode.values()) {\n    if (selectedNode.marker === NO_MARKER) {\n      // deep-walk all referenced modules\n      // in a non-recursive way\n      // start by entering the selected node\n      selectedNode.marker = IN_PROGRESS_MARKER; // keep a stack to avoid recursive walk\n\n      /** @type {StackEntry<T>[]} */\n\n      const stack = [{\n        node: selectedNode,\n        openEdges: Array.from(selectedNode.dependencies)\n      }]; // process the top item until stack is empty\n\n      while (stack.length > 0) {\n        const topOfStack = stack[stack.length - 1]; // Are there still edges unprocessed in the current node?\n\n        if (topOfStack.openEdges.length > 0) {\n          // Process one dependency\n          const dependency = topOfStack.openEdges.pop();\n\n          switch (dependency.marker) {\n            case NO_MARKER:\n              // dependency has not be visited yet\n              // mark it as in-progress and recurse\n              stack.push({\n                node: dependency,\n                openEdges: Array.from(dependency.dependencies)\n              });\n              dependency.marker = IN_PROGRESS_MARKER;\n              break;\n\n            case IN_PROGRESS_MARKER:\n              {\n                // It's a in-progress cycle\n                let cycle = dependency.cycle;\n\n                if (!cycle) {\n                  cycle = new Cycle();\n                  cycle.nodes.add(dependency);\n                  dependency.cycle = cycle;\n                } // set cycle property for each node in the cycle\n                // if nodes are already part of a cycle\n                // we merge the cycles to a shared cycle\n\n\n                for (let i = stack.length - 1; stack[i].node !== dependency; i--) {\n                  const node = stack[i].node;\n\n                  if (node.cycle) {\n                    if (node.cycle !== cycle) {\n                      // merge cycles\n                      for (const cycleNode of node.cycle.nodes) {\n                        cycleNode.cycle = cycle;\n                        cycle.nodes.add(cycleNode);\n                      }\n                    }\n                  } else {\n                    node.cycle = cycle;\n                    cycle.nodes.add(node);\n                  }\n                } // don't recurse into dependencies\n                // these are already on the stack\n\n\n                break;\n              }\n\n            case DONE_AND_ROOT_MARKER:\n              // This node has be visited yet and is currently a root node\n              // But as this is a new reference to the node\n              // it's not really a root\n              // so we have to convert it to a normal node\n              dependency.marker = DONE_MARKER;\n              roots.delete(dependency);\n              break;\n\n            case DONE_MAYBE_ROOT_CYCLE_MARKER:\n              // This node has be visited yet and\n              // is maybe currently part of a completed root cycle\n              // we found a new reference to the cycle\n              // so it's not really a root cycle\n              // remove the cycle from the root cycles\n              // and convert it to a normal node\n              rootCycles.delete(dependency.cycle);\n              dependency.marker = DONE_MARKER;\n              break;\n            // DONE_MARKER: nothing to do, don't recurse into dependencies\n          }\n        } else {\n          // All dependencies of the current node has been visited\n          // we leave the node\n          stack.pop();\n          topOfStack.node.marker = DONE_MARKER;\n        }\n      }\n\n      const cycle = selectedNode.cycle;\n\n      if (cycle) {\n        for (const node of cycle.nodes) {\n          node.marker = DONE_MAYBE_ROOT_CYCLE_MARKER;\n        }\n\n        rootCycles.add(cycle);\n      } else {\n        selectedNode.marker = DONE_AND_ROOT_MARKER;\n        roots.add(selectedNode);\n      }\n    }\n  } // Extract roots from root cycles\n  // We take the nodes with most incoming edges\n  // inside of the cycle\n\n\n  for (const cycle of rootCycles) {\n    let max = 0;\n    /** @type {Set<Node<T>>} */\n\n    const cycleRoots = new Set();\n    const nodes = cycle.nodes;\n\n    for (const node of nodes) {\n      for (const dep of node.dependencies) {\n        if (nodes.has(dep)) {\n          dep.incoming++;\n          if (dep.incoming < max) continue;\n\n          if (dep.incoming > max) {\n            cycleRoots.clear();\n            max = dep.incoming;\n          }\n\n          cycleRoots.add(dep);\n        }\n      }\n    }\n\n    for (const cycleRoot of cycleRoots) {\n      roots.add(cycleRoot);\n    }\n  } // When roots were found, return them\n\n\n  if (roots.size > 0) {\n    return Array.from(roots, r => r.item);\n  } else {\n    throw new Error(\"Implementation of findGraphRoots is broken\");\n  }\n};","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/util/findGraphRoots.js"],"names":["NO_MARKER","IN_PROGRESS_MARKER","DONE_MARKER","DONE_MAYBE_ROOT_CYCLE_MARKER","DONE_AND_ROOT_MARKER","Node","constructor","item","dependencies","Set","marker","cycle","undefined","incoming","Cycle","nodes","module","exports","items","getDependencies","itemToNode","Map","node","set","size","values","dep","depNode","get","add","roots","rootCycles","selectedNode","stack","openEdges","Array","from","length","topOfStack","dependency","pop","push","i","cycleNode","delete","max","cycleRoots","has","clear","cycleRoot","r","Error"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst NO_MARKER = 0;\nconst IN_PROGRESS_MARKER = 1;\nconst DONE_MARKER = 2;\nconst DONE_MAYBE_ROOT_CYCLE_MARKER = 3;\nconst DONE_AND_ROOT_MARKER = 4;\n\n/**\n * @template T\n */\nclass Node {\n\t/**\n\t * @param {T} item the value of the node\n\t */\n\tconstructor(item) {\n\t\tthis.item = item;\n\t\t/** @type {Set<Node<T>>} */\n\t\tthis.dependencies = new Set();\n\t\tthis.marker = NO_MARKER;\n\t\t/** @type {Cycle<T> | undefined} */\n\t\tthis.cycle = undefined;\n\t\tthis.incoming = 0;\n\t}\n}\n\n/**\n * @template T\n */\nclass Cycle {\n\tconstructor() {\n\t\t/** @type {Set<Node<T>>} */\n\t\tthis.nodes = new Set();\n\t}\n}\n\n/**\n * @template T\n * @typedef {Object} StackEntry\n * @property {Node<T>} node\n * @property {Node<T>[]} openEdges\n */\n\n/**\n * @template T\n * @param {Iterable<T>} items list of items\n * @param {function(T): Iterable<T>} getDependencies function to get dependencies of an item (items that are not in list are ignored)\n * @returns {Iterable<T>} graph roots of the items\n */\nmodule.exports = (items, getDependencies) => {\n\t/** @type {Map<T, Node<T>>} */\n\tconst itemToNode = new Map();\n\tfor (const item of items) {\n\t\tconst node = new Node(item);\n\t\titemToNode.set(item, node);\n\t}\n\n\t// early exit when there is only a single item\n\tif (itemToNode.size <= 1) return items;\n\n\t// grab all the dependencies\n\tfor (const node of itemToNode.values()) {\n\t\tfor (const dep of getDependencies(node.item)) {\n\t\t\tconst depNode = itemToNode.get(dep);\n\t\t\tif (depNode !== undefined) {\n\t\t\t\tnode.dependencies.add(depNode);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set of current root modules\n\t// items will be removed if a new reference to it has been found\n\t/** @type {Set<Node<T>>} */\n\tconst roots = new Set();\n\n\t// Set of current cycles without references to it\n\t// cycles will be removed if a new reference to it has been found\n\t// that is not part of the cycle\n\t/** @type {Set<Cycle<T>>} */\n\tconst rootCycles = new Set();\n\n\t// For all non-marked nodes\n\tfor (const selectedNode of itemToNode.values()) {\n\t\tif (selectedNode.marker === NO_MARKER) {\n\t\t\t// deep-walk all referenced modules\n\t\t\t// in a non-recursive way\n\n\t\t\t// start by entering the selected node\n\t\t\tselectedNode.marker = IN_PROGRESS_MARKER;\n\n\t\t\t// keep a stack to avoid recursive walk\n\t\t\t/** @type {StackEntry<T>[]} */\n\t\t\tconst stack = [\n\t\t\t\t{\n\t\t\t\t\tnode: selectedNode,\n\t\t\t\t\topenEdges: Array.from(selectedNode.dependencies)\n\t\t\t\t}\n\t\t\t];\n\n\t\t\t// process the top item until stack is empty\n\t\t\twhile (stack.length > 0) {\n\t\t\t\tconst topOfStack = stack[stack.length - 1];\n\n\t\t\t\t// Are there still edges unprocessed in the current node?\n\t\t\t\tif (topOfStack.openEdges.length > 0) {\n\t\t\t\t\t// Process one dependency\n\t\t\t\t\tconst dependency = topOfStack.openEdges.pop();\n\t\t\t\t\tswitch (dependency.marker) {\n\t\t\t\t\t\tcase NO_MARKER:\n\t\t\t\t\t\t\t// dependency has not be visited yet\n\t\t\t\t\t\t\t// mark it as in-progress and recurse\n\t\t\t\t\t\t\tstack.push({\n\t\t\t\t\t\t\t\tnode: dependency,\n\t\t\t\t\t\t\t\topenEdges: Array.from(dependency.dependencies)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tdependency.marker = IN_PROGRESS_MARKER;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IN_PROGRESS_MARKER: {\n\t\t\t\t\t\t\t// It's a in-progress cycle\n\t\t\t\t\t\t\tlet cycle = dependency.cycle;\n\t\t\t\t\t\t\tif (!cycle) {\n\t\t\t\t\t\t\t\tcycle = new Cycle();\n\t\t\t\t\t\t\t\tcycle.nodes.add(dependency);\n\t\t\t\t\t\t\t\tdependency.cycle = cycle;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// set cycle property for each node in the cycle\n\t\t\t\t\t\t\t// if nodes are already part of a cycle\n\t\t\t\t\t\t\t// we merge the cycles to a shared cycle\n\t\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\t\tlet i = stack.length - 1;\n\t\t\t\t\t\t\t\tstack[i].node !== dependency;\n\t\t\t\t\t\t\t\ti--\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst node = stack[i].node;\n\t\t\t\t\t\t\t\tif (node.cycle) {\n\t\t\t\t\t\t\t\t\tif (node.cycle !== cycle) {\n\t\t\t\t\t\t\t\t\t\t// merge cycles\n\t\t\t\t\t\t\t\t\t\tfor (const cycleNode of node.cycle.nodes) {\n\t\t\t\t\t\t\t\t\t\t\tcycleNode.cycle = cycle;\n\t\t\t\t\t\t\t\t\t\t\tcycle.nodes.add(cycleNode);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnode.cycle = cycle;\n\t\t\t\t\t\t\t\t\tcycle.nodes.add(node);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// don't recurse into dependencies\n\t\t\t\t\t\t\t// these are already on the stack\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase DONE_AND_ROOT_MARKER:\n\t\t\t\t\t\t\t// This node has be visited yet and is currently a root node\n\t\t\t\t\t\t\t// But as this is a new reference to the node\n\t\t\t\t\t\t\t// it's not really a root\n\t\t\t\t\t\t\t// so we have to convert it to a normal node\n\t\t\t\t\t\t\tdependency.marker = DONE_MARKER;\n\t\t\t\t\t\t\troots.delete(dependency);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase DONE_MAYBE_ROOT_CYCLE_MARKER:\n\t\t\t\t\t\t\t// This node has be visited yet and\n\t\t\t\t\t\t\t// is maybe currently part of a completed root cycle\n\t\t\t\t\t\t\t// we found a new reference to the cycle\n\t\t\t\t\t\t\t// so it's not really a root cycle\n\t\t\t\t\t\t\t// remove the cycle from the root cycles\n\t\t\t\t\t\t\t// and convert it to a normal node\n\t\t\t\t\t\t\trootCycles.delete(dependency.cycle);\n\t\t\t\t\t\t\tdependency.marker = DONE_MARKER;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// DONE_MARKER: nothing to do, don't recurse into dependencies\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// All dependencies of the current node has been visited\n\t\t\t\t\t// we leave the node\n\t\t\t\t\tstack.pop();\n\t\t\t\t\ttopOfStack.node.marker = DONE_MARKER;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst cycle = selectedNode.cycle;\n\t\t\tif (cycle) {\n\t\t\t\tfor (const node of cycle.nodes) {\n\t\t\t\t\tnode.marker = DONE_MAYBE_ROOT_CYCLE_MARKER;\n\t\t\t\t}\n\t\t\t\trootCycles.add(cycle);\n\t\t\t} else {\n\t\t\t\tselectedNode.marker = DONE_AND_ROOT_MARKER;\n\t\t\t\troots.add(selectedNode);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Extract roots from root cycles\n\t// We take the nodes with most incoming edges\n\t// inside of the cycle\n\tfor (const cycle of rootCycles) {\n\t\tlet max = 0;\n\t\t/** @type {Set<Node<T>>} */\n\t\tconst cycleRoots = new Set();\n\t\tconst nodes = cycle.nodes;\n\t\tfor (const node of nodes) {\n\t\t\tfor (const dep of node.dependencies) {\n\t\t\t\tif (nodes.has(dep)) {\n\t\t\t\t\tdep.incoming++;\n\t\t\t\t\tif (dep.incoming < max) continue;\n\t\t\t\t\tif (dep.incoming > max) {\n\t\t\t\t\t\tcycleRoots.clear();\n\t\t\t\t\t\tmax = dep.incoming;\n\t\t\t\t\t}\n\t\t\t\t\tcycleRoots.add(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const cycleRoot of cycleRoots) {\n\t\t\troots.add(cycleRoot);\n\t\t}\n\t}\n\n\t// When roots were found, return them\n\tif (roots.size > 0) {\n\t\treturn Array.from(roots, r => r.item);\n\t} else {\n\t\tthrow new Error(\"Implementation of findGraphRoots is broken\");\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}