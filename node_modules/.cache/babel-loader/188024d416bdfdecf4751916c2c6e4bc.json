{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst streamChunksOfSourceMap = require(\"./streamChunksOfSourceMap\");\n\nconst splitIntoLines = require(\"./splitIntoLines\");\n\nconst streamChunksOfCombinedSourceMap = (source, sourceMap, innerSourceName, innerSource, innerSourceMap, removeInnerSource, onChunk, onSource, onName, finalSource, columns) => {\n  let sourceMapping = new Map();\n  let nameMapping = new Map();\n  const sourceIndexMapping = [];\n  const nameIndexMapping = [];\n  const nameIndexValueMapping = [];\n  let innerSourceIndex = -2;\n  const innerSourceIndexMapping = [];\n  const innerSourceIndexValueMapping = [];\n  const innerSourceContents = [];\n  const innerSourceContentLines = [];\n  const innerNameIndexMapping = [];\n  const innerNameIndexValueMapping = [];\n  const innerSourceMapLineData = [];\n\n  const findInnerMapping = (line, column) => {\n    if (line > innerSourceMapLineData.length) return -1;\n    const {\n      mappingsData\n    } = innerSourceMapLineData[line - 1];\n    let l = 0;\n    let r = mappingsData.length / 5;\n\n    while (l < r) {\n      let m = l + r >> 1;\n\n      if (mappingsData[m * 5] <= column) {\n        l = m + 1;\n      } else {\n        r = m;\n      }\n    }\n\n    if (l === 0) return -1;\n    return l - 1;\n  };\n\n  return streamChunksOfSourceMap(source, sourceMap, (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {\n    // Check if this is a mapping to the inner source\n    if (sourceIndex === innerSourceIndex) {\n      // Check if there is a mapping in the inner source\n      const idx = findInnerMapping(originalLine, originalColumn);\n\n      if (idx !== -1) {\n        const {\n          chunks,\n          mappingsData\n        } = innerSourceMapLineData[originalLine - 1];\n        const mi = idx * 5;\n        const innerSourceIndex = mappingsData[mi + 1];\n        const innerOriginalLine = mappingsData[mi + 2];\n        let innerOriginalColumn = mappingsData[mi + 3];\n        let innerNameIndex = mappingsData[mi + 4];\n\n        if (innerSourceIndex >= 0) {\n          // Check for an identity mapping\n          // where we are allowed to adjust the original column\n          const innerChunk = chunks[idx];\n          const innerGeneratedColumn = mappingsData[mi];\n          const locationInChunk = originalColumn - innerGeneratedColumn;\n\n          if (locationInChunk > 0) {\n            let originalSourceLines = innerSourceIndex < innerSourceContentLines.length ? innerSourceContentLines[innerSourceIndex] : null;\n\n            if (originalSourceLines === undefined) {\n              const originalSource = innerSourceContents[innerSourceIndex];\n              originalSourceLines = originalSource ? splitIntoLines(originalSource) : null;\n              innerSourceContentLines[innerSourceIndex] = originalSourceLines;\n            }\n\n            if (originalSourceLines !== null) {\n              const originalChunk = innerOriginalLine <= originalSourceLines.length ? originalSourceLines[innerOriginalLine - 1].slice(innerOriginalColumn, innerOriginalColumn + locationInChunk) : \"\";\n\n              if (innerChunk.slice(0, locationInChunk) === originalChunk) {\n                innerOriginalColumn += locationInChunk;\n                innerNameIndex = -1;\n              }\n            }\n          } // We have a inner mapping to original source\n          // emit source when needed and compute global source index\n\n\n          let sourceIndex = innerSourceIndex < innerSourceIndexMapping.length ? innerSourceIndexMapping[innerSourceIndex] : -2;\n\n          if (sourceIndex === -2) {\n            const [source, sourceContent] = innerSourceIndex < innerSourceIndexValueMapping.length ? innerSourceIndexValueMapping[innerSourceIndex] : [null, undefined];\n            let globalIndex = sourceMapping.get(source);\n\n            if (globalIndex === undefined) {\n              sourceMapping.set(source, globalIndex = sourceMapping.size);\n              onSource(globalIndex, source, sourceContent);\n            }\n\n            sourceIndex = globalIndex;\n            innerSourceIndexMapping[innerSourceIndex] = sourceIndex;\n          } // emit name when needed and compute global name index\n\n\n          let finalNameIndex = -1;\n\n          if (innerNameIndex >= 0) {\n            // when we have a inner name\n            finalNameIndex = innerNameIndex < innerNameIndexMapping.length ? innerNameIndexMapping[innerNameIndex] : -2;\n\n            if (finalNameIndex === -2) {\n              const name = innerNameIndex < innerNameIndexValueMapping.length ? innerNameIndexValueMapping[innerNameIndex] : undefined;\n\n              if (name) {\n                let globalIndex = nameMapping.get(name);\n\n                if (globalIndex === undefined) {\n                  nameMapping.set(name, globalIndex = nameMapping.size);\n                  onName(globalIndex, name);\n                }\n\n                finalNameIndex = globalIndex;\n              } else {\n                finalNameIndex = -1;\n              }\n\n              innerNameIndexMapping[innerNameIndex] = finalNameIndex;\n            }\n          } else if (nameIndex >= 0) {\n            // when we don't have an inner name,\n            // but we have an outer name\n            // it can be used when inner original code equals to the name\n            let originalSourceLines = innerSourceContentLines[innerSourceIndex];\n\n            if (originalSourceLines === undefined) {\n              const originalSource = innerSourceContents[innerSourceIndex];\n              originalSourceLines = originalSource ? splitIntoLines(originalSource) : null;\n              innerSourceContentLines[innerSourceIndex] = originalSourceLines;\n            }\n\n            if (originalSourceLines !== null) {\n              const name = nameIndexValueMapping[nameIndex];\n              const originalName = innerOriginalLine <= originalSourceLines.length ? originalSourceLines[innerOriginalLine - 1].slice(innerOriginalColumn, innerOriginalColumn + name.length) : \"\";\n\n              if (name === originalName) {\n                finalNameIndex = nameIndex < nameIndexMapping.length ? nameIndexMapping[nameIndex] : -2;\n\n                if (finalNameIndex === -2) {\n                  const name = nameIndexValueMapping[nameIndex];\n\n                  if (name) {\n                    let globalIndex = nameMapping.get(name);\n\n                    if (globalIndex === undefined) {\n                      nameMapping.set(name, globalIndex = nameMapping.size);\n                      onName(globalIndex, name);\n                    }\n\n                    finalNameIndex = globalIndex;\n                  } else {\n                    finalNameIndex = -1;\n                  }\n\n                  nameIndexMapping[nameIndex] = finalNameIndex;\n                }\n              }\n            }\n          }\n\n          onChunk(chunk, generatedLine, generatedColumn, sourceIndex, innerOriginalLine, innerOriginalColumn, finalNameIndex);\n          return;\n        }\n      } // We have a mapping to the inner source, but no inner mapping\n\n\n      if (removeInnerSource) {\n        onChunk(chunk, generatedLine, generatedColumn, -1, -1, -1, -1);\n        return;\n      } else {\n        if (sourceIndexMapping[sourceIndex] === -2) {\n          let globalIndex = sourceMapping.get(innerSourceName);\n\n          if (globalIndex === undefined) {\n            sourceMapping.set(source, globalIndex = sourceMapping.size);\n            onSource(globalIndex, innerSourceName, innerSource);\n          }\n\n          sourceIndexMapping[sourceIndex] = globalIndex;\n        }\n      }\n    }\n\n    const finalSourceIndex = sourceIndex < 0 || sourceIndex >= sourceIndexMapping.length ? -1 : sourceIndexMapping[sourceIndex];\n\n    if (finalSourceIndex < 0) {\n      // no source, so we make it a generated chunk\n      onChunk(chunk, generatedLine, generatedColumn, -1, -1, -1, -1);\n    } else {\n      // Pass through the chunk with mapping\n      let finalNameIndex = -1;\n\n      if (nameIndex >= 0 && nameIndex < nameIndexMapping.length) {\n        finalNameIndex = nameIndexMapping[nameIndex];\n\n        if (finalNameIndex === -2) {\n          const name = nameIndexValueMapping[nameIndex];\n          let globalIndex = nameMapping.get(name);\n\n          if (globalIndex === undefined) {\n            nameMapping.set(name, globalIndex = nameMapping.size);\n            onName(globalIndex, name);\n          }\n\n          finalNameIndex = globalIndex;\n          nameIndexMapping[nameIndex] = finalNameIndex;\n        }\n      }\n\n      onChunk(chunk, generatedLine, generatedColumn, finalSourceIndex, originalLine, originalColumn, finalNameIndex);\n    }\n  }, (i, source, sourceContent) => {\n    if (source === innerSourceName) {\n      innerSourceIndex = i;\n      if (innerSource !== undefined) sourceContent = innerSource;else innerSource = sourceContent;\n      sourceIndexMapping[i] = -2;\n      streamChunksOfSourceMap(sourceContent, innerSourceMap, (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {\n        while (innerSourceMapLineData.length < generatedLine) {\n          innerSourceMapLineData.push({\n            mappingsData: [],\n            chunks: []\n          });\n        }\n\n        const data = innerSourceMapLineData[generatedLine - 1];\n        data.mappingsData.push(generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex);\n        data.chunks.push(chunk);\n      }, (i, source, sourceContent) => {\n        innerSourceContents[i] = sourceContent;\n        innerSourceContentLines[i] = undefined;\n        innerSourceIndexMapping[i] = -2;\n        innerSourceIndexValueMapping[i] = [source, sourceContent];\n      }, (i, name) => {\n        innerNameIndexMapping[i] = -2;\n        innerNameIndexValueMapping[i] = name;\n      }, false, columns);\n    } else {\n      let globalIndex = sourceMapping.get(source);\n\n      if (globalIndex === undefined) {\n        sourceMapping.set(source, globalIndex = sourceMapping.size);\n        onSource(globalIndex, source, sourceContent);\n      }\n\n      sourceIndexMapping[i] = globalIndex;\n    }\n  }, (i, name) => {\n    nameIndexMapping[i] = -2;\n    nameIndexValueMapping[i] = name;\n  }, finalSource, columns);\n};\n\nmodule.exports = streamChunksOfCombinedSourceMap;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack-sources/lib/helpers/streamChunksOfCombinedSourceMap.js"],"names":["streamChunksOfSourceMap","require","splitIntoLines","streamChunksOfCombinedSourceMap","source","sourceMap","innerSourceName","innerSource","innerSourceMap","removeInnerSource","onChunk","onSource","onName","finalSource","columns","sourceMapping","Map","nameMapping","sourceIndexMapping","nameIndexMapping","nameIndexValueMapping","innerSourceIndex","innerSourceIndexMapping","innerSourceIndexValueMapping","innerSourceContents","innerSourceContentLines","innerNameIndexMapping","innerNameIndexValueMapping","innerSourceMapLineData","findInnerMapping","line","column","length","mappingsData","l","r","m","chunk","generatedLine","generatedColumn","sourceIndex","originalLine","originalColumn","nameIndex","idx","chunks","mi","innerOriginalLine","innerOriginalColumn","innerNameIndex","innerChunk","innerGeneratedColumn","locationInChunk","originalSourceLines","undefined","originalSource","originalChunk","slice","sourceContent","globalIndex","get","set","size","finalNameIndex","name","originalName","finalSourceIndex","i","push","data","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst streamChunksOfSourceMap = require(\"./streamChunksOfSourceMap\");\nconst splitIntoLines = require(\"./splitIntoLines\");\n\nconst streamChunksOfCombinedSourceMap = (\n\tsource,\n\tsourceMap,\n\tinnerSourceName,\n\tinnerSource,\n\tinnerSourceMap,\n\tremoveInnerSource,\n\tonChunk,\n\tonSource,\n\tonName,\n\tfinalSource,\n\tcolumns\n) => {\n\tlet sourceMapping = new Map();\n\tlet nameMapping = new Map();\n\tconst sourceIndexMapping = [];\n\tconst nameIndexMapping = [];\n\tconst nameIndexValueMapping = [];\n\tlet innerSourceIndex = -2;\n\tconst innerSourceIndexMapping = [];\n\tconst innerSourceIndexValueMapping = [];\n\tconst innerSourceContents = [];\n\tconst innerSourceContentLines = [];\n\tconst innerNameIndexMapping = [];\n\tconst innerNameIndexValueMapping = [];\n\tconst innerSourceMapLineData = [];\n\tconst findInnerMapping = (line, column) => {\n\t\tif (line > innerSourceMapLineData.length) return -1;\n\t\tconst { mappingsData } = innerSourceMapLineData[line - 1];\n\t\tlet l = 0;\n\t\tlet r = mappingsData.length / 5;\n\t\twhile (l < r) {\n\t\t\tlet m = (l + r) >> 1;\n\t\t\tif (mappingsData[m * 5] <= column) {\n\t\t\t\tl = m + 1;\n\t\t\t} else {\n\t\t\t\tr = m;\n\t\t\t}\n\t\t}\n\t\tif (l === 0) return -1;\n\t\treturn l - 1;\n\t};\n\treturn streamChunksOfSourceMap(\n\t\tsource,\n\t\tsourceMap,\n\t\t(\n\t\t\tchunk,\n\t\t\tgeneratedLine,\n\t\t\tgeneratedColumn,\n\t\t\tsourceIndex,\n\t\t\toriginalLine,\n\t\t\toriginalColumn,\n\t\t\tnameIndex\n\t\t) => {\n\t\t\t// Check if this is a mapping to the inner source\n\t\t\tif (sourceIndex === innerSourceIndex) {\n\t\t\t\t// Check if there is a mapping in the inner source\n\t\t\t\tconst idx = findInnerMapping(originalLine, originalColumn);\n\t\t\t\tif (idx !== -1) {\n\t\t\t\t\tconst { chunks, mappingsData } = innerSourceMapLineData[\n\t\t\t\t\t\toriginalLine - 1\n\t\t\t\t\t];\n\t\t\t\t\tconst mi = idx * 5;\n\t\t\t\t\tconst innerSourceIndex = mappingsData[mi + 1];\n\t\t\t\t\tconst innerOriginalLine = mappingsData[mi + 2];\n\t\t\t\t\tlet innerOriginalColumn = mappingsData[mi + 3];\n\t\t\t\t\tlet innerNameIndex = mappingsData[mi + 4];\n\t\t\t\t\tif (innerSourceIndex >= 0) {\n\t\t\t\t\t\t// Check for an identity mapping\n\t\t\t\t\t\t// where we are allowed to adjust the original column\n\t\t\t\t\t\tconst innerChunk = chunks[idx];\n\t\t\t\t\t\tconst innerGeneratedColumn = mappingsData[mi];\n\t\t\t\t\t\tconst locationInChunk = originalColumn - innerGeneratedColumn;\n\t\t\t\t\t\tif (locationInChunk > 0) {\n\t\t\t\t\t\t\tlet originalSourceLines =\n\t\t\t\t\t\t\t\tinnerSourceIndex < innerSourceContentLines.length\n\t\t\t\t\t\t\t\t\t? innerSourceContentLines[innerSourceIndex]\n\t\t\t\t\t\t\t\t\t: null;\n\t\t\t\t\t\t\tif (originalSourceLines === undefined) {\n\t\t\t\t\t\t\t\tconst originalSource = innerSourceContents[innerSourceIndex];\n\t\t\t\t\t\t\t\toriginalSourceLines = originalSource\n\t\t\t\t\t\t\t\t\t? splitIntoLines(originalSource)\n\t\t\t\t\t\t\t\t\t: null;\n\t\t\t\t\t\t\t\tinnerSourceContentLines[innerSourceIndex] = originalSourceLines;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (originalSourceLines !== null) {\n\t\t\t\t\t\t\t\tconst originalChunk =\n\t\t\t\t\t\t\t\t\tinnerOriginalLine <= originalSourceLines.length\n\t\t\t\t\t\t\t\t\t\t? originalSourceLines[innerOriginalLine - 1].slice(\n\t\t\t\t\t\t\t\t\t\t\t\tinnerOriginalColumn,\n\t\t\t\t\t\t\t\t\t\t\t\tinnerOriginalColumn + locationInChunk\n\t\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t\t: \"\";\n\t\t\t\t\t\t\t\tif (innerChunk.slice(0, locationInChunk) === originalChunk) {\n\t\t\t\t\t\t\t\t\tinnerOriginalColumn += locationInChunk;\n\t\t\t\t\t\t\t\t\tinnerNameIndex = -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We have a inner mapping to original source\n\n\t\t\t\t\t\t// emit source when needed and compute global source index\n\t\t\t\t\t\tlet sourceIndex =\n\t\t\t\t\t\t\tinnerSourceIndex < innerSourceIndexMapping.length\n\t\t\t\t\t\t\t\t? innerSourceIndexMapping[innerSourceIndex]\n\t\t\t\t\t\t\t\t: -2;\n\t\t\t\t\t\tif (sourceIndex === -2) {\n\t\t\t\t\t\t\tconst [source, sourceContent] =\n\t\t\t\t\t\t\t\tinnerSourceIndex < innerSourceIndexValueMapping.length\n\t\t\t\t\t\t\t\t\t? innerSourceIndexValueMapping[innerSourceIndex]\n\t\t\t\t\t\t\t\t\t: [null, undefined];\n\t\t\t\t\t\t\tlet globalIndex = sourceMapping.get(source);\n\t\t\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\t\t\tsourceMapping.set(source, (globalIndex = sourceMapping.size));\n\t\t\t\t\t\t\t\tonSource(globalIndex, source, sourceContent);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsourceIndex = globalIndex;\n\t\t\t\t\t\t\tinnerSourceIndexMapping[innerSourceIndex] = sourceIndex;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// emit name when needed and compute global name index\n\t\t\t\t\t\tlet finalNameIndex = -1;\n\t\t\t\t\t\tif (innerNameIndex >= 0) {\n\t\t\t\t\t\t\t// when we have a inner name\n\t\t\t\t\t\t\tfinalNameIndex =\n\t\t\t\t\t\t\t\tinnerNameIndex < innerNameIndexMapping.length\n\t\t\t\t\t\t\t\t\t? innerNameIndexMapping[innerNameIndex]\n\t\t\t\t\t\t\t\t\t: -2;\n\t\t\t\t\t\t\tif (finalNameIndex === -2) {\n\t\t\t\t\t\t\t\tconst name =\n\t\t\t\t\t\t\t\t\tinnerNameIndex < innerNameIndexValueMapping.length\n\t\t\t\t\t\t\t\t\t\t? innerNameIndexValueMapping[innerNameIndex]\n\t\t\t\t\t\t\t\t\t\t: undefined;\n\t\t\t\t\t\t\t\tif (name) {\n\t\t\t\t\t\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\t\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\t\t\t\t\tnameMapping.set(name, (globalIndex = nameMapping.size));\n\t\t\t\t\t\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfinalNameIndex = globalIndex;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfinalNameIndex = -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tinnerNameIndexMapping[innerNameIndex] = finalNameIndex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (nameIndex >= 0) {\n\t\t\t\t\t\t\t// when we don't have an inner name,\n\t\t\t\t\t\t\t// but we have an outer name\n\t\t\t\t\t\t\t// it can be used when inner original code equals to the name\n\t\t\t\t\t\t\tlet originalSourceLines =\n\t\t\t\t\t\t\t\tinnerSourceContentLines[innerSourceIndex];\n\t\t\t\t\t\t\tif (originalSourceLines === undefined) {\n\t\t\t\t\t\t\t\tconst originalSource = innerSourceContents[innerSourceIndex];\n\t\t\t\t\t\t\t\toriginalSourceLines = originalSource\n\t\t\t\t\t\t\t\t\t? splitIntoLines(originalSource)\n\t\t\t\t\t\t\t\t\t: null;\n\t\t\t\t\t\t\t\tinnerSourceContentLines[innerSourceIndex] = originalSourceLines;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (originalSourceLines !== null) {\n\t\t\t\t\t\t\t\tconst name = nameIndexValueMapping[nameIndex];\n\t\t\t\t\t\t\t\tconst originalName =\n\t\t\t\t\t\t\t\t\tinnerOriginalLine <= originalSourceLines.length\n\t\t\t\t\t\t\t\t\t\t? originalSourceLines[innerOriginalLine - 1].slice(\n\t\t\t\t\t\t\t\t\t\t\t\tinnerOriginalColumn,\n\t\t\t\t\t\t\t\t\t\t\t\tinnerOriginalColumn + name.length\n\t\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t\t: \"\";\n\t\t\t\t\t\t\t\tif (name === originalName) {\n\t\t\t\t\t\t\t\t\tfinalNameIndex =\n\t\t\t\t\t\t\t\t\t\tnameIndex < nameIndexMapping.length\n\t\t\t\t\t\t\t\t\t\t\t? nameIndexMapping[nameIndex]\n\t\t\t\t\t\t\t\t\t\t\t: -2;\n\t\t\t\t\t\t\t\t\tif (finalNameIndex === -2) {\n\t\t\t\t\t\t\t\t\t\tconst name = nameIndexValueMapping[nameIndex];\n\t\t\t\t\t\t\t\t\t\tif (name) {\n\t\t\t\t\t\t\t\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\t\t\t\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\tnameMapping.set(name, (globalIndex = nameMapping.size));\n\t\t\t\t\t\t\t\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tfinalNameIndex = globalIndex;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tfinalNameIndex = -1;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tnameIndexMapping[nameIndex] = finalNameIndex;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tgeneratedLine,\n\t\t\t\t\t\t\tgeneratedColumn,\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tinnerOriginalLine,\n\t\t\t\t\t\t\tinnerOriginalColumn,\n\t\t\t\t\t\t\tfinalNameIndex\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We have a mapping to the inner source, but no inner mapping\n\t\t\t\tif (removeInnerSource) {\n\t\t\t\t\tonChunk(chunk, generatedLine, generatedColumn, -1, -1, -1, -1);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tif (sourceIndexMapping[sourceIndex] === -2) {\n\t\t\t\t\t\tlet globalIndex = sourceMapping.get(innerSourceName);\n\t\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\t\tsourceMapping.set(source, (globalIndex = sourceMapping.size));\n\t\t\t\t\t\t\tonSource(globalIndex, innerSourceName, innerSource);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsourceIndexMapping[sourceIndex] = globalIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst finalSourceIndex =\n\t\t\t\tsourceIndex < 0 || sourceIndex >= sourceIndexMapping.length\n\t\t\t\t\t? -1\n\t\t\t\t\t: sourceIndexMapping[sourceIndex];\n\t\t\tif (finalSourceIndex < 0) {\n\t\t\t\t// no source, so we make it a generated chunk\n\t\t\t\tonChunk(chunk, generatedLine, generatedColumn, -1, -1, -1, -1);\n\t\t\t} else {\n\t\t\t\t// Pass through the chunk with mapping\n\t\t\t\tlet finalNameIndex = -1;\n\t\t\t\tif (nameIndex >= 0 && nameIndex < nameIndexMapping.length) {\n\t\t\t\t\tfinalNameIndex = nameIndexMapping[nameIndex];\n\t\t\t\t\tif (finalNameIndex === -2) {\n\t\t\t\t\t\tconst name = nameIndexValueMapping[nameIndex];\n\t\t\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\t\tnameMapping.set(name, (globalIndex = nameMapping.size));\n\t\t\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinalNameIndex = globalIndex;\n\t\t\t\t\t\tnameIndexMapping[nameIndex] = finalNameIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tonChunk(\n\t\t\t\t\tchunk,\n\t\t\t\t\tgeneratedLine,\n\t\t\t\t\tgeneratedColumn,\n\t\t\t\t\tfinalSourceIndex,\n\t\t\t\t\toriginalLine,\n\t\t\t\t\toriginalColumn,\n\t\t\t\t\tfinalNameIndex\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t\t(i, source, sourceContent) => {\n\t\t\tif (source === innerSourceName) {\n\t\t\t\tinnerSourceIndex = i;\n\t\t\t\tif (innerSource !== undefined) sourceContent = innerSource;\n\t\t\t\telse innerSource = sourceContent;\n\t\t\t\tsourceIndexMapping[i] = -2;\n\t\t\t\tstreamChunksOfSourceMap(\n\t\t\t\t\tsourceContent,\n\t\t\t\t\tinnerSourceMap,\n\t\t\t\t\t(\n\t\t\t\t\t\tchunk,\n\t\t\t\t\t\tgeneratedLine,\n\t\t\t\t\t\tgeneratedColumn,\n\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\tnameIndex\n\t\t\t\t\t) => {\n\t\t\t\t\t\twhile (innerSourceMapLineData.length < generatedLine) {\n\t\t\t\t\t\t\tinnerSourceMapLineData.push({\n\t\t\t\t\t\t\t\tmappingsData: [],\n\t\t\t\t\t\t\t\tchunks: []\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst data = innerSourceMapLineData[generatedLine - 1];\n\t\t\t\t\t\tdata.mappingsData.push(\n\t\t\t\t\t\t\tgeneratedColumn,\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\tnameIndex\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdata.chunks.push(chunk);\n\t\t\t\t\t},\n\t\t\t\t\t(i, source, sourceContent) => {\n\t\t\t\t\t\tinnerSourceContents[i] = sourceContent;\n\t\t\t\t\t\tinnerSourceContentLines[i] = undefined;\n\t\t\t\t\t\tinnerSourceIndexMapping[i] = -2;\n\t\t\t\t\t\tinnerSourceIndexValueMapping[i] = [source, sourceContent];\n\t\t\t\t\t},\n\t\t\t\t\t(i, name) => {\n\t\t\t\t\t\tinnerNameIndexMapping[i] = -2;\n\t\t\t\t\t\tinnerNameIndexValueMapping[i] = name;\n\t\t\t\t\t},\n\t\t\t\t\tfalse,\n\t\t\t\t\tcolumns\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tlet globalIndex = sourceMapping.get(source);\n\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\tsourceMapping.set(source, (globalIndex = sourceMapping.size));\n\t\t\t\t\tonSource(globalIndex, source, sourceContent);\n\t\t\t\t}\n\t\t\t\tsourceIndexMapping[i] = globalIndex;\n\t\t\t}\n\t\t},\n\t\t(i, name) => {\n\t\t\tnameIndexMapping[i] = -2;\n\t\t\tnameIndexValueMapping[i] = name;\n\t\t},\n\t\tfinalSource,\n\t\tcolumns\n\t);\n};\n\nmodule.exports = streamChunksOfCombinedSourceMap;\n"]},"metadata":{},"sourceType":"script"}