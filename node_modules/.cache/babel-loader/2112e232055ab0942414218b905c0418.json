{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst RequireEnsureDependenciesBlock = require(\"./RequireEnsureDependenciesBlock\");\n\nconst RequireEnsureDependency = require(\"./RequireEnsureDependency\");\n\nconst RequireEnsureItemDependency = require(\"./RequireEnsureItemDependency\");\n\nconst getFunctionExpression = require(\"./getFunctionExpression\");\n\nmodule.exports = class RequireEnsureDependenciesBlockParserPlugin {\n  apply(parser) {\n    parser.hooks.call.for(\"require.ensure\").tap(\"RequireEnsureDependenciesBlockParserPlugin\", expr => {\n      let chunkName = null;\n      let errorExpressionArg = null;\n      let errorExpression = null;\n\n      switch (expr.arguments.length) {\n        case 4:\n          {\n            const chunkNameExpr = parser.evaluateExpression(expr.arguments[3]);\n            if (!chunkNameExpr.isString()) return;\n            chunkName = chunkNameExpr.string;\n          }\n        // falls through\n\n        case 3:\n          {\n            errorExpressionArg = expr.arguments[2];\n            errorExpression = getFunctionExpression(errorExpressionArg);\n\n            if (!errorExpression && !chunkName) {\n              const chunkNameExpr = parser.evaluateExpression(expr.arguments[2]);\n              if (!chunkNameExpr.isString()) return;\n              chunkName = chunkNameExpr.string;\n            }\n          }\n        // falls through\n\n        case 2:\n          {\n            const dependenciesExpr = parser.evaluateExpression(expr.arguments[0]);\n            const dependenciesItems = dependenciesExpr.isArray() ? dependenciesExpr.items : [dependenciesExpr];\n            const successExpressionArg = expr.arguments[1];\n            const successExpression = getFunctionExpression(successExpressionArg);\n\n            if (successExpression) {\n              parser.walkExpressions(successExpression.expressions);\n            }\n\n            if (errorExpression) {\n              parser.walkExpressions(errorExpression.expressions);\n            }\n\n            const depBlock = new RequireEnsureDependenciesBlock(chunkName, expr.loc);\n            const errorCallbackExists = expr.arguments.length === 4 || !chunkName && expr.arguments.length === 3;\n            const dep = new RequireEnsureDependency(expr.range, expr.arguments[1].range, errorCallbackExists && expr.arguments[2].range);\n            dep.loc = expr.loc;\n            depBlock.addDependency(dep);\n            const old = parser.state.current;\n            parser.state.current = depBlock;\n\n            try {\n              let failed = false;\n              parser.inScope([], () => {\n                for (const ee of dependenciesItems) {\n                  if (ee.isString()) {\n                    const ensureDependency = new RequireEnsureItemDependency(ee.string);\n                    ensureDependency.loc = ee.loc || expr.loc;\n                    depBlock.addDependency(ensureDependency);\n                  } else {\n                    failed = true;\n                  }\n                }\n              });\n\n              if (failed) {\n                return;\n              }\n\n              if (successExpression) {\n                if (successExpression.fn.body.type === \"BlockStatement\") {\n                  parser.walkStatement(successExpression.fn.body);\n                } else {\n                  parser.walkExpression(successExpression.fn.body);\n                }\n              }\n\n              old.addBlock(depBlock);\n            } finally {\n              parser.state.current = old;\n            }\n\n            if (!successExpression) {\n              parser.walkExpression(successExpressionArg);\n            }\n\n            if (errorExpression) {\n              if (errorExpression.fn.body.type === \"BlockStatement\") {\n                parser.walkStatement(errorExpression.fn.body);\n              } else {\n                parser.walkExpression(errorExpression.fn.body);\n              }\n            } else if (errorExpressionArg) {\n              parser.walkExpression(errorExpressionArg);\n            }\n\n            return true;\n          }\n      }\n    });\n  }\n\n};","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/dependencies/RequireEnsureDependenciesBlockParserPlugin.js"],"names":["RequireEnsureDependenciesBlock","require","RequireEnsureDependency","RequireEnsureItemDependency","getFunctionExpression","module","exports","RequireEnsureDependenciesBlockParserPlugin","apply","parser","hooks","call","for","tap","expr","chunkName","errorExpressionArg","errorExpression","arguments","length","chunkNameExpr","evaluateExpression","isString","string","dependenciesExpr","dependenciesItems","isArray","items","successExpressionArg","successExpression","walkExpressions","expressions","depBlock","loc","errorCallbackExists","dep","range","addDependency","old","state","current","failed","inScope","ee","ensureDependency","fn","body","type","walkStatement","walkExpression","addBlock"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst RequireEnsureDependenciesBlock = require(\"./RequireEnsureDependenciesBlock\");\nconst RequireEnsureDependency = require(\"./RequireEnsureDependency\");\nconst RequireEnsureItemDependency = require(\"./RequireEnsureItemDependency\");\nconst getFunctionExpression = require(\"./getFunctionExpression\");\n\nmodule.exports = class RequireEnsureDependenciesBlockParserPlugin {\n\tapply(parser) {\n\t\tparser.hooks.call\n\t\t\t.for(\"require.ensure\")\n\t\t\t.tap(\"RequireEnsureDependenciesBlockParserPlugin\", expr => {\n\t\t\t\tlet chunkName = null;\n\t\t\t\tlet errorExpressionArg = null;\n\t\t\t\tlet errorExpression = null;\n\t\t\t\tswitch (expr.arguments.length) {\n\t\t\t\t\tcase 4: {\n\t\t\t\t\t\tconst chunkNameExpr = parser.evaluateExpression(expr.arguments[3]);\n\t\t\t\t\t\tif (!chunkNameExpr.isString()) return;\n\t\t\t\t\t\tchunkName = chunkNameExpr.string;\n\t\t\t\t\t}\n\t\t\t\t\t// falls through\n\t\t\t\t\tcase 3: {\n\t\t\t\t\t\terrorExpressionArg = expr.arguments[2];\n\t\t\t\t\t\terrorExpression = getFunctionExpression(errorExpressionArg);\n\n\t\t\t\t\t\tif (!errorExpression && !chunkName) {\n\t\t\t\t\t\t\tconst chunkNameExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\texpr.arguments[2]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (!chunkNameExpr.isString()) return;\n\t\t\t\t\t\t\tchunkName = chunkNameExpr.string;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// falls through\n\t\t\t\t\tcase 2: {\n\t\t\t\t\t\tconst dependenciesExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\texpr.arguments[0]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst dependenciesItems = dependenciesExpr.isArray()\n\t\t\t\t\t\t\t? dependenciesExpr.items\n\t\t\t\t\t\t\t: [dependenciesExpr];\n\t\t\t\t\t\tconst successExpressionArg = expr.arguments[1];\n\t\t\t\t\t\tconst successExpression =\n\t\t\t\t\t\t\tgetFunctionExpression(successExpressionArg);\n\n\t\t\t\t\t\tif (successExpression) {\n\t\t\t\t\t\t\tparser.walkExpressions(successExpression.expressions);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (errorExpression) {\n\t\t\t\t\t\t\tparser.walkExpressions(errorExpression.expressions);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst depBlock = new RequireEnsureDependenciesBlock(\n\t\t\t\t\t\t\tchunkName,\n\t\t\t\t\t\t\texpr.loc\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst errorCallbackExists =\n\t\t\t\t\t\t\texpr.arguments.length === 4 ||\n\t\t\t\t\t\t\t(!chunkName && expr.arguments.length === 3);\n\t\t\t\t\t\tconst dep = new RequireEnsureDependency(\n\t\t\t\t\t\t\texpr.range,\n\t\t\t\t\t\t\texpr.arguments[1].range,\n\t\t\t\t\t\t\terrorCallbackExists && expr.arguments[2].range\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\t\tdepBlock.addDependency(dep);\n\t\t\t\t\t\tconst old = parser.state.current;\n\t\t\t\t\t\tparser.state.current = depBlock;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet failed = false;\n\t\t\t\t\t\t\tparser.inScope([], () => {\n\t\t\t\t\t\t\t\tfor (const ee of dependenciesItems) {\n\t\t\t\t\t\t\t\t\tif (ee.isString()) {\n\t\t\t\t\t\t\t\t\t\tconst ensureDependency = new RequireEnsureItemDependency(\n\t\t\t\t\t\t\t\t\t\t\tee.string\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tensureDependency.loc = ee.loc || expr.loc;\n\t\t\t\t\t\t\t\t\t\tdepBlock.addDependency(ensureDependency);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tfailed = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif (failed) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (successExpression) {\n\t\t\t\t\t\t\t\tif (successExpression.fn.body.type === \"BlockStatement\") {\n\t\t\t\t\t\t\t\t\tparser.walkStatement(successExpression.fn.body);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tparser.walkExpression(successExpression.fn.body);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\told.addBlock(depBlock);\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tparser.state.current = old;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!successExpression) {\n\t\t\t\t\t\t\tparser.walkExpression(successExpressionArg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (errorExpression) {\n\t\t\t\t\t\t\tif (errorExpression.fn.body.type === \"BlockStatement\") {\n\t\t\t\t\t\t\t\tparser.walkStatement(errorExpression.fn.body);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tparser.walkExpression(errorExpression.fn.body);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (errorExpressionArg) {\n\t\t\t\t\t\t\tparser.walkExpression(errorExpressionArg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}