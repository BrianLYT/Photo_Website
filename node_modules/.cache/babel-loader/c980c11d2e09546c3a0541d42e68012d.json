{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\n\nconst Template = require(\"../Template\");\n\nconst {\n  isSubset\n} = require(\"../util/SetHelpers\");\n\nconst {\n  getAllChunks\n} = require(\"./ChunkHelpers\");\n/** @typedef {import(\"../util/Hash\")} Hash */\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n\n/** @typedef {import(\"../ChunkGraph\").EntryModuleWithChunkGroup} EntryModuleWithChunkGroup */\n\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n\n/** @typedef {(string|number)[]} EntryItem */\n\n\nconst EXPORT_PREFIX = \"var __webpack_exports__ = \";\n/**\n * @param {ChunkGraph} chunkGraph chunkGraph\n * @param {RuntimeTemplate} runtimeTemplate runtimeTemplate\n * @param {EntryModuleWithChunkGroup[]} entries entries\n * @param {Chunk} chunk chunk\n * @param {boolean} passive true: passive startup with on chunks loaded\n * @returns {string} runtime code\n */\n\nexports.generateEntryStartup = (chunkGraph, runtimeTemplate, entries, chunk, passive) => {\n  /** @type {string[]} */\n  const runtime = [`var __webpack_exec__ = ${runtimeTemplate.returningFunction(`__webpack_require__(${RuntimeGlobals.entryModuleId} = moduleId)`, \"moduleId\")}`];\n\n  const runModule = id => {\n    return `__webpack_exec__(${JSON.stringify(id)})`;\n  };\n\n  const outputCombination = (chunks, moduleIds, final) => {\n    if (chunks.size === 0) {\n      runtime.push(`${final ? EXPORT_PREFIX : \"\"}(${moduleIds.map(runModule).join(\", \")});`);\n    } else {\n      const fn = runtimeTemplate.returningFunction(moduleIds.map(runModule).join(\", \"));\n      runtime.push(`${final && !passive ? EXPORT_PREFIX : \"\"}${passive ? RuntimeGlobals.onChunksLoaded : RuntimeGlobals.startupEntrypoint}(0, ${JSON.stringify(Array.from(chunks, c => c.id))}, ${fn});`);\n\n      if (final && passive) {\n        runtime.push(`${EXPORT_PREFIX}${RuntimeGlobals.onChunksLoaded}();`);\n      }\n    }\n  };\n\n  let currentChunks = undefined;\n  let currentModuleIds = undefined;\n\n  for (const [module, entrypoint] of entries) {\n    const runtimeChunk = entrypoint.getRuntimeChunk();\n    const moduleId = chunkGraph.getModuleId(module);\n    const chunks = getAllChunks(entrypoint, chunk, runtimeChunk);\n\n    if (currentChunks && currentChunks.size === chunks.size && isSubset(currentChunks, chunks)) {\n      currentModuleIds.push(moduleId);\n    } else {\n      if (currentChunks) {\n        outputCombination(currentChunks, currentModuleIds);\n      }\n\n      currentChunks = chunks;\n      currentModuleIds = [moduleId];\n    }\n  } // output current modules with export prefix\n\n\n  if (currentChunks) {\n    outputCombination(currentChunks, currentModuleIds, true);\n  }\n\n  runtime.push(\"\");\n  return Template.asString(runtime);\n};\n/**\n * @param {Hash} hash the hash to update\n * @param {ChunkGraph} chunkGraph chunkGraph\n * @param {EntryModuleWithChunkGroup[]} entries entries\n * @param {Chunk} chunk chunk\n * @returns {void}\n */\n\n\nexports.updateHashForEntryStartup = (hash, chunkGraph, entries, chunk) => {\n  for (const [module, entrypoint] of entries) {\n    const runtimeChunk = entrypoint.getRuntimeChunk();\n    const moduleId = chunkGraph.getModuleId(module);\n    hash.update(`${moduleId}`);\n\n    for (const c of getAllChunks(entrypoint, chunk, runtimeChunk)) hash.update(`${c.id}`);\n  }\n};\n/**\n * @param {Chunk} chunk the chunk\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {function(Chunk, ChunkGraph): boolean} filterFn filter function\n * @returns {Set<number | string>} initially fulfilled chunk ids\n */\n\n\nexports.getInitialChunkIds = (chunk, chunkGraph, filterFn) => {\n  const initialChunkIds = new Set(chunk.ids);\n\n  for (const c of chunk.getAllInitialChunks()) {\n    if (c === chunk || filterFn(c, chunkGraph)) continue;\n\n    for (const id of c.ids) initialChunkIds.add(id);\n  }\n\n  return initialChunkIds;\n};","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/javascript/StartupHelpers.js"],"names":["RuntimeGlobals","require","Template","isSubset","getAllChunks","EXPORT_PREFIX","exports","generateEntryStartup","chunkGraph","runtimeTemplate","entries","chunk","passive","runtime","returningFunction","entryModuleId","runModule","id","JSON","stringify","outputCombination","chunks","moduleIds","final","size","push","map","join","fn","onChunksLoaded","startupEntrypoint","Array","from","c","currentChunks","undefined","currentModuleIds","module","entrypoint","runtimeChunk","getRuntimeChunk","moduleId","getModuleId","asString","updateHashForEntryStartup","hash","update","getInitialChunkIds","filterFn","initialChunkIds","Set","ids","getAllInitialChunks","add"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst Template = require(\"../Template\");\nconst { isSubset } = require(\"../util/SetHelpers\");\nconst { getAllChunks } = require(\"./ChunkHelpers\");\n\n/** @typedef {import(\"../util/Hash\")} Hash */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../ChunkGraph\").EntryModuleWithChunkGroup} EntryModuleWithChunkGroup */\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {(string|number)[]} EntryItem */\n\nconst EXPORT_PREFIX = \"var __webpack_exports__ = \";\n\n/**\n * @param {ChunkGraph} chunkGraph chunkGraph\n * @param {RuntimeTemplate} runtimeTemplate runtimeTemplate\n * @param {EntryModuleWithChunkGroup[]} entries entries\n * @param {Chunk} chunk chunk\n * @param {boolean} passive true: passive startup with on chunks loaded\n * @returns {string} runtime code\n */\nexports.generateEntryStartup = (\n\tchunkGraph,\n\truntimeTemplate,\n\tentries,\n\tchunk,\n\tpassive\n) => {\n\t/** @type {string[]} */\n\tconst runtime = [\n\t\t`var __webpack_exec__ = ${runtimeTemplate.returningFunction(\n\t\t\t`__webpack_require__(${RuntimeGlobals.entryModuleId} = moduleId)`,\n\t\t\t\"moduleId\"\n\t\t)}`\n\t];\n\n\tconst runModule = id => {\n\t\treturn `__webpack_exec__(${JSON.stringify(id)})`;\n\t};\n\tconst outputCombination = (chunks, moduleIds, final) => {\n\t\tif (chunks.size === 0) {\n\t\t\truntime.push(\n\t\t\t\t`${final ? EXPORT_PREFIX : \"\"}(${moduleIds.map(runModule).join(\", \")});`\n\t\t\t);\n\t\t} else {\n\t\t\tconst fn = runtimeTemplate.returningFunction(\n\t\t\t\tmoduleIds.map(runModule).join(\", \")\n\t\t\t);\n\t\t\truntime.push(\n\t\t\t\t`${final && !passive ? EXPORT_PREFIX : \"\"}${\n\t\t\t\t\tpassive\n\t\t\t\t\t\t? RuntimeGlobals.onChunksLoaded\n\t\t\t\t\t\t: RuntimeGlobals.startupEntrypoint\n\t\t\t\t}(0, ${JSON.stringify(Array.from(chunks, c => c.id))}, ${fn});`\n\t\t\t);\n\t\t\tif (final && passive) {\n\t\t\t\truntime.push(`${EXPORT_PREFIX}${RuntimeGlobals.onChunksLoaded}();`);\n\t\t\t}\n\t\t}\n\t};\n\n\tlet currentChunks = undefined;\n\tlet currentModuleIds = undefined;\n\n\tfor (const [module, entrypoint] of entries) {\n\t\tconst runtimeChunk = entrypoint.getRuntimeChunk();\n\t\tconst moduleId = chunkGraph.getModuleId(module);\n\t\tconst chunks = getAllChunks(entrypoint, chunk, runtimeChunk);\n\t\tif (\n\t\t\tcurrentChunks &&\n\t\t\tcurrentChunks.size === chunks.size &&\n\t\t\tisSubset(currentChunks, chunks)\n\t\t) {\n\t\t\tcurrentModuleIds.push(moduleId);\n\t\t} else {\n\t\t\tif (currentChunks) {\n\t\t\t\toutputCombination(currentChunks, currentModuleIds);\n\t\t\t}\n\t\t\tcurrentChunks = chunks;\n\t\t\tcurrentModuleIds = [moduleId];\n\t\t}\n\t}\n\n\t// output current modules with export prefix\n\tif (currentChunks) {\n\t\toutputCombination(currentChunks, currentModuleIds, true);\n\t}\n\truntime.push(\"\");\n\treturn Template.asString(runtime);\n};\n\n/**\n * @param {Hash} hash the hash to update\n * @param {ChunkGraph} chunkGraph chunkGraph\n * @param {EntryModuleWithChunkGroup[]} entries entries\n * @param {Chunk} chunk chunk\n * @returns {void}\n */\nexports.updateHashForEntryStartup = (hash, chunkGraph, entries, chunk) => {\n\tfor (const [module, entrypoint] of entries) {\n\t\tconst runtimeChunk = entrypoint.getRuntimeChunk();\n\t\tconst moduleId = chunkGraph.getModuleId(module);\n\t\thash.update(`${moduleId}`);\n\t\tfor (const c of getAllChunks(entrypoint, chunk, runtimeChunk))\n\t\t\thash.update(`${c.id}`);\n\t}\n};\n\n/**\n * @param {Chunk} chunk the chunk\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {function(Chunk, ChunkGraph): boolean} filterFn filter function\n * @returns {Set<number | string>} initially fulfilled chunk ids\n */\nexports.getInitialChunkIds = (chunk, chunkGraph, filterFn) => {\n\tconst initialChunkIds = new Set(chunk.ids);\n\tfor (const c of chunk.getAllInitialChunks()) {\n\t\tif (c === chunk || filterFn(c, chunkGraph)) continue;\n\t\tfor (const id of c.ids) initialChunkIds.add(id);\n\t}\n\treturn initialChunkIds;\n};\n"]},"metadata":{},"sourceType":"script"}