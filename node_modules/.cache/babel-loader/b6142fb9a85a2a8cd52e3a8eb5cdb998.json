{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  parseResource\n} = require(\"../util/identifier\");\n/** @typedef {import(\"estree\").Node} EsTreeNode */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").JavascriptParserOptions} JavascriptParserOptions */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").ModuleOptionsNormalized} ModuleOptions */\n\n/** @typedef {import(\"../javascript/BasicEvaluatedExpression\")} BasicEvaluatedExpression */\n\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n\n/** @typedef {import(\"./ContextDependency\")} ContextDependency */\n\n/** @typedef {import(\"./ContextDependency\").ContextDependencyOptions} ContextDependencyOptions */\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\n\n\nconst quoteMeta = str => {\n  return str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\nconst splitContextFromPrefix = prefix => {\n  const idx = prefix.lastIndexOf(\"/\");\n  let context = \".\";\n\n  if (idx >= 0) {\n    context = prefix.substr(0, idx);\n    prefix = `.${prefix.substr(idx)}`;\n  }\n\n  return {\n    context,\n    prefix\n  };\n};\n/** @typedef {Partial<Omit<ContextDependencyOptions, \"resource\">>} PartialContextDependencyOptions */\n\n/** @typedef {{ new(options: ContextDependencyOptions, range: [number, number], valueRange: [number, number]): ContextDependency }} ContextDependencyConstructor */\n\n/**\n * @param {ContextDependencyConstructor} Dep the Dependency class\n * @param {[number, number]} range source range\n * @param {BasicEvaluatedExpression} param context param\n * @param {EsTreeNode} expr expr\n * @param {Pick<JavascriptParserOptions, `${\"expr\"|\"wrapped\"}Context${\"Critical\"|\"Recursive\"|\"RegExp\"}` | \"exprContextRequest\">} options options for context creation\n * @param {PartialContextDependencyOptions} contextOptions options for the ContextModule\n * @param {JavascriptParser} parser the parser\n * @returns {ContextDependency} the created Dependency\n */\n\n\nexports.create = (Dep, range, param, expr, options, contextOptions, parser) => {\n  if (param.isTemplateString()) {\n    let prefixRaw = param.quasis[0].string;\n    let postfixRaw = param.quasis.length > 1 ? param.quasis[param.quasis.length - 1].string : \"\";\n    const valueRange = param.range;\n    const {\n      context,\n      prefix\n    } = splitContextFromPrefix(prefixRaw);\n    const {\n      path: postfix,\n      query,\n      fragment\n    } = parseResource(postfixRaw, parser); // When there are more than two quasis, the generated RegExp can be more precise\n    // We join the quasis with the expression regexp\n\n    const innerQuasis = param.quasis.slice(1, param.quasis.length - 1);\n    const innerRegExp = options.wrappedContextRegExp.source + innerQuasis.map(q => quoteMeta(q.string) + options.wrappedContextRegExp.source).join(\"\"); // Example: `./context/pre${e}inner${e}inner2${e}post?query#frag`\n    // context: \"./context\"\n    // prefix: \"./pre\"\n    // innerQuasis: [BEE(\"inner\"), BEE(\"inner2\")]\n    // (BEE = BasicEvaluatedExpression)\n    // postfix: \"post\"\n    // query: \"?query\"\n    // fragment: \"#frag\"\n    // regExp: /^\\.\\/pre.*inner.*inner2.*post$/\n\n    const regExp = new RegExp(`^${quoteMeta(prefix)}${innerRegExp}${quoteMeta(postfix)}$`);\n    const dep = new Dep({\n      request: context + query + fragment,\n      recursive: options.wrappedContextRecursive,\n      regExp,\n      mode: \"sync\",\n      ...contextOptions\n    }, range, valueRange);\n    dep.loc = expr.loc;\n    const replaces = [];\n    param.parts.forEach((part, i) => {\n      if (i % 2 === 0) {\n        // Quasis or merged quasi\n        let range = part.range;\n        let value = part.string;\n\n        if (param.templateStringKind === \"cooked\") {\n          value = JSON.stringify(value);\n          value = value.slice(1, value.length - 1);\n        }\n\n        if (i === 0) {\n          // prefix\n          value = prefix;\n          range = [param.range[0], part.range[1]];\n          value = (param.templateStringKind === \"cooked\" ? \"`\" : \"String.raw`\") + value;\n        } else if (i === param.parts.length - 1) {\n          // postfix\n          value = postfix;\n          range = [part.range[0], param.range[1]];\n          value = value + \"`\";\n        } else if (part.expression && part.expression.type === \"TemplateElement\" && part.expression.value.raw === value) {\n          // Shortcut when it's a single quasi and doesn't need to be replaced\n          return;\n        }\n\n        replaces.push({\n          range,\n          value\n        });\n      } else {\n        // Expression\n        parser.walkExpression(part.expression);\n      }\n    });\n    dep.replaces = replaces;\n    dep.critical = options.wrappedContextCritical && \"a part of the request of a dependency is an expression\";\n    return dep;\n  } else if (param.isWrapped() && (param.prefix && param.prefix.isString() || param.postfix && param.postfix.isString())) {\n    let prefixRaw = param.prefix && param.prefix.isString() ? param.prefix.string : \"\";\n    let postfixRaw = param.postfix && param.postfix.isString() ? param.postfix.string : \"\";\n    const prefixRange = param.prefix && param.prefix.isString() ? param.prefix.range : null;\n    const postfixRange = param.postfix && param.postfix.isString() ? param.postfix.range : null;\n    const valueRange = param.range;\n    const {\n      context,\n      prefix\n    } = splitContextFromPrefix(prefixRaw);\n    const {\n      path: postfix,\n      query,\n      fragment\n    } = parseResource(postfixRaw, parser);\n    const regExp = new RegExp(`^${quoteMeta(prefix)}${options.wrappedContextRegExp.source}${quoteMeta(postfix)}$`);\n    const dep = new Dep({\n      request: context + query + fragment,\n      recursive: options.wrappedContextRecursive,\n      regExp,\n      mode: \"sync\",\n      ...contextOptions\n    }, range, valueRange);\n    dep.loc = expr.loc;\n    const replaces = [];\n\n    if (prefixRange) {\n      replaces.push({\n        range: prefixRange,\n        value: JSON.stringify(prefix)\n      });\n    }\n\n    if (postfixRange) {\n      replaces.push({\n        range: postfixRange,\n        value: JSON.stringify(postfix)\n      });\n    }\n\n    dep.replaces = replaces;\n    dep.critical = options.wrappedContextCritical && \"a part of the request of a dependency is an expression\";\n\n    if (parser && param.wrappedInnerExpressions) {\n      for (const part of param.wrappedInnerExpressions) {\n        if (part.expression) parser.walkExpression(part.expression);\n      }\n    }\n\n    return dep;\n  } else {\n    const dep = new Dep({\n      request: options.exprContextRequest,\n      recursive: options.exprContextRecursive,\n      regExp:\n      /** @type {RegExp} */\n      options.exprContextRegExp,\n      mode: \"sync\",\n      ...contextOptions\n    }, range, param.range);\n    dep.loc = expr.loc;\n    dep.critical = options.exprContextCritical && \"the request of a dependency is an expression\";\n    parser.walkExpression(param.expression);\n    return dep;\n  }\n};","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/dependencies/ContextDependencyHelpers.js"],"names":["parseResource","require","quoteMeta","str","replace","splitContextFromPrefix","prefix","idx","lastIndexOf","context","substr","exports","create","Dep","range","param","expr","options","contextOptions","parser","isTemplateString","prefixRaw","quasis","string","postfixRaw","length","valueRange","path","postfix","query","fragment","innerQuasis","slice","innerRegExp","wrappedContextRegExp","source","map","q","join","regExp","RegExp","dep","request","recursive","wrappedContextRecursive","mode","loc","replaces","parts","forEach","part","i","value","templateStringKind","JSON","stringify","expression","type","raw","push","walkExpression","critical","wrappedContextCritical","isWrapped","isString","prefixRange","postfixRange","wrappedInnerExpressions","exprContextRequest","exprContextRecursive","exprContextRegExp","exprContextCritical"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { parseResource } = require(\"../util/identifier\");\n\n/** @typedef {import(\"estree\").Node} EsTreeNode */\n/** @typedef {import(\"../../declarations/WebpackOptions\").JavascriptParserOptions} JavascriptParserOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").ModuleOptionsNormalized} ModuleOptions */\n/** @typedef {import(\"../javascript/BasicEvaluatedExpression\")} BasicEvaluatedExpression */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"./ContextDependency\")} ContextDependency */\n/** @typedef {import(\"./ContextDependency\").ContextDependencyOptions} ContextDependencyOptions */\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nconst quoteMeta = str => {\n\treturn str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\nconst splitContextFromPrefix = prefix => {\n\tconst idx = prefix.lastIndexOf(\"/\");\n\tlet context = \".\";\n\tif (idx >= 0) {\n\t\tcontext = prefix.substr(0, idx);\n\t\tprefix = `.${prefix.substr(idx)}`;\n\t}\n\treturn {\n\t\tcontext,\n\t\tprefix\n\t};\n};\n\n/** @typedef {Partial<Omit<ContextDependencyOptions, \"resource\">>} PartialContextDependencyOptions */\n\n/** @typedef {{ new(options: ContextDependencyOptions, range: [number, number], valueRange: [number, number]): ContextDependency }} ContextDependencyConstructor */\n\n/**\n * @param {ContextDependencyConstructor} Dep the Dependency class\n * @param {[number, number]} range source range\n * @param {BasicEvaluatedExpression} param context param\n * @param {EsTreeNode} expr expr\n * @param {Pick<JavascriptParserOptions, `${\"expr\"|\"wrapped\"}Context${\"Critical\"|\"Recursive\"|\"RegExp\"}` | \"exprContextRequest\">} options options for context creation\n * @param {PartialContextDependencyOptions} contextOptions options for the ContextModule\n * @param {JavascriptParser} parser the parser\n * @returns {ContextDependency} the created Dependency\n */\nexports.create = (Dep, range, param, expr, options, contextOptions, parser) => {\n\tif (param.isTemplateString()) {\n\t\tlet prefixRaw = param.quasis[0].string;\n\t\tlet postfixRaw =\n\t\t\tparam.quasis.length > 1\n\t\t\t\t? param.quasis[param.quasis.length - 1].string\n\t\t\t\t: \"\";\n\n\t\tconst valueRange = param.range;\n\t\tconst { context, prefix } = splitContextFromPrefix(prefixRaw);\n\t\tconst {\n\t\t\tpath: postfix,\n\t\t\tquery,\n\t\t\tfragment\n\t\t} = parseResource(postfixRaw, parser);\n\n\t\t// When there are more than two quasis, the generated RegExp can be more precise\n\t\t// We join the quasis with the expression regexp\n\t\tconst innerQuasis = param.quasis.slice(1, param.quasis.length - 1);\n\t\tconst innerRegExp =\n\t\t\toptions.wrappedContextRegExp.source +\n\t\t\tinnerQuasis\n\t\t\t\t.map(q => quoteMeta(q.string) + options.wrappedContextRegExp.source)\n\t\t\t\t.join(\"\");\n\n\t\t// Example: `./context/pre${e}inner${e}inner2${e}post?query#frag`\n\t\t// context: \"./context\"\n\t\t// prefix: \"./pre\"\n\t\t// innerQuasis: [BEE(\"inner\"), BEE(\"inner2\")]\n\t\t// (BEE = BasicEvaluatedExpression)\n\t\t// postfix: \"post\"\n\t\t// query: \"?query\"\n\t\t// fragment: \"#frag\"\n\t\t// regExp: /^\\.\\/pre.*inner.*inner2.*post$/\n\t\tconst regExp = new RegExp(\n\t\t\t`^${quoteMeta(prefix)}${innerRegExp}${quoteMeta(postfix)}$`\n\t\t);\n\t\tconst dep = new Dep(\n\t\t\t{\n\t\t\t\trequest: context + query + fragment,\n\t\t\t\trecursive: options.wrappedContextRecursive,\n\t\t\t\tregExp,\n\t\t\t\tmode: \"sync\",\n\t\t\t\t...contextOptions\n\t\t\t},\n\t\t\trange,\n\t\t\tvalueRange\n\t\t);\n\t\tdep.loc = expr.loc;\n\t\tconst replaces = [];\n\n\t\tparam.parts.forEach((part, i) => {\n\t\t\tif (i % 2 === 0) {\n\t\t\t\t// Quasis or merged quasi\n\t\t\t\tlet range = part.range;\n\t\t\t\tlet value = part.string;\n\t\t\t\tif (param.templateStringKind === \"cooked\") {\n\t\t\t\t\tvalue = JSON.stringify(value);\n\t\t\t\t\tvalue = value.slice(1, value.length - 1);\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\t// prefix\n\t\t\t\t\tvalue = prefix;\n\t\t\t\t\trange = [param.range[0], part.range[1]];\n\t\t\t\t\tvalue =\n\t\t\t\t\t\t(param.templateStringKind === \"cooked\" ? \"`\" : \"String.raw`\") +\n\t\t\t\t\t\tvalue;\n\t\t\t\t} else if (i === param.parts.length - 1) {\n\t\t\t\t\t// postfix\n\t\t\t\t\tvalue = postfix;\n\t\t\t\t\trange = [part.range[0], param.range[1]];\n\t\t\t\t\tvalue = value + \"`\";\n\t\t\t\t} else if (\n\t\t\t\t\tpart.expression &&\n\t\t\t\t\tpart.expression.type === \"TemplateElement\" &&\n\t\t\t\t\tpart.expression.value.raw === value\n\t\t\t\t) {\n\t\t\t\t\t// Shortcut when it's a single quasi and doesn't need to be replaced\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treplaces.push({\n\t\t\t\t\trange,\n\t\t\t\t\tvalue\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Expression\n\t\t\t\tparser.walkExpression(part.expression);\n\t\t\t}\n\t\t});\n\n\t\tdep.replaces = replaces;\n\t\tdep.critical =\n\t\t\toptions.wrappedContextCritical &&\n\t\t\t\"a part of the request of a dependency is an expression\";\n\t\treturn dep;\n\t} else if (\n\t\tparam.isWrapped() &&\n\t\t((param.prefix && param.prefix.isString()) ||\n\t\t\t(param.postfix && param.postfix.isString()))\n\t) {\n\t\tlet prefixRaw =\n\t\t\tparam.prefix && param.prefix.isString() ? param.prefix.string : \"\";\n\t\tlet postfixRaw =\n\t\t\tparam.postfix && param.postfix.isString() ? param.postfix.string : \"\";\n\t\tconst prefixRange =\n\t\t\tparam.prefix && param.prefix.isString() ? param.prefix.range : null;\n\t\tconst postfixRange =\n\t\t\tparam.postfix && param.postfix.isString() ? param.postfix.range : null;\n\t\tconst valueRange = param.range;\n\t\tconst { context, prefix } = splitContextFromPrefix(prefixRaw);\n\t\tconst {\n\t\t\tpath: postfix,\n\t\t\tquery,\n\t\t\tfragment\n\t\t} = parseResource(postfixRaw, parser);\n\t\tconst regExp = new RegExp(\n\t\t\t`^${quoteMeta(prefix)}${options.wrappedContextRegExp.source}${quoteMeta(\n\t\t\t\tpostfix\n\t\t\t)}$`\n\t\t);\n\t\tconst dep = new Dep(\n\t\t\t{\n\t\t\t\trequest: context + query + fragment,\n\t\t\t\trecursive: options.wrappedContextRecursive,\n\t\t\t\tregExp,\n\t\t\t\tmode: \"sync\",\n\t\t\t\t...contextOptions\n\t\t\t},\n\t\t\trange,\n\t\t\tvalueRange\n\t\t);\n\t\tdep.loc = expr.loc;\n\t\tconst replaces = [];\n\t\tif (prefixRange) {\n\t\t\treplaces.push({\n\t\t\t\trange: prefixRange,\n\t\t\t\tvalue: JSON.stringify(prefix)\n\t\t\t});\n\t\t}\n\t\tif (postfixRange) {\n\t\t\treplaces.push({\n\t\t\t\trange: postfixRange,\n\t\t\t\tvalue: JSON.stringify(postfix)\n\t\t\t});\n\t\t}\n\t\tdep.replaces = replaces;\n\t\tdep.critical =\n\t\t\toptions.wrappedContextCritical &&\n\t\t\t\"a part of the request of a dependency is an expression\";\n\n\t\tif (parser && param.wrappedInnerExpressions) {\n\t\t\tfor (const part of param.wrappedInnerExpressions) {\n\t\t\t\tif (part.expression) parser.walkExpression(part.expression);\n\t\t\t}\n\t\t}\n\n\t\treturn dep;\n\t} else {\n\t\tconst dep = new Dep(\n\t\t\t{\n\t\t\t\trequest: options.exprContextRequest,\n\t\t\t\trecursive: options.exprContextRecursive,\n\t\t\t\tregExp: /** @type {RegExp} */ (options.exprContextRegExp),\n\t\t\t\tmode: \"sync\",\n\t\t\t\t...contextOptions\n\t\t\t},\n\t\t\trange,\n\t\t\tparam.range\n\t\t);\n\t\tdep.loc = expr.loc;\n\t\tdep.critical =\n\t\t\toptions.exprContextCritical &&\n\t\t\t\"the request of a dependency is an expression\";\n\n\t\tparser.walkExpression(param.expression);\n\n\t\treturn dep;\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}