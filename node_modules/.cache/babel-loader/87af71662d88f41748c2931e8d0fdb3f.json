{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Source = require(\"./Source\");\n\nconst RawSource = require(\"./RawSource\");\n\nconst streamChunks = require(\"./helpers/streamChunks\");\n\nconst {\n  getMap,\n  getSourceAndMap\n} = require(\"./helpers/getFromStreamChunks\");\n\nconst REPLACE_REGEX = /\\n(?=.|\\s)/g;\n\nclass PrefixSource extends Source {\n  constructor(prefix, source) {\n    super();\n    this._source = typeof source === \"string\" || Buffer.isBuffer(source) ? new RawSource(source, true) : source;\n    this._prefix = prefix;\n  }\n\n  getPrefix() {\n    return this._prefix;\n  }\n\n  original() {\n    return this._source;\n  }\n\n  source() {\n    const node = this._source.source();\n\n    const prefix = this._prefix;\n    return prefix + node.replace(REPLACE_REGEX, \"\\n\" + prefix);\n  } // TODO efficient buffer() implementation\n\n\n  map(options) {\n    return getMap(this, options);\n  }\n\n  sourceAndMap(options) {\n    return getSourceAndMap(this, options);\n  }\n\n  streamChunks(options, onChunk, onSource, onName) {\n    const prefix = this._prefix;\n    const prefixOffset = prefix.length;\n    const linesOnly = !!(options && options.columns === false);\n    const {\n      generatedLine,\n      generatedColumn,\n      source\n    } = streamChunks(this._source, options, (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {\n      if (generatedColumn !== 0) {\n        // In the middle of the line, we just adject the column\n        generatedColumn += prefixOffset;\n      } else if (chunk !== undefined) {\n        // At the start of the line, when we have source content\n        // add the prefix as generated mapping\n        // (in lines only mode we just add it to the original mapping\n        // for performance reasons)\n        if (linesOnly || sourceIndex < 0) {\n          chunk = prefix + chunk;\n        } else if (prefixOffset > 0) {\n          onChunk(prefix, generatedLine, generatedColumn, -1, -1, -1, -1);\n          generatedColumn += prefixOffset;\n        }\n      } else if (!linesOnly) {\n        // Without source content, we only need to adject the column info\n        // expect in lines only mode where prefix is added to original mapping\n        generatedColumn += prefixOffset;\n      }\n\n      onChunk(chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex);\n    }, onSource, onName);\n    return {\n      generatedLine,\n      generatedColumn: generatedColumn === 0 ? 0 : prefixOffset + generatedColumn,\n      source: source !== undefined ? prefix + source.replace(REPLACE_REGEX, \"\\n\" + prefix) : undefined\n    };\n  }\n\n  updateHash(hash) {\n    hash.update(\"PrefixSource\");\n\n    this._source.updateHash(hash);\n\n    hash.update(this._prefix);\n  }\n\n}\n\nmodule.exports = PrefixSource;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack-sources/lib/PrefixSource.js"],"names":["Source","require","RawSource","streamChunks","getMap","getSourceAndMap","REPLACE_REGEX","PrefixSource","constructor","prefix","source","_source","Buffer","isBuffer","_prefix","getPrefix","original","node","replace","map","options","sourceAndMap","onChunk","onSource","onName","prefixOffset","length","linesOnly","columns","generatedLine","generatedColumn","chunk","sourceIndex","originalLine","originalColumn","nameIndex","undefined","updateHash","hash","update","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Source = require(\"./Source\");\nconst RawSource = require(\"./RawSource\");\nconst streamChunks = require(\"./helpers/streamChunks\");\nconst { getMap, getSourceAndMap } = require(\"./helpers/getFromStreamChunks\");\n\nconst REPLACE_REGEX = /\\n(?=.|\\s)/g;\n\nclass PrefixSource extends Source {\n\tconstructor(prefix, source) {\n\t\tsuper();\n\t\tthis._source =\n\t\t\ttypeof source === \"string\" || Buffer.isBuffer(source)\n\t\t\t\t? new RawSource(source, true)\n\t\t\t\t: source;\n\t\tthis._prefix = prefix;\n\t}\n\n\tgetPrefix() {\n\t\treturn this._prefix;\n\t}\n\n\toriginal() {\n\t\treturn this._source;\n\t}\n\n\tsource() {\n\t\tconst node = this._source.source();\n\t\tconst prefix = this._prefix;\n\t\treturn prefix + node.replace(REPLACE_REGEX, \"\\n\" + prefix);\n\t}\n\n\t// TODO efficient buffer() implementation\n\n\tmap(options) {\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tconst prefix = this._prefix;\n\t\tconst prefixOffset = prefix.length;\n\t\tconst linesOnly = !!(options && options.columns === false);\n\t\tconst { generatedLine, generatedColumn, source } = streamChunks(\n\t\t\tthis._source,\n\t\t\toptions,\n\t\t\t(\n\t\t\t\tchunk,\n\t\t\t\tgeneratedLine,\n\t\t\t\tgeneratedColumn,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\tnameIndex\n\t\t\t) => {\n\t\t\t\tif (generatedColumn !== 0) {\n\t\t\t\t\t// In the middle of the line, we just adject the column\n\t\t\t\t\tgeneratedColumn += prefixOffset;\n\t\t\t\t} else if (chunk !== undefined) {\n\t\t\t\t\t// At the start of the line, when we have source content\n\t\t\t\t\t// add the prefix as generated mapping\n\t\t\t\t\t// (in lines only mode we just add it to the original mapping\n\t\t\t\t\t// for performance reasons)\n\t\t\t\t\tif (linesOnly || sourceIndex < 0) {\n\t\t\t\t\t\tchunk = prefix + chunk;\n\t\t\t\t\t} else if (prefixOffset > 0) {\n\t\t\t\t\t\tonChunk(prefix, generatedLine, generatedColumn, -1, -1, -1, -1);\n\t\t\t\t\t\tgeneratedColumn += prefixOffset;\n\t\t\t\t\t}\n\t\t\t\t} else if (!linesOnly) {\n\t\t\t\t\t// Without source content, we only need to adject the column info\n\t\t\t\t\t// expect in lines only mode where prefix is added to original mapping\n\t\t\t\t\tgeneratedColumn += prefixOffset;\n\t\t\t\t}\n\t\t\t\tonChunk(\n\t\t\t\t\tchunk,\n\t\t\t\t\tgeneratedLine,\n\t\t\t\t\tgeneratedColumn,\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\toriginalLine,\n\t\t\t\t\toriginalColumn,\n\t\t\t\t\tnameIndex\n\t\t\t\t);\n\t\t\t},\n\t\t\tonSource,\n\t\t\tonName\n\t\t);\n\t\treturn {\n\t\t\tgeneratedLine,\n\t\t\tgeneratedColumn:\n\t\t\t\tgeneratedColumn === 0 ? 0 : prefixOffset + generatedColumn,\n\t\t\tsource:\n\t\t\t\tsource !== undefined\n\t\t\t\t\t? prefix + source.replace(REPLACE_REGEX, \"\\n\" + prefix)\n\t\t\t\t\t: undefined\n\t\t};\n\t}\n\n\tupdateHash(hash) {\n\t\thash.update(\"PrefixSource\");\n\t\tthis._source.updateHash(hash);\n\t\thash.update(this._prefix);\n\t}\n}\n\nmodule.exports = PrefixSource;\n"]},"metadata":{},"sourceType":"script"}