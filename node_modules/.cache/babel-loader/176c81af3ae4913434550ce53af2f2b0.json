{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\"use strict\";\n\nconst path = require(\"path\");\n\nconst WINDOWS_ABS_PATH_REGEXP = /^[a-zA-Z]:[\\\\/]/;\nconst SEGMENTS_SPLIT_REGEXP = /([|!])/;\nconst WINDOWS_PATH_SEPARATOR_REGEXP = /\\\\/g;\n/**\n * @typedef {Object} MakeRelativePathsCache\n * @property {Map<string, Map<string, string>>=} relativePaths\n */\n\nconst relativePathToRequest = relativePath => {\n  if (relativePath === \"\") return \"./.\";\n  if (relativePath === \"..\") return \"../.\";\n  if (relativePath.startsWith(\"../\")) return relativePath;\n  return `./${relativePath}`;\n};\n/**\n * @param {string} context context for relative path\n * @param {string} maybeAbsolutePath path to make relative\n * @returns {string} relative path in request style\n */\n\n\nconst absoluteToRequest = (context, maybeAbsolutePath) => {\n  if (maybeAbsolutePath[0] === \"/\") {\n    if (maybeAbsolutePath.length > 1 && maybeAbsolutePath[maybeAbsolutePath.length - 1] === \"/\") {\n      // this 'path' is actually a regexp generated by dynamic requires.\n      // Don't treat it as an absolute path.\n      return maybeAbsolutePath;\n    }\n\n    const querySplitPos = maybeAbsolutePath.indexOf(\"?\");\n    let resource = querySplitPos === -1 ? maybeAbsolutePath : maybeAbsolutePath.slice(0, querySplitPos);\n    resource = relativePathToRequest(path.posix.relative(context, resource));\n    return querySplitPos === -1 ? resource : resource + maybeAbsolutePath.slice(querySplitPos);\n  }\n\n  if (WINDOWS_ABS_PATH_REGEXP.test(maybeAbsolutePath)) {\n    const querySplitPos = maybeAbsolutePath.indexOf(\"?\");\n    let resource = querySplitPos === -1 ? maybeAbsolutePath : maybeAbsolutePath.slice(0, querySplitPos);\n    resource = path.win32.relative(context, resource);\n\n    if (!WINDOWS_ABS_PATH_REGEXP.test(resource)) {\n      resource = relativePathToRequest(resource.replace(WINDOWS_PATH_SEPARATOR_REGEXP, \"/\"));\n    }\n\n    return querySplitPos === -1 ? resource : resource + maybeAbsolutePath.slice(querySplitPos);\n  } // not an absolute path\n\n\n  return maybeAbsolutePath;\n};\n/**\n * @param {string} context context for relative path\n * @param {string} relativePath path\n * @returns {string} absolute path\n */\n\n\nconst requestToAbsolute = (context, relativePath) => {\n  if (relativePath.startsWith(\"./\") || relativePath.startsWith(\"../\")) return path.join(context, relativePath);\n  return relativePath;\n};\n\nconst makeCacheable = realFn => {\n  /** @type {WeakMap<object, Map<string, ParsedResource>>} */\n  const cache = new WeakMap();\n\n  const getCache = associatedObjectForCache => {\n    const entry = cache.get(associatedObjectForCache);\n    if (entry !== undefined) return entry;\n    /** @type {Map<string, ParsedResource>} */\n\n    const map = new Map();\n    cache.set(associatedObjectForCache, map);\n    return map;\n  };\n  /**\n   * @param {string} str the path with query and fragment\n   * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n   * @returns {ParsedResource} parsed parts\n   */\n\n\n  const fn = (str, associatedObjectForCache) => {\n    if (!associatedObjectForCache) return realFn(str);\n    const cache = getCache(associatedObjectForCache);\n    const entry = cache.get(str);\n    if (entry !== undefined) return entry;\n    const result = realFn(str);\n    cache.set(str, result);\n    return result;\n  };\n\n  fn.bindCache = associatedObjectForCache => {\n    const cache = getCache(associatedObjectForCache);\n    return str => {\n      const entry = cache.get(str);\n      if (entry !== undefined) return entry;\n      const result = realFn(str);\n      cache.set(str, result);\n      return result;\n    };\n  };\n\n  return fn;\n};\n\nconst makeCacheableWithContext = fn => {\n  /** @type {WeakMap<object, Map<string, Map<string, string>>>} */\n  const cache = new WeakMap();\n  /**\n   * @param {string} context context used to create relative path\n   * @param {string} identifier identifier used to create relative path\n   * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n   * @returns {string} the returned relative path\n   */\n\n  const cachedFn = (context, identifier, associatedObjectForCache) => {\n    if (!associatedObjectForCache) return fn(context, identifier);\n    let innerCache = cache.get(associatedObjectForCache);\n\n    if (innerCache === undefined) {\n      innerCache = new Map();\n      cache.set(associatedObjectForCache, innerCache);\n    }\n\n    let cachedResult;\n    let innerSubCache = innerCache.get(context);\n\n    if (innerSubCache === undefined) {\n      innerCache.set(context, innerSubCache = new Map());\n    } else {\n      cachedResult = innerSubCache.get(identifier);\n    }\n\n    if (cachedResult !== undefined) {\n      return cachedResult;\n    } else {\n      const result = fn(context, identifier);\n      innerSubCache.set(identifier, result);\n      return result;\n    }\n  };\n  /**\n   * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n   * @returns {function(string, string): string} cached function\n   */\n\n\n  cachedFn.bindCache = associatedObjectForCache => {\n    let innerCache;\n\n    if (associatedObjectForCache) {\n      innerCache = cache.get(associatedObjectForCache);\n\n      if (innerCache === undefined) {\n        innerCache = new Map();\n        cache.set(associatedObjectForCache, innerCache);\n      }\n    } else {\n      innerCache = new Map();\n    }\n    /**\n     * @param {string} context context used to create relative path\n     * @param {string} identifier identifier used to create relative path\n     * @returns {string} the returned relative path\n     */\n\n\n    const boundFn = (context, identifier) => {\n      let cachedResult;\n      let innerSubCache = innerCache.get(context);\n\n      if (innerSubCache === undefined) {\n        innerCache.set(context, innerSubCache = new Map());\n      } else {\n        cachedResult = innerSubCache.get(identifier);\n      }\n\n      if (cachedResult !== undefined) {\n        return cachedResult;\n      } else {\n        const result = fn(context, identifier);\n        innerSubCache.set(identifier, result);\n        return result;\n      }\n    };\n\n    return boundFn;\n  };\n  /**\n   * @param {string} context context used to create relative path\n   * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n   * @returns {function(string): string} cached function\n   */\n\n\n  cachedFn.bindContextCache = (context, associatedObjectForCache) => {\n    let innerSubCache;\n\n    if (associatedObjectForCache) {\n      let innerCache = cache.get(associatedObjectForCache);\n\n      if (innerCache === undefined) {\n        innerCache = new Map();\n        cache.set(associatedObjectForCache, innerCache);\n      }\n\n      innerSubCache = innerCache.get(context);\n\n      if (innerSubCache === undefined) {\n        innerCache.set(context, innerSubCache = new Map());\n      }\n    } else {\n      innerSubCache = new Map();\n    }\n    /**\n     * @param {string} identifier identifier used to create relative path\n     * @returns {string} the returned relative path\n     */\n\n\n    const boundFn = identifier => {\n      const cachedResult = innerSubCache.get(identifier);\n\n      if (cachedResult !== undefined) {\n        return cachedResult;\n      } else {\n        const result = fn(context, identifier);\n        innerSubCache.set(identifier, result);\n        return result;\n      }\n    };\n\n    return boundFn;\n  };\n\n  return cachedFn;\n};\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\n\n\nconst _makePathsRelative = (context, identifier) => {\n  return identifier.split(SEGMENTS_SPLIT_REGEXP).map(str => absoluteToRequest(context, str)).join(\"\");\n};\n\nexports.makePathsRelative = makeCacheableWithContext(_makePathsRelative);\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\n\nconst _makePathsAbsolute = (context, identifier) => {\n  return identifier.split(SEGMENTS_SPLIT_REGEXP).map(str => requestToAbsolute(context, str)).join(\"\");\n};\n\nexports.makePathsAbsolute = makeCacheableWithContext(_makePathsAbsolute);\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string may containing absolute paths, query string, etc.\n * @returns {string} a new request string avoiding absolute paths when possible\n */\n\nconst _contextify = (context, request) => {\n  return request.split(\"!\").map(r => absoluteToRequest(context, r)).join(\"!\");\n};\n\nconst contextify = makeCacheableWithContext(_contextify);\nexports.contextify = contextify;\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string\n * @returns {string} a new request string using absolute paths when possible\n */\n\nconst _absolutify = (context, request) => {\n  return request.split(\"!\").map(r => requestToAbsolute(context, r)).join(\"!\");\n};\n\nconst absolutify = makeCacheableWithContext(_absolutify);\nexports.absolutify = absolutify;\nconst PATH_QUERY_FRAGMENT_REGEXP = /^((?:\\0.|[^?#\\0])*)(\\?(?:\\0.|[^#\\0])*)?(#.*)?$/;\nconst PATH_QUERY_REGEXP = /^((?:\\0.|[^?\\0])*)(\\?.*)?$/;\n/** @typedef {{ resource: string, path: string, query: string, fragment: string }} ParsedResource */\n\n/** @typedef {{ resource: string, path: string, query: string }} ParsedResourceWithoutFragment */\n\n/**\n * @param {string} str the path with query and fragment\n * @returns {ParsedResource} parsed parts\n */\n\nconst _parseResource = str => {\n  const match = PATH_QUERY_FRAGMENT_REGEXP.exec(str);\n  return {\n    resource: str,\n    path: match[1].replace(/\\0(.)/g, \"$1\"),\n    query: match[2] ? match[2].replace(/\\0(.)/g, \"$1\") : \"\",\n    fragment: match[3] || \"\"\n  };\n};\n\nexports.parseResource = makeCacheable(_parseResource);\n/**\n * Parse resource, skips fragment part\n * @param {string} str the path with query and fragment\n * @returns {ParsedResourceWithoutFragment} parsed parts\n */\n\nconst _parseResourceWithoutFragment = str => {\n  const match = PATH_QUERY_REGEXP.exec(str);\n  return {\n    resource: str,\n    path: match[1].replace(/\\0(.)/g, \"$1\"),\n    query: match[2] ? match[2].replace(/\\0(.)/g, \"$1\") : \"\"\n  };\n};\n\nexports.parseResourceWithoutFragment = makeCacheable(_parseResourceWithoutFragment);\n/**\n * @param {string} filename the filename which should be undone\n * @param {string} outputPath the output path that is restored (only relevant when filename contains \"..\")\n * @param {boolean} enforceRelative true returns ./ for empty paths\n * @returns {string} repeated ../ to leave the directory of the provided filename to be back on output dir\n */\n\nexports.getUndoPath = (filename, outputPath, enforceRelative) => {\n  let depth = -1;\n  let append = \"\";\n  outputPath = outputPath.replace(/[\\\\/]$/, \"\");\n\n  for (const part of filename.split(/[/\\\\]+/)) {\n    if (part === \"..\") {\n      if (depth > -1) {\n        depth--;\n      } else {\n        const i = outputPath.lastIndexOf(\"/\");\n        const j = outputPath.lastIndexOf(\"\\\\\");\n        const pos = i < 0 ? j : j < 0 ? i : Math.max(i, j);\n        if (pos < 0) return outputPath + \"/\";\n        append = outputPath.slice(pos + 1) + \"/\" + append;\n        outputPath = outputPath.slice(0, pos);\n      }\n    } else if (part !== \".\") {\n      depth++;\n    }\n  }\n\n  return depth > 0 ? `${\"../\".repeat(depth)}${append}` : enforceRelative ? `./${append}` : append;\n};","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/util/identifier.js"],"names":["path","require","WINDOWS_ABS_PATH_REGEXP","SEGMENTS_SPLIT_REGEXP","WINDOWS_PATH_SEPARATOR_REGEXP","relativePathToRequest","relativePath","startsWith","absoluteToRequest","context","maybeAbsolutePath","length","querySplitPos","indexOf","resource","slice","posix","relative","test","win32","replace","requestToAbsolute","join","makeCacheable","realFn","cache","WeakMap","getCache","associatedObjectForCache","entry","get","undefined","map","Map","set","fn","str","result","bindCache","makeCacheableWithContext","cachedFn","identifier","innerCache","cachedResult","innerSubCache","boundFn","bindContextCache","_makePathsRelative","split","exports","makePathsRelative","_makePathsAbsolute","makePathsAbsolute","_contextify","request","r","contextify","_absolutify","absolutify","PATH_QUERY_FRAGMENT_REGEXP","PATH_QUERY_REGEXP","_parseResource","match","exec","query","fragment","parseResource","_parseResourceWithoutFragment","parseResourceWithoutFragment","getUndoPath","filename","outputPath","enforceRelative","depth","append","part","i","lastIndexOf","j","pos","Math","max","repeat"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\n\nconst WINDOWS_ABS_PATH_REGEXP = /^[a-zA-Z]:[\\\\/]/;\nconst SEGMENTS_SPLIT_REGEXP = /([|!])/;\nconst WINDOWS_PATH_SEPARATOR_REGEXP = /\\\\/g;\n\n/**\n * @typedef {Object} MakeRelativePathsCache\n * @property {Map<string, Map<string, string>>=} relativePaths\n */\n\nconst relativePathToRequest = relativePath => {\n\tif (relativePath === \"\") return \"./.\";\n\tif (relativePath === \"..\") return \"../.\";\n\tif (relativePath.startsWith(\"../\")) return relativePath;\n\treturn `./${relativePath}`;\n};\n\n/**\n * @param {string} context context for relative path\n * @param {string} maybeAbsolutePath path to make relative\n * @returns {string} relative path in request style\n */\nconst absoluteToRequest = (context, maybeAbsolutePath) => {\n\tif (maybeAbsolutePath[0] === \"/\") {\n\t\tif (\n\t\t\tmaybeAbsolutePath.length > 1 &&\n\t\t\tmaybeAbsolutePath[maybeAbsolutePath.length - 1] === \"/\"\n\t\t) {\n\t\t\t// this 'path' is actually a regexp generated by dynamic requires.\n\t\t\t// Don't treat it as an absolute path.\n\t\t\treturn maybeAbsolutePath;\n\t\t}\n\n\t\tconst querySplitPos = maybeAbsolutePath.indexOf(\"?\");\n\t\tlet resource =\n\t\t\tquerySplitPos === -1\n\t\t\t\t? maybeAbsolutePath\n\t\t\t\t: maybeAbsolutePath.slice(0, querySplitPos);\n\t\tresource = relativePathToRequest(path.posix.relative(context, resource));\n\t\treturn querySplitPos === -1\n\t\t\t? resource\n\t\t\t: resource + maybeAbsolutePath.slice(querySplitPos);\n\t}\n\n\tif (WINDOWS_ABS_PATH_REGEXP.test(maybeAbsolutePath)) {\n\t\tconst querySplitPos = maybeAbsolutePath.indexOf(\"?\");\n\t\tlet resource =\n\t\t\tquerySplitPos === -1\n\t\t\t\t? maybeAbsolutePath\n\t\t\t\t: maybeAbsolutePath.slice(0, querySplitPos);\n\t\tresource = path.win32.relative(context, resource);\n\t\tif (!WINDOWS_ABS_PATH_REGEXP.test(resource)) {\n\t\t\tresource = relativePathToRequest(\n\t\t\t\tresource.replace(WINDOWS_PATH_SEPARATOR_REGEXP, \"/\")\n\t\t\t);\n\t\t}\n\t\treturn querySplitPos === -1\n\t\t\t? resource\n\t\t\t: resource + maybeAbsolutePath.slice(querySplitPos);\n\t}\n\n\t// not an absolute path\n\treturn maybeAbsolutePath;\n};\n\n/**\n * @param {string} context context for relative path\n * @param {string} relativePath path\n * @returns {string} absolute path\n */\nconst requestToAbsolute = (context, relativePath) => {\n\tif (relativePath.startsWith(\"./\") || relativePath.startsWith(\"../\"))\n\t\treturn path.join(context, relativePath);\n\treturn relativePath;\n};\n\nconst makeCacheable = realFn => {\n\t/** @type {WeakMap<object, Map<string, ParsedResource>>} */\n\tconst cache = new WeakMap();\n\n\tconst getCache = associatedObjectForCache => {\n\t\tconst entry = cache.get(associatedObjectForCache);\n\t\tif (entry !== undefined) return entry;\n\t\t/** @type {Map<string, ParsedResource>} */\n\t\tconst map = new Map();\n\t\tcache.set(associatedObjectForCache, map);\n\t\treturn map;\n\t};\n\n\t/**\n\t * @param {string} str the path with query and fragment\n\t * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n\t * @returns {ParsedResource} parsed parts\n\t */\n\tconst fn = (str, associatedObjectForCache) => {\n\t\tif (!associatedObjectForCache) return realFn(str);\n\t\tconst cache = getCache(associatedObjectForCache);\n\t\tconst entry = cache.get(str);\n\t\tif (entry !== undefined) return entry;\n\t\tconst result = realFn(str);\n\t\tcache.set(str, result);\n\t\treturn result;\n\t};\n\n\tfn.bindCache = associatedObjectForCache => {\n\t\tconst cache = getCache(associatedObjectForCache);\n\t\treturn str => {\n\t\t\tconst entry = cache.get(str);\n\t\t\tif (entry !== undefined) return entry;\n\t\t\tconst result = realFn(str);\n\t\t\tcache.set(str, result);\n\t\t\treturn result;\n\t\t};\n\t};\n\n\treturn fn;\n};\n\nconst makeCacheableWithContext = fn => {\n\t/** @type {WeakMap<object, Map<string, Map<string, string>>>} */\n\tconst cache = new WeakMap();\n\n\t/**\n\t * @param {string} context context used to create relative path\n\t * @param {string} identifier identifier used to create relative path\n\t * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n\t * @returns {string} the returned relative path\n\t */\n\tconst cachedFn = (context, identifier, associatedObjectForCache) => {\n\t\tif (!associatedObjectForCache) return fn(context, identifier);\n\n\t\tlet innerCache = cache.get(associatedObjectForCache);\n\t\tif (innerCache === undefined) {\n\t\t\tinnerCache = new Map();\n\t\t\tcache.set(associatedObjectForCache, innerCache);\n\t\t}\n\n\t\tlet cachedResult;\n\t\tlet innerSubCache = innerCache.get(context);\n\t\tif (innerSubCache === undefined) {\n\t\t\tinnerCache.set(context, (innerSubCache = new Map()));\n\t\t} else {\n\t\t\tcachedResult = innerSubCache.get(identifier);\n\t\t}\n\n\t\tif (cachedResult !== undefined) {\n\t\t\treturn cachedResult;\n\t\t} else {\n\t\t\tconst result = fn(context, identifier);\n\t\t\tinnerSubCache.set(identifier, result);\n\t\t\treturn result;\n\t\t}\n\t};\n\n\t/**\n\t * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n\t * @returns {function(string, string): string} cached function\n\t */\n\tcachedFn.bindCache = associatedObjectForCache => {\n\t\tlet innerCache;\n\t\tif (associatedObjectForCache) {\n\t\t\tinnerCache = cache.get(associatedObjectForCache);\n\t\t\tif (innerCache === undefined) {\n\t\t\t\tinnerCache = new Map();\n\t\t\t\tcache.set(associatedObjectForCache, innerCache);\n\t\t\t}\n\t\t} else {\n\t\t\tinnerCache = new Map();\n\t\t}\n\n\t\t/**\n\t\t * @param {string} context context used to create relative path\n\t\t * @param {string} identifier identifier used to create relative path\n\t\t * @returns {string} the returned relative path\n\t\t */\n\t\tconst boundFn = (context, identifier) => {\n\t\t\tlet cachedResult;\n\t\t\tlet innerSubCache = innerCache.get(context);\n\t\t\tif (innerSubCache === undefined) {\n\t\t\t\tinnerCache.set(context, (innerSubCache = new Map()));\n\t\t\t} else {\n\t\t\t\tcachedResult = innerSubCache.get(identifier);\n\t\t\t}\n\n\t\t\tif (cachedResult !== undefined) {\n\t\t\t\treturn cachedResult;\n\t\t\t} else {\n\t\t\t\tconst result = fn(context, identifier);\n\t\t\t\tinnerSubCache.set(identifier, result);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\n\t\treturn boundFn;\n\t};\n\n\t/**\n\t * @param {string} context context used to create relative path\n\t * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n\t * @returns {function(string): string} cached function\n\t */\n\tcachedFn.bindContextCache = (context, associatedObjectForCache) => {\n\t\tlet innerSubCache;\n\t\tif (associatedObjectForCache) {\n\t\t\tlet innerCache = cache.get(associatedObjectForCache);\n\t\t\tif (innerCache === undefined) {\n\t\t\t\tinnerCache = new Map();\n\t\t\t\tcache.set(associatedObjectForCache, innerCache);\n\t\t\t}\n\n\t\t\tinnerSubCache = innerCache.get(context);\n\t\t\tif (innerSubCache === undefined) {\n\t\t\t\tinnerCache.set(context, (innerSubCache = new Map()));\n\t\t\t}\n\t\t} else {\n\t\t\tinnerSubCache = new Map();\n\t\t}\n\n\t\t/**\n\t\t * @param {string} identifier identifier used to create relative path\n\t\t * @returns {string} the returned relative path\n\t\t */\n\t\tconst boundFn = identifier => {\n\t\t\tconst cachedResult = innerSubCache.get(identifier);\n\t\t\tif (cachedResult !== undefined) {\n\t\t\t\treturn cachedResult;\n\t\t\t} else {\n\t\t\t\tconst result = fn(context, identifier);\n\t\t\t\tinnerSubCache.set(identifier, result);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\n\t\treturn boundFn;\n\t};\n\n\treturn cachedFn;\n};\n\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\nconst _makePathsRelative = (context, identifier) => {\n\treturn identifier\n\t\t.split(SEGMENTS_SPLIT_REGEXP)\n\t\t.map(str => absoluteToRequest(context, str))\n\t\t.join(\"\");\n};\n\nexports.makePathsRelative = makeCacheableWithContext(_makePathsRelative);\n\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\nconst _makePathsAbsolute = (context, identifier) => {\n\treturn identifier\n\t\t.split(SEGMENTS_SPLIT_REGEXP)\n\t\t.map(str => requestToAbsolute(context, str))\n\t\t.join(\"\");\n};\n\nexports.makePathsAbsolute = makeCacheableWithContext(_makePathsAbsolute);\n\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string may containing absolute paths, query string, etc.\n * @returns {string} a new request string avoiding absolute paths when possible\n */\nconst _contextify = (context, request) => {\n\treturn request\n\t\t.split(\"!\")\n\t\t.map(r => absoluteToRequest(context, r))\n\t\t.join(\"!\");\n};\n\nconst contextify = makeCacheableWithContext(_contextify);\nexports.contextify = contextify;\n\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string\n * @returns {string} a new request string using absolute paths when possible\n */\nconst _absolutify = (context, request) => {\n\treturn request\n\t\t.split(\"!\")\n\t\t.map(r => requestToAbsolute(context, r))\n\t\t.join(\"!\");\n};\n\nconst absolutify = makeCacheableWithContext(_absolutify);\nexports.absolutify = absolutify;\n\nconst PATH_QUERY_FRAGMENT_REGEXP =\n\t/^((?:\\0.|[^?#\\0])*)(\\?(?:\\0.|[^#\\0])*)?(#.*)?$/;\nconst PATH_QUERY_REGEXP = /^((?:\\0.|[^?\\0])*)(\\?.*)?$/;\n\n/** @typedef {{ resource: string, path: string, query: string, fragment: string }} ParsedResource */\n/** @typedef {{ resource: string, path: string, query: string }} ParsedResourceWithoutFragment */\n\n/**\n * @param {string} str the path with query and fragment\n * @returns {ParsedResource} parsed parts\n */\nconst _parseResource = str => {\n\tconst match = PATH_QUERY_FRAGMENT_REGEXP.exec(str);\n\treturn {\n\t\tresource: str,\n\t\tpath: match[1].replace(/\\0(.)/g, \"$1\"),\n\t\tquery: match[2] ? match[2].replace(/\\0(.)/g, \"$1\") : \"\",\n\t\tfragment: match[3] || \"\"\n\t};\n};\nexports.parseResource = makeCacheable(_parseResource);\n\n/**\n * Parse resource, skips fragment part\n * @param {string} str the path with query and fragment\n * @returns {ParsedResourceWithoutFragment} parsed parts\n */\nconst _parseResourceWithoutFragment = str => {\n\tconst match = PATH_QUERY_REGEXP.exec(str);\n\treturn {\n\t\tresource: str,\n\t\tpath: match[1].replace(/\\0(.)/g, \"$1\"),\n\t\tquery: match[2] ? match[2].replace(/\\0(.)/g, \"$1\") : \"\"\n\t};\n};\nexports.parseResourceWithoutFragment = makeCacheable(\n\t_parseResourceWithoutFragment\n);\n\n/**\n * @param {string} filename the filename which should be undone\n * @param {string} outputPath the output path that is restored (only relevant when filename contains \"..\")\n * @param {boolean} enforceRelative true returns ./ for empty paths\n * @returns {string} repeated ../ to leave the directory of the provided filename to be back on output dir\n */\nexports.getUndoPath = (filename, outputPath, enforceRelative) => {\n\tlet depth = -1;\n\tlet append = \"\";\n\toutputPath = outputPath.replace(/[\\\\/]$/, \"\");\n\tfor (const part of filename.split(/[/\\\\]+/)) {\n\t\tif (part === \"..\") {\n\t\t\tif (depth > -1) {\n\t\t\t\tdepth--;\n\t\t\t} else {\n\t\t\t\tconst i = outputPath.lastIndexOf(\"/\");\n\t\t\t\tconst j = outputPath.lastIndexOf(\"\\\\\");\n\t\t\t\tconst pos = i < 0 ? j : j < 0 ? i : Math.max(i, j);\n\t\t\t\tif (pos < 0) return outputPath + \"/\";\n\t\t\t\tappend = outputPath.slice(pos + 1) + \"/\" + append;\n\t\t\t\toutputPath = outputPath.slice(0, pos);\n\t\t\t}\n\t\t} else if (part !== \".\") {\n\t\t\tdepth++;\n\t\t}\n\t}\n\treturn depth > 0\n\t\t? `${\"../\".repeat(depth)}${append}`\n\t\t: enforceRelative\n\t\t? `./${append}`\n\t\t: append;\n};\n"]},"metadata":{},"sourceType":"script"}