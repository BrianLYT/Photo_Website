{"ast":null,"code":"function _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nimport * as leb from \"@webassemblyjs/leb128\";\nimport * as ieee754 from \"@webassemblyjs/ieee754\";\nimport * as utf8 from \"@webassemblyjs/utf8\";\nimport constants from \"@webassemblyjs/helper-wasm-bytecode\";\nimport { encodeNode } from \"../index\";\n\nfunction assertNotIdentifierNode(n) {\n  if (n.type === \"Identifier\") {\n    throw new Error(\"Unsupported node Identifier\");\n  }\n}\n\nexport function encodeVersion(v) {\n  var bytes = constants.moduleVersion;\n  bytes[0] = v;\n  return bytes;\n}\nexport function encodeHeader() {\n  return constants.magicModuleHeader;\n}\nexport function encodeU32(v) {\n  var uint8view = new Uint8Array(leb.encodeU32(v));\n\n  var array = _toConsumableArray(uint8view);\n\n  return array;\n}\nexport function encodeI32(v) {\n  var uint8view = new Uint8Array(leb.encodeI32(v));\n\n  var array = _toConsumableArray(uint8view);\n\n  return array;\n}\nexport function encodeI64(v) {\n  var uint8view = new Uint8Array(leb.encodeI64(v));\n\n  var array = _toConsumableArray(uint8view);\n\n  return array;\n}\nexport function encodeVec(elements) {\n  var size = encodeU32(elements.length);\n  return _toConsumableArray(size).concat(_toConsumableArray(elements));\n}\nexport function encodeValtype(v) {\n  var byte = constants.valtypesByString[v];\n\n  if (typeof byte === \"undefined\") {\n    throw new Error(\"Unknown valtype: \" + v);\n  }\n\n  return parseInt(byte, 10);\n}\nexport function encodeMutability(v) {\n  var byte = constants.globalTypesByString[v];\n\n  if (typeof byte === \"undefined\") {\n    throw new Error(\"Unknown mutability: \" + v);\n  }\n\n  return parseInt(byte, 10);\n}\nexport function encodeUTF8Vec(str) {\n  return encodeVec(utf8.encode(str));\n}\nexport function encodeLimits(n) {\n  var out = [];\n\n  if (typeof n.max === \"number\") {\n    out.push(0x01);\n    out.push.apply(out, _toConsumableArray(encodeU32(n.min))); // $FlowIgnore: ensured by the typeof\n\n    out.push.apply(out, _toConsumableArray(encodeU32(n.max)));\n  } else {\n    out.push(0x00);\n    out.push.apply(out, _toConsumableArray(encodeU32(n.min)));\n  }\n\n  return out;\n}\nexport function encodeModuleImport(n) {\n  var out = [];\n  out.push.apply(out, _toConsumableArray(encodeUTF8Vec(n.module)));\n  out.push.apply(out, _toConsumableArray(encodeUTF8Vec(n.name)));\n\n  switch (n.descr.type) {\n    case \"GlobalType\":\n      {\n        out.push(0x03); // $FlowIgnore: GlobalType ensure that these props exists\n\n        out.push(encodeValtype(n.descr.valtype)); // $FlowIgnore: GlobalType ensure that these props exists\n\n        out.push(encodeMutability(n.descr.mutability));\n        break;\n      }\n\n    case \"Memory\":\n      {\n        out.push(0x02); // $FlowIgnore\n\n        out.push.apply(out, _toConsumableArray(encodeLimits(n.descr.limits)));\n        break;\n      }\n\n    case \"Table\":\n      {\n        out.push(0x01);\n        out.push(0x70); // element type\n        // $FlowIgnore\n\n        out.push.apply(out, _toConsumableArray(encodeLimits(n.descr.limits)));\n        break;\n      }\n\n    case \"FuncImportDescr\":\n      {\n        out.push(0x00); // $FlowIgnore\n\n        assertNotIdentifierNode(n.descr.id); // $FlowIgnore\n\n        out.push.apply(out, _toConsumableArray(encodeU32(n.descr.id.value)));\n        break;\n      }\n\n    default:\n      throw new Error(\"Unsupport operation: encode module import of type: \" + n.descr.type);\n  }\n\n  return out;\n}\nexport function encodeSectionMetadata(n) {\n  var out = [];\n  var sectionId = constants.sections[n.section];\n\n  if (typeof sectionId === \"undefined\") {\n    throw new Error(\"Unknown section: \" + n.section);\n  }\n\n  if (n.section === \"start\") {\n    /**\n     * This is not implemented yet because it's a special case which\n     * doesn't have a vector in its section.\n     */\n    throw new Error(\"Unsupported section encoding of type start\");\n  }\n\n  out.push(sectionId);\n  out.push.apply(out, _toConsumableArray(encodeU32(n.size.value)));\n  out.push.apply(out, _toConsumableArray(encodeU32(n.vectorOfSize.value)));\n  return out;\n}\nexport function encodeCallInstruction(n) {\n  var out = [];\n  assertNotIdentifierNode(n.index);\n  out.push(0x10); // $FlowIgnore\n\n  out.push.apply(out, _toConsumableArray(encodeU32(n.index.value)));\n  return out;\n}\nexport function encodeCallIndirectInstruction(n) {\n  var out = []; // $FlowIgnore\n\n  assertNotIdentifierNode(n.index);\n  out.push(0x11); // $FlowIgnore\n\n  out.push.apply(out, _toConsumableArray(encodeU32(n.index.value))); // add a reserved byte\n\n  out.push(0x00);\n  return out;\n}\nexport function encodeModuleExport(n) {\n  var out = [];\n  assertNotIdentifierNode(n.descr.id);\n  var exportTypeByteString = constants.exportTypesByName[n.descr.exportType];\n\n  if (typeof exportTypeByteString === \"undefined\") {\n    throw new Error(\"Unknown export of type: \" + n.descr.exportType);\n  }\n\n  var exportTypeByte = parseInt(exportTypeByteString, 10);\n  out.push.apply(out, _toConsumableArray(encodeUTF8Vec(n.name)));\n  out.push(exportTypeByte); // $FlowIgnore\n\n  out.push.apply(out, _toConsumableArray(encodeU32(n.descr.id.value)));\n  return out;\n}\nexport function encodeTypeInstruction(n) {\n  var out = [0x60];\n  var params = n.functype.params.map(function (x) {\n    return x.valtype;\n  }).map(encodeValtype);\n  var results = n.functype.results.map(encodeValtype);\n  out.push.apply(out, _toConsumableArray(encodeVec(params)));\n  out.push.apply(out, _toConsumableArray(encodeVec(results)));\n  return out;\n}\nexport function encodeInstr(n) {\n  var out = [];\n  var instructionName = n.id;\n\n  if (typeof n.object === \"string\") {\n    instructionName = \"\".concat(n.object, \".\").concat(String(n.id));\n  }\n\n  var byteString = constants.symbolsByName[instructionName];\n\n  if (typeof byteString === \"undefined\") {\n    throw new Error(\"encodeInstr: unknown instruction \" + JSON.stringify(instructionName));\n  }\n\n  var byte = parseInt(byteString, 10);\n  out.push(byte);\n\n  if (n.args) {\n    n.args.forEach(function (arg) {\n      var encoder = encodeU32; // find correct encoder\n\n      if (n.object === \"i32\") {\n        encoder = encodeI32;\n      }\n\n      if (n.object === \"i64\") {\n        encoder = encodeI64;\n      }\n\n      if (n.object === \"f32\") {\n        encoder = ieee754.encodeF32;\n      }\n\n      if (n.object === \"f64\") {\n        encoder = ieee754.encodeF64;\n      }\n\n      if (arg.type === \"NumberLiteral\" || arg.type === \"FloatLiteral\" || arg.type === \"LongNumberLiteral\") {\n        // $FlowIgnore\n        out.push.apply(out, _toConsumableArray(encoder(arg.value)));\n      } else {\n        throw new Error(\"Unsupported instruction argument encoding \" + JSON.stringify(arg.type));\n      }\n    });\n  }\n\n  return out;\n}\n\nfunction encodeExpr(instrs) {\n  var out = [];\n  instrs.forEach(function (instr) {\n    // $FlowIgnore\n    var n = encodeNode(instr);\n    out.push.apply(out, _toConsumableArray(n));\n  });\n  return out;\n}\n\nexport function encodeStringLiteral(n) {\n  return encodeUTF8Vec(n.value);\n}\nexport function encodeGlobal(n) {\n  var out = [];\n  var _n$globalType = n.globalType,\n      valtype = _n$globalType.valtype,\n      mutability = _n$globalType.mutability;\n  out.push(encodeValtype(valtype));\n  out.push(encodeMutability(mutability));\n  out.push.apply(out, _toConsumableArray(encodeExpr(n.init)));\n  return out;\n}\nexport function encodeFuncBody(n) {\n  var out = [];\n  out.push(-1); // temporary function body size\n  // FIXME(sven): get the func locals?\n\n  var localBytes = encodeVec([]);\n  out.push.apply(out, _toConsumableArray(localBytes));\n  var funcBodyBytes = encodeExpr(n.body);\n  out[0] = funcBodyBytes.length + localBytes.length;\n  out.push.apply(out, _toConsumableArray(funcBodyBytes));\n  return out;\n}\nexport function encodeIndexInFuncSection(n) {\n  assertNotIdentifierNode(n.index); // $FlowIgnore\n\n  return encodeU32(n.index.value);\n}\nexport function encodeElem(n) {\n  var out = [];\n  assertNotIdentifierNode(n.table); // $FlowIgnore\n\n  out.push.apply(out, _toConsumableArray(encodeU32(n.table.value)));\n  out.push.apply(out, _toConsumableArray(encodeExpr(n.offset))); // $FlowIgnore\n\n  var funcs = n.funcs.reduce(function (acc, x) {\n    return _toConsumableArray(acc).concat(_toConsumableArray(encodeU32(x.value)));\n  }, []);\n  out.push.apply(out, _toConsumableArray(encodeVec(funcs)));\n  return out;\n}","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/@webassemblyjs/wasm-gen/esm/encoder/index.js"],"names":["_toConsumableArray","arr","Array","isArray","i","arr2","length","from","leb","ieee754","utf8","constants","encodeNode","assertNotIdentifierNode","n","type","Error","encodeVersion","v","bytes","moduleVersion","encodeHeader","magicModuleHeader","encodeU32","uint8view","Uint8Array","array","encodeI32","encodeI64","encodeVec","elements","size","concat","encodeValtype","byte","valtypesByString","parseInt","encodeMutability","globalTypesByString","encodeUTF8Vec","str","encode","encodeLimits","out","max","push","apply","min","encodeModuleImport","module","name","descr","valtype","mutability","limits","id","value","encodeSectionMetadata","sectionId","sections","section","vectorOfSize","encodeCallInstruction","index","encodeCallIndirectInstruction","encodeModuleExport","exportTypeByteString","exportTypesByName","exportType","exportTypeByte","encodeTypeInstruction","params","functype","map","x","results","encodeInstr","instructionName","object","String","byteString","symbolsByName","JSON","stringify","args","forEach","arg","encoder","encodeF32","encodeF64","encodeExpr","instrs","instr","encodeStringLiteral","encodeGlobal","_n$globalType","globalType","init","encodeFuncBody","localBytes","funcBodyBytes","body","encodeIndexInFuncSection","encodeElem","table","offset","funcs","reduce","acc"],"mappings":"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","sourcesContent":["function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nimport * as leb from \"@webassemblyjs/leb128\";\nimport * as ieee754 from \"@webassemblyjs/ieee754\";\nimport * as utf8 from \"@webassemblyjs/utf8\";\nimport constants from \"@webassemblyjs/helper-wasm-bytecode\";\nimport { encodeNode } from \"../index\";\n\nfunction assertNotIdentifierNode(n) {\n  if (n.type === \"Identifier\") {\n    throw new Error(\"Unsupported node Identifier\");\n  }\n}\n\nexport function encodeVersion(v) {\n  var bytes = constants.moduleVersion;\n  bytes[0] = v;\n  return bytes;\n}\nexport function encodeHeader() {\n  return constants.magicModuleHeader;\n}\nexport function encodeU32(v) {\n  var uint8view = new Uint8Array(leb.encodeU32(v));\n\n  var array = _toConsumableArray(uint8view);\n\n  return array;\n}\nexport function encodeI32(v) {\n  var uint8view = new Uint8Array(leb.encodeI32(v));\n\n  var array = _toConsumableArray(uint8view);\n\n  return array;\n}\nexport function encodeI64(v) {\n  var uint8view = new Uint8Array(leb.encodeI64(v));\n\n  var array = _toConsumableArray(uint8view);\n\n  return array;\n}\nexport function encodeVec(elements) {\n  var size = encodeU32(elements.length);\n  return _toConsumableArray(size).concat(_toConsumableArray(elements));\n}\nexport function encodeValtype(v) {\n  var byte = constants.valtypesByString[v];\n\n  if (typeof byte === \"undefined\") {\n    throw new Error(\"Unknown valtype: \" + v);\n  }\n\n  return parseInt(byte, 10);\n}\nexport function encodeMutability(v) {\n  var byte = constants.globalTypesByString[v];\n\n  if (typeof byte === \"undefined\") {\n    throw new Error(\"Unknown mutability: \" + v);\n  }\n\n  return parseInt(byte, 10);\n}\nexport function encodeUTF8Vec(str) {\n  return encodeVec(utf8.encode(str));\n}\nexport function encodeLimits(n) {\n  var out = [];\n\n  if (typeof n.max === \"number\") {\n    out.push(0x01);\n    out.push.apply(out, _toConsumableArray(encodeU32(n.min))); // $FlowIgnore: ensured by the typeof\n\n    out.push.apply(out, _toConsumableArray(encodeU32(n.max)));\n  } else {\n    out.push(0x00);\n    out.push.apply(out, _toConsumableArray(encodeU32(n.min)));\n  }\n\n  return out;\n}\nexport function encodeModuleImport(n) {\n  var out = [];\n  out.push.apply(out, _toConsumableArray(encodeUTF8Vec(n.module)));\n  out.push.apply(out, _toConsumableArray(encodeUTF8Vec(n.name)));\n\n  switch (n.descr.type) {\n    case \"GlobalType\":\n      {\n        out.push(0x03); // $FlowIgnore: GlobalType ensure that these props exists\n\n        out.push(encodeValtype(n.descr.valtype)); // $FlowIgnore: GlobalType ensure that these props exists\n\n        out.push(encodeMutability(n.descr.mutability));\n        break;\n      }\n\n    case \"Memory\":\n      {\n        out.push(0x02); // $FlowIgnore\n\n        out.push.apply(out, _toConsumableArray(encodeLimits(n.descr.limits)));\n        break;\n      }\n\n    case \"Table\":\n      {\n        out.push(0x01);\n        out.push(0x70); // element type\n        // $FlowIgnore\n\n        out.push.apply(out, _toConsumableArray(encodeLimits(n.descr.limits)));\n        break;\n      }\n\n    case \"FuncImportDescr\":\n      {\n        out.push(0x00); // $FlowIgnore\n\n        assertNotIdentifierNode(n.descr.id); // $FlowIgnore\n\n        out.push.apply(out, _toConsumableArray(encodeU32(n.descr.id.value)));\n        break;\n      }\n\n    default:\n      throw new Error(\"Unsupport operation: encode module import of type: \" + n.descr.type);\n  }\n\n  return out;\n}\nexport function encodeSectionMetadata(n) {\n  var out = [];\n  var sectionId = constants.sections[n.section];\n\n  if (typeof sectionId === \"undefined\") {\n    throw new Error(\"Unknown section: \" + n.section);\n  }\n\n  if (n.section === \"start\") {\n    /**\n     * This is not implemented yet because it's a special case which\n     * doesn't have a vector in its section.\n     */\n    throw new Error(\"Unsupported section encoding of type start\");\n  }\n\n  out.push(sectionId);\n  out.push.apply(out, _toConsumableArray(encodeU32(n.size.value)));\n  out.push.apply(out, _toConsumableArray(encodeU32(n.vectorOfSize.value)));\n  return out;\n}\nexport function encodeCallInstruction(n) {\n  var out = [];\n  assertNotIdentifierNode(n.index);\n  out.push(0x10); // $FlowIgnore\n\n  out.push.apply(out, _toConsumableArray(encodeU32(n.index.value)));\n  return out;\n}\nexport function encodeCallIndirectInstruction(n) {\n  var out = []; // $FlowIgnore\n\n  assertNotIdentifierNode(n.index);\n  out.push(0x11); // $FlowIgnore\n\n  out.push.apply(out, _toConsumableArray(encodeU32(n.index.value))); // add a reserved byte\n\n  out.push(0x00);\n  return out;\n}\nexport function encodeModuleExport(n) {\n  var out = [];\n  assertNotIdentifierNode(n.descr.id);\n  var exportTypeByteString = constants.exportTypesByName[n.descr.exportType];\n\n  if (typeof exportTypeByteString === \"undefined\") {\n    throw new Error(\"Unknown export of type: \" + n.descr.exportType);\n  }\n\n  var exportTypeByte = parseInt(exportTypeByteString, 10);\n  out.push.apply(out, _toConsumableArray(encodeUTF8Vec(n.name)));\n  out.push(exportTypeByte); // $FlowIgnore\n\n  out.push.apply(out, _toConsumableArray(encodeU32(n.descr.id.value)));\n  return out;\n}\nexport function encodeTypeInstruction(n) {\n  var out = [0x60];\n  var params = n.functype.params.map(function (x) {\n    return x.valtype;\n  }).map(encodeValtype);\n  var results = n.functype.results.map(encodeValtype);\n  out.push.apply(out, _toConsumableArray(encodeVec(params)));\n  out.push.apply(out, _toConsumableArray(encodeVec(results)));\n  return out;\n}\nexport function encodeInstr(n) {\n  var out = [];\n  var instructionName = n.id;\n\n  if (typeof n.object === \"string\") {\n    instructionName = \"\".concat(n.object, \".\").concat(String(n.id));\n  }\n\n  var byteString = constants.symbolsByName[instructionName];\n\n  if (typeof byteString === \"undefined\") {\n    throw new Error(\"encodeInstr: unknown instruction \" + JSON.stringify(instructionName));\n  }\n\n  var byte = parseInt(byteString, 10);\n  out.push(byte);\n\n  if (n.args) {\n    n.args.forEach(function (arg) {\n      var encoder = encodeU32; // find correct encoder\n\n      if (n.object === \"i32\") {\n        encoder = encodeI32;\n      }\n\n      if (n.object === \"i64\") {\n        encoder = encodeI64;\n      }\n\n      if (n.object === \"f32\") {\n        encoder = ieee754.encodeF32;\n      }\n\n      if (n.object === \"f64\") {\n        encoder = ieee754.encodeF64;\n      }\n\n      if (arg.type === \"NumberLiteral\" || arg.type === \"FloatLiteral\" || arg.type === \"LongNumberLiteral\") {\n        // $FlowIgnore\n        out.push.apply(out, _toConsumableArray(encoder(arg.value)));\n      } else {\n        throw new Error(\"Unsupported instruction argument encoding \" + JSON.stringify(arg.type));\n      }\n    });\n  }\n\n  return out;\n}\n\nfunction encodeExpr(instrs) {\n  var out = [];\n  instrs.forEach(function (instr) {\n    // $FlowIgnore\n    var n = encodeNode(instr);\n    out.push.apply(out, _toConsumableArray(n));\n  });\n  return out;\n}\n\nexport function encodeStringLiteral(n) {\n  return encodeUTF8Vec(n.value);\n}\nexport function encodeGlobal(n) {\n  var out = [];\n  var _n$globalType = n.globalType,\n      valtype = _n$globalType.valtype,\n      mutability = _n$globalType.mutability;\n  out.push(encodeValtype(valtype));\n  out.push(encodeMutability(mutability));\n  out.push.apply(out, _toConsumableArray(encodeExpr(n.init)));\n  return out;\n}\nexport function encodeFuncBody(n) {\n  var out = [];\n  out.push(-1); // temporary function body size\n  // FIXME(sven): get the func locals?\n\n  var localBytes = encodeVec([]);\n  out.push.apply(out, _toConsumableArray(localBytes));\n  var funcBodyBytes = encodeExpr(n.body);\n  out[0] = funcBodyBytes.length + localBytes.length;\n  out.push.apply(out, _toConsumableArray(funcBodyBytes));\n  return out;\n}\nexport function encodeIndexInFuncSection(n) {\n  assertNotIdentifierNode(n.index); // $FlowIgnore\n\n  return encodeU32(n.index.value);\n}\nexport function encodeElem(n) {\n  var out = [];\n  assertNotIdentifierNode(n.table); // $FlowIgnore\n\n  out.push.apply(out, _toConsumableArray(encodeU32(n.table.value)));\n  out.push.apply(out, _toConsumableArray(encodeExpr(n.offset))); // $FlowIgnore\n\n  var funcs = n.funcs.reduce(function (acc, x) {\n    return _toConsumableArray(acc).concat(_toConsumableArray(encodeU32(x.value)));\n  }, []);\n  out.push.apply(out, _toConsumableArray(encodeVec(funcs)));\n  return out;\n}"]},"metadata":{},"sourceType":"module"}