{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\n/** @typedef {import(\"./MultiCompiler\")} MultiCompiler */\n\n/** @typedef {import(\"./Watching\")} Watching */\n\n/**\n * @template T\n * @callback Callback\n * @param {(Error | null)=} err\n * @param {T=} result\n */\n\n\nclass MultiWatching {\n  /**\n   * @param {Watching[]} watchings child compilers' watchers\n   * @param {MultiCompiler} compiler the compiler\n   */\n  constructor(watchings, compiler) {\n    this.watchings = watchings;\n    this.compiler = compiler;\n  }\n\n  invalidate(callback) {\n    if (callback) {\n      asyncLib.each(this.watchings, (watching, callback) => watching.invalidate(callback), callback);\n    } else {\n      for (const watching of this.watchings) {\n        watching.invalidate();\n      }\n    }\n  }\n\n  suspend() {\n    for (const watching of this.watchings) {\n      watching.suspend();\n    }\n  }\n\n  resume() {\n    for (const watching of this.watchings) {\n      watching.resume();\n    }\n  }\n  /**\n   * @param {Callback<void>} callback signals when the watcher is closed\n   * @returns {void}\n   */\n\n\n  close(callback) {\n    asyncLib.forEach(this.watchings, (watching, finishedCallback) => {\n      watching.close(finishedCallback);\n    }, err => {\n      this.compiler.hooks.watchClose.call();\n\n      if (typeof callback === \"function\") {\n        this.compiler.running = false;\n        callback(err);\n      }\n    });\n  }\n\n}\n\nmodule.exports = MultiWatching;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/MultiWatching.js"],"names":["asyncLib","require","MultiWatching","constructor","watchings","compiler","invalidate","callback","each","watching","suspend","resume","close","forEach","finishedCallback","err","hooks","watchClose","call","running","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,WAAD,CAAxB;AAEA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMC,aAAN,CAAoB;AACnB;AACD;AACA;AACA;AACCC,EAAAA,WAAW,CAACC,SAAD,EAAYC,QAAZ,EAAsB;AAChC,SAAKD,SAAL,GAAiBA,SAAjB;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA;;AAEDC,EAAAA,UAAU,CAACC,QAAD,EAAW;AACpB,QAAIA,QAAJ,EAAc;AACbP,MAAAA,QAAQ,CAACQ,IAAT,CACC,KAAKJ,SADN,EAEC,CAACK,QAAD,EAAWF,QAAX,KAAwBE,QAAQ,CAACH,UAAT,CAAoBC,QAApB,CAFzB,EAGCA,QAHD;AAKA,KAND,MAMO;AACN,WAAK,MAAME,QAAX,IAAuB,KAAKL,SAA5B,EAAuC;AACtCK,QAAAA,QAAQ,CAACH,UAAT;AACA;AACD;AACD;;AAEDI,EAAAA,OAAO,GAAG;AACT,SAAK,MAAMD,QAAX,IAAuB,KAAKL,SAA5B,EAAuC;AACtCK,MAAAA,QAAQ,CAACC,OAAT;AACA;AACD;;AAEDC,EAAAA,MAAM,GAAG;AACR,SAAK,MAAMF,QAAX,IAAuB,KAAKL,SAA5B,EAAuC;AACtCK,MAAAA,QAAQ,CAACE,MAAT;AACA;AACD;AAED;AACD;AACA;AACA;;;AACCC,EAAAA,KAAK,CAACL,QAAD,EAAW;AACfP,IAAAA,QAAQ,CAACa,OAAT,CACC,KAAKT,SADN,EAEC,CAACK,QAAD,EAAWK,gBAAX,KAAgC;AAC/BL,MAAAA,QAAQ,CAACG,KAAT,CAAeE,gBAAf;AACA,KAJF,EAKCC,GAAG,IAAI;AACN,WAAKV,QAAL,CAAcW,KAAd,CAAoBC,UAApB,CAA+BC,IAA/B;;AACA,UAAI,OAAOX,QAAP,KAAoB,UAAxB,EAAoC;AACnC,aAAKF,QAAL,CAAcc,OAAd,GAAwB,KAAxB;AACAZ,QAAAA,QAAQ,CAACQ,GAAD,CAAR;AACA;AACD,KAXF;AAaA;;AAtDkB;;AAyDpBK,MAAM,CAACC,OAAP,GAAiBnB,aAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\n\n/** @typedef {import(\"./MultiCompiler\")} MultiCompiler */\n/** @typedef {import(\"./Watching\")} Watching */\n\n/**\n * @template T\n * @callback Callback\n * @param {(Error | null)=} err\n * @param {T=} result\n */\n\nclass MultiWatching {\n\t/**\n\t * @param {Watching[]} watchings child compilers' watchers\n\t * @param {MultiCompiler} compiler the compiler\n\t */\n\tconstructor(watchings, compiler) {\n\t\tthis.watchings = watchings;\n\t\tthis.compiler = compiler;\n\t}\n\n\tinvalidate(callback) {\n\t\tif (callback) {\n\t\t\tasyncLib.each(\n\t\t\t\tthis.watchings,\n\t\t\t\t(watching, callback) => watching.invalidate(callback),\n\t\t\t\tcallback\n\t\t\t);\n\t\t} else {\n\t\t\tfor (const watching of this.watchings) {\n\t\t\t\twatching.invalidate();\n\t\t\t}\n\t\t}\n\t}\n\n\tsuspend() {\n\t\tfor (const watching of this.watchings) {\n\t\t\twatching.suspend();\n\t\t}\n\t}\n\n\tresume() {\n\t\tfor (const watching of this.watchings) {\n\t\t\twatching.resume();\n\t\t}\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the watcher is closed\n\t * @returns {void}\n\t */\n\tclose(callback) {\n\t\tasyncLib.forEach(\n\t\t\tthis.watchings,\n\t\t\t(watching, finishedCallback) => {\n\t\t\t\twatching.close(finishedCallback);\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tthis.compiler.hooks.watchClose.call();\n\t\t\t\tif (typeof callback === \"function\") {\n\t\t\t\t\tthis.compiler.running = false;\n\t\t\t\t\tcallback(err);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = MultiWatching;\n"]},"metadata":{},"sourceType":"script"}