{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/** @typedef {import(\"./RuleSetCompiler\")} RuleSetCompiler */\n\n/** @typedef {import(\"./RuleSetCompiler\").RuleCondition} RuleCondition */\n\nclass ObjectMatcherRulePlugin {\n  constructor(ruleProperty, dataProperty) {\n    this.ruleProperty = ruleProperty;\n    this.dataProperty = dataProperty || ruleProperty;\n  }\n  /**\n   * @param {RuleSetCompiler} ruleSetCompiler the rule set compiler\n   * @returns {void}\n   */\n\n\n  apply(ruleSetCompiler) {\n    const {\n      ruleProperty,\n      dataProperty\n    } = this;\n    ruleSetCompiler.hooks.rule.tap(\"ObjectMatcherRulePlugin\", (path, rule, unhandledProperties, result) => {\n      if (unhandledProperties.has(ruleProperty)) {\n        unhandledProperties.delete(ruleProperty);\n        const value = rule[ruleProperty];\n\n        for (const property of Object.keys(value)) {\n          const nestedDataProperties = property.split(\".\");\n          const condition = ruleSetCompiler.compileCondition(`${path}.${ruleProperty}.${property}`, value[property]);\n          result.conditions.push({\n            property: [dataProperty, ...nestedDataProperties],\n            matchWhenEmpty: condition.matchWhenEmpty,\n            fn: condition.fn\n          });\n        }\n      }\n    });\n  }\n\n}\n\nmodule.exports = ObjectMatcherRulePlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/rules/ObjectMatcherRulePlugin.js"],"names":["ObjectMatcherRulePlugin","constructor","ruleProperty","dataProperty","apply","ruleSetCompiler","hooks","rule","tap","path","unhandledProperties","result","has","delete","value","property","Object","keys","nestedDataProperties","split","condition","compileCondition","conditions","push","matchWhenEmpty","fn","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;AAEA;;AACA;;AAEA,MAAMA,uBAAN,CAA8B;AAC7BC,EAAAA,WAAW,CAACC,YAAD,EAAeC,YAAf,EAA6B;AACvC,SAAKD,YAAL,GAAoBA,YAApB;AACA,SAAKC,YAAL,GAAoBA,YAAY,IAAID,YAApC;AACA;AAED;AACD;AACA;AACA;;;AACCE,EAAAA,KAAK,CAACC,eAAD,EAAkB;AACtB,UAAM;AAAEH,MAAAA,YAAF;AAAgBC,MAAAA;AAAhB,QAAiC,IAAvC;AACAE,IAAAA,eAAe,CAACC,KAAhB,CAAsBC,IAAtB,CAA2BC,GAA3B,CACC,yBADD,EAEC,CAACC,IAAD,EAAOF,IAAP,EAAaG,mBAAb,EAAkCC,MAAlC,KAA6C;AAC5C,UAAID,mBAAmB,CAACE,GAApB,CAAwBV,YAAxB,CAAJ,EAA2C;AAC1CQ,QAAAA,mBAAmB,CAACG,MAApB,CAA2BX,YAA3B;AACA,cAAMY,KAAK,GAAGP,IAAI,CAACL,YAAD,CAAlB;;AACA,aAAK,MAAMa,QAAX,IAAuBC,MAAM,CAACC,IAAP,CAAYH,KAAZ,CAAvB,EAA2C;AAC1C,gBAAMI,oBAAoB,GAAGH,QAAQ,CAACI,KAAT,CAAe,GAAf,CAA7B;AACA,gBAAMC,SAAS,GAAGf,eAAe,CAACgB,gBAAhB,CAChB,GAAEZ,IAAK,IAAGP,YAAa,IAAGa,QAAS,EADnB,EAEjBD,KAAK,CAACC,QAAD,CAFY,CAAlB;AAIAJ,UAAAA,MAAM,CAACW,UAAP,CAAkBC,IAAlB,CAAuB;AACtBR,YAAAA,QAAQ,EAAE,CAACZ,YAAD,EAAe,GAAGe,oBAAlB,CADY;AAEtBM,YAAAA,cAAc,EAAEJ,SAAS,CAACI,cAFJ;AAGtBC,YAAAA,EAAE,EAAEL,SAAS,CAACK;AAHQ,WAAvB;AAKA;AACD;AACD,KAnBF;AAqBA;;AAjC4B;;AAoC9BC,MAAM,CAACC,OAAP,GAAiB3B,uBAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @typedef {import(\"./RuleSetCompiler\")} RuleSetCompiler */\n/** @typedef {import(\"./RuleSetCompiler\").RuleCondition} RuleCondition */\n\nclass ObjectMatcherRulePlugin {\n\tconstructor(ruleProperty, dataProperty) {\n\t\tthis.ruleProperty = ruleProperty;\n\t\tthis.dataProperty = dataProperty || ruleProperty;\n\t}\n\n\t/**\n\t * @param {RuleSetCompiler} ruleSetCompiler the rule set compiler\n\t * @returns {void}\n\t */\n\tapply(ruleSetCompiler) {\n\t\tconst { ruleProperty, dataProperty } = this;\n\t\truleSetCompiler.hooks.rule.tap(\n\t\t\t\"ObjectMatcherRulePlugin\",\n\t\t\t(path, rule, unhandledProperties, result) => {\n\t\t\t\tif (unhandledProperties.has(ruleProperty)) {\n\t\t\t\t\tunhandledProperties.delete(ruleProperty);\n\t\t\t\t\tconst value = rule[ruleProperty];\n\t\t\t\t\tfor (const property of Object.keys(value)) {\n\t\t\t\t\t\tconst nestedDataProperties = property.split(\".\");\n\t\t\t\t\t\tconst condition = ruleSetCompiler.compileCondition(\n\t\t\t\t\t\t\t`${path}.${ruleProperty}.${property}`,\n\t\t\t\t\t\t\tvalue[property]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tresult.conditions.push({\n\t\t\t\t\t\t\tproperty: [dataProperty, ...nestedDataProperties],\n\t\t\t\t\t\t\tmatchWhenEmpty: condition.matchWhenEmpty,\n\t\t\t\t\t\t\tfn: condition.fn\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = ObjectMatcherRulePlugin;\n"]},"metadata":{},"sourceType":"script"}