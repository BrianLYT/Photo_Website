{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\"use strict\";\n\nconst WebpackError = require(\"../WebpackError\");\n\nconst {\n  evaluateToIdentifier\n} = require(\"../javascript/JavascriptParserHelpers\");\n\nconst ImportMetaContextDependency = require(\"./ImportMetaContextDependency\");\n/** @typedef {import(\"estree\").Expression} ExpressionNode */\n\n/** @typedef {import(\"estree\").ObjectExpression} ObjectExpressionNode */\n\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n\n/** @typedef {import(\"../ContextModule\").ContextModuleOptions} ContextModuleOptions */\n\n/** @typedef {import(\"../ChunkGroup\").RawChunkGroupOptions} RawChunkGroupOptions */\n\n/** @typedef {Pick<ContextModuleOptions, 'mode'|'recursive'|'regExp'|'include'|'exclude'|'chunkName'>&{groupOptions: RawChunkGroupOptions, exports?: ContextModuleOptions[\"referencedExports\"]}} ImportMetaContextOptions */\n\n\nfunction createPropertyParseError(prop, expect) {\n  return createError(`Parsing import.meta.webpackContext options failed. Unknown value for property ${JSON.stringify(prop.key.name)}, expected type ${expect}.`, prop.value.loc);\n}\n\nfunction createError(msg, loc) {\n  const error = new WebpackError(msg);\n  error.name = \"ImportMetaContextError\";\n  error.loc = loc;\n  return error;\n}\n\nmodule.exports = class ImportMetaContextDependencyParserPlugin {\n  apply(parser) {\n    parser.hooks.evaluateIdentifier.for(\"import.meta.webpackContext\").tap(\"HotModuleReplacementPlugin\", expr => {\n      return evaluateToIdentifier(\"import.meta.webpackContext\", \"import.meta\", () => [\"webpackContext\"], true)(expr);\n    });\n    parser.hooks.call.for(\"import.meta.webpackContext\").tap(\"ImportMetaContextDependencyParserPlugin\", expr => {\n      if (expr.arguments.length < 1 || expr.arguments.length > 2) return;\n      const [directoryNode, optionsNode] = expr.arguments;\n      if (optionsNode && optionsNode.type !== \"ObjectExpression\") return;\n      const requestExpr = parser.evaluateExpression(directoryNode);\n      if (!requestExpr.isString()) return;\n      const request = requestExpr.string;\n      const errors = [];\n      let regExp = /^\\.\\/.*$/;\n      let recursive = true;\n      /** @type {ContextModuleOptions[\"mode\"]} */\n\n      let mode = \"sync\";\n      /** @type {ContextModuleOptions[\"include\"]} */\n\n      let include;\n      /** @type {ContextModuleOptions[\"exclude\"]} */\n\n      let exclude;\n      /** @type {RawChunkGroupOptions} */\n\n      const groupOptions = {};\n      /** @type {ContextModuleOptions[\"chunkName\"]} */\n\n      let chunkName;\n      /** @type {ContextModuleOptions[\"referencedExports\"]} */\n\n      let exports;\n\n      if (optionsNode) {\n        for (const prop of optionsNode.properties) {\n          if (prop.type !== \"Property\" || prop.key.type !== \"Identifier\") {\n            errors.push(createError(\"Parsing import.meta.webpackContext options failed.\", optionsNode.loc));\n            break;\n          }\n\n          switch (prop.key.name) {\n            case \"regExp\":\n              {\n                const regExpExpr = parser.evaluateExpression(\n                /** @type {ExpressionNode} */\n                prop.value);\n\n                if (!regExpExpr.isRegExp()) {\n                  errors.push(createPropertyParseError(prop, \"RegExp\"));\n                } else {\n                  regExp = regExpExpr.regExp;\n                }\n\n                break;\n              }\n\n            case \"include\":\n              {\n                const regExpExpr = parser.evaluateExpression(\n                /** @type {ExpressionNode} */\n                prop.value);\n\n                if (!regExpExpr.isRegExp()) {\n                  errors.push(createPropertyParseError(prop, \"RegExp\"));\n                } else {\n                  include = regExpExpr.regExp;\n                }\n\n                break;\n              }\n\n            case \"exclude\":\n              {\n                const regExpExpr = parser.evaluateExpression(\n                /** @type {ExpressionNode} */\n                prop.value);\n\n                if (!regExpExpr.isRegExp()) {\n                  errors.push(createPropertyParseError(prop, \"RegExp\"));\n                } else {\n                  exclude = regExpExpr.regExp;\n                }\n\n                break;\n              }\n\n            case \"mode\":\n              {\n                const modeExpr = parser.evaluateExpression(\n                /** @type {ExpressionNode} */\n                prop.value);\n\n                if (!modeExpr.isString()) {\n                  errors.push(createPropertyParseError(prop, \"string\"));\n                } else {\n                  mode =\n                  /** @type {ContextModuleOptions[\"mode\"]} */\n                  modeExpr.string;\n                }\n\n                break;\n              }\n\n            case \"chunkName\":\n              {\n                const expr = parser.evaluateExpression(\n                /** @type {ExpressionNode} */\n                prop.value);\n\n                if (!expr.isString()) {\n                  errors.push(createPropertyParseError(prop, \"string\"));\n                } else {\n                  chunkName = expr.string;\n                }\n\n                break;\n              }\n\n            case \"exports\":\n              {\n                const expr = parser.evaluateExpression(\n                /** @type {ExpressionNode} */\n                prop.value);\n\n                if (expr.isString()) {\n                  exports = [[expr.string]];\n                } else if (expr.isArray()) {\n                  const items = expr.items;\n\n                  if (items.every(i => {\n                    if (!i.isArray()) return false;\n                    const innerItems = i.items;\n                    return innerItems.every(i => i.isString());\n                  })) {\n                    exports = [];\n\n                    for (const i1 of items) {\n                      const export_ = [];\n\n                      for (const i2 of i1.items) {\n                        export_.push(i2.string);\n                      }\n\n                      exports.push(export_);\n                    }\n                  } else {\n                    errors.push(createPropertyParseError(prop, \"string|string[][]\"));\n                  }\n                } else {\n                  errors.push(createPropertyParseError(prop, \"string|string[][]\"));\n                }\n\n                break;\n              }\n\n            case \"prefetch\":\n              {\n                const expr = parser.evaluateExpression(\n                /** @type {ExpressionNode} */\n                prop.value);\n\n                if (expr.isBoolean()) {\n                  groupOptions.prefetchOrder = 0;\n                } else if (expr.isNumber()) {\n                  groupOptions.prefetchOrder = expr.number;\n                } else {\n                  errors.push(createPropertyParseError(prop, \"boolean|number\"));\n                }\n\n                break;\n              }\n\n            case \"preload\":\n              {\n                const expr = parser.evaluateExpression(\n                /** @type {ExpressionNode} */\n                prop.value);\n\n                if (expr.isBoolean()) {\n                  groupOptions.preloadOrder = 0;\n                } else if (expr.isNumber()) {\n                  groupOptions.preloadOrder = expr.number;\n                } else {\n                  errors.push(createPropertyParseError(prop, \"boolean|number\"));\n                }\n\n                break;\n              }\n\n            case \"recursive\":\n              {\n                const recursiveExpr = parser.evaluateExpression(\n                /** @type {ExpressionNode} */\n                prop.value);\n\n                if (!recursiveExpr.isBoolean()) {\n                  errors.push(createPropertyParseError(prop, \"boolean\"));\n                } else {\n                  recursive = recursiveExpr.bool;\n                }\n\n                break;\n              }\n\n            default:\n              errors.push(createError(`Parsing import.meta.webpackContext options failed. Unknown property ${JSON.stringify(prop.key.name)}.`, optionsNode.loc));\n          }\n        }\n      }\n\n      if (errors.length) {\n        for (const error of errors) parser.state.current.addError(error);\n\n        return;\n      }\n\n      const dep = new ImportMetaContextDependency({\n        request,\n        include,\n        exclude,\n        recursive,\n        regExp,\n        groupOptions,\n        chunkName,\n        referencedExports: exports,\n        mode,\n        category: \"esm\"\n      }, expr.range);\n      dep.loc = expr.loc;\n      dep.optional = !!parser.scope.inTry;\n      parser.state.current.addDependency(dep);\n      return true;\n    });\n  }\n\n};","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/dependencies/ImportMetaContextDependencyParserPlugin.js"],"names":["WebpackError","require","evaluateToIdentifier","ImportMetaContextDependency","createPropertyParseError","prop","expect","createError","JSON","stringify","key","name","value","loc","msg","error","module","exports","ImportMetaContextDependencyParserPlugin","apply","parser","hooks","evaluateIdentifier","for","tap","expr","call","arguments","length","directoryNode","optionsNode","type","requestExpr","evaluateExpression","isString","request","string","errors","regExp","recursive","mode","include","exclude","groupOptions","chunkName","properties","push","regExpExpr","isRegExp","modeExpr","isArray","items","every","i","innerItems","i1","export_","i2","isBoolean","prefetchOrder","isNumber","number","preloadOrder","recursiveExpr","bool","state","current","addError","dep","referencedExports","category","range","optional","scope","inTry","addDependency"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nconst WebpackError = require(\"../WebpackError\");\nconst {\n\tevaluateToIdentifier\n} = require(\"../javascript/JavascriptParserHelpers\");\nconst ImportMetaContextDependency = require(\"./ImportMetaContextDependency\");\n\n/** @typedef {import(\"estree\").Expression} ExpressionNode */\n/** @typedef {import(\"estree\").ObjectExpression} ObjectExpressionNode */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../ContextModule\").ContextModuleOptions} ContextModuleOptions */\n/** @typedef {import(\"../ChunkGroup\").RawChunkGroupOptions} RawChunkGroupOptions */\n/** @typedef {Pick<ContextModuleOptions, 'mode'|'recursive'|'regExp'|'include'|'exclude'|'chunkName'>&{groupOptions: RawChunkGroupOptions, exports?: ContextModuleOptions[\"referencedExports\"]}} ImportMetaContextOptions */\n\nfunction createPropertyParseError(prop, expect) {\n\treturn createError(\n\t\t`Parsing import.meta.webpackContext options failed. Unknown value for property ${JSON.stringify(\n\t\t\tprop.key.name\n\t\t)}, expected type ${expect}.`,\n\t\tprop.value.loc\n\t);\n}\n\nfunction createError(msg, loc) {\n\tconst error = new WebpackError(msg);\n\terror.name = \"ImportMetaContextError\";\n\terror.loc = loc;\n\treturn error;\n}\n\nmodule.exports = class ImportMetaContextDependencyParserPlugin {\n\tapply(parser) {\n\t\tparser.hooks.evaluateIdentifier\n\t\t\t.for(\"import.meta.webpackContext\")\n\t\t\t.tap(\"HotModuleReplacementPlugin\", expr => {\n\t\t\t\treturn evaluateToIdentifier(\n\t\t\t\t\t\"import.meta.webpackContext\",\n\t\t\t\t\t\"import.meta\",\n\t\t\t\t\t() => [\"webpackContext\"],\n\t\t\t\t\ttrue\n\t\t\t\t)(expr);\n\t\t\t});\n\t\tparser.hooks.call\n\t\t\t.for(\"import.meta.webpackContext\")\n\t\t\t.tap(\"ImportMetaContextDependencyParserPlugin\", expr => {\n\t\t\t\tif (expr.arguments.length < 1 || expr.arguments.length > 2) return;\n\t\t\t\tconst [directoryNode, optionsNode] = expr.arguments;\n\t\t\t\tif (optionsNode && optionsNode.type !== \"ObjectExpression\") return;\n\t\t\t\tconst requestExpr = parser.evaluateExpression(directoryNode);\n\t\t\t\tif (!requestExpr.isString()) return;\n\t\t\t\tconst request = requestExpr.string;\n\t\t\t\tconst errors = [];\n\t\t\t\tlet regExp = /^\\.\\/.*$/;\n\t\t\t\tlet recursive = true;\n\t\t\t\t/** @type {ContextModuleOptions[\"mode\"]} */\n\t\t\t\tlet mode = \"sync\";\n\t\t\t\t/** @type {ContextModuleOptions[\"include\"]} */\n\t\t\t\tlet include;\n\t\t\t\t/** @type {ContextModuleOptions[\"exclude\"]} */\n\t\t\t\tlet exclude;\n\t\t\t\t/** @type {RawChunkGroupOptions} */\n\t\t\t\tconst groupOptions = {};\n\t\t\t\t/** @type {ContextModuleOptions[\"chunkName\"]} */\n\t\t\t\tlet chunkName;\n\t\t\t\t/** @type {ContextModuleOptions[\"referencedExports\"]} */\n\t\t\t\tlet exports;\n\t\t\t\tif (optionsNode) {\n\t\t\t\t\tfor (const prop of optionsNode.properties) {\n\t\t\t\t\t\tif (prop.type !== \"Property\" || prop.key.type !== \"Identifier\") {\n\t\t\t\t\t\t\terrors.push(\n\t\t\t\t\t\t\t\tcreateError(\n\t\t\t\t\t\t\t\t\t\"Parsing import.meta.webpackContext options failed.\",\n\t\t\t\t\t\t\t\t\toptionsNode.loc\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch (prop.key.name) {\n\t\t\t\t\t\t\tcase \"regExp\": {\n\t\t\t\t\t\t\t\tconst regExpExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (!regExpExpr.isRegExp()) {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"RegExp\"));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tregExp = regExpExpr.regExp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"include\": {\n\t\t\t\t\t\t\t\tconst regExpExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (!regExpExpr.isRegExp()) {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"RegExp\"));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tinclude = regExpExpr.regExp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"exclude\": {\n\t\t\t\t\t\t\t\tconst regExpExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (!regExpExpr.isRegExp()) {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"RegExp\"));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\texclude = regExpExpr.regExp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"mode\": {\n\t\t\t\t\t\t\t\tconst modeExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (!modeExpr.isString()) {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"string\"));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmode = /** @type {ContextModuleOptions[\"mode\"]} */ (\n\t\t\t\t\t\t\t\t\t\tmodeExpr.string\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"chunkName\": {\n\t\t\t\t\t\t\t\tconst expr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (!expr.isString()) {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"string\"));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tchunkName = expr.string;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"exports\": {\n\t\t\t\t\t\t\t\tconst expr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (expr.isString()) {\n\t\t\t\t\t\t\t\t\texports = [[expr.string]];\n\t\t\t\t\t\t\t\t} else if (expr.isArray()) {\n\t\t\t\t\t\t\t\t\tconst items = expr.items;\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\titems.every(i => {\n\t\t\t\t\t\t\t\t\t\t\tif (!i.isArray()) return false;\n\t\t\t\t\t\t\t\t\t\t\tconst innerItems = i.items;\n\t\t\t\t\t\t\t\t\t\t\treturn innerItems.every(i => i.isString());\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\texports = [];\n\t\t\t\t\t\t\t\t\t\tfor (const i1 of items) {\n\t\t\t\t\t\t\t\t\t\t\tconst export_ = [];\n\t\t\t\t\t\t\t\t\t\t\tfor (const i2 of i1.items) {\n\t\t\t\t\t\t\t\t\t\t\t\texport_.push(i2.string);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\texports.push(export_);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\terrors.push(\n\t\t\t\t\t\t\t\t\t\t\tcreatePropertyParseError(prop, \"string|string[][]\")\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\terrors.push(\n\t\t\t\t\t\t\t\t\t\tcreatePropertyParseError(prop, \"string|string[][]\")\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"prefetch\": {\n\t\t\t\t\t\t\t\tconst expr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (expr.isBoolean()) {\n\t\t\t\t\t\t\t\t\tgroupOptions.prefetchOrder = 0;\n\t\t\t\t\t\t\t\t} else if (expr.isNumber()) {\n\t\t\t\t\t\t\t\t\tgroupOptions.prefetchOrder = expr.number;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"boolean|number\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"preload\": {\n\t\t\t\t\t\t\t\tconst expr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (expr.isBoolean()) {\n\t\t\t\t\t\t\t\t\tgroupOptions.preloadOrder = 0;\n\t\t\t\t\t\t\t\t} else if (expr.isNumber()) {\n\t\t\t\t\t\t\t\t\tgroupOptions.preloadOrder = expr.number;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"boolean|number\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"recursive\": {\n\t\t\t\t\t\t\t\tconst recursiveExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (!recursiveExpr.isBoolean()) {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"boolean\"));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\trecursive = recursiveExpr.bool;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\terrors.push(\n\t\t\t\t\t\t\t\t\tcreateError(\n\t\t\t\t\t\t\t\t\t\t`Parsing import.meta.webpackContext options failed. Unknown property ${JSON.stringify(\n\t\t\t\t\t\t\t\t\t\t\tprop.key.name\n\t\t\t\t\t\t\t\t\t\t)}.`,\n\t\t\t\t\t\t\t\t\t\toptionsNode.loc\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (errors.length) {\n\t\t\t\t\tfor (const error of errors) parser.state.current.addError(error);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst dep = new ImportMetaContextDependency(\n\t\t\t\t\t{\n\t\t\t\t\t\trequest,\n\t\t\t\t\t\tinclude,\n\t\t\t\t\t\texclude,\n\t\t\t\t\t\trecursive,\n\t\t\t\t\t\tregExp,\n\t\t\t\t\t\tgroupOptions,\n\t\t\t\t\t\tchunkName,\n\t\t\t\t\t\treferencedExports: exports,\n\t\t\t\t\t\tmode,\n\t\t\t\t\t\tcategory: \"esm\"\n\t\t\t\t\t},\n\t\t\t\t\texpr.range\n\t\t\t\t);\n\t\t\t\tdep.loc = expr.loc;\n\t\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\treturn true;\n\t\t\t});\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}