{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst nextTick = require(\"process\").nextTick;\n/** @typedef {import(\"./Resolver\").FileSystem} FileSystem */\n\n/** @typedef {import(\"./Resolver\").SyncFileSystem} SyncFileSystem */\n\n\nconst dirname = path => {\n  let idx = path.length - 1;\n\n  while (idx >= 0) {\n    const c = path.charCodeAt(idx); // slash or backslash\n\n    if (c === 47 || c === 92) break;\n    idx--;\n  }\n\n  if (idx < 0) return \"\";\n  return path.slice(0, idx);\n};\n\nconst runCallbacks = (callbacks, err, result) => {\n  if (callbacks.length === 1) {\n    callbacks[0](err, result);\n    callbacks.length = 0;\n    return;\n  }\n\n  let error;\n\n  for (const callback of callbacks) {\n    try {\n      callback(err, result);\n    } catch (e) {\n      if (!error) error = e;\n    }\n  }\n\n  callbacks.length = 0;\n  if (error) throw error;\n};\n\nclass OperationMergerBackend {\n  /**\n   * @param {any} provider async method\n   * @param {any} syncProvider sync method\n   * @param {any} providerContext call context for the provider methods\n   */\n  constructor(provider, syncProvider, providerContext) {\n    this._provider = provider;\n    this._syncProvider = syncProvider;\n    this._providerContext = providerContext;\n    this._activeAsyncOperations = new Map();\n    this.provide = this._provider ? (path, options, callback) => {\n      if (typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n      }\n\n      if (options) {\n        return this._provider.call(this._providerContext, path, options, callback);\n      }\n\n      if (typeof path !== \"string\") {\n        callback(new TypeError(\"path must be a string\"));\n        return;\n      }\n\n      let callbacks = this._activeAsyncOperations.get(path);\n\n      if (callbacks) {\n        callbacks.push(callback);\n        return;\n      }\n\n      this._activeAsyncOperations.set(path, callbacks = [callback]);\n\n      provider(path, (err, result) => {\n        this._activeAsyncOperations.delete(path);\n\n        runCallbacks(callbacks, err, result);\n      });\n    } : null;\n    this.provideSync = this._syncProvider ? (path, options) => {\n      return this._syncProvider.call(this._providerContext, path, options);\n    } : null;\n  }\n\n  purge() {}\n\n  purgeParent() {}\n\n}\n/*\n\nIDLE:\n\tinsert data: goto SYNC\n\nSYNC:\n\tbefore provide: run ticks\n\tevent loop tick: goto ASYNC_ACTIVE\n\nASYNC:\n\ttimeout: run tick, goto ASYNC_PASSIVE\n\nASYNC_PASSIVE:\n\tbefore provide: run ticks\n\nIDLE --[insert data]--> SYNC --[event loop tick]--> ASYNC_ACTIVE --[interval tick]-> ASYNC_PASSIVE\n                                                          ^                             |\n                                                          +---------[insert data]-------+\n*/\n\n\nconst STORAGE_MODE_IDLE = 0;\nconst STORAGE_MODE_SYNC = 1;\nconst STORAGE_MODE_ASYNC = 2;\n\nclass CacheBackend {\n  /**\n   * @param {number} duration max cache duration of items\n   * @param {any} provider async method\n   * @param {any} syncProvider sync method\n   * @param {any} providerContext call context for the provider methods\n   */\n  constructor(duration, provider, syncProvider, providerContext) {\n    this._duration = duration;\n    this._provider = provider;\n    this._syncProvider = syncProvider;\n    this._providerContext = providerContext;\n    /** @type {Map<string, (function(Error, any): void)[]>} */\n\n    this._activeAsyncOperations = new Map();\n    /** @type {Map<string, { err: Error, result: any, level: Set<string> }>} */\n\n    this._data = new Map();\n    /** @type {Set<string>[]} */\n\n    this._levels = [];\n\n    for (let i = 0; i < 10; i++) this._levels.push(new Set());\n\n    for (let i = 5000; i < duration; i += 500) this._levels.push(new Set());\n\n    this._currentLevel = 0;\n    this._tickInterval = Math.floor(duration / this._levels.length);\n    /** @type {STORAGE_MODE_IDLE | STORAGE_MODE_SYNC | STORAGE_MODE_ASYNC} */\n\n    this._mode = STORAGE_MODE_IDLE;\n    /** @type {NodeJS.Timeout | undefined} */\n\n    this._timeout = undefined;\n    /** @type {number | undefined} */\n\n    this._nextDecay = undefined;\n    this.provide = provider ? this.provide.bind(this) : null;\n    this.provideSync = syncProvider ? this.provideSync.bind(this) : null;\n  }\n\n  provide(path, options, callback) {\n    if (typeof options === \"function\") {\n      callback = options;\n      options = undefined;\n    }\n\n    if (typeof path !== \"string\") {\n      callback(new TypeError(\"path must be a string\"));\n      return;\n    }\n\n    if (options) {\n      return this._provider.call(this._providerContext, path, options, callback);\n    } // When in sync mode we can move to async mode\n\n\n    if (this._mode === STORAGE_MODE_SYNC) {\n      this._enterAsyncMode();\n    } // Check in cache\n\n\n    let cacheEntry = this._data.get(path);\n\n    if (cacheEntry !== undefined) {\n      if (cacheEntry.err) return nextTick(callback, cacheEntry.err);\n      return nextTick(callback, null, cacheEntry.result);\n    } // Check if there is already the same operation running\n\n\n    let callbacks = this._activeAsyncOperations.get(path);\n\n    if (callbacks !== undefined) {\n      callbacks.push(callback);\n      return;\n    }\n\n    this._activeAsyncOperations.set(path, callbacks = [callback]); // Run the operation\n\n\n    this._provider.call(this._providerContext, path, (err, result) => {\n      this._activeAsyncOperations.delete(path);\n\n      this._storeResult(path, err, result); // Enter async mode if not yet done\n\n\n      this._enterAsyncMode();\n\n      runCallbacks(callbacks, err, result);\n    });\n  }\n\n  provideSync(path, options) {\n    if (typeof path !== \"string\") {\n      throw new TypeError(\"path must be a string\");\n    }\n\n    if (options) {\n      return this._syncProvider.call(this._providerContext, path, options);\n    } // In sync mode we may have to decay some cache items\n\n\n    if (this._mode === STORAGE_MODE_SYNC) {\n      this._runDecays();\n    } // Check in cache\n\n\n    let cacheEntry = this._data.get(path);\n\n    if (cacheEntry !== undefined) {\n      if (cacheEntry.err) throw cacheEntry.err;\n      return cacheEntry.result;\n    } // Get all active async operations\n    // This sync operation will also complete them\n\n\n    const callbacks = this._activeAsyncOperations.get(path);\n\n    this._activeAsyncOperations.delete(path); // Run the operation\n    // When in idle mode, we will enter sync mode\n\n\n    let result;\n\n    try {\n      result = this._syncProvider.call(this._providerContext, path);\n    } catch (err) {\n      this._storeResult(path, err, undefined);\n\n      this._enterSyncModeWhenIdle();\n\n      if (callbacks) runCallbacks(callbacks, err, undefined);\n      throw err;\n    }\n\n    this._storeResult(path, undefined, result);\n\n    this._enterSyncModeWhenIdle();\n\n    if (callbacks) runCallbacks(callbacks, undefined, result);\n    return result;\n  }\n\n  purge(what) {\n    if (!what) {\n      if (this._mode !== STORAGE_MODE_IDLE) {\n        this._data.clear();\n\n        for (const level of this._levels) {\n          level.clear();\n        }\n\n        this._enterIdleMode();\n      }\n    } else if (typeof what === \"string\") {\n      for (let [key, data] of this._data) {\n        if (key.startsWith(what)) {\n          this._data.delete(key);\n\n          data.level.delete(key);\n        }\n      }\n\n      if (this._data.size === 0) {\n        this._enterIdleMode();\n      }\n    } else {\n      for (let [key, data] of this._data) {\n        for (const item of what) {\n          if (key.startsWith(item)) {\n            this._data.delete(key);\n\n            data.level.delete(key);\n            break;\n          }\n        }\n      }\n\n      if (this._data.size === 0) {\n        this._enterIdleMode();\n      }\n    }\n  }\n\n  purgeParent(what) {\n    if (!what) {\n      this.purge();\n    } else if (typeof what === \"string\") {\n      this.purge(dirname(what));\n    } else {\n      const set = new Set();\n\n      for (const item of what) {\n        set.add(dirname(item));\n      }\n\n      this.purge(set);\n    }\n  }\n\n  _storeResult(path, err, result) {\n    if (this._data.has(path)) return;\n    const level = this._levels[this._currentLevel];\n\n    this._data.set(path, {\n      err,\n      result,\n      level\n    });\n\n    level.add(path);\n  }\n\n  _decayLevel() {\n    const nextLevel = (this._currentLevel + 1) % this._levels.length;\n    const decay = this._levels[nextLevel];\n    this._currentLevel = nextLevel;\n\n    for (let item of decay) {\n      this._data.delete(item);\n    }\n\n    decay.clear();\n\n    if (this._data.size === 0) {\n      this._enterIdleMode();\n    } else {\n      // @ts-ignore _nextDecay is always a number in sync mode\n      this._nextDecay += this._tickInterval;\n    }\n  }\n\n  _runDecays() {\n    while (\n    /** @type {number} */\n    this._nextDecay <= Date.now() && this._mode !== STORAGE_MODE_IDLE) {\n      this._decayLevel();\n    }\n  }\n\n  _enterAsyncMode() {\n    let timeout = 0;\n\n    switch (this._mode) {\n      case STORAGE_MODE_ASYNC:\n        return;\n\n      case STORAGE_MODE_IDLE:\n        this._nextDecay = Date.now() + this._tickInterval;\n        timeout = this._tickInterval;\n        break;\n\n      case STORAGE_MODE_SYNC:\n        this._runDecays(); // @ts-ignore _runDecays may change the mode\n\n\n        if (this._mode === STORAGE_MODE_IDLE) return;\n        timeout = Math.max(0,\n        /** @type {number} */\n        this._nextDecay - Date.now());\n        break;\n    }\n\n    this._mode = STORAGE_MODE_ASYNC;\n    const ref = setTimeout(() => {\n      this._mode = STORAGE_MODE_SYNC;\n\n      this._runDecays();\n    }, timeout);\n    if (ref.unref) ref.unref();\n    this._timeout = ref;\n  }\n\n  _enterSyncModeWhenIdle() {\n    if (this._mode === STORAGE_MODE_IDLE) {\n      this._mode = STORAGE_MODE_SYNC;\n      this._nextDecay = Date.now() + this._tickInterval;\n    }\n  }\n\n  _enterIdleMode() {\n    this._mode = STORAGE_MODE_IDLE;\n    this._nextDecay = undefined;\n    if (this._timeout) clearTimeout(this._timeout);\n  }\n\n}\n\nconst createBackend = (duration, provider, syncProvider, providerContext) => {\n  if (duration > 0) {\n    return new CacheBackend(duration, provider, syncProvider, providerContext);\n  }\n\n  return new OperationMergerBackend(provider, syncProvider, providerContext);\n};\n\nmodule.exports = class CachedInputFileSystem {\n  constructor(fileSystem, duration) {\n    this.fileSystem = fileSystem;\n    this._lstatBackend = createBackend(duration, this.fileSystem.lstat, this.fileSystem.lstatSync, this.fileSystem);\n    const lstat = this._lstatBackend.provide;\n    this.lstat =\n    /** @type {FileSystem[\"lstat\"]} */\n    lstat;\n    const lstatSync = this._lstatBackend.provideSync;\n    this.lstatSync =\n    /** @type {SyncFileSystem[\"lstatSync\"]} */\n    lstatSync;\n    this._statBackend = createBackend(duration, this.fileSystem.stat, this.fileSystem.statSync, this.fileSystem);\n    const stat = this._statBackend.provide;\n    this.stat =\n    /** @type {FileSystem[\"stat\"]} */\n    stat;\n    const statSync = this._statBackend.provideSync;\n    this.statSync =\n    /** @type {SyncFileSystem[\"statSync\"]} */\n    statSync;\n    this._readdirBackend = createBackend(duration, this.fileSystem.readdir, this.fileSystem.readdirSync, this.fileSystem);\n    const readdir = this._readdirBackend.provide;\n    this.readdir =\n    /** @type {FileSystem[\"readdir\"]} */\n    readdir;\n    const readdirSync = this._readdirBackend.provideSync;\n    this.readdirSync =\n    /** @type {SyncFileSystem[\"readdirSync\"]} */\n    readdirSync;\n    this._readFileBackend = createBackend(duration, this.fileSystem.readFile, this.fileSystem.readFileSync, this.fileSystem);\n    const readFile = this._readFileBackend.provide;\n    this.readFile =\n    /** @type {FileSystem[\"readFile\"]} */\n    readFile;\n    const readFileSync = this._readFileBackend.provideSync;\n    this.readFileSync =\n    /** @type {SyncFileSystem[\"readFileSync\"]} */\n    readFileSync;\n    this._readJsonBackend = createBackend(duration, this.fileSystem.readJson || this.readFile && ((path, callback) => {\n      // @ts-ignore\n      this.readFile(path, (err, buffer) => {\n        if (err) return callback(err);\n        if (!buffer || buffer.length === 0) return callback(new Error(\"No file content\"));\n        let data;\n\n        try {\n          data = JSON.parse(buffer.toString(\"utf-8\"));\n        } catch (e) {\n          return callback(e);\n        }\n\n        callback(null, data);\n      });\n    }), this.fileSystem.readJsonSync || this.readFileSync && (path => {\n      const buffer = this.readFileSync(path);\n      const data = JSON.parse(buffer.toString(\"utf-8\"));\n      return data;\n    }), this.fileSystem);\n    const readJson = this._readJsonBackend.provide;\n    this.readJson =\n    /** @type {FileSystem[\"readJson\"]} */\n    readJson;\n    const readJsonSync = this._readJsonBackend.provideSync;\n    this.readJsonSync =\n    /** @type {SyncFileSystem[\"readJsonSync\"]} */\n    readJsonSync;\n    this._readlinkBackend = createBackend(duration, this.fileSystem.readlink, this.fileSystem.readlinkSync, this.fileSystem);\n    const readlink = this._readlinkBackend.provide;\n    this.readlink =\n    /** @type {FileSystem[\"readlink\"]} */\n    readlink;\n    const readlinkSync = this._readlinkBackend.provideSync;\n    this.readlinkSync =\n    /** @type {SyncFileSystem[\"readlinkSync\"]} */\n    readlinkSync;\n  }\n\n  purge(what) {\n    this._statBackend.purge(what);\n\n    this._lstatBackend.purge(what);\n\n    this._readdirBackend.purgeParent(what);\n\n    this._readFileBackend.purge(what);\n\n    this._readlinkBackend.purge(what);\n\n    this._readJsonBackend.purge(what);\n  }\n\n};","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/enhanced-resolve/lib/CachedInputFileSystem.js"],"names":["nextTick","require","dirname","path","idx","length","c","charCodeAt","slice","runCallbacks","callbacks","err","result","error","callback","e","OperationMergerBackend","constructor","provider","syncProvider","providerContext","_provider","_syncProvider","_providerContext","_activeAsyncOperations","Map","provide","options","undefined","call","TypeError","get","push","set","delete","provideSync","purge","purgeParent","STORAGE_MODE_IDLE","STORAGE_MODE_SYNC","STORAGE_MODE_ASYNC","CacheBackend","duration","_duration","_data","_levels","i","Set","_currentLevel","_tickInterval","Math","floor","_mode","_timeout","_nextDecay","bind","_enterAsyncMode","cacheEntry","_storeResult","_runDecays","_enterSyncModeWhenIdle","what","clear","level","_enterIdleMode","key","data","startsWith","size","item","add","has","_decayLevel","nextLevel","decay","Date","now","timeout","max","ref","setTimeout","unref","clearTimeout","createBackend","module","exports","CachedInputFileSystem","fileSystem","_lstatBackend","lstat","lstatSync","_statBackend","stat","statSync","_readdirBackend","readdir","readdirSync","_readFileBackend","readFile","readFileSync","_readJsonBackend","readJson","buffer","Error","JSON","parse","toString","readJsonSync","_readlinkBackend","readlink","readlinkSync"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst nextTick = require(\"process\").nextTick;\n\n/** @typedef {import(\"./Resolver\").FileSystem} FileSystem */\n/** @typedef {import(\"./Resolver\").SyncFileSystem} SyncFileSystem */\n\nconst dirname = path => {\n\tlet idx = path.length - 1;\n\twhile (idx >= 0) {\n\t\tconst c = path.charCodeAt(idx);\n\t\t// slash or backslash\n\t\tif (c === 47 || c === 92) break;\n\t\tidx--;\n\t}\n\tif (idx < 0) return \"\";\n\treturn path.slice(0, idx);\n};\n\nconst runCallbacks = (callbacks, err, result) => {\n\tif (callbacks.length === 1) {\n\t\tcallbacks[0](err, result);\n\t\tcallbacks.length = 0;\n\t\treturn;\n\t}\n\tlet error;\n\tfor (const callback of callbacks) {\n\t\ttry {\n\t\t\tcallback(err, result);\n\t\t} catch (e) {\n\t\t\tif (!error) error = e;\n\t\t}\n\t}\n\tcallbacks.length = 0;\n\tif (error) throw error;\n};\n\nclass OperationMergerBackend {\n\t/**\n\t * @param {any} provider async method\n\t * @param {any} syncProvider sync method\n\t * @param {any} providerContext call context for the provider methods\n\t */\n\tconstructor(provider, syncProvider, providerContext) {\n\t\tthis._provider = provider;\n\t\tthis._syncProvider = syncProvider;\n\t\tthis._providerContext = providerContext;\n\t\tthis._activeAsyncOperations = new Map();\n\n\t\tthis.provide = this._provider\n\t\t\t? (path, options, callback) => {\n\t\t\t\t\tif (typeof options === \"function\") {\n\t\t\t\t\t\tcallback = options;\n\t\t\t\t\t\toptions = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tif (options) {\n\t\t\t\t\t\treturn this._provider.call(\n\t\t\t\t\t\t\tthis._providerContext,\n\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof path !== \"string\") {\n\t\t\t\t\t\tcallback(new TypeError(\"path must be a string\"));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tlet callbacks = this._activeAsyncOperations.get(path);\n\t\t\t\t\tif (callbacks) {\n\t\t\t\t\t\tcallbacks.push(callback);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis._activeAsyncOperations.set(path, (callbacks = [callback]));\n\t\t\t\t\tprovider(path, (err, result) => {\n\t\t\t\t\t\tthis._activeAsyncOperations.delete(path);\n\t\t\t\t\t\trunCallbacks(callbacks, err, result);\n\t\t\t\t\t});\n\t\t\t  }\n\t\t\t: null;\n\t\tthis.provideSync = this._syncProvider\n\t\t\t? (path, options) => {\n\t\t\t\t\treturn this._syncProvider.call(this._providerContext, path, options);\n\t\t\t  }\n\t\t\t: null;\n\t}\n\n\tpurge() {}\n\tpurgeParent() {}\n}\n\n/*\n\nIDLE:\n\tinsert data: goto SYNC\n\nSYNC:\n\tbefore provide: run ticks\n\tevent loop tick: goto ASYNC_ACTIVE\n\nASYNC:\n\ttimeout: run tick, goto ASYNC_PASSIVE\n\nASYNC_PASSIVE:\n\tbefore provide: run ticks\n\nIDLE --[insert data]--> SYNC --[event loop tick]--> ASYNC_ACTIVE --[interval tick]-> ASYNC_PASSIVE\n                                                          ^                             |\n                                                          +---------[insert data]-------+\n*/\n\nconst STORAGE_MODE_IDLE = 0;\nconst STORAGE_MODE_SYNC = 1;\nconst STORAGE_MODE_ASYNC = 2;\n\nclass CacheBackend {\n\t/**\n\t * @param {number} duration max cache duration of items\n\t * @param {any} provider async method\n\t * @param {any} syncProvider sync method\n\t * @param {any} providerContext call context for the provider methods\n\t */\n\tconstructor(duration, provider, syncProvider, providerContext) {\n\t\tthis._duration = duration;\n\t\tthis._provider = provider;\n\t\tthis._syncProvider = syncProvider;\n\t\tthis._providerContext = providerContext;\n\t\t/** @type {Map<string, (function(Error, any): void)[]>} */\n\t\tthis._activeAsyncOperations = new Map();\n\t\t/** @type {Map<string, { err: Error, result: any, level: Set<string> }>} */\n\t\tthis._data = new Map();\n\t\t/** @type {Set<string>[]} */\n\t\tthis._levels = [];\n\t\tfor (let i = 0; i < 10; i++) this._levels.push(new Set());\n\t\tfor (let i = 5000; i < duration; i += 500) this._levels.push(new Set());\n\t\tthis._currentLevel = 0;\n\t\tthis._tickInterval = Math.floor(duration / this._levels.length);\n\t\t/** @type {STORAGE_MODE_IDLE | STORAGE_MODE_SYNC | STORAGE_MODE_ASYNC} */\n\t\tthis._mode = STORAGE_MODE_IDLE;\n\n\t\t/** @type {NodeJS.Timeout | undefined} */\n\t\tthis._timeout = undefined;\n\t\t/** @type {number | undefined} */\n\t\tthis._nextDecay = undefined;\n\n\t\tthis.provide = provider ? this.provide.bind(this) : null;\n\t\tthis.provideSync = syncProvider ? this.provideSync.bind(this) : null;\n\t}\n\n\tprovide(path, options, callback) {\n\t\tif (typeof options === \"function\") {\n\t\t\tcallback = options;\n\t\t\toptions = undefined;\n\t\t}\n\t\tif (typeof path !== \"string\") {\n\t\t\tcallback(new TypeError(\"path must be a string\"));\n\t\t\treturn;\n\t\t}\n\t\tif (options) {\n\t\t\treturn this._provider.call(\n\t\t\t\tthis._providerContext,\n\t\t\t\tpath,\n\t\t\t\toptions,\n\t\t\t\tcallback\n\t\t\t);\n\t\t}\n\n\t\t// When in sync mode we can move to async mode\n\t\tif (this._mode === STORAGE_MODE_SYNC) {\n\t\t\tthis._enterAsyncMode();\n\t\t}\n\n\t\t// Check in cache\n\t\tlet cacheEntry = this._data.get(path);\n\t\tif (cacheEntry !== undefined) {\n\t\t\tif (cacheEntry.err) return nextTick(callback, cacheEntry.err);\n\t\t\treturn nextTick(callback, null, cacheEntry.result);\n\t\t}\n\n\t\t// Check if there is already the same operation running\n\t\tlet callbacks = this._activeAsyncOperations.get(path);\n\t\tif (callbacks !== undefined) {\n\t\t\tcallbacks.push(callback);\n\t\t\treturn;\n\t\t}\n\t\tthis._activeAsyncOperations.set(path, (callbacks = [callback]));\n\n\t\t// Run the operation\n\t\tthis._provider.call(this._providerContext, path, (err, result) => {\n\t\t\tthis._activeAsyncOperations.delete(path);\n\t\t\tthis._storeResult(path, err, result);\n\n\t\t\t// Enter async mode if not yet done\n\t\t\tthis._enterAsyncMode();\n\n\t\t\trunCallbacks(callbacks, err, result);\n\t\t});\n\t}\n\n\tprovideSync(path, options) {\n\t\tif (typeof path !== \"string\") {\n\t\t\tthrow new TypeError(\"path must be a string\");\n\t\t}\n\t\tif (options) {\n\t\t\treturn this._syncProvider.call(this._providerContext, path, options);\n\t\t}\n\n\t\t// In sync mode we may have to decay some cache items\n\t\tif (this._mode === STORAGE_MODE_SYNC) {\n\t\t\tthis._runDecays();\n\t\t}\n\n\t\t// Check in cache\n\t\tlet cacheEntry = this._data.get(path);\n\t\tif (cacheEntry !== undefined) {\n\t\t\tif (cacheEntry.err) throw cacheEntry.err;\n\t\t\treturn cacheEntry.result;\n\t\t}\n\n\t\t// Get all active async operations\n\t\t// This sync operation will also complete them\n\t\tconst callbacks = this._activeAsyncOperations.get(path);\n\t\tthis._activeAsyncOperations.delete(path);\n\n\t\t// Run the operation\n\t\t// When in idle mode, we will enter sync mode\n\t\tlet result;\n\t\ttry {\n\t\t\tresult = this._syncProvider.call(this._providerContext, path);\n\t\t} catch (err) {\n\t\t\tthis._storeResult(path, err, undefined);\n\t\t\tthis._enterSyncModeWhenIdle();\n\t\t\tif (callbacks) runCallbacks(callbacks, err, undefined);\n\t\t\tthrow err;\n\t\t}\n\t\tthis._storeResult(path, undefined, result);\n\t\tthis._enterSyncModeWhenIdle();\n\t\tif (callbacks) runCallbacks(callbacks, undefined, result);\n\t\treturn result;\n\t}\n\n\tpurge(what) {\n\t\tif (!what) {\n\t\t\tif (this._mode !== STORAGE_MODE_IDLE) {\n\t\t\t\tthis._data.clear();\n\t\t\t\tfor (const level of this._levels) {\n\t\t\t\t\tlevel.clear();\n\t\t\t\t}\n\t\t\t\tthis._enterIdleMode();\n\t\t\t}\n\t\t} else if (typeof what === \"string\") {\n\t\t\tfor (let [key, data] of this._data) {\n\t\t\t\tif (key.startsWith(what)) {\n\t\t\t\t\tthis._data.delete(key);\n\t\t\t\t\tdata.level.delete(key);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._data.size === 0) {\n\t\t\t\tthis._enterIdleMode();\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let [key, data] of this._data) {\n\t\t\t\tfor (const item of what) {\n\t\t\t\t\tif (key.startsWith(item)) {\n\t\t\t\t\t\tthis._data.delete(key);\n\t\t\t\t\t\tdata.level.delete(key);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._data.size === 0) {\n\t\t\t\tthis._enterIdleMode();\n\t\t\t}\n\t\t}\n\t}\n\n\tpurgeParent(what) {\n\t\tif (!what) {\n\t\t\tthis.purge();\n\t\t} else if (typeof what === \"string\") {\n\t\t\tthis.purge(dirname(what));\n\t\t} else {\n\t\t\tconst set = new Set();\n\t\t\tfor (const item of what) {\n\t\t\t\tset.add(dirname(item));\n\t\t\t}\n\t\t\tthis.purge(set);\n\t\t}\n\t}\n\n\t_storeResult(path, err, result) {\n\t\tif (this._data.has(path)) return;\n\t\tconst level = this._levels[this._currentLevel];\n\t\tthis._data.set(path, { err, result, level });\n\t\tlevel.add(path);\n\t}\n\n\t_decayLevel() {\n\t\tconst nextLevel = (this._currentLevel + 1) % this._levels.length;\n\t\tconst decay = this._levels[nextLevel];\n\t\tthis._currentLevel = nextLevel;\n\t\tfor (let item of decay) {\n\t\t\tthis._data.delete(item);\n\t\t}\n\t\tdecay.clear();\n\t\tif (this._data.size === 0) {\n\t\t\tthis._enterIdleMode();\n\t\t} else {\n\t\t\t// @ts-ignore _nextDecay is always a number in sync mode\n\t\t\tthis._nextDecay += this._tickInterval;\n\t\t}\n\t}\n\n\t_runDecays() {\n\t\twhile (\n\t\t\t/** @type {number} */ (this._nextDecay) <= Date.now() &&\n\t\t\tthis._mode !== STORAGE_MODE_IDLE\n\t\t) {\n\t\t\tthis._decayLevel();\n\t\t}\n\t}\n\n\t_enterAsyncMode() {\n\t\tlet timeout = 0;\n\t\tswitch (this._mode) {\n\t\t\tcase STORAGE_MODE_ASYNC:\n\t\t\t\treturn;\n\t\t\tcase STORAGE_MODE_IDLE:\n\t\t\t\tthis._nextDecay = Date.now() + this._tickInterval;\n\t\t\t\ttimeout = this._tickInterval;\n\t\t\t\tbreak;\n\t\t\tcase STORAGE_MODE_SYNC:\n\t\t\t\tthis._runDecays();\n\t\t\t\t// @ts-ignore _runDecays may change the mode\n\t\t\t\tif (this._mode === STORAGE_MODE_IDLE) return;\n\t\t\t\ttimeout = Math.max(\n\t\t\t\t\t0,\n\t\t\t\t\t/** @type {number} */ (this._nextDecay) - Date.now()\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t}\n\t\tthis._mode = STORAGE_MODE_ASYNC;\n\t\tconst ref = setTimeout(() => {\n\t\t\tthis._mode = STORAGE_MODE_SYNC;\n\t\t\tthis._runDecays();\n\t\t}, timeout);\n\t\tif (ref.unref) ref.unref();\n\t\tthis._timeout = ref;\n\t}\n\n\t_enterSyncModeWhenIdle() {\n\t\tif (this._mode === STORAGE_MODE_IDLE) {\n\t\t\tthis._mode = STORAGE_MODE_SYNC;\n\t\t\tthis._nextDecay = Date.now() + this._tickInterval;\n\t\t}\n\t}\n\n\t_enterIdleMode() {\n\t\tthis._mode = STORAGE_MODE_IDLE;\n\t\tthis._nextDecay = undefined;\n\t\tif (this._timeout) clearTimeout(this._timeout);\n\t}\n}\n\nconst createBackend = (duration, provider, syncProvider, providerContext) => {\n\tif (duration > 0) {\n\t\treturn new CacheBackend(duration, provider, syncProvider, providerContext);\n\t}\n\treturn new OperationMergerBackend(provider, syncProvider, providerContext);\n};\n\nmodule.exports = class CachedInputFileSystem {\n\tconstructor(fileSystem, duration) {\n\t\tthis.fileSystem = fileSystem;\n\n\t\tthis._lstatBackend = createBackend(\n\t\t\tduration,\n\t\t\tthis.fileSystem.lstat,\n\t\t\tthis.fileSystem.lstatSync,\n\t\t\tthis.fileSystem\n\t\t);\n\t\tconst lstat = this._lstatBackend.provide;\n\t\tthis.lstat = /** @type {FileSystem[\"lstat\"]} */ (lstat);\n\t\tconst lstatSync = this._lstatBackend.provideSync;\n\t\tthis.lstatSync = /** @type {SyncFileSystem[\"lstatSync\"]} */ (lstatSync);\n\n\t\tthis._statBackend = createBackend(\n\t\t\tduration,\n\t\t\tthis.fileSystem.stat,\n\t\t\tthis.fileSystem.statSync,\n\t\t\tthis.fileSystem\n\t\t);\n\t\tconst stat = this._statBackend.provide;\n\t\tthis.stat = /** @type {FileSystem[\"stat\"]} */ (stat);\n\t\tconst statSync = this._statBackend.provideSync;\n\t\tthis.statSync = /** @type {SyncFileSystem[\"statSync\"]} */ (statSync);\n\n\t\tthis._readdirBackend = createBackend(\n\t\t\tduration,\n\t\t\tthis.fileSystem.readdir,\n\t\t\tthis.fileSystem.readdirSync,\n\t\t\tthis.fileSystem\n\t\t);\n\t\tconst readdir = this._readdirBackend.provide;\n\t\tthis.readdir = /** @type {FileSystem[\"readdir\"]} */ (readdir);\n\t\tconst readdirSync = this._readdirBackend.provideSync;\n\t\tthis.readdirSync = /** @type {SyncFileSystem[\"readdirSync\"]} */ (readdirSync);\n\n\t\tthis._readFileBackend = createBackend(\n\t\t\tduration,\n\t\t\tthis.fileSystem.readFile,\n\t\t\tthis.fileSystem.readFileSync,\n\t\t\tthis.fileSystem\n\t\t);\n\t\tconst readFile = this._readFileBackend.provide;\n\t\tthis.readFile = /** @type {FileSystem[\"readFile\"]} */ (readFile);\n\t\tconst readFileSync = this._readFileBackend.provideSync;\n\t\tthis.readFileSync = /** @type {SyncFileSystem[\"readFileSync\"]} */ (readFileSync);\n\n\t\tthis._readJsonBackend = createBackend(\n\t\t\tduration,\n\t\t\tthis.fileSystem.readJson ||\n\t\t\t\t(this.readFile &&\n\t\t\t\t\t((path, callback) => {\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tthis.readFile(path, (err, buffer) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tif (!buffer || buffer.length === 0)\n\t\t\t\t\t\t\t\treturn callback(new Error(\"No file content\"));\n\t\t\t\t\t\t\tlet data;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tdata = JSON.parse(buffer.toString(\"utf-8\"));\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\treturn callback(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcallback(null, data);\n\t\t\t\t\t\t});\n\t\t\t\t\t})),\n\t\t\tthis.fileSystem.readJsonSync ||\n\t\t\t\t(this.readFileSync &&\n\t\t\t\t\t(path => {\n\t\t\t\t\t\tconst buffer = this.readFileSync(path);\n\t\t\t\t\t\tconst data = JSON.parse(buffer.toString(\"utf-8\"));\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t})),\n\t\t\tthis.fileSystem\n\t\t);\n\t\tconst readJson = this._readJsonBackend.provide;\n\t\tthis.readJson = /** @type {FileSystem[\"readJson\"]} */ (readJson);\n\t\tconst readJsonSync = this._readJsonBackend.provideSync;\n\t\tthis.readJsonSync = /** @type {SyncFileSystem[\"readJsonSync\"]} */ (readJsonSync);\n\n\t\tthis._readlinkBackend = createBackend(\n\t\t\tduration,\n\t\t\tthis.fileSystem.readlink,\n\t\t\tthis.fileSystem.readlinkSync,\n\t\t\tthis.fileSystem\n\t\t);\n\t\tconst readlink = this._readlinkBackend.provide;\n\t\tthis.readlink = /** @type {FileSystem[\"readlink\"]} */ (readlink);\n\t\tconst readlinkSync = this._readlinkBackend.provideSync;\n\t\tthis.readlinkSync = /** @type {SyncFileSystem[\"readlinkSync\"]} */ (readlinkSync);\n\t}\n\n\tpurge(what) {\n\t\tthis._statBackend.purge(what);\n\t\tthis._lstatBackend.purge(what);\n\t\tthis._readdirBackend.purgeParent(what);\n\t\tthis._readFileBackend.purge(what);\n\t\tthis._readlinkBackend.purge(what);\n\t\tthis._readJsonBackend.purge(what);\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}