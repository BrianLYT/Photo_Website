{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/** @typedef {(string|number|undefined|[])[]} SemVerRange */\n\n/**\n * @param {string} str version string\n * @returns {(string|number|undefined|[])[]} parsed version\n */\n\nconst parseVersion = str => {\n  var splitAndConvert = function (str) {\n    return str.split(\".\").map(function (item) {\n      // eslint-disable-next-line eqeqeq\n      return +item == item ? +item : item;\n    });\n  };\n\n  var match = /^([^-+]+)?(?:-([^+]+))?(?:\\+(.+))?$/.exec(str);\n  /** @type {(string|number|undefined|[])[]} */\n\n  var ver = match[1] ? splitAndConvert(match[1]) : [];\n\n  if (match[2]) {\n    ver.length++;\n    ver.push.apply(ver, splitAndConvert(match[2]));\n  }\n\n  if (match[3]) {\n    ver.push([]);\n    ver.push.apply(ver, splitAndConvert(match[3]));\n  }\n\n  return ver;\n};\n\nexports.parseVersion = parseVersion;\n/* eslint-disable eqeqeq */\n\n/**\n * @param {string} a version\n * @param {string} b version\n * @returns {boolean} true, iff a < b\n */\n\nconst versionLt = (a, b) => {\n  // @ts-expect-error\n  a = parseVersion(a); // @ts-expect-error\n\n  b = parseVersion(b);\n  var i = 0;\n\n  for (;;) {\n    // a       b  EOA     object  undefined  number  string\n    // EOA        a == b  a < b   b < a      a < b   a < b\n    // object     b < a   (0)     b < a      a < b   a < b\n    // undefined  a < b   a < b   (0)        a < b   a < b\n    // number     b < a   b < a   b < a      (1)     a < b\n    // string     b < a   b < a   b < a      b < a   (1)\n    // EOA end of array\n    // (0) continue on\n    // (1) compare them via \"<\"\n    // Handles first row in table\n    if (i >= a.length) return i < b.length && (typeof b[i])[0] != \"u\";\n    var aValue = a[i];\n    var aType = (typeof aValue)[0]; // Handles first column in table\n\n    if (i >= b.length) return aType == \"u\";\n    var bValue = b[i];\n    var bType = (typeof bValue)[0];\n\n    if (aType == bType) {\n      if (aType != \"o\" && aType != \"u\" && aValue != bValue) {\n        return aValue < bValue;\n      }\n\n      i++;\n    } else {\n      // Handles remaining cases\n      if (aType == \"o\" && bType == \"n\") return true;\n      return bType == \"s\" || aType == \"u\";\n    }\n  }\n};\n/* eslint-enable eqeqeq */\n\n\nexports.versionLt = versionLt;\n/**\n * @param {string} str range string\n * @returns {SemVerRange} parsed range\n */\n\nexports.parseRange = str => {\n  const splitAndConvert = str => {\n    return str.split(\".\").map(item => item !== \"NaN\" && `${+item}` === item ? +item : item);\n  }; // see https://docs.npmjs.com/misc/semver#range-grammar for grammar\n\n\n  const parsePartial = str => {\n    const match = /^([^-+]+)?(?:-([^+]+))?(?:\\+(.+))?$/.exec(str);\n    /** @type {(string|number|undefined|[])[]} */\n\n    const ver = match[1] ? [0, ...splitAndConvert(match[1])] : [0];\n\n    if (match[2]) {\n      ver.length++;\n      ver.push.apply(ver, splitAndConvert(match[2]));\n    } // remove trailing any matchers\n\n\n    let last = ver[ver.length - 1];\n\n    while (ver.length && (last === undefined || /^[*xX]$/.test(\n    /** @type {string} */\n    last))) {\n      ver.pop();\n      last = ver[ver.length - 1];\n    }\n\n    return ver;\n  };\n\n  const toFixed = range => {\n    if (range.length === 1) {\n      // Special case for \"*\" is \"x.x.x\" instead of \"=\"\n      return [0];\n    } else if (range.length === 2) {\n      // Special case for \"1\" is \"1.x.x\" instead of \"=1\"\n      return [1, ...range.slice(1)];\n    } else if (range.length === 3) {\n      // Special case for \"1.2\" is \"1.2.x\" instead of \"=1.2\"\n      return [2, ...range.slice(1)];\n    } else {\n      return [range.length, ...range.slice(1)];\n    }\n  };\n\n  const negate = range => {\n    return [-range[0] - 1, ...range.slice(1)];\n  };\n\n  const parseSimple = str => {\n    // simple       ::= primitive | partial | tilde | caret\n    // primitive    ::= ( '<' | '>' | '>=' | '<=' | '=' | '!' ) ( ' ' ) * partial\n    // tilde        ::= '~' ( ' ' ) * partial\n    // caret        ::= '^' ( ' ' ) * partial\n    const match = /^(\\^|~|<=|<|>=|>|=|v|!)/.exec(str);\n    const start = match ? match[0] : \"\";\n    const remainder = parsePartial(start.length ? str.slice(start.length).trim() : str.trim());\n\n    switch (start) {\n      case \"^\":\n        if (remainder.length > 1 && remainder[1] === 0) {\n          if (remainder.length > 2 && remainder[2] === 0) {\n            return [3, ...remainder.slice(1)];\n          }\n\n          return [2, ...remainder.slice(1)];\n        }\n\n        return [1, ...remainder.slice(1)];\n\n      case \"~\":\n        return [2, ...remainder.slice(1)];\n\n      case \">=\":\n        return remainder;\n\n      case \"=\":\n      case \"v\":\n      case \"\":\n        return toFixed(remainder);\n\n      case \"<\":\n        return negate(remainder);\n\n      case \">\":\n        {\n          // and( >=, not( = ) ) => >=, =, not, and\n          const fixed = toFixed(remainder); // eslint-disable-next-line no-sparse-arrays\n\n          return [, fixed, 0, remainder, 2];\n        }\n\n      case \"<=\":\n        // or( <, = ) => <, =, or\n        // eslint-disable-next-line no-sparse-arrays\n        return [, toFixed(remainder), negate(remainder), 1];\n\n      case \"!\":\n        {\n          // not =\n          const fixed = toFixed(remainder); // eslint-disable-next-line no-sparse-arrays\n\n          return [, fixed, 0];\n        }\n\n      default:\n        throw new Error(\"Unexpected start value\");\n    }\n  };\n\n  const combine = (items, fn) => {\n    if (items.length === 1) return items[0];\n    const arr = [];\n\n    for (const item of items.slice().reverse()) {\n      if (0 in item) {\n        arr.push(item);\n      } else {\n        arr.push(...item.slice(1));\n      }\n    } // eslint-disable-next-line no-sparse-arrays\n\n\n    return [, ...arr, ...items.slice(1).map(() => fn)];\n  };\n\n  const parseRange = str => {\n    // range      ::= hyphen | simple ( ' ' ( ' ' ) * simple ) * | ''\n    // hyphen     ::= partial ( ' ' ) * ' - ' ( ' ' ) * partial\n    const items = str.split(/\\s+-\\s+/);\n\n    if (items.length === 1) {\n      const items = str.trim().split(/(?<=[-0-9A-Za-z])\\s+/g).map(parseSimple);\n      return combine(items, 2);\n    }\n\n    const a = parsePartial(items[0]);\n    const b = parsePartial(items[1]); // >=a <=b => and( >=a, or( <b, =b ) ) => >=a, <b, =b, or, and\n    // eslint-disable-next-line no-sparse-arrays\n\n    return [, toFixed(b), negate(b), 1, a, 2];\n  };\n\n  const parseLogicalOr = str => {\n    // range-set  ::= range ( logical-or range ) *\n    // logical-or ::= ( ' ' ) * '||' ( ' ' ) *\n    const items = str.split(/\\s*\\|\\|\\s*/).map(parseRange);\n    return combine(items, 1);\n  };\n\n  return parseLogicalOr(str);\n};\n/* eslint-disable eqeqeq */\n\n\nconst rangeToString = range => {\n  var fixCount = range[0];\n  var str = \"\";\n\n  if (range.length === 1) {\n    return \"*\";\n  } else if (fixCount + 0.5) {\n    str += fixCount == 0 ? \">=\" : fixCount == -1 ? \"<\" : fixCount == 1 ? \"^\" : fixCount == 2 ? \"~\" : fixCount > 0 ? \"=\" : \"!=\";\n    var needDot = 1; // eslint-disable-next-line no-redeclare\n\n    for (var i = 1; i < range.length; i++) {\n      var item = range[i];\n      var t = (typeof item)[0];\n      needDot--;\n      str += t == \"u\" ? // undefined: prerelease marker, add an \"-\"\n      \"-\" : // number or string: add the item, set flag to add an \".\" between two of them\n      (needDot > 0 ? \".\" : \"\") + (needDot = 2, item);\n    }\n\n    return str;\n  } else {\n    var stack = []; // eslint-disable-next-line no-redeclare\n\n    for (var i = 1; i < range.length; i++) {\n      // eslint-disable-next-line no-redeclare\n      var item = range[i];\n      stack.push(item === 0 ? \"not(\" + pop() + \")\" : item === 1 ? \"(\" + pop() + \" || \" + pop() + \")\" : item === 2 ? stack.pop() + \" \" + stack.pop() : rangeToString(item));\n    }\n\n    return pop();\n  }\n\n  function pop() {\n    return stack.pop().replace(/^\\((.+)\\)$/, \"$1\");\n  }\n};\n/* eslint-enable eqeqeq */\n\n\nexports.rangeToString = rangeToString;\n/* eslint-disable eqeqeq */\n\n/**\n * @param {SemVerRange} range version range\n * @param {string} version the version\n * @returns {boolean} if version satisfy the range\n */\n\nconst satisfy = (range, version) => {\n  if (0 in range) {\n    // @ts-expect-error\n    version = parseVersion(version);\n    var fixCount = range[0]; // when negated is set it swill set for < instead of >=\n\n    var negated = fixCount < 0;\n    if (negated) fixCount = -fixCount - 1;\n\n    for (var i = 0, j = 1, isEqual = true;; j++, i++) {\n      // cspell:word nequal nequ\n      // when isEqual = true:\n      // range         version: EOA/object  undefined  number    string\n      // EOA                    equal       block      big-ver   big-ver\n      // undefined              bigger      next       big-ver   big-ver\n      // number                 smaller     block      cmp       big-cmp\n      // fixed number           smaller     block      cmp-fix   differ\n      // string                 smaller     block      differ    cmp\n      // fixed string           smaller     block      small-cmp cmp-fix\n      // when isEqual = false:\n      // range         version: EOA/object  undefined  number    string\n      // EOA                    nequal      block      next-ver  next-ver\n      // undefined              nequal      block      next-ver  next-ver\n      // number                 nequal      block      next      next\n      // fixed number           nequal      block      next      next   (this never happens)\n      // string                 nequal      block      next      next\n      // fixed string           nequal      block      next      next   (this never happens)\n      // EOA end of array\n      // equal (version is equal range):\n      //   when !negated: return true,\n      //   when negated: return false\n      // bigger (version is bigger as range):\n      //   when fixed: return false,\n      //   when !negated: return true,\n      //   when negated: return false,\n      // smaller (version is smaller as range):\n      //   when !negated: return false,\n      //   when negated: return true\n      // nequal (version is not equal range (> resp <)): return true\n      // block (version is in different prerelease area): return false\n      // differ (version is different from fixed range (string vs. number)): return false\n      // next: continues to the next items\n      // next-ver: when fixed: return false, continues to the next item only for the version, sets isEqual=false\n      // big-ver: when fixed || negated: return false, continues to the next item only for the version, sets isEqual=false\n      // next-nequ: continues to the next items, sets isEqual=false\n      // cmp (negated === false): version < range => return false, version > range => next-nequ, else => next\n      // cmp (negated === true): version > range => return false, version < range => next-nequ, else => next\n      // cmp-fix: version == range => next, else => return false\n      // big-cmp: when negated => return false, else => next-nequ\n      // small-cmp: when negated => next-nequ, else => return false\n      var rangeType = j < range.length ? (typeof range[j])[0] : \"\";\n      var versionValue;\n      var versionType; // Handles first column in both tables (end of version or object)\n\n      if (i >= version.length || (versionValue = version[i], (versionType = (typeof versionValue)[0]) == \"o\")) {\n        // Handles nequal\n        if (!isEqual) return true; // Handles bigger\n\n        if (rangeType == \"u\") return j > fixCount && !negated; // Handles equal and smaller: (range === EOA) XOR negated\n\n        return rangeType == \"\" != negated; // equal + smaller\n      } // Handles second column in both tables (version = undefined)\n\n\n      if (versionType == \"u\") {\n        if (!isEqual || rangeType != \"u\") {\n          return false;\n        }\n      } // switch between first and second table\n      else if (isEqual) {\n        // Handle diagonal\n        if (rangeType == versionType) {\n          if (j <= fixCount) {\n            // Handles \"cmp-fix\" cases\n            if (versionValue != range[j]) {\n              return false;\n            }\n          } else {\n            // Handles \"cmp\" cases\n            if (negated ? versionValue > range[j] : versionValue < range[j]) {\n              return false;\n            }\n\n            if (versionValue != range[j]) isEqual = false;\n          }\n        } // Handle big-ver\n        else if (rangeType != \"s\" && rangeType != \"n\") {\n          if (negated || j <= fixCount) return false;\n          isEqual = false;\n          j--;\n        } // Handle differ, big-cmp and small-cmp\n        else if (j <= fixCount || versionType < rangeType != negated) {\n          return false;\n        } else {\n          isEqual = false;\n        }\n      } else {\n        // Handles all \"next-ver\" cases in the second table\n        if (rangeType != \"s\" && rangeType != \"n\") {\n          isEqual = false;\n          j--;\n        } // next is applied by default\n\n      }\n    }\n  }\n  /** @type {(boolean | number)[]} */\n\n\n  var stack = [];\n  var p = stack.pop.bind(stack); // eslint-disable-next-line no-redeclare\n\n  for (var i = 1; i < range.length; i++) {\n    var item =\n    /** @type {SemVerRange | 0 | 1 | 2} */\n    range[i];\n    stack.push(item == 1 ? p() | p() : item == 2 ? p() & p() : item ? satisfy(item, version) : !p());\n  }\n\n  return !!p();\n};\n/* eslint-enable eqeqeq */\n\n\nexports.satisfy = satisfy;\n\nexports.stringifyHoley = json => {\n  switch (typeof json) {\n    case \"undefined\":\n      return \"\";\n\n    case \"object\":\n      if (Array.isArray(json)) {\n        let str = \"[\";\n\n        for (let i = 0; i < json.length; i++) {\n          if (i !== 0) str += \",\";\n          str += this.stringifyHoley(json[i]);\n        }\n\n        str += \"]\";\n        return str;\n      } else {\n        return JSON.stringify(json);\n      }\n\n    default:\n      return JSON.stringify(json);\n  }\n}; //#region runtime code: parseVersion\n\n\nexports.parseVersionRuntimeCode = runtimeTemplate => `var parseVersion = ${runtimeTemplate.basicFunction(\"str\", [\"// see webpack/lib/util/semver.js for original code\", `var p=${runtimeTemplate.supportsArrowFunction() ? \"p=>\" : \"function(p)\"}{return p.split(\".\").map((${runtimeTemplate.supportsArrowFunction() ? \"p=>\" : \"function(p)\"}{return+p==p?+p:p}))},n=/^([^-+]+)?(?:-([^+]+))?(?:\\\\+(.+))?$/.exec(str),r=n[1]?p(n[1]):[];return n[2]&&(r.length++,r.push.apply(r,p(n[2]))),n[3]&&(r.push([]),r.push.apply(r,p(n[3]))),r;`])}`; //#endregion\n//#region runtime code: versionLt\n\n\nexports.versionLtRuntimeCode = runtimeTemplate => `var versionLt = ${runtimeTemplate.basicFunction(\"a, b\", [\"// see webpack/lib/util/semver.js for original code\", 'a=parseVersion(a),b=parseVersion(b);for(var r=0;;){if(r>=a.length)return r<b.length&&\"u\"!=(typeof b[r])[0];var e=a[r],n=(typeof e)[0];if(r>=b.length)return\"u\"==n;var t=b[r],f=(typeof t)[0];if(n!=f)return\"o\"==n&&\"n\"==f||(\"s\"==f||\"u\"==n);if(\"o\"!=n&&\"u\"!=n&&e!=t)return e<t;r++}'])}`; //#endregion\n//#region runtime code: rangeToString\n\n\nexports.rangeToStringRuntimeCode = runtimeTemplate => `var rangeToString = ${runtimeTemplate.basicFunction(\"range\", [\"// see webpack/lib/util/semver.js for original code\", 'var r=range[0],n=\"\";if(1===range.length)return\"*\";if(r+.5){n+=0==r?\">=\":-1==r?\"<\":1==r?\"^\":2==r?\"~\":r>0?\"=\":\"!=\";for(var e=1,a=1;a<range.length;a++){e--,n+=\"u\"==(typeof(t=range[a]))[0]?\"-\":(e>0?\".\":\"\")+(e=2,t)}return n}var g=[];for(a=1;a<range.length;a++){var t=range[a];g.push(0===t?\"not(\"+o()+\")\":1===t?\"(\"+o()+\" || \"+o()+\")\":2===t?g.pop()+\" \"+g.pop():rangeToString(t))}return o();function o(){return g.pop().replace(/^\\\\((.+)\\\\)$/,\"$1\")}'])}`; //#endregion\n//#region runtime code: satisfy\n\n\nexports.satisfyRuntimeCode = runtimeTemplate => `var satisfy = ${runtimeTemplate.basicFunction(\"range, version\", [\"// see webpack/lib/util/semver.js for original code\", 'if(0 in range){version=parseVersion(version);var e=range[0],r=e<0;r&&(e=-e-1);for(var n=0,i=1,a=!0;;i++,n++){var f,s,g=i<range.length?(typeof range[i])[0]:\"\";if(n>=version.length||\"o\"==(s=(typeof(f=version[n]))[0]))return!a||(\"u\"==g?i>e&&!r:\"\"==g!=r);if(\"u\"==s){if(!a||\"u\"!=g)return!1}else if(a)if(g==s)if(i<=e){if(f!=range[i])return!1}else{if(r?f>range[i]:f<range[i])return!1;f!=range[i]&&(a=!1)}else if(\"s\"!=g&&\"n\"!=g){if(r||i<=e)return!1;a=!1,i--}else{if(i<=e||s<g!=r)return!1;a=!1}else\"s\"!=g&&\"n\"!=g&&(a=!1,i--)}}var t=[],o=t.pop.bind(t);for(n=1;n<range.length;n++){var u=range[n];t.push(1==u?o()|o():2==u?o()&o():u?satisfy(u,version):!o())}return!!o();'])}`; //#endregion","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/util/semver.js"],"names":["parseVersion","str","splitAndConvert","split","map","item","match","exec","ver","length","push","apply","exports","versionLt","a","b","i","aValue","aType","bValue","bType","parseRange","parsePartial","last","undefined","test","pop","toFixed","range","slice","negate","parseSimple","start","remainder","trim","fixed","Error","combine","items","fn","arr","reverse","parseLogicalOr","rangeToString","fixCount","needDot","t","stack","replace","satisfy","version","negated","j","isEqual","rangeType","versionValue","versionType","p","bind","stringifyHoley","json","Array","isArray","JSON","stringify","parseVersionRuntimeCode","runtimeTemplate","basicFunction","supportsArrowFunction","versionLtRuntimeCode","rangeToStringRuntimeCode","satisfyRuntimeCode"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @typedef {(string|number|undefined|[])[]} SemVerRange */\n\n/**\n * @param {string} str version string\n * @returns {(string|number|undefined|[])[]} parsed version\n */\nconst parseVersion = str => {\n\tvar splitAndConvert = function (str) {\n\t\treturn str.split(\".\").map(function (item) {\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\treturn +item == item ? +item : item;\n\t\t});\n\t};\n\tvar match = /^([^-+]+)?(?:-([^+]+))?(?:\\+(.+))?$/.exec(str);\n\t/** @type {(string|number|undefined|[])[]} */\n\tvar ver = match[1] ? splitAndConvert(match[1]) : [];\n\tif (match[2]) {\n\t\tver.length++;\n\t\tver.push.apply(ver, splitAndConvert(match[2]));\n\t}\n\tif (match[3]) {\n\t\tver.push([]);\n\t\tver.push.apply(ver, splitAndConvert(match[3]));\n\t}\n\treturn ver;\n};\nexports.parseVersion = parseVersion;\n\n/* eslint-disable eqeqeq */\n/**\n * @param {string} a version\n * @param {string} b version\n * @returns {boolean} true, iff a < b\n */\nconst versionLt = (a, b) => {\n\t// @ts-expect-error\n\ta = parseVersion(a);\n\t// @ts-expect-error\n\tb = parseVersion(b);\n\tvar i = 0;\n\tfor (;;) {\n\t\t// a       b  EOA     object  undefined  number  string\n\t\t// EOA        a == b  a < b   b < a      a < b   a < b\n\t\t// object     b < a   (0)     b < a      a < b   a < b\n\t\t// undefined  a < b   a < b   (0)        a < b   a < b\n\t\t// number     b < a   b < a   b < a      (1)     a < b\n\t\t// string     b < a   b < a   b < a      b < a   (1)\n\t\t// EOA end of array\n\t\t// (0) continue on\n\t\t// (1) compare them via \"<\"\n\n\t\t// Handles first row in table\n\t\tif (i >= a.length) return i < b.length && (typeof b[i])[0] != \"u\";\n\n\t\tvar aValue = a[i];\n\t\tvar aType = (typeof aValue)[0];\n\n\t\t// Handles first column in table\n\t\tif (i >= b.length) return aType == \"u\";\n\n\t\tvar bValue = b[i];\n\t\tvar bType = (typeof bValue)[0];\n\n\t\tif (aType == bType) {\n\t\t\tif (aType != \"o\" && aType != \"u\" && aValue != bValue) {\n\t\t\t\treturn aValue < bValue;\n\t\t\t}\n\t\t\ti++;\n\t\t} else {\n\t\t\t// Handles remaining cases\n\t\t\tif (aType == \"o\" && bType == \"n\") return true;\n\t\t\treturn bType == \"s\" || aType == \"u\";\n\t\t}\n\t}\n};\n/* eslint-enable eqeqeq */\nexports.versionLt = versionLt;\n\n/**\n * @param {string} str range string\n * @returns {SemVerRange} parsed range\n */\nexports.parseRange = str => {\n\tconst splitAndConvert = str => {\n\t\treturn str\n\t\t\t.split(\".\")\n\t\t\t.map(item => (item !== \"NaN\" && `${+item}` === item ? +item : item));\n\t};\n\t// see https://docs.npmjs.com/misc/semver#range-grammar for grammar\n\tconst parsePartial = str => {\n\t\tconst match = /^([^-+]+)?(?:-([^+]+))?(?:\\+(.+))?$/.exec(str);\n\t\t/** @type {(string|number|undefined|[])[]} */\n\t\tconst ver = match[1] ? [0, ...splitAndConvert(match[1])] : [0];\n\t\tif (match[2]) {\n\t\t\tver.length++;\n\t\t\tver.push.apply(ver, splitAndConvert(match[2]));\n\t\t}\n\n\t\t// remove trailing any matchers\n\t\tlet last = ver[ver.length - 1];\n\t\twhile (\n\t\t\tver.length &&\n\t\t\t(last === undefined || /^[*xX]$/.test(/** @type {string} */ (last)))\n\t\t) {\n\t\t\tver.pop();\n\t\t\tlast = ver[ver.length - 1];\n\t\t}\n\n\t\treturn ver;\n\t};\n\tconst toFixed = range => {\n\t\tif (range.length === 1) {\n\t\t\t// Special case for \"*\" is \"x.x.x\" instead of \"=\"\n\t\t\treturn [0];\n\t\t} else if (range.length === 2) {\n\t\t\t// Special case for \"1\" is \"1.x.x\" instead of \"=1\"\n\t\t\treturn [1, ...range.slice(1)];\n\t\t} else if (range.length === 3) {\n\t\t\t// Special case for \"1.2\" is \"1.2.x\" instead of \"=1.2\"\n\t\t\treturn [2, ...range.slice(1)];\n\t\t} else {\n\t\t\treturn [range.length, ...range.slice(1)];\n\t\t}\n\t};\n\tconst negate = range => {\n\t\treturn [-range[0] - 1, ...range.slice(1)];\n\t};\n\tconst parseSimple = str => {\n\t\t// simple       ::= primitive | partial | tilde | caret\n\t\t// primitive    ::= ( '<' | '>' | '>=' | '<=' | '=' | '!' ) ( ' ' ) * partial\n\t\t// tilde        ::= '~' ( ' ' ) * partial\n\t\t// caret        ::= '^' ( ' ' ) * partial\n\t\tconst match = /^(\\^|~|<=|<|>=|>|=|v|!)/.exec(str);\n\t\tconst start = match ? match[0] : \"\";\n\t\tconst remainder = parsePartial(\n\t\t\tstart.length ? str.slice(start.length).trim() : str.trim()\n\t\t);\n\t\tswitch (start) {\n\t\t\tcase \"^\":\n\t\t\t\tif (remainder.length > 1 && remainder[1] === 0) {\n\t\t\t\t\tif (remainder.length > 2 && remainder[2] === 0) {\n\t\t\t\t\t\treturn [3, ...remainder.slice(1)];\n\t\t\t\t\t}\n\t\t\t\t\treturn [2, ...remainder.slice(1)];\n\t\t\t\t}\n\t\t\t\treturn [1, ...remainder.slice(1)];\n\t\t\tcase \"~\":\n\t\t\t\treturn [2, ...remainder.slice(1)];\n\t\t\tcase \">=\":\n\t\t\t\treturn remainder;\n\t\t\tcase \"=\":\n\t\t\tcase \"v\":\n\t\t\tcase \"\":\n\t\t\t\treturn toFixed(remainder);\n\t\t\tcase \"<\":\n\t\t\t\treturn negate(remainder);\n\t\t\tcase \">\": {\n\t\t\t\t// and( >=, not( = ) ) => >=, =, not, and\n\t\t\t\tconst fixed = toFixed(remainder);\n\t\t\t\t// eslint-disable-next-line no-sparse-arrays\n\t\t\t\treturn [, fixed, 0, remainder, 2];\n\t\t\t}\n\t\t\tcase \"<=\":\n\t\t\t\t// or( <, = ) => <, =, or\n\t\t\t\t// eslint-disable-next-line no-sparse-arrays\n\t\t\t\treturn [, toFixed(remainder), negate(remainder), 1];\n\t\t\tcase \"!\": {\n\t\t\t\t// not =\n\t\t\t\tconst fixed = toFixed(remainder);\n\t\t\t\t// eslint-disable-next-line no-sparse-arrays\n\t\t\t\treturn [, fixed, 0];\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unexpected start value\");\n\t\t}\n\t};\n\tconst combine = (items, fn) => {\n\t\tif (items.length === 1) return items[0];\n\t\tconst arr = [];\n\t\tfor (const item of items.slice().reverse()) {\n\t\t\tif (0 in item) {\n\t\t\t\tarr.push(item);\n\t\t\t} else {\n\t\t\t\tarr.push(...item.slice(1));\n\t\t\t}\n\t\t}\n\t\t// eslint-disable-next-line no-sparse-arrays\n\t\treturn [, ...arr, ...items.slice(1).map(() => fn)];\n\t};\n\tconst parseRange = str => {\n\t\t// range      ::= hyphen | simple ( ' ' ( ' ' ) * simple ) * | ''\n\t\t// hyphen     ::= partial ( ' ' ) * ' - ' ( ' ' ) * partial\n\t\tconst items = str.split(/\\s+-\\s+/);\n\t\tif (items.length === 1) {\n\t\t\tconst items = str\n\t\t\t\t.trim()\n\t\t\t\t.split(/(?<=[-0-9A-Za-z])\\s+/g)\n\t\t\t\t.map(parseSimple);\n\t\t\treturn combine(items, 2);\n\t\t}\n\t\tconst a = parsePartial(items[0]);\n\t\tconst b = parsePartial(items[1]);\n\t\t// >=a <=b => and( >=a, or( <b, =b ) ) => >=a, <b, =b, or, and\n\t\t// eslint-disable-next-line no-sparse-arrays\n\t\treturn [, toFixed(b), negate(b), 1, a, 2];\n\t};\n\tconst parseLogicalOr = str => {\n\t\t// range-set  ::= range ( logical-or range ) *\n\t\t// logical-or ::= ( ' ' ) * '||' ( ' ' ) *\n\t\tconst items = str.split(/\\s*\\|\\|\\s*/).map(parseRange);\n\t\treturn combine(items, 1);\n\t};\n\treturn parseLogicalOr(str);\n};\n\n/* eslint-disable eqeqeq */\nconst rangeToString = range => {\n\tvar fixCount = range[0];\n\tvar str = \"\";\n\tif (range.length === 1) {\n\t\treturn \"*\";\n\t} else if (fixCount + 0.5) {\n\t\tstr +=\n\t\t\tfixCount == 0\n\t\t\t\t? \">=\"\n\t\t\t\t: fixCount == -1\n\t\t\t\t? \"<\"\n\t\t\t\t: fixCount == 1\n\t\t\t\t? \"^\"\n\t\t\t\t: fixCount == 2\n\t\t\t\t? \"~\"\n\t\t\t\t: fixCount > 0\n\t\t\t\t? \"=\"\n\t\t\t\t: \"!=\";\n\t\tvar needDot = 1;\n\t\t// eslint-disable-next-line no-redeclare\n\t\tfor (var i = 1; i < range.length; i++) {\n\t\t\tvar item = range[i];\n\t\t\tvar t = (typeof item)[0];\n\t\t\tneedDot--;\n\t\t\tstr +=\n\t\t\t\tt == \"u\"\n\t\t\t\t\t? // undefined: prerelease marker, add an \"-\"\n\t\t\t\t\t  \"-\"\n\t\t\t\t\t: // number or string: add the item, set flag to add an \".\" between two of them\n\t\t\t\t\t  (needDot > 0 ? \".\" : \"\") + ((needDot = 2), item);\n\t\t}\n\t\treturn str;\n\t} else {\n\t\tvar stack = [];\n\t\t// eslint-disable-next-line no-redeclare\n\t\tfor (var i = 1; i < range.length; i++) {\n\t\t\t// eslint-disable-next-line no-redeclare\n\t\t\tvar item = range[i];\n\t\t\tstack.push(\n\t\t\t\titem === 0\n\t\t\t\t\t? \"not(\" + pop() + \")\"\n\t\t\t\t\t: item === 1\n\t\t\t\t\t? \"(\" + pop() + \" || \" + pop() + \")\"\n\t\t\t\t\t: item === 2\n\t\t\t\t\t? stack.pop() + \" \" + stack.pop()\n\t\t\t\t\t: rangeToString(item)\n\t\t\t);\n\t\t}\n\t\treturn pop();\n\t}\n\tfunction pop() {\n\t\treturn stack.pop().replace(/^\\((.+)\\)$/, \"$1\");\n\t}\n};\n/* eslint-enable eqeqeq */\nexports.rangeToString = rangeToString;\n\n/* eslint-disable eqeqeq */\n/**\n * @param {SemVerRange} range version range\n * @param {string} version the version\n * @returns {boolean} if version satisfy the range\n */\nconst satisfy = (range, version) => {\n\tif (0 in range) {\n\t\t// @ts-expect-error\n\t\tversion = parseVersion(version);\n\t\tvar fixCount = range[0];\n\t\t// when negated is set it swill set for < instead of >=\n\t\tvar negated = fixCount < 0;\n\t\tif (negated) fixCount = -fixCount - 1;\n\t\tfor (var i = 0, j = 1, isEqual = true; ; j++, i++) {\n\t\t\t// cspell:word nequal nequ\n\n\t\t\t// when isEqual = true:\n\t\t\t// range         version: EOA/object  undefined  number    string\n\t\t\t// EOA                    equal       block      big-ver   big-ver\n\t\t\t// undefined              bigger      next       big-ver   big-ver\n\t\t\t// number                 smaller     block      cmp       big-cmp\n\t\t\t// fixed number           smaller     block      cmp-fix   differ\n\t\t\t// string                 smaller     block      differ    cmp\n\t\t\t// fixed string           smaller     block      small-cmp cmp-fix\n\n\t\t\t// when isEqual = false:\n\t\t\t// range         version: EOA/object  undefined  number    string\n\t\t\t// EOA                    nequal      block      next-ver  next-ver\n\t\t\t// undefined              nequal      block      next-ver  next-ver\n\t\t\t// number                 nequal      block      next      next\n\t\t\t// fixed number           nequal      block      next      next   (this never happens)\n\t\t\t// string                 nequal      block      next      next\n\t\t\t// fixed string           nequal      block      next      next   (this never happens)\n\n\t\t\t// EOA end of array\n\t\t\t// equal (version is equal range):\n\t\t\t//   when !negated: return true,\n\t\t\t//   when negated: return false\n\t\t\t// bigger (version is bigger as range):\n\t\t\t//   when fixed: return false,\n\t\t\t//   when !negated: return true,\n\t\t\t//   when negated: return false,\n\t\t\t// smaller (version is smaller as range):\n\t\t\t//   when !negated: return false,\n\t\t\t//   when negated: return true\n\t\t\t// nequal (version is not equal range (> resp <)): return true\n\t\t\t// block (version is in different prerelease area): return false\n\t\t\t// differ (version is different from fixed range (string vs. number)): return false\n\t\t\t// next: continues to the next items\n\t\t\t// next-ver: when fixed: return false, continues to the next item only for the version, sets isEqual=false\n\t\t\t// big-ver: when fixed || negated: return false, continues to the next item only for the version, sets isEqual=false\n\t\t\t// next-nequ: continues to the next items, sets isEqual=false\n\t\t\t// cmp (negated === false): version < range => return false, version > range => next-nequ, else => next\n\t\t\t// cmp (negated === true): version > range => return false, version < range => next-nequ, else => next\n\t\t\t// cmp-fix: version == range => next, else => return false\n\t\t\t// big-cmp: when negated => return false, else => next-nequ\n\t\t\t// small-cmp: when negated => next-nequ, else => return false\n\n\t\t\tvar rangeType = j < range.length ? (typeof range[j])[0] : \"\";\n\n\t\t\tvar versionValue;\n\t\t\tvar versionType;\n\n\t\t\t// Handles first column in both tables (end of version or object)\n\t\t\tif (\n\t\t\t\ti >= version.length ||\n\t\t\t\t((versionValue = version[i]),\n\t\t\t\t(versionType = (typeof versionValue)[0]) == \"o\")\n\t\t\t) {\n\t\t\t\t// Handles nequal\n\t\t\t\tif (!isEqual) return true;\n\t\t\t\t// Handles bigger\n\t\t\t\tif (rangeType == \"u\") return j > fixCount && !negated;\n\t\t\t\t// Handles equal and smaller: (range === EOA) XOR negated\n\t\t\t\treturn (rangeType == \"\") != negated; // equal + smaller\n\t\t\t}\n\n\t\t\t// Handles second column in both tables (version = undefined)\n\t\t\tif (versionType == \"u\") {\n\t\t\t\tif (!isEqual || rangeType != \"u\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// switch between first and second table\n\t\t\telse if (isEqual) {\n\t\t\t\t// Handle diagonal\n\t\t\t\tif (rangeType == versionType) {\n\t\t\t\t\tif (j <= fixCount) {\n\t\t\t\t\t\t// Handles \"cmp-fix\" cases\n\t\t\t\t\t\tif (versionValue != range[j]) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Handles \"cmp\" cases\n\t\t\t\t\t\tif (negated ? versionValue > range[j] : versionValue < range[j]) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (versionValue != range[j]) isEqual = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Handle big-ver\n\t\t\t\telse if (rangeType != \"s\" && rangeType != \"n\") {\n\t\t\t\t\tif (negated || j <= fixCount) return false;\n\t\t\t\t\tisEqual = false;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\n\t\t\t\t// Handle differ, big-cmp and small-cmp\n\t\t\t\telse if (j <= fixCount || versionType < rangeType != negated) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tisEqual = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Handles all \"next-ver\" cases in the second table\n\t\t\t\tif (rangeType != \"s\" && rangeType != \"n\") {\n\t\t\t\t\tisEqual = false;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\n\t\t\t\t// next is applied by default\n\t\t\t}\n\t\t}\n\t}\n\t/** @type {(boolean | number)[]} */\n\tvar stack = [];\n\tvar p = stack.pop.bind(stack);\n\t// eslint-disable-next-line no-redeclare\n\tfor (var i = 1; i < range.length; i++) {\n\t\tvar item = /** @type {SemVerRange | 0 | 1 | 2} */ (range[i]);\n\t\tstack.push(\n\t\t\titem == 1\n\t\t\t\t? p() | p()\n\t\t\t\t: item == 2\n\t\t\t\t? p() & p()\n\t\t\t\t: item\n\t\t\t\t? satisfy(item, version)\n\t\t\t\t: !p()\n\t\t);\n\t}\n\treturn !!p();\n};\n/* eslint-enable eqeqeq */\nexports.satisfy = satisfy;\n\nexports.stringifyHoley = json => {\n\tswitch (typeof json) {\n\t\tcase \"undefined\":\n\t\t\treturn \"\";\n\t\tcase \"object\":\n\t\t\tif (Array.isArray(json)) {\n\t\t\t\tlet str = \"[\";\n\t\t\t\tfor (let i = 0; i < json.length; i++) {\n\t\t\t\t\tif (i !== 0) str += \",\";\n\t\t\t\t\tstr += this.stringifyHoley(json[i]);\n\t\t\t\t}\n\t\t\t\tstr += \"]\";\n\t\t\t\treturn str;\n\t\t\t} else {\n\t\t\t\treturn JSON.stringify(json);\n\t\t\t}\n\t\tdefault:\n\t\t\treturn JSON.stringify(json);\n\t}\n};\n\n//#region runtime code: parseVersion\nexports.parseVersionRuntimeCode = runtimeTemplate =>\n\t`var parseVersion = ${runtimeTemplate.basicFunction(\"str\", [\n\t\t\"// see webpack/lib/util/semver.js for original code\",\n\t\t`var p=${\n\t\t\truntimeTemplate.supportsArrowFunction() ? \"p=>\" : \"function(p)\"\n\t\t}{return p.split(\".\").map((${\n\t\t\truntimeTemplate.supportsArrowFunction() ? \"p=>\" : \"function(p)\"\n\t\t}{return+p==p?+p:p}))},n=/^([^-+]+)?(?:-([^+]+))?(?:\\\\+(.+))?$/.exec(str),r=n[1]?p(n[1]):[];return n[2]&&(r.length++,r.push.apply(r,p(n[2]))),n[3]&&(r.push([]),r.push.apply(r,p(n[3]))),r;`\n\t])}`;\n//#endregion\n\n//#region runtime code: versionLt\nexports.versionLtRuntimeCode = runtimeTemplate =>\n\t`var versionLt = ${runtimeTemplate.basicFunction(\"a, b\", [\n\t\t\"// see webpack/lib/util/semver.js for original code\",\n\t\t'a=parseVersion(a),b=parseVersion(b);for(var r=0;;){if(r>=a.length)return r<b.length&&\"u\"!=(typeof b[r])[0];var e=a[r],n=(typeof e)[0];if(r>=b.length)return\"u\"==n;var t=b[r],f=(typeof t)[0];if(n!=f)return\"o\"==n&&\"n\"==f||(\"s\"==f||\"u\"==n);if(\"o\"!=n&&\"u\"!=n&&e!=t)return e<t;r++}'\n\t])}`;\n//#endregion\n\n//#region runtime code: rangeToString\nexports.rangeToStringRuntimeCode = runtimeTemplate =>\n\t`var rangeToString = ${runtimeTemplate.basicFunction(\"range\", [\n\t\t\"// see webpack/lib/util/semver.js for original code\",\n\t\t'var r=range[0],n=\"\";if(1===range.length)return\"*\";if(r+.5){n+=0==r?\">=\":-1==r?\"<\":1==r?\"^\":2==r?\"~\":r>0?\"=\":\"!=\";for(var e=1,a=1;a<range.length;a++){e--,n+=\"u\"==(typeof(t=range[a]))[0]?\"-\":(e>0?\".\":\"\")+(e=2,t)}return n}var g=[];for(a=1;a<range.length;a++){var t=range[a];g.push(0===t?\"not(\"+o()+\")\":1===t?\"(\"+o()+\" || \"+o()+\")\":2===t?g.pop()+\" \"+g.pop():rangeToString(t))}return o();function o(){return g.pop().replace(/^\\\\((.+)\\\\)$/,\"$1\")}'\n\t])}`;\n//#endregion\n\n//#region runtime code: satisfy\nexports.satisfyRuntimeCode = runtimeTemplate =>\n\t`var satisfy = ${runtimeTemplate.basicFunction(\"range, version\", [\n\t\t\"// see webpack/lib/util/semver.js for original code\",\n\t\t'if(0 in range){version=parseVersion(version);var e=range[0],r=e<0;r&&(e=-e-1);for(var n=0,i=1,a=!0;;i++,n++){var f,s,g=i<range.length?(typeof range[i])[0]:\"\";if(n>=version.length||\"o\"==(s=(typeof(f=version[n]))[0]))return!a||(\"u\"==g?i>e&&!r:\"\"==g!=r);if(\"u\"==s){if(!a||\"u\"!=g)return!1}else if(a)if(g==s)if(i<=e){if(f!=range[i])return!1}else{if(r?f>range[i]:f<range[i])return!1;f!=range[i]&&(a=!1)}else if(\"s\"!=g&&\"n\"!=g){if(r||i<=e)return!1;a=!1,i--}else{if(i<=e||s<g!=r)return!1;a=!1}else\"s\"!=g&&\"n\"!=g&&(a=!1,i--)}}var t=[],o=t.pop.bind(t);for(n=1;n<range.length;n++){var u=range[n];t.push(1==u?o()|o():2==u?o()&o():u?satisfy(u,version):!o())}return!!o();'\n\t])}`;\n//#endregion\n"]},"metadata":{},"sourceType":"script"}