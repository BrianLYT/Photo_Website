{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst streamChunksOfRawSource = require(\"./helpers/streamChunksOfRawSource\");\n\nconst Source = require(\"./Source\");\n\nclass RawSource extends Source {\n  constructor(value) {\n    let convertToString = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super();\n    const isBuffer = Buffer.isBuffer(value);\n\n    if (!isBuffer && typeof value !== \"string\") {\n      throw new TypeError(\"argument 'value' must be either string of Buffer\");\n    }\n\n    this._valueIsBuffer = !convertToString && isBuffer;\n    this._value = convertToString && isBuffer ? undefined : value;\n    this._valueAsBuffer = isBuffer ? value : undefined;\n    this._valueAsString = isBuffer ? undefined : value;\n  }\n\n  isBuffer() {\n    return this._valueIsBuffer;\n  }\n\n  source() {\n    if (this._value === undefined) {\n      this._value = this._valueAsBuffer.toString(\"utf-8\");\n    }\n\n    return this._value;\n  }\n\n  buffer() {\n    if (this._valueAsBuffer === undefined) {\n      this._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n    }\n\n    return this._valueAsBuffer;\n  }\n\n  map(options) {\n    return null;\n  }\n  /**\n   * @param {object} options options\n   * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code\n   * @param {function(number, string, string)} onSource called for each source\n   * @param {function(number, string)} onName called for each name\n   * @returns {void}\n   */\n\n\n  streamChunks(options, onChunk, onSource, onName) {\n    if (this._value === undefined) {\n      this._value = Buffer.from(this._valueAsBuffer, \"utf-8\");\n    }\n\n    if (this._valueAsString === undefined) {\n      this._valueAsString = typeof this._value === \"string\" ? this._value : this._value.toString(\"utf-8\");\n    }\n\n    return streamChunksOfRawSource(this._valueAsString, onChunk, onSource, onName, !!(options && options.finalSource));\n  }\n\n  updateHash(hash) {\n    if (this._valueAsBuffer === undefined) {\n      this._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n    }\n\n    hash.update(\"RawSource\");\n    hash.update(this._valueAsBuffer);\n  }\n\n}\n\nmodule.exports = RawSource;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack-sources/lib/RawSource.js"],"names":["streamChunksOfRawSource","require","Source","RawSource","constructor","value","convertToString","isBuffer","Buffer","TypeError","_valueIsBuffer","_value","undefined","_valueAsBuffer","_valueAsString","source","toString","buffer","from","map","options","streamChunks","onChunk","onSource","onName","finalSource","updateHash","hash","update","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,uBAAuB,GAAGC,OAAO,CAAC,mCAAD,CAAvC;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,UAAD,CAAtB;;AAEA,MAAME,SAAN,SAAwBD,MAAxB,CAA+B;AAC9BE,EAAAA,WAAW,CAACC,KAAD,EAAiC;AAAA,QAAzBC,eAAyB,uEAAP,KAAO;AAC3C;AACA,UAAMC,QAAQ,GAAGC,MAAM,CAACD,QAAP,CAAgBF,KAAhB,CAAjB;;AACA,QAAI,CAACE,QAAD,IAAa,OAAOF,KAAP,KAAiB,QAAlC,EAA4C;AAC3C,YAAM,IAAII,SAAJ,CAAc,kDAAd,CAAN;AACA;;AACD,SAAKC,cAAL,GAAsB,CAACJ,eAAD,IAAoBC,QAA1C;AACA,SAAKI,MAAL,GAAcL,eAAe,IAAIC,QAAnB,GAA8BK,SAA9B,GAA0CP,KAAxD;AACA,SAAKQ,cAAL,GAAsBN,QAAQ,GAAGF,KAAH,GAAWO,SAAzC;AACA,SAAKE,cAAL,GAAsBP,QAAQ,GAAGK,SAAH,GAAeP,KAA7C;AACA;;AAEDE,EAAAA,QAAQ,GAAG;AACV,WAAO,KAAKG,cAAZ;AACA;;AAEDK,EAAAA,MAAM,GAAG;AACR,QAAI,KAAKJ,MAAL,KAAgBC,SAApB,EAA+B;AAC9B,WAAKD,MAAL,GAAc,KAAKE,cAAL,CAAoBG,QAApB,CAA6B,OAA7B,CAAd;AACA;;AACD,WAAO,KAAKL,MAAZ;AACA;;AAEDM,EAAAA,MAAM,GAAG;AACR,QAAI,KAAKJ,cAAL,KAAwBD,SAA5B,EAAuC;AACtC,WAAKC,cAAL,GAAsBL,MAAM,CAACU,IAAP,CAAY,KAAKP,MAAjB,EAAyB,OAAzB,CAAtB;AACA;;AACD,WAAO,KAAKE,cAAZ;AACA;;AAEDM,EAAAA,GAAG,CAACC,OAAD,EAAU;AACZ,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,YAAY,CAACD,OAAD,EAAUE,OAAV,EAAmBC,QAAnB,EAA6BC,MAA7B,EAAqC;AAChD,QAAI,KAAKb,MAAL,KAAgBC,SAApB,EAA+B;AAC9B,WAAKD,MAAL,GAAcH,MAAM,CAACU,IAAP,CAAY,KAAKL,cAAjB,EAAiC,OAAjC,CAAd;AACA;;AACD,QAAI,KAAKC,cAAL,KAAwBF,SAA5B,EAAuC;AACtC,WAAKE,cAAL,GACC,OAAO,KAAKH,MAAZ,KAAuB,QAAvB,GACG,KAAKA,MADR,GAEG,KAAKA,MAAL,CAAYK,QAAZ,CAAqB,OAArB,CAHJ;AAIA;;AACD,WAAOhB,uBAAuB,CAC7B,KAAKc,cADwB,EAE7BQ,OAF6B,EAG7BC,QAH6B,EAI7BC,MAJ6B,EAK7B,CAAC,EAAEJ,OAAO,IAAIA,OAAO,CAACK,WAArB,CAL4B,CAA9B;AAOA;;AAEDC,EAAAA,UAAU,CAACC,IAAD,EAAO;AAChB,QAAI,KAAKd,cAAL,KAAwBD,SAA5B,EAAuC;AACtC,WAAKC,cAAL,GAAsBL,MAAM,CAACU,IAAP,CAAY,KAAKP,MAAjB,EAAyB,OAAzB,CAAtB;AACA;;AACDgB,IAAAA,IAAI,CAACC,MAAL,CAAY,WAAZ;AACAD,IAAAA,IAAI,CAACC,MAAL,CAAY,KAAKf,cAAjB;AACA;;AAnE6B;;AAsE/BgB,MAAM,CAACC,OAAP,GAAiB3B,SAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst streamChunksOfRawSource = require(\"./helpers/streamChunksOfRawSource\");\nconst Source = require(\"./Source\");\n\nclass RawSource extends Source {\n\tconstructor(value, convertToString = false) {\n\t\tsuper();\n\t\tconst isBuffer = Buffer.isBuffer(value);\n\t\tif (!isBuffer && typeof value !== \"string\") {\n\t\t\tthrow new TypeError(\"argument 'value' must be either string of Buffer\");\n\t\t}\n\t\tthis._valueIsBuffer = !convertToString && isBuffer;\n\t\tthis._value = convertToString && isBuffer ? undefined : value;\n\t\tthis._valueAsBuffer = isBuffer ? value : undefined;\n\t\tthis._valueAsString = isBuffer ? undefined : value;\n\t}\n\n\tisBuffer() {\n\t\treturn this._valueIsBuffer;\n\t}\n\n\tsource() {\n\t\tif (this._value === undefined) {\n\t\t\tthis._value = this._valueAsBuffer.toString(\"utf-8\");\n\t\t}\n\t\treturn this._value;\n\t}\n\n\tbuffer() {\n\t\tif (this._valueAsBuffer === undefined) {\n\t\t\tthis._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n\t\t}\n\t\treturn this._valueAsBuffer;\n\t}\n\n\tmap(options) {\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param {object} options options\n\t * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code\n\t * @param {function(number, string, string)} onSource called for each source\n\t * @param {function(number, string)} onName called for each name\n\t * @returns {void}\n\t */\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tif (this._value === undefined) {\n\t\t\tthis._value = Buffer.from(this._valueAsBuffer, \"utf-8\");\n\t\t}\n\t\tif (this._valueAsString === undefined) {\n\t\t\tthis._valueAsString =\n\t\t\t\ttypeof this._value === \"string\"\n\t\t\t\t\t? this._value\n\t\t\t\t\t: this._value.toString(\"utf-8\");\n\t\t}\n\t\treturn streamChunksOfRawSource(\n\t\t\tthis._valueAsString,\n\t\t\tonChunk,\n\t\t\tonSource,\n\t\t\tonName,\n\t\t\t!!(options && options.finalSource)\n\t\t);\n\t}\n\n\tupdateHash(hash) {\n\t\tif (this._valueAsBuffer === undefined) {\n\t\t\tthis._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n\t\t}\n\t\thash.update(\"RawSource\");\n\t\thash.update(this._valueAsBuffer);\n\t}\n}\n\nmodule.exports = RawSource;\n"]},"metadata":{},"sourceType":"script"}