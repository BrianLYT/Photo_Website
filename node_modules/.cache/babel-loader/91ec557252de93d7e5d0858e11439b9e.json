{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importAssertions = importAssertions;\n\nvar _acorn = _interopRequireWildcard(require(\"acorn\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nconst leftCurlyBrace = \"{\".charCodeAt(0);\nconst space = \" \".charCodeAt(0);\nconst keyword = \"assert\";\nconst FUNC_STATEMENT = 1,\n      FUNC_HANGING_STATEMENT = 2,\n      FUNC_NULLABLE_ID = 4;\n\nfunction importAssertions(Parser) {\n  // Use supplied version acorn version if present, to avoid\n  // reference mismatches due to different acorn versions. This\n  // allows this plugin to be used with Rollup which supplies\n  // its own internal version of acorn and thereby sidesteps\n  // the package manager.\n  const acorn = Parser.acorn || _acorn;\n  const {\n    tokTypes: tt,\n    TokenType\n  } = acorn;\n  return class extends Parser {\n    constructor() {\n      super(...arguments);\n      this.assertToken = new TokenType(keyword);\n    }\n\n    _codeAt(i) {\n      return this.input.charCodeAt(i);\n    }\n\n    _eat(t) {\n      if (this.type !== t) {\n        this.unexpected();\n      }\n\n      this.next();\n    }\n\n    readToken(code) {\n      let i = 0;\n\n      for (; i < keyword.length; i++) {\n        if (this._codeAt(this.pos + i) !== keyword.charCodeAt(i)) {\n          return super.readToken(code);\n        }\n      } // ensure that the keyword is at the correct location\n      // ie `assert{...` or `assert {...`\n\n\n      for (;; i++) {\n        if (this._codeAt(this.pos + i) === leftCurlyBrace) {\n          // Found '{'\n          break;\n        } else if (this._codeAt(this.pos + i) === space) {\n          // white space is allowed between `assert` and `{`, so continue.\n          continue;\n        } else {\n          return super.readToken(code);\n        }\n      } // If we're inside a dynamic import expression we'll parse\n      // the `assert` keyword as a standard object property name\n      // ie `import(\"\"./foo.json\", { assert: { type: \"json\" } })`\n\n\n      if (this.type.label === \"{\") {\n        return super.readToken(code);\n      }\n\n      this.pos += keyword.length;\n      return this.finishToken(this.assertToken);\n    }\n\n    parseDynamicImport(node) {\n      this.next(); // skip `(`\n      // Parse node.source.\n\n      node.source = this.parseMaybeAssign();\n\n      if (this.eat(tt.comma)) {\n        const obj = this.parseObj(false);\n        node.arguments = [obj];\n      }\n\n      this._eat(tt.parenR);\n\n      return this.finishNode(node, \"ImportExpression\");\n    } // ported from acorn/src/statement.js pp.parseExport\n\n\n    parseExport(node, exports) {\n      this.next(); // export * from '...'\n\n      if (this.eat(tt.star)) {\n        if (this.options.ecmaVersion >= 11) {\n          if (this.eatContextual(\"as\")) {\n            node.exported = this.parseIdent(true);\n            this.checkExport(exports, node.exported.name, this.lastTokStart);\n          } else {\n            node.exported = null;\n          }\n        }\n\n        this.expectContextual(\"from\");\n\n        if (this.type !== tt.string) {\n          this.unexpected();\n        }\n\n        node.source = this.parseExprAtom();\n\n        if (this.type === this.assertToken) {\n          this.next();\n          const assertions = this.parseImportAssertions();\n\n          if (assertions) {\n            node.assertions = assertions;\n          }\n        }\n\n        this.semicolon();\n        return this.finishNode(node, \"ExportAllDeclaration\");\n      }\n\n      if (this.eat(tt._default)) {\n        // export default ...\n        this.checkExport(exports, \"default\", this.lastTokStart);\n        var isAsync;\n\n        if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n          var fNode = this.startNode();\n          this.next();\n\n          if (isAsync) {\n            this.next();\n          }\n\n          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n        } else if (this.type === tt._class) {\n          var cNode = this.startNode();\n          node.declaration = this.parseClass(cNode, \"nullableID\");\n        } else {\n          node.declaration = this.parseMaybeAssign();\n          this.semicolon();\n        }\n\n        return this.finishNode(node, \"ExportDefaultDeclaration\");\n      } // export var|const|let|function|class ...\n\n\n      if (this.shouldParseExportStatement()) {\n        node.declaration = this.parseStatement(null);\n\n        if (node.declaration.type === \"VariableDeclaration\") {\n          this.checkVariableExport(exports, node.declaration.declarations);\n        } else {\n          this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);\n        }\n\n        node.specifiers = [];\n        node.source = null;\n      } else {\n        // export { x, y as z } [from '...']\n        node.declaration = null;\n        node.specifiers = this.parseExportSpecifiers(exports);\n\n        if (this.eatContextual(\"from\")) {\n          if (this.type !== tt.string) {\n            this.unexpected();\n          }\n\n          node.source = this.parseExprAtom();\n\n          if (this.type === this.assertToken) {\n            this.next();\n            const assertions = this.parseImportAssertions();\n\n            if (assertions) {\n              node.assertions = assertions;\n            }\n          }\n        } else {\n          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n            // check for keywords used as local names\n            var spec = list[i];\n            this.checkUnreserved(spec.local); // check if export is defined\n\n            this.checkLocalExport(spec.local);\n          }\n\n          node.source = null;\n        }\n\n        this.semicolon();\n      }\n\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    parseImport(node) {\n      this.next(); // import '...'\n\n      if (this.type === tt.string) {\n        node.specifiers = [];\n        node.source = this.parseExprAtom();\n      } else {\n        node.specifiers = this.parseImportSpecifiers();\n        this.expectContextual(\"from\");\n        node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n      }\n\n      if (this.type === this.assertToken) {\n        this.next();\n        const assertions = this.parseImportAssertions();\n\n        if (assertions) {\n          node.assertions = assertions;\n        }\n      }\n\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    parseImportAssertions() {\n      this._eat(tt.braceL);\n\n      const attrs = this.parseAssertEntries();\n\n      this._eat(tt.braceR);\n\n      return attrs;\n    }\n\n    parseAssertEntries() {\n      const attrs = [];\n      const attrNames = new Set();\n\n      do {\n        if (this.type === tt.braceR) {\n          break;\n        }\n\n        const node = this.startNode(); // parse AssertionKey : IdentifierName, StringLiteral\n\n        let assertionKeyNode;\n\n        if (this.type === tt.string) {\n          assertionKeyNode = this.parseLiteral(this.value);\n        } else {\n          assertionKeyNode = this.parseIdent(true);\n        }\n\n        this.next();\n        node.key = assertionKeyNode; // check if we already have an entry for an attribute\n        // if a duplicate entry is found, throw an error\n        // for now this logic will come into play only when someone declares `type` twice\n\n        if (attrNames.has(node.key.name)) {\n          this.raise(this.pos, \"Duplicated key in assertions\");\n        }\n\n        attrNames.add(node.key.name);\n\n        if (this.type !== tt.string) {\n          this.raise(this.pos, \"Only string is supported as an assertion value\");\n        }\n\n        node.value = this.parseLiteral(this.value);\n        attrs.push(this.finishNode(node, \"ImportAttribute\"));\n      } while (this.eat(tt.comma));\n\n      return attrs;\n    }\n\n  };\n}","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/acorn-import-assertions/lib/index.js"],"names":["Object","defineProperty","exports","value","importAssertions","_acorn","_interopRequireWildcard","require","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","leftCurlyBrace","charCodeAt","space","keyword","FUNC_STATEMENT","FUNC_HANGING_STATEMENT","FUNC_NULLABLE_ID","Parser","acorn","tokTypes","tt","TokenType","constructor","assertToken","_codeAt","i","input","_eat","t","type","unexpected","next","readToken","code","length","pos","label","finishToken","parseDynamicImport","node","source","parseMaybeAssign","eat","comma","parseObj","arguments","parenR","finishNode","parseExport","star","options","ecmaVersion","eatContextual","exported","parseIdent","checkExport","name","lastTokStart","expectContextual","string","parseExprAtom","assertions","parseImportAssertions","semicolon","_default","isAsync","_function","isAsyncFunction","fNode","startNode","declaration","parseFunction","_class","cNode","parseClass","shouldParseExportStatement","parseStatement","checkVariableExport","declarations","id","start","specifiers","parseExportSpecifiers","list","spec","checkUnreserved","local","checkLocalExport","parseImport","parseImportSpecifiers","braceL","attrs","parseAssertEntries","braceR","attrNames","Set","assertionKeyNode","parseLiteral","raise","add","push"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importAssertions = importAssertions;\n\nvar _acorn = _interopRequireWildcard(require(\"acorn\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst leftCurlyBrace = \"{\".charCodeAt(0);\nconst space = \" \".charCodeAt(0);\nconst keyword = \"assert\";\nconst FUNC_STATEMENT = 1,\n      FUNC_HANGING_STATEMENT = 2,\n      FUNC_NULLABLE_ID = 4;\n\nfunction importAssertions(Parser) {\n  // Use supplied version acorn version if present, to avoid\n  // reference mismatches due to different acorn versions. This\n  // allows this plugin to be used with Rollup which supplies\n  // its own internal version of acorn and thereby sidesteps\n  // the package manager.\n  const acorn = Parser.acorn || _acorn;\n  const {\n    tokTypes: tt,\n    TokenType\n  } = acorn;\n  return class extends Parser {\n    constructor(...args) {\n      super(...args);\n      this.assertToken = new TokenType(keyword);\n    }\n\n    _codeAt(i) {\n      return this.input.charCodeAt(i);\n    }\n\n    _eat(t) {\n      if (this.type !== t) {\n        this.unexpected();\n      }\n\n      this.next();\n    }\n\n    readToken(code) {\n      let i = 0;\n\n      for (; i < keyword.length; i++) {\n        if (this._codeAt(this.pos + i) !== keyword.charCodeAt(i)) {\n          return super.readToken(code);\n        }\n      } // ensure that the keyword is at the correct location\n      // ie `assert{...` or `assert {...`\n\n\n      for (;; i++) {\n        if (this._codeAt(this.pos + i) === leftCurlyBrace) {\n          // Found '{'\n          break;\n        } else if (this._codeAt(this.pos + i) === space) {\n          // white space is allowed between `assert` and `{`, so continue.\n          continue;\n        } else {\n          return super.readToken(code);\n        }\n      } // If we're inside a dynamic import expression we'll parse\n      // the `assert` keyword as a standard object property name\n      // ie `import(\"\"./foo.json\", { assert: { type: \"json\" } })`\n\n\n      if (this.type.label === \"{\") {\n        return super.readToken(code);\n      }\n\n      this.pos += keyword.length;\n      return this.finishToken(this.assertToken);\n    }\n\n    parseDynamicImport(node) {\n      this.next(); // skip `(`\n      // Parse node.source.\n\n      node.source = this.parseMaybeAssign();\n\n      if (this.eat(tt.comma)) {\n        const obj = this.parseObj(false);\n        node.arguments = [obj];\n      }\n\n      this._eat(tt.parenR);\n\n      return this.finishNode(node, \"ImportExpression\");\n    } // ported from acorn/src/statement.js pp.parseExport\n\n\n    parseExport(node, exports) {\n      this.next(); // export * from '...'\n\n      if (this.eat(tt.star)) {\n        if (this.options.ecmaVersion >= 11) {\n          if (this.eatContextual(\"as\")) {\n            node.exported = this.parseIdent(true);\n            this.checkExport(exports, node.exported.name, this.lastTokStart);\n          } else {\n            node.exported = null;\n          }\n        }\n\n        this.expectContextual(\"from\");\n\n        if (this.type !== tt.string) {\n          this.unexpected();\n        }\n\n        node.source = this.parseExprAtom();\n\n        if (this.type === this.assertToken) {\n          this.next();\n          const assertions = this.parseImportAssertions();\n\n          if (assertions) {\n            node.assertions = assertions;\n          }\n        }\n\n        this.semicolon();\n        return this.finishNode(node, \"ExportAllDeclaration\");\n      }\n\n      if (this.eat(tt._default)) {\n        // export default ...\n        this.checkExport(exports, \"default\", this.lastTokStart);\n        var isAsync;\n\n        if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n          var fNode = this.startNode();\n          this.next();\n\n          if (isAsync) {\n            this.next();\n          }\n\n          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n        } else if (this.type === tt._class) {\n          var cNode = this.startNode();\n          node.declaration = this.parseClass(cNode, \"nullableID\");\n        } else {\n          node.declaration = this.parseMaybeAssign();\n          this.semicolon();\n        }\n\n        return this.finishNode(node, \"ExportDefaultDeclaration\");\n      } // export var|const|let|function|class ...\n\n\n      if (this.shouldParseExportStatement()) {\n        node.declaration = this.parseStatement(null);\n\n        if (node.declaration.type === \"VariableDeclaration\") {\n          this.checkVariableExport(exports, node.declaration.declarations);\n        } else {\n          this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);\n        }\n\n        node.specifiers = [];\n        node.source = null;\n      } else {\n        // export { x, y as z } [from '...']\n        node.declaration = null;\n        node.specifiers = this.parseExportSpecifiers(exports);\n\n        if (this.eatContextual(\"from\")) {\n          if (this.type !== tt.string) {\n            this.unexpected();\n          }\n\n          node.source = this.parseExprAtom();\n\n          if (this.type === this.assertToken) {\n            this.next();\n            const assertions = this.parseImportAssertions();\n\n            if (assertions) {\n              node.assertions = assertions;\n            }\n          }\n        } else {\n          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n            // check for keywords used as local names\n            var spec = list[i];\n            this.checkUnreserved(spec.local); // check if export is defined\n\n            this.checkLocalExport(spec.local);\n          }\n\n          node.source = null;\n        }\n\n        this.semicolon();\n      }\n\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    parseImport(node) {\n      this.next(); // import '...'\n\n      if (this.type === tt.string) {\n        node.specifiers = [];\n        node.source = this.parseExprAtom();\n      } else {\n        node.specifiers = this.parseImportSpecifiers();\n        this.expectContextual(\"from\");\n        node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n      }\n\n      if (this.type === this.assertToken) {\n        this.next();\n        const assertions = this.parseImportAssertions();\n\n        if (assertions) {\n          node.assertions = assertions;\n        }\n      }\n\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    parseImportAssertions() {\n      this._eat(tt.braceL);\n\n      const attrs = this.parseAssertEntries();\n\n      this._eat(tt.braceR);\n\n      return attrs;\n    }\n\n    parseAssertEntries() {\n      const attrs = [];\n      const attrNames = new Set();\n\n      do {\n        if (this.type === tt.braceR) {\n          break;\n        }\n\n        const node = this.startNode(); // parse AssertionKey : IdentifierName, StringLiteral\n\n        let assertionKeyNode;\n\n        if (this.type === tt.string) {\n          assertionKeyNode = this.parseLiteral(this.value);\n        } else {\n          assertionKeyNode = this.parseIdent(true);\n        }\n\n        this.next();\n        node.key = assertionKeyNode; // check if we already have an entry for an attribute\n        // if a duplicate entry is found, throw an error\n        // for now this logic will come into play only when someone declares `type` twice\n\n        if (attrNames.has(node.key.name)) {\n          this.raise(this.pos, \"Duplicated key in assertions\");\n        }\n\n        attrNames.add(node.key.name);\n\n        if (this.type !== tt.string) {\n          this.raise(this.pos, \"Only string is supported as an assertion value\");\n        }\n\n        node.value = this.parseLiteral(this.value);\n        attrs.push(this.finishNode(node, \"ImportAttribute\"));\n      } while (this.eat(tt.comma));\n\n      return attrs;\n    }\n\n  };\n}"]},"metadata":{},"sourceType":"script"}