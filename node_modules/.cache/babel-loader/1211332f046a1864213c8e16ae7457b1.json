{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\n\nconst {\n  connectChunkGroupParentAndChild\n} = require(\"./GraphHelpers\");\n\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\n\nconst {\n  getEntryRuntime,\n  mergeRuntime\n} = require(\"./util/runtime\");\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"./Compilation\")} Compilation */\n\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n\n/** @typedef {import(\"./Dependency\")} Dependency */\n\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n\n/** @typedef {import(\"./ModuleGraphConnection\").ConnectionState} ConnectionState */\n\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {Object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n * @property {ChunkGroupInfo} chunkGroupInfo\n */\n\n/** @typedef {Set<Module> & { plus: Set<Module> }} ModuleSetPlus */\n\n/**\n * @typedef {Object} ChunkGroupInfo\n * @property {ChunkGroup} chunkGroup the chunk group\n * @property {RuntimeSpec} runtime the runtimes\n * @property {ModuleSetPlus} minAvailableModules current minimal set of modules available at this point\n * @property {boolean} minAvailableModulesOwned true, if minAvailableModules is owned and can be modified\n * @property {ModuleSetPlus[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {Set<Module>=} skippedItems modules that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<[Module, ConnectionState]>=} skippedModuleConnections referenced modules that where skipped because they were not active in this runtime\n * @property {ModuleSetPlus} resultingAvailableModules set of modules available including modules from this chunk group\n * @property {Set<ChunkGroupInfo>} children set of children chunk groups, that will be revisited when availableModules shrink\n * @property {Set<ChunkGroupInfo>} availableSources set of chunk groups that are the source for minAvailableModules\n * @property {Set<ChunkGroupInfo>} availableChildren set of chunk groups which depend on the this chunk group as availableSource\n * @property {number} preOrderIndex next pre order index\n * @property {number} postOrderIndex next post order index\n * @property {boolean} chunkLoading has a chunk loading mechanism\n * @property {boolean} asyncChunks create async chunks\n */\n\n/**\n * @typedef {Object} BlockChunkGroupConnection\n * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\n\nconst EMPTY_SET =\n/** @type {ModuleSetPlus} */\nnew Set();\nEMPTY_SET.plus = EMPTY_SET;\n/**\n * @param {ModuleSetPlus} a first set\n * @param {ModuleSetPlus} b second set\n * @returns {number} cmp\n */\n\nconst bySetSize = (a, b) => {\n  return b.size + b.plus.size - a.size - a.plus.size;\n};\n\nconst extractBlockModules = (module, moduleGraph, runtime, blockModulesMap) => {\n  let blockCache;\n  let modules;\n  const arrays = [];\n  const queue = [module];\n\n  while (queue.length > 0) {\n    const block = queue.pop();\n    const arr = [];\n    arrays.push(arr);\n    blockModulesMap.set(block, arr);\n\n    for (const b of block.blocks) {\n      queue.push(b);\n    }\n  }\n\n  for (const connection of moduleGraph.getOutgoingConnections(module)) {\n    const d = connection.dependency; // We skip connections without dependency\n\n    if (!d) continue;\n    const m = connection.module; // We skip connections without Module pointer\n\n    if (!m) continue; // We skip weak connections\n\n    if (connection.weak) continue;\n    const state = connection.getActiveState(runtime); // We skip inactive connections\n\n    if (state === false) continue;\n    const block = moduleGraph.getParentBlock(d);\n    let index = moduleGraph.getParentBlockIndex(d); // deprecated fallback\n\n    if (index < 0) {\n      index = block.dependencies.indexOf(d);\n    }\n\n    if (blockCache !== block) {\n      modules = blockModulesMap.get(blockCache = block);\n    }\n\n    const i = index << 2;\n    modules[i] = m;\n    modules[i + 1] = state;\n  }\n\n  for (const modules of arrays) {\n    if (modules.length === 0) continue;\n    let indexMap;\n    let length = 0;\n\n    outer: for (let j = 0; j < modules.length; j += 2) {\n      const m = modules[j];\n      if (m === undefined) continue;\n      const state = modules[j + 1];\n\n      if (indexMap === undefined) {\n        let i = 0;\n\n        for (; i < length; i += 2) {\n          if (modules[i] === m) {\n            const merged = modules[i + 1];\n            if (merged === true) continue outer;\n            modules[i + 1] = ModuleGraphConnection.addConnectionStates(merged, state);\n          }\n        }\n\n        modules[length] = m;\n        length++;\n        modules[length] = state;\n        length++;\n\n        if (length > 30) {\n          // To avoid worse case performance, we will use an index map for\n          // linear cost access, which allows to maintain O(n) complexity\n          // while keeping allocations down to a minimum\n          indexMap = new Map();\n\n          for (let i = 0; i < length; i += 2) {\n            indexMap.set(modules[i], i + 1);\n          }\n        }\n      } else {\n        const idx = indexMap.get(m);\n\n        if (idx !== undefined) {\n          const merged = modules[idx];\n          if (merged === true) continue outer;\n          modules[idx] = ModuleGraphConnection.addConnectionStates(merged, state);\n        } else {\n          modules[length] = m;\n          length++;\n          modules[length] = state;\n          indexMap.set(m, length);\n          length++;\n        }\n      }\n    }\n\n    modules.length = length;\n  }\n};\n/**\n *\n * @param {Logger} logger a logger\n * @param {Compilation} compilation the compilation\n * @param {Map<Entrypoint, Module[]>} inputEntrypointsAndModules chunk groups which are processed with the modules\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here\n */\n\n\nconst visitModules = (logger, compilation, inputEntrypointsAndModules, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups) => {\n  const {\n    moduleGraph,\n    chunkGraph,\n    moduleMemCaches\n  } = compilation;\n  const blockModulesRuntimeMap = new Map();\n  /** @type {RuntimeSpec | false} */\n\n  let blockModulesMapRuntime = false;\n  let blockModulesMap;\n  /**\n   *\n   * @param {DependenciesBlock} block block\n   * @param {RuntimeSpec} runtime runtime\n   * @returns {(Module | ConnectionState)[]} block modules in flatten tuples\n   */\n\n  const getBlockModules = (block, runtime) => {\n    if (blockModulesMapRuntime !== runtime) {\n      blockModulesMap = blockModulesRuntimeMap.get(runtime);\n\n      if (blockModulesMap === undefined) {\n        blockModulesMap = new Map();\n        blockModulesRuntimeMap.set(runtime, blockModulesMap);\n      }\n    }\n\n    let blockModules = blockModulesMap.get(block);\n    if (blockModules !== undefined) return blockModules;\n    const module =\n    /** @type {Module} */\n    block.getRootBlock();\n    const memCache = moduleMemCaches && moduleMemCaches.get(module);\n\n    if (memCache !== undefined) {\n      const map = memCache.provide(\"bundleChunkGraph.blockModules\", runtime, () => {\n        logger.time(\"visitModules: prepare\");\n        const map = new Map();\n        extractBlockModules(module, moduleGraph, runtime, map);\n        logger.timeAggregate(\"visitModules: prepare\");\n        return map;\n      });\n\n      for (const [block, blockModules] of map) blockModulesMap.set(block, blockModules);\n\n      return map.get(block);\n    } else {\n      logger.time(\"visitModules: prepare\");\n      extractBlockModules(module, moduleGraph, runtime, blockModulesMap);\n      blockModules = blockModulesMap.get(block);\n      logger.timeAggregate(\"visitModules: prepare\");\n      return blockModules;\n    }\n  };\n\n  let statProcessedQueueItems = 0;\n  let statProcessedBlocks = 0;\n  let statConnectedChunkGroups = 0;\n  let statProcessedChunkGroupsForMerging = 0;\n  let statMergedAvailableModuleSets = 0;\n  let statForkedAvailableModules = 0;\n  let statForkedAvailableModulesCount = 0;\n  let statForkedAvailableModulesCountPlus = 0;\n  let statForkedMergedModulesCount = 0;\n  let statForkedMergedModulesCountPlus = 0;\n  let statForkedResultModulesCount = 0;\n  let statChunkGroupInfoUpdated = 0;\n  let statChildChunkGroupsReconnected = 0;\n  let nextChunkGroupIndex = 0;\n  let nextFreeModulePreOrderIndex = 0;\n  let nextFreeModulePostOrderIndex = 0;\n  /** @type {Map<DependenciesBlock, ChunkGroupInfo>} */\n\n  const blockChunkGroups = new Map();\n  /** @type {Map<string, ChunkGroupInfo>} */\n\n  const namedChunkGroups = new Map();\n  /** @type {Map<string, ChunkGroupInfo>} */\n\n  const namedAsyncEntrypoints = new Map();\n  const ADD_AND_ENTER_ENTRY_MODULE = 0;\n  const ADD_AND_ENTER_MODULE = 1;\n  const ENTER_MODULE = 2;\n  const PROCESS_BLOCK = 3;\n  const PROCESS_ENTRY_BLOCK = 4;\n  const LEAVE_MODULE = 5;\n  /** @type {QueueItem[]} */\n\n  let queue = [];\n  /** @type {Map<ChunkGroupInfo, Set<ChunkGroupInfo>>} */\n\n  const queueConnect = new Map();\n  /** @type {Set<ChunkGroupInfo>} */\n\n  const chunkGroupsForCombining = new Set(); // Fill queue with entrypoint modules\n  // Create ChunkGroupInfo for entrypoints\n\n  for (const [chunkGroup, modules] of inputEntrypointsAndModules) {\n    const runtime = getEntryRuntime(compilation, chunkGroup.name, chunkGroup.options);\n    /** @type {ChunkGroupInfo} */\n\n    const chunkGroupInfo = {\n      chunkGroup,\n      runtime,\n      minAvailableModules: undefined,\n      minAvailableModulesOwned: false,\n      availableModulesToBeMerged: [],\n      skippedItems: undefined,\n      resultingAvailableModules: undefined,\n      children: undefined,\n      availableSources: undefined,\n      availableChildren: undefined,\n      preOrderIndex: 0,\n      postOrderIndex: 0,\n      chunkLoading: chunkGroup.options.chunkLoading !== undefined ? chunkGroup.options.chunkLoading !== false : compilation.outputOptions.chunkLoading !== false,\n      asyncChunks: chunkGroup.options.asyncChunks !== undefined ? chunkGroup.options.asyncChunks : compilation.outputOptions.asyncChunks !== false\n    };\n    chunkGroup.index = nextChunkGroupIndex++;\n\n    if (chunkGroup.getNumberOfParents() > 0) {\n      // minAvailableModules for child entrypoints are unknown yet, set to undefined.\n      // This means no module is added until other sets are merged into\n      // this minAvailableModules (by the parent entrypoints)\n      const skippedItems = new Set();\n\n      for (const module of modules) {\n        skippedItems.add(module);\n      }\n\n      chunkGroupInfo.skippedItems = skippedItems;\n      chunkGroupsForCombining.add(chunkGroupInfo);\n    } else {\n      // The application may start here: We start with an empty list of available modules\n      chunkGroupInfo.minAvailableModules = EMPTY_SET;\n      const chunk = chunkGroup.getEntrypointChunk();\n\n      for (const module of modules) {\n        queue.push({\n          action: ADD_AND_ENTER_MODULE,\n          block: module,\n          module,\n          chunk,\n          chunkGroup,\n          chunkGroupInfo\n        });\n      }\n    }\n\n    chunkGroupInfoMap.set(chunkGroup, chunkGroupInfo);\n\n    if (chunkGroup.name) {\n      namedChunkGroups.set(chunkGroup.name, chunkGroupInfo);\n    }\n  } // Fill availableSources with parent-child dependencies between entrypoints\n\n\n  for (const chunkGroupInfo of chunkGroupsForCombining) {\n    const {\n      chunkGroup\n    } = chunkGroupInfo;\n    chunkGroupInfo.availableSources = new Set();\n\n    for (const parent of chunkGroup.parentsIterable) {\n      const parentChunkGroupInfo = chunkGroupInfoMap.get(parent);\n      chunkGroupInfo.availableSources.add(parentChunkGroupInfo);\n\n      if (parentChunkGroupInfo.availableChildren === undefined) {\n        parentChunkGroupInfo.availableChildren = new Set();\n      }\n\n      parentChunkGroupInfo.availableChildren.add(chunkGroupInfo);\n    }\n  } // pop() is used to read from the queue\n  // so it need to be reversed to be iterated in\n  // correct order\n\n\n  queue.reverse();\n  /** @type {Set<ChunkGroupInfo>} */\n\n  const outdatedChunkGroupInfo = new Set();\n  /** @type {Set<ChunkGroupInfo>} */\n\n  const chunkGroupsForMerging = new Set();\n  /** @type {QueueItem[]} */\n\n  let queueDelayed = [];\n  /** @type {[Module, ConnectionState][]} */\n\n  const skipConnectionBuffer = [];\n  /** @type {Module[]} */\n\n  const skipBuffer = [];\n  /** @type {QueueItem[]} */\n\n  const queueBuffer = [];\n  /** @type {Module} */\n\n  let module;\n  /** @type {Chunk} */\n\n  let chunk;\n  /** @type {ChunkGroup} */\n\n  let chunkGroup;\n  /** @type {DependenciesBlock} */\n\n  let block;\n  /** @type {ChunkGroupInfo} */\n\n  let chunkGroupInfo; // For each async Block in graph\n\n  /**\n   * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n   * @returns {void}\n   */\n\n  const iteratorBlock = b => {\n    // 1. We create a chunk group with single chunk in it for this Block\n    // but only once (blockChunkGroups map)\n    let cgi = blockChunkGroups.get(b);\n    /** @type {ChunkGroup} */\n\n    let c;\n    /** @type {Entrypoint} */\n\n    let entrypoint;\n    const entryOptions = b.groupOptions && b.groupOptions.entryOptions;\n\n    if (cgi === undefined) {\n      const chunkName = b.groupOptions && b.groupOptions.name || b.chunkName;\n\n      if (entryOptions) {\n        cgi = namedAsyncEntrypoints.get(chunkName);\n\n        if (!cgi) {\n          entrypoint = compilation.addAsyncEntrypoint(entryOptions, module, b.loc, b.request);\n          entrypoint.index = nextChunkGroupIndex++;\n          cgi = {\n            chunkGroup: entrypoint,\n            runtime: entrypoint.options.runtime || entrypoint.name,\n            minAvailableModules: EMPTY_SET,\n            minAvailableModulesOwned: false,\n            availableModulesToBeMerged: [],\n            skippedItems: undefined,\n            resultingAvailableModules: undefined,\n            children: undefined,\n            availableSources: undefined,\n            availableChildren: undefined,\n            preOrderIndex: 0,\n            postOrderIndex: 0,\n            chunkLoading: entryOptions.chunkLoading !== undefined ? entryOptions.chunkLoading !== false : chunkGroupInfo.chunkLoading,\n            asyncChunks: entryOptions.asyncChunks !== undefined ? entryOptions.asyncChunks : chunkGroupInfo.asyncChunks\n          };\n          chunkGroupInfoMap.set(entrypoint, cgi);\n          chunkGraph.connectBlockAndChunkGroup(b, entrypoint);\n\n          if (chunkName) {\n            namedAsyncEntrypoints.set(chunkName, cgi);\n          }\n        } else {\n          entrypoint =\n          /** @type {Entrypoint} */\n          cgi.chunkGroup; // TODO merge entryOptions\n\n          entrypoint.addOrigin(module, b.loc, b.request);\n          chunkGraph.connectBlockAndChunkGroup(b, entrypoint);\n        } // 2. We enqueue the DependenciesBlock for traversal\n\n\n        queueDelayed.push({\n          action: PROCESS_ENTRY_BLOCK,\n          block: b,\n          module: module,\n          chunk: entrypoint.chunks[0],\n          chunkGroup: entrypoint,\n          chunkGroupInfo: cgi\n        });\n      } else if (!chunkGroupInfo.asyncChunks || !chunkGroupInfo.chunkLoading) {\n        // Just queue the block into the current chunk group\n        queue.push({\n          action: PROCESS_BLOCK,\n          block: b,\n          module: module,\n          chunk,\n          chunkGroup,\n          chunkGroupInfo\n        });\n      } else {\n        cgi = chunkName && namedChunkGroups.get(chunkName);\n\n        if (!cgi) {\n          c = compilation.addChunkInGroup(b.groupOptions || b.chunkName, module, b.loc, b.request);\n          c.index = nextChunkGroupIndex++;\n          cgi = {\n            chunkGroup: c,\n            runtime: chunkGroupInfo.runtime,\n            minAvailableModules: undefined,\n            minAvailableModulesOwned: undefined,\n            availableModulesToBeMerged: [],\n            skippedItems: undefined,\n            resultingAvailableModules: undefined,\n            children: undefined,\n            availableSources: undefined,\n            availableChildren: undefined,\n            preOrderIndex: 0,\n            postOrderIndex: 0,\n            chunkLoading: chunkGroupInfo.chunkLoading,\n            asyncChunks: chunkGroupInfo.asyncChunks\n          };\n          allCreatedChunkGroups.add(c);\n          chunkGroupInfoMap.set(c, cgi);\n\n          if (chunkName) {\n            namedChunkGroups.set(chunkName, cgi);\n          }\n        } else {\n          c = cgi.chunkGroup;\n\n          if (c.isInitial()) {\n            compilation.errors.push(new AsyncDependencyToInitialChunkError(chunkName, module, b.loc));\n            c = chunkGroup;\n          }\n\n          c.addOptions(b.groupOptions);\n          c.addOrigin(module, b.loc, b.request);\n        }\n\n        blockConnections.set(b, []);\n      }\n\n      blockChunkGroups.set(b, cgi);\n    } else if (entryOptions) {\n      entrypoint =\n      /** @type {Entrypoint} */\n      cgi.chunkGroup;\n    } else {\n      c = cgi.chunkGroup;\n    }\n\n    if (c !== undefined) {\n      // 2. We store the connection for the block\n      // to connect it later if needed\n      blockConnections.get(b).push({\n        originChunkGroupInfo: chunkGroupInfo,\n        chunkGroup: c\n      }); // 3. We enqueue the chunk group info creation/updating\n\n      let connectList = queueConnect.get(chunkGroupInfo);\n\n      if (connectList === undefined) {\n        connectList = new Set();\n        queueConnect.set(chunkGroupInfo, connectList);\n      }\n\n      connectList.add(cgi); // TODO check if this really need to be done for each traversal\n      // or if it is enough when it's queued when created\n      // 4. We enqueue the DependenciesBlock for traversal\n\n      queueDelayed.push({\n        action: PROCESS_BLOCK,\n        block: b,\n        module: module,\n        chunk: c.chunks[0],\n        chunkGroup: c,\n        chunkGroupInfo: cgi\n      });\n    } else if (entrypoint !== undefined) {\n      chunkGroupInfo.chunkGroup.addAsyncEntrypoint(entrypoint);\n    }\n  };\n  /**\n   * @param {DependenciesBlock} block the block\n   * @returns {void}\n   */\n\n\n  const processBlock = block => {\n    statProcessedBlocks++; // get prepared block info\n\n    const blockModules = getBlockModules(block, chunkGroupInfo.runtime);\n\n    if (blockModules !== undefined) {\n      const {\n        minAvailableModules\n      } = chunkGroupInfo; // Buffer items because order need to be reversed to get indices correct\n      // Traverse all referenced modules\n\n      for (let i = 0; i < blockModules.length; i += 2) {\n        const refModule =\n        /** @type {Module} */\n        blockModules[i];\n\n        if (chunkGraph.isModuleInChunk(refModule, chunk)) {\n          // skip early if already connected\n          continue;\n        }\n\n        const activeState =\n        /** @type {ConnectionState} */\n        blockModules[i + 1];\n\n        if (activeState !== true) {\n          skipConnectionBuffer.push([refModule, activeState]);\n          if (activeState === false) continue;\n        }\n\n        if (activeState === true && (minAvailableModules.has(refModule) || minAvailableModules.plus.has(refModule))) {\n          // already in parent chunks, skip it for now\n          skipBuffer.push(refModule);\n          continue;\n        } // enqueue, then add and enter to be in the correct order\n        // this is relevant with circular dependencies\n\n\n        queueBuffer.push({\n          action: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\n          block: refModule,\n          module: refModule,\n          chunk,\n          chunkGroup,\n          chunkGroupInfo\n        });\n      } // Add buffered items in reverse order\n\n\n      if (skipConnectionBuffer.length > 0) {\n        let {\n          skippedModuleConnections\n        } = chunkGroupInfo;\n\n        if (skippedModuleConnections === undefined) {\n          chunkGroupInfo.skippedModuleConnections = skippedModuleConnections = new Set();\n        }\n\n        for (let i = skipConnectionBuffer.length - 1; i >= 0; i--) {\n          skippedModuleConnections.add(skipConnectionBuffer[i]);\n        }\n\n        skipConnectionBuffer.length = 0;\n      }\n\n      if (skipBuffer.length > 0) {\n        let {\n          skippedItems\n        } = chunkGroupInfo;\n\n        if (skippedItems === undefined) {\n          chunkGroupInfo.skippedItems = skippedItems = new Set();\n        }\n\n        for (let i = skipBuffer.length - 1; i >= 0; i--) {\n          skippedItems.add(skipBuffer[i]);\n        }\n\n        skipBuffer.length = 0;\n      }\n\n      if (queueBuffer.length > 0) {\n        for (let i = queueBuffer.length - 1; i >= 0; i--) {\n          queue.push(queueBuffer[i]);\n        }\n\n        queueBuffer.length = 0;\n      }\n    } // Traverse all Blocks\n\n\n    for (const b of block.blocks) {\n      iteratorBlock(b);\n    }\n\n    if (block.blocks.length > 0 && module !== block) {\n      blocksWithNestedBlocks.add(block);\n    }\n  };\n  /**\n   * @param {DependenciesBlock} block the block\n   * @returns {void}\n   */\n\n\n  const processEntryBlock = block => {\n    statProcessedBlocks++; // get prepared block info\n\n    const blockModules = getBlockModules(block, chunkGroupInfo.runtime);\n\n    if (blockModules !== undefined) {\n      // Traverse all referenced modules\n      for (let i = 0; i < blockModules.length; i += 2) {\n        const refModule =\n        /** @type {Module} */\n        blockModules[i];\n        const activeState =\n        /** @type {ConnectionState} */\n        blockModules[i + 1]; // enqueue, then add and enter to be in the correct order\n        // this is relevant with circular dependencies\n\n        queueBuffer.push({\n          action: activeState === true ? ADD_AND_ENTER_ENTRY_MODULE : PROCESS_BLOCK,\n          block: refModule,\n          module: refModule,\n          chunk,\n          chunkGroup,\n          chunkGroupInfo\n        });\n      } // Add buffered items in reverse order\n\n\n      if (queueBuffer.length > 0) {\n        for (let i = queueBuffer.length - 1; i >= 0; i--) {\n          queue.push(queueBuffer[i]);\n        }\n\n        queueBuffer.length = 0;\n      }\n    } // Traverse all Blocks\n\n\n    for (const b of block.blocks) {\n      iteratorBlock(b);\n    }\n\n    if (block.blocks.length > 0 && module !== block) {\n      blocksWithNestedBlocks.add(block);\n    }\n  };\n\n  const processQueue = () => {\n    while (queue.length) {\n      statProcessedQueueItems++;\n      const queueItem = queue.pop();\n      module = queueItem.module;\n      block = queueItem.block;\n      chunk = queueItem.chunk;\n      chunkGroup = queueItem.chunkGroup;\n      chunkGroupInfo = queueItem.chunkGroupInfo;\n\n      switch (queueItem.action) {\n        case ADD_AND_ENTER_ENTRY_MODULE:\n          chunkGraph.connectChunkAndEntryModule(chunk, module,\n          /** @type {Entrypoint} */\n          chunkGroup);\n        // fallthrough\n\n        case ADD_AND_ENTER_MODULE:\n          {\n            if (chunkGraph.isModuleInChunk(module, chunk)) {\n              // already connected, skip it\n              break;\n            } // We connect Module and Chunk\n\n\n            chunkGraph.connectChunkAndModule(chunk, module);\n          }\n        // fallthrough\n\n        case ENTER_MODULE:\n          {\n            const index = chunkGroup.getModulePreOrderIndex(module);\n\n            if (index === undefined) {\n              chunkGroup.setModulePreOrderIndex(module, chunkGroupInfo.preOrderIndex++);\n            }\n\n            if (moduleGraph.setPreOrderIndexIfUnset(module, nextFreeModulePreOrderIndex)) {\n              nextFreeModulePreOrderIndex++;\n            } // reuse queueItem\n\n\n            queueItem.action = LEAVE_MODULE;\n            queue.push(queueItem);\n          }\n        // fallthrough\n\n        case PROCESS_BLOCK:\n          {\n            processBlock(block);\n            break;\n          }\n\n        case PROCESS_ENTRY_BLOCK:\n          {\n            processEntryBlock(block);\n            break;\n          }\n\n        case LEAVE_MODULE:\n          {\n            const index = chunkGroup.getModulePostOrderIndex(module);\n\n            if (index === undefined) {\n              chunkGroup.setModulePostOrderIndex(module, chunkGroupInfo.postOrderIndex++);\n            }\n\n            if (moduleGraph.setPostOrderIndexIfUnset(module, nextFreeModulePostOrderIndex)) {\n              nextFreeModulePostOrderIndex++;\n            }\n\n            break;\n          }\n      }\n    }\n  };\n\n  const calculateResultingAvailableModules = chunkGroupInfo => {\n    if (chunkGroupInfo.resultingAvailableModules) return chunkGroupInfo.resultingAvailableModules;\n    const minAvailableModules = chunkGroupInfo.minAvailableModules; // Create a new Set of available modules at this point\n    // We want to be as lazy as possible. There are multiple ways doing this:\n    // Note that resultingAvailableModules is stored as \"(a) + (b)\" as it's a ModuleSetPlus\n    // - resultingAvailableModules = (modules of chunk) + (minAvailableModules + minAvailableModules.plus)\n    // - resultingAvailableModules = (minAvailableModules + modules of chunk) + (minAvailableModules.plus)\n    // We choose one depending on the size of minAvailableModules vs minAvailableModules.plus\n\n    let resultingAvailableModules;\n\n    if (minAvailableModules.size > minAvailableModules.plus.size) {\n      // resultingAvailableModules = (modules of chunk) + (minAvailableModules + minAvailableModules.plus)\n      resultingAvailableModules =\n      /** @type {Set<Module> & {plus: Set<Module>}} */\n      new Set();\n\n      for (const module of minAvailableModules.plus) minAvailableModules.add(module);\n\n      minAvailableModules.plus = EMPTY_SET;\n      resultingAvailableModules.plus = minAvailableModules;\n      chunkGroupInfo.minAvailableModulesOwned = false;\n    } else {\n      // resultingAvailableModules = (minAvailableModules + modules of chunk) + (minAvailableModules.plus)\n      resultingAvailableModules =\n      /** @type {Set<Module> & {plus: Set<Module>}} */\n      new Set(minAvailableModules);\n      resultingAvailableModules.plus = minAvailableModules.plus;\n    } // add the modules from the chunk group to the set\n\n\n    for (const chunk of chunkGroupInfo.chunkGroup.chunks) {\n      for (const m of chunkGraph.getChunkModulesIterable(chunk)) {\n        resultingAvailableModules.add(m);\n      }\n    }\n\n    return chunkGroupInfo.resultingAvailableModules = resultingAvailableModules;\n  };\n\n  const processConnectQueue = () => {\n    // Figure out new parents for chunk groups\n    // to get new available modules for these children\n    for (const [chunkGroupInfo, targets] of queueConnect) {\n      // 1. Add new targets to the list of children\n      if (chunkGroupInfo.children === undefined) {\n        chunkGroupInfo.children = targets;\n      } else {\n        for (const target of targets) {\n          chunkGroupInfo.children.add(target);\n        }\n      } // 2. Calculate resulting available modules\n\n\n      const resultingAvailableModules = calculateResultingAvailableModules(chunkGroupInfo);\n      const runtime = chunkGroupInfo.runtime; // 3. Update chunk group info\n\n      for (const target of targets) {\n        target.availableModulesToBeMerged.push(resultingAvailableModules);\n        chunkGroupsForMerging.add(target);\n        const oldRuntime = target.runtime;\n        const newRuntime = mergeRuntime(oldRuntime, runtime);\n\n        if (oldRuntime !== newRuntime) {\n          target.runtime = newRuntime;\n          outdatedChunkGroupInfo.add(target);\n        }\n      }\n\n      statConnectedChunkGroups += targets.size;\n    }\n\n    queueConnect.clear();\n  };\n\n  const processChunkGroupsForMerging = () => {\n    statProcessedChunkGroupsForMerging += chunkGroupsForMerging.size; // Execute the merge\n\n    for (const info of chunkGroupsForMerging) {\n      const availableModulesToBeMerged = info.availableModulesToBeMerged;\n      let cachedMinAvailableModules = info.minAvailableModules;\n      statMergedAvailableModuleSets += availableModulesToBeMerged.length; // 1. Get minimal available modules\n      // It doesn't make sense to traverse a chunk again with more available modules.\n      // This step calculates the minimal available modules and skips traversal when\n      // the list didn't shrink.\n\n      if (availableModulesToBeMerged.length > 1) {\n        availableModulesToBeMerged.sort(bySetSize);\n      }\n\n      let changed = false;\n\n      merge: for (const availableModules of availableModulesToBeMerged) {\n        if (cachedMinAvailableModules === undefined) {\n          cachedMinAvailableModules = availableModules;\n          info.minAvailableModules = cachedMinAvailableModules;\n          info.minAvailableModulesOwned = false;\n          changed = true;\n        } else {\n          if (info.minAvailableModulesOwned) {\n            // We own it and can modify it\n            if (cachedMinAvailableModules.plus === availableModules.plus) {\n              for (const m of cachedMinAvailableModules) {\n                if (!availableModules.has(m)) {\n                  cachedMinAvailableModules.delete(m);\n                  changed = true;\n                }\n              }\n            } else {\n              for (const m of cachedMinAvailableModules) {\n                if (!availableModules.has(m) && !availableModules.plus.has(m)) {\n                  cachedMinAvailableModules.delete(m);\n                  changed = true;\n                }\n              }\n\n              for (const m of cachedMinAvailableModules.plus) {\n                if (!availableModules.has(m) && !availableModules.plus.has(m)) {\n                  // We can't remove modules from the plus part\n                  // so we need to merge plus into the normal part to allow modifying it\n                  const iterator = cachedMinAvailableModules.plus[Symbol.iterator](); // fast forward add all modules until m\n\n                  /** @type {IteratorResult<Module>} */\n\n                  let it;\n\n                  while (!(it = iterator.next()).done) {\n                    const module = it.value;\n                    if (module === m) break;\n                    cachedMinAvailableModules.add(module);\n                  } // check the remaining modules before adding\n\n\n                  while (!(it = iterator.next()).done) {\n                    const module = it.value;\n\n                    if (availableModules.has(module) || availableModules.plus.has(module)) {\n                      cachedMinAvailableModules.add(module);\n                    }\n                  }\n\n                  cachedMinAvailableModules.plus = EMPTY_SET;\n                  changed = true;\n                  continue merge;\n                }\n              }\n            }\n          } else if (cachedMinAvailableModules.plus === availableModules.plus) {\n            // Common and fast case when the plus part is shared\n            // We only need to care about the normal part\n            if (availableModules.size < cachedMinAvailableModules.size) {\n              // the new availableModules is smaller so it's faster to\n              // fork from the new availableModules\n              statForkedAvailableModules++;\n              statForkedAvailableModulesCount += availableModules.size;\n              statForkedMergedModulesCount += cachedMinAvailableModules.size; // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\n              const newSet =\n              /** @type {ModuleSetPlus} */\n              new Set();\n              newSet.plus = availableModules.plus;\n\n              for (const m of availableModules) {\n                if (cachedMinAvailableModules.has(m)) {\n                  newSet.add(m);\n                }\n              }\n\n              statForkedResultModulesCount += newSet.size;\n              cachedMinAvailableModules = newSet;\n              info.minAvailableModulesOwned = true;\n              info.minAvailableModules = newSet;\n              changed = true;\n              continue merge;\n            }\n\n            for (const m of cachedMinAvailableModules) {\n              if (!availableModules.has(m)) {\n                // cachedMinAvailableModules need to be modified\n                // but we don't own it\n                statForkedAvailableModules++;\n                statForkedAvailableModulesCount += cachedMinAvailableModules.size;\n                statForkedMergedModulesCount += availableModules.size; // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n                // as the plus part is equal we can just take over this one\n\n                const newSet =\n                /** @type {ModuleSetPlus} */\n                new Set();\n                newSet.plus = availableModules.plus;\n                const iterator = cachedMinAvailableModules[Symbol.iterator](); // fast forward add all modules until m\n\n                /** @type {IteratorResult<Module>} */\n\n                let it;\n\n                while (!(it = iterator.next()).done) {\n                  const module = it.value;\n                  if (module === m) break;\n                  newSet.add(module);\n                } // check the remaining modules before adding\n\n\n                while (!(it = iterator.next()).done) {\n                  const module = it.value;\n\n                  if (availableModules.has(module)) {\n                    newSet.add(module);\n                  }\n                }\n\n                statForkedResultModulesCount += newSet.size;\n                cachedMinAvailableModules = newSet;\n                info.minAvailableModulesOwned = true;\n                info.minAvailableModules = newSet;\n                changed = true;\n                continue merge;\n              }\n            }\n          } else {\n            for (const m of cachedMinAvailableModules) {\n              if (!availableModules.has(m) && !availableModules.plus.has(m)) {\n                // cachedMinAvailableModules need to be modified\n                // but we don't own it\n                statForkedAvailableModules++;\n                statForkedAvailableModulesCount += cachedMinAvailableModules.size;\n                statForkedAvailableModulesCountPlus += cachedMinAvailableModules.plus.size;\n                statForkedMergedModulesCount += availableModules.size;\n                statForkedMergedModulesCountPlus += availableModules.plus.size; // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\n                const newSet =\n                /** @type {ModuleSetPlus} */\n                new Set();\n                newSet.plus = EMPTY_SET;\n                const iterator = cachedMinAvailableModules[Symbol.iterator](); // fast forward add all modules until m\n\n                /** @type {IteratorResult<Module>} */\n\n                let it;\n\n                while (!(it = iterator.next()).done) {\n                  const module = it.value;\n                  if (module === m) break;\n                  newSet.add(module);\n                } // check the remaining modules before adding\n\n\n                while (!(it = iterator.next()).done) {\n                  const module = it.value;\n\n                  if (availableModules.has(module) || availableModules.plus.has(module)) {\n                    newSet.add(module);\n                  }\n                } // also check all modules in cachedMinAvailableModules.plus\n\n\n                for (const module of cachedMinAvailableModules.plus) {\n                  if (availableModules.has(module) || availableModules.plus.has(module)) {\n                    newSet.add(module);\n                  }\n                }\n\n                statForkedResultModulesCount += newSet.size;\n                cachedMinAvailableModules = newSet;\n                info.minAvailableModulesOwned = true;\n                info.minAvailableModules = newSet;\n                changed = true;\n                continue merge;\n              }\n            }\n\n            for (const m of cachedMinAvailableModules.plus) {\n              if (!availableModules.has(m) && !availableModules.plus.has(m)) {\n                // cachedMinAvailableModules need to be modified\n                // but we don't own it\n                statForkedAvailableModules++;\n                statForkedAvailableModulesCount += cachedMinAvailableModules.size;\n                statForkedAvailableModulesCountPlus += cachedMinAvailableModules.plus.size;\n                statForkedMergedModulesCount += availableModules.size;\n                statForkedMergedModulesCountPlus += availableModules.plus.size; // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n                // we already know that all modules directly from cachedMinAvailableModules are in availableModules too\n\n                const newSet =\n                /** @type {ModuleSetPlus} */\n                new Set(cachedMinAvailableModules);\n                newSet.plus = EMPTY_SET;\n                const iterator = cachedMinAvailableModules.plus[Symbol.iterator](); // fast forward add all modules until m\n\n                /** @type {IteratorResult<Module>} */\n\n                let it;\n\n                while (!(it = iterator.next()).done) {\n                  const module = it.value;\n                  if (module === m) break;\n                  newSet.add(module);\n                } // check the remaining modules before adding\n\n\n                while (!(it = iterator.next()).done) {\n                  const module = it.value;\n\n                  if (availableModules.has(module) || availableModules.plus.has(module)) {\n                    newSet.add(module);\n                  }\n                }\n\n                statForkedResultModulesCount += newSet.size;\n                cachedMinAvailableModules = newSet;\n                info.minAvailableModulesOwned = true;\n                info.minAvailableModules = newSet;\n                changed = true;\n                continue merge;\n              }\n            }\n          }\n        }\n      }\n\n      availableModulesToBeMerged.length = 0;\n\n      if (changed) {\n        info.resultingAvailableModules = undefined;\n        outdatedChunkGroupInfo.add(info);\n      }\n    }\n\n    chunkGroupsForMerging.clear();\n  };\n\n  const processChunkGroupsForCombining = () => {\n    for (const info of chunkGroupsForCombining) {\n      for (const source of info.availableSources) {\n        if (!source.minAvailableModules) {\n          chunkGroupsForCombining.delete(info);\n          break;\n        }\n      }\n    }\n\n    for (const info of chunkGroupsForCombining) {\n      const availableModules =\n      /** @type {ModuleSetPlus} */\n      new Set();\n      availableModules.plus = EMPTY_SET;\n\n      const mergeSet = set => {\n        if (set.size > availableModules.plus.size) {\n          for (const item of availableModules.plus) availableModules.add(item);\n\n          availableModules.plus = set;\n        } else {\n          for (const item of set) availableModules.add(item);\n        }\n      }; // combine minAvailableModules from all resultingAvailableModules\n\n\n      for (const source of info.availableSources) {\n        const resultingAvailableModules = calculateResultingAvailableModules(source);\n        mergeSet(resultingAvailableModules);\n        mergeSet(resultingAvailableModules.plus);\n      }\n\n      info.minAvailableModules = availableModules;\n      info.minAvailableModulesOwned = false;\n      info.resultingAvailableModules = undefined;\n      outdatedChunkGroupInfo.add(info);\n    }\n\n    chunkGroupsForCombining.clear();\n  };\n\n  const processOutdatedChunkGroupInfo = () => {\n    statChunkGroupInfoUpdated += outdatedChunkGroupInfo.size; // Revisit skipped elements\n\n    for (const info of outdatedChunkGroupInfo) {\n      // 1. Reconsider skipped items\n      if (info.skippedItems !== undefined) {\n        const {\n          minAvailableModules\n        } = info;\n\n        for (const module of info.skippedItems) {\n          if (!minAvailableModules.has(module) && !minAvailableModules.plus.has(module)) {\n            queue.push({\n              action: ADD_AND_ENTER_MODULE,\n              block: module,\n              module,\n              chunk: info.chunkGroup.chunks[0],\n              chunkGroup: info.chunkGroup,\n              chunkGroupInfo: info\n            });\n            info.skippedItems.delete(module);\n          }\n        }\n      } // 2. Reconsider skipped connections\n\n\n      if (info.skippedModuleConnections !== undefined) {\n        const {\n          minAvailableModules\n        } = info;\n\n        for (const entry of info.skippedModuleConnections) {\n          const [module, activeState] = entry;\n          if (activeState === false) continue;\n\n          if (activeState === true) {\n            info.skippedModuleConnections.delete(entry);\n          }\n\n          if (activeState === true && (minAvailableModules.has(module) || minAvailableModules.plus.has(module))) {\n            info.skippedItems.add(module);\n            continue;\n          }\n\n          queue.push({\n            action: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\n            block: module,\n            module,\n            chunk: info.chunkGroup.chunks[0],\n            chunkGroup: info.chunkGroup,\n            chunkGroupInfo: info\n          });\n        }\n      } // 2. Reconsider children chunk groups\n\n\n      if (info.children !== undefined) {\n        statChildChunkGroupsReconnected += info.children.size;\n\n        for (const cgi of info.children) {\n          let connectList = queueConnect.get(info);\n\n          if (connectList === undefined) {\n            connectList = new Set();\n            queueConnect.set(info, connectList);\n          }\n\n          connectList.add(cgi);\n        }\n      } // 3. Reconsider chunk groups for combining\n\n\n      if (info.availableChildren !== undefined) {\n        for (const cgi of info.availableChildren) {\n          chunkGroupsForCombining.add(cgi);\n        }\n      }\n    }\n\n    outdatedChunkGroupInfo.clear();\n  }; // Iterative traversal of the Module graph\n  // Recursive would be simpler to write but could result in Stack Overflows\n\n\n  while (queue.length || queueConnect.size) {\n    logger.time(\"visitModules: visiting\");\n    processQueue();\n    logger.timeAggregateEnd(\"visitModules: prepare\");\n    logger.timeEnd(\"visitModules: visiting\");\n\n    if (chunkGroupsForCombining.size > 0) {\n      logger.time(\"visitModules: combine available modules\");\n      processChunkGroupsForCombining();\n      logger.timeEnd(\"visitModules: combine available modules\");\n    }\n\n    if (queueConnect.size > 0) {\n      logger.time(\"visitModules: calculating available modules\");\n      processConnectQueue();\n      logger.timeEnd(\"visitModules: calculating available modules\");\n\n      if (chunkGroupsForMerging.size > 0) {\n        logger.time(\"visitModules: merging available modules\");\n        processChunkGroupsForMerging();\n        logger.timeEnd(\"visitModules: merging available modules\");\n      }\n    }\n\n    if (outdatedChunkGroupInfo.size > 0) {\n      logger.time(\"visitModules: check modules for revisit\");\n      processOutdatedChunkGroupInfo();\n      logger.timeEnd(\"visitModules: check modules for revisit\");\n    } // Run queueDelayed when all items of the queue are processed\n    // This is important to get the global indexing correct\n    // Async blocks should be processed after all sync blocks are processed\n\n\n    if (queue.length === 0) {\n      const tempQueue = queue;\n      queue = queueDelayed.reverse();\n      queueDelayed = tempQueue;\n    }\n  }\n\n  logger.log(`${statProcessedQueueItems} queue items processed (${statProcessedBlocks} blocks)`);\n  logger.log(`${statConnectedChunkGroups} chunk groups connected`);\n  logger.log(`${statProcessedChunkGroupsForMerging} chunk groups processed for merging (${statMergedAvailableModuleSets} module sets, ${statForkedAvailableModules} forked, ${statForkedAvailableModulesCount} + ${statForkedAvailableModulesCountPlus} modules forked, ${statForkedMergedModulesCount} + ${statForkedMergedModulesCountPlus} modules merged into fork, ${statForkedResultModulesCount} resulting modules)`);\n  logger.log(`${statChunkGroupInfoUpdated} chunk group info updated (${statChildChunkGroupsReconnected} already connected chunk groups reconnected)`);\n};\n/**\n *\n * @param {Compilation} compilation the compilation\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n */\n\n\nconst connectChunkGroups = (compilation, blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap) => {\n  const {\n    chunkGraph\n  } = compilation;\n  /**\n   * Helper function to check if all modules of a chunk are available\n   *\n   * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n   * @param {ModuleSetPlus} availableModules the comparator set\n   * @returns {boolean} return true if all modules of a chunk are available\n   */\n\n  const areModulesAvailable = (chunkGroup, availableModules) => {\n    for (const chunk of chunkGroup.chunks) {\n      for (const module of chunkGraph.getChunkModulesIterable(chunk)) {\n        if (!availableModules.has(module) && !availableModules.plus.has(module)) return false;\n      }\n    }\n\n    return true;\n  }; // For each edge in the basic chunk graph\n\n\n  for (const [block, connections] of blockConnections) {\n    // 1. Check if connection is needed\n    // When none of the dependencies need to be connected\n    // we can skip all of them\n    // It's not possible to filter each item so it doesn't create inconsistent\n    // connections and modules can only create one version\n    // TODO maybe decide this per runtime\n    if ( // TODO is this needed?\n    !blocksWithNestedBlocks.has(block) && connections.every(_ref => {\n      let {\n        chunkGroup,\n        originChunkGroupInfo\n      } = _ref;\n      return areModulesAvailable(chunkGroup, originChunkGroupInfo.resultingAvailableModules);\n    })) {\n      continue;\n    } // 2. Foreach edge\n\n\n    for (let i = 0; i < connections.length; i++) {\n      const {\n        chunkGroup,\n        originChunkGroupInfo\n      } = connections[i]; // 3. Connect block with chunk\n\n      chunkGraph.connectBlockAndChunkGroup(block, chunkGroup); // 4. Connect chunk with parent\n\n      connectChunkGroupParentAndChild(originChunkGroupInfo.chunkGroup, chunkGroup);\n    }\n  }\n};\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\n\n\nconst cleanupUnconnectedGroups = (compilation, allCreatedChunkGroups) => {\n  const {\n    chunkGraph\n  } = compilation;\n\n  for (const chunkGroup of allCreatedChunkGroups) {\n    if (chunkGroup.getNumberOfParents() === 0) {\n      for (const chunk of chunkGroup.chunks) {\n        compilation.chunks.delete(chunk);\n        chunkGraph.disconnectChunk(chunk);\n      }\n\n      chunkGraph.disconnectChunkGroup(chunkGroup);\n      chunkGroup.remove();\n    }\n  }\n};\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {Map<Entrypoint, Module[]>} inputEntrypointsAndModules chunk groups which are processed with the modules\n * @returns {void}\n */\n\n\nconst buildChunkGraph = (compilation, inputEntrypointsAndModules) => {\n  const logger = compilation.getLogger(\"webpack.buildChunkGraph\"); // SHARED STATE\n\n  /** @type {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} */\n\n  const blockConnections = new Map();\n  /** @type {Set<ChunkGroup>} */\n\n  const allCreatedChunkGroups = new Set();\n  /** @type {Map<ChunkGroup, ChunkGroupInfo>} */\n\n  const chunkGroupInfoMap = new Map();\n  /** @type {Set<DependenciesBlock>} */\n\n  const blocksWithNestedBlocks = new Set(); // PART ONE\n\n  logger.time(\"visitModules\");\n  visitModules(logger, compilation, inputEntrypointsAndModules, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups);\n  logger.timeEnd(\"visitModules\"); // PART TWO\n\n  logger.time(\"connectChunkGroups\");\n  connectChunkGroups(compilation, blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap);\n  logger.timeEnd(\"connectChunkGroups\");\n\n  for (const [chunkGroup, chunkGroupInfo] of chunkGroupInfoMap) {\n    for (const chunk of chunkGroup.chunks) chunk.runtime = mergeRuntime(chunk.runtime, chunkGroupInfo.runtime);\n  } // Cleanup work\n\n\n  logger.time(\"cleanup\");\n  cleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n  logger.timeEnd(\"cleanup\");\n};\n\nmodule.exports = buildChunkGraph;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/buildChunkGraph.js"],"names":["AsyncDependencyToInitialChunkError","require","connectChunkGroupParentAndChild","ModuleGraphConnection","getEntryRuntime","mergeRuntime","EMPTY_SET","Set","plus","bySetSize","a","b","size","extractBlockModules","module","moduleGraph","runtime","blockModulesMap","blockCache","modules","arrays","queue","length","block","pop","arr","push","set","blocks","connection","getOutgoingConnections","d","dependency","m","weak","state","getActiveState","getParentBlock","index","getParentBlockIndex","dependencies","indexOf","get","i","indexMap","outer","j","undefined","merged","addConnectionStates","Map","idx","visitModules","logger","compilation","inputEntrypointsAndModules","chunkGroupInfoMap","blockConnections","blocksWithNestedBlocks","allCreatedChunkGroups","chunkGraph","moduleMemCaches","blockModulesRuntimeMap","blockModulesMapRuntime","getBlockModules","blockModules","getRootBlock","memCache","map","provide","time","timeAggregate","statProcessedQueueItems","statProcessedBlocks","statConnectedChunkGroups","statProcessedChunkGroupsForMerging","statMergedAvailableModuleSets","statForkedAvailableModules","statForkedAvailableModulesCount","statForkedAvailableModulesCountPlus","statForkedMergedModulesCount","statForkedMergedModulesCountPlus","statForkedResultModulesCount","statChunkGroupInfoUpdated","statChildChunkGroupsReconnected","nextChunkGroupIndex","nextFreeModulePreOrderIndex","nextFreeModulePostOrderIndex","blockChunkGroups","namedChunkGroups","namedAsyncEntrypoints","ADD_AND_ENTER_ENTRY_MODULE","ADD_AND_ENTER_MODULE","ENTER_MODULE","PROCESS_BLOCK","PROCESS_ENTRY_BLOCK","LEAVE_MODULE","queueConnect","chunkGroupsForCombining","chunkGroup","name","options","chunkGroupInfo","minAvailableModules","minAvailableModulesOwned","availableModulesToBeMerged","skippedItems","resultingAvailableModules","children","availableSources","availableChildren","preOrderIndex","postOrderIndex","chunkLoading","outputOptions","asyncChunks","getNumberOfParents","add","chunk","getEntrypointChunk","action","parent","parentsIterable","parentChunkGroupInfo","reverse","outdatedChunkGroupInfo","chunkGroupsForMerging","queueDelayed","skipConnectionBuffer","skipBuffer","queueBuffer","iteratorBlock","cgi","c","entrypoint","entryOptions","groupOptions","chunkName","addAsyncEntrypoint","loc","request","connectBlockAndChunkGroup","addOrigin","chunks","addChunkInGroup","isInitial","errors","addOptions","originChunkGroupInfo","connectList","processBlock","refModule","isModuleInChunk","activeState","has","skippedModuleConnections","processEntryBlock","processQueue","queueItem","connectChunkAndEntryModule","connectChunkAndModule","getModulePreOrderIndex","setModulePreOrderIndex","setPreOrderIndexIfUnset","getModulePostOrderIndex","setModulePostOrderIndex","setPostOrderIndexIfUnset","calculateResultingAvailableModules","getChunkModulesIterable","processConnectQueue","targets","target","oldRuntime","newRuntime","clear","processChunkGroupsForMerging","info","cachedMinAvailableModules","sort","changed","merge","availableModules","delete","iterator","Symbol","it","next","done","value","newSet","processChunkGroupsForCombining","source","mergeSet","item","processOutdatedChunkGroupInfo","entry","timeAggregateEnd","timeEnd","tempQueue","log","connectChunkGroups","areModulesAvailable","connections","every","cleanupUnconnectedGroups","disconnectChunk","disconnectChunkGroup","remove","buildChunkGraph","getLogger","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\nconst { connectChunkGroupParentAndChild } = require(\"./GraphHelpers\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst { getEntryRuntime, mergeRuntime } = require(\"./util/runtime\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./ModuleGraphConnection\").ConnectionState} ConnectionState */\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {Object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n * @property {ChunkGroupInfo} chunkGroupInfo\n */\n\n/** @typedef {Set<Module> & { plus: Set<Module> }} ModuleSetPlus */\n\n/**\n * @typedef {Object} ChunkGroupInfo\n * @property {ChunkGroup} chunkGroup the chunk group\n * @property {RuntimeSpec} runtime the runtimes\n * @property {ModuleSetPlus} minAvailableModules current minimal set of modules available at this point\n * @property {boolean} minAvailableModulesOwned true, if minAvailableModules is owned and can be modified\n * @property {ModuleSetPlus[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {Set<Module>=} skippedItems modules that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<[Module, ConnectionState]>=} skippedModuleConnections referenced modules that where skipped because they were not active in this runtime\n * @property {ModuleSetPlus} resultingAvailableModules set of modules available including modules from this chunk group\n * @property {Set<ChunkGroupInfo>} children set of children chunk groups, that will be revisited when availableModules shrink\n * @property {Set<ChunkGroupInfo>} availableSources set of chunk groups that are the source for minAvailableModules\n * @property {Set<ChunkGroupInfo>} availableChildren set of chunk groups which depend on the this chunk group as availableSource\n * @property {number} preOrderIndex next pre order index\n * @property {number} postOrderIndex next post order index\n * @property {boolean} chunkLoading has a chunk loading mechanism\n * @property {boolean} asyncChunks create async chunks\n */\n\n/**\n * @typedef {Object} BlockChunkGroupConnection\n * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\nconst EMPTY_SET = /** @type {ModuleSetPlus} */ (new Set());\nEMPTY_SET.plus = EMPTY_SET;\n\n/**\n * @param {ModuleSetPlus} a first set\n * @param {ModuleSetPlus} b second set\n * @returns {number} cmp\n */\nconst bySetSize = (a, b) => {\n\treturn b.size + b.plus.size - a.size - a.plus.size;\n};\n\nconst extractBlockModules = (module, moduleGraph, runtime, blockModulesMap) => {\n\tlet blockCache;\n\tlet modules;\n\n\tconst arrays = [];\n\n\tconst queue = [module];\n\twhile (queue.length > 0) {\n\t\tconst block = queue.pop();\n\t\tconst arr = [];\n\t\tarrays.push(arr);\n\t\tblockModulesMap.set(block, arr);\n\t\tfor (const b of block.blocks) {\n\t\t\tqueue.push(b);\n\t\t}\n\t}\n\n\tfor (const connection of moduleGraph.getOutgoingConnections(module)) {\n\t\tconst d = connection.dependency;\n\t\t// We skip connections without dependency\n\t\tif (!d) continue;\n\t\tconst m = connection.module;\n\t\t// We skip connections without Module pointer\n\t\tif (!m) continue;\n\t\t// We skip weak connections\n\t\tif (connection.weak) continue;\n\t\tconst state = connection.getActiveState(runtime);\n\t\t// We skip inactive connections\n\t\tif (state === false) continue;\n\n\t\tconst block = moduleGraph.getParentBlock(d);\n\t\tlet index = moduleGraph.getParentBlockIndex(d);\n\n\t\t// deprecated fallback\n\t\tif (index < 0) {\n\t\t\tindex = block.dependencies.indexOf(d);\n\t\t}\n\n\t\tif (blockCache !== block) {\n\t\t\tmodules = blockModulesMap.get((blockCache = block));\n\t\t}\n\n\t\tconst i = index << 2;\n\t\tmodules[i] = m;\n\t\tmodules[i + 1] = state;\n\t}\n\n\tfor (const modules of arrays) {\n\t\tif (modules.length === 0) continue;\n\t\tlet indexMap;\n\t\tlet length = 0;\n\t\touter: for (let j = 0; j < modules.length; j += 2) {\n\t\t\tconst m = modules[j];\n\t\t\tif (m === undefined) continue;\n\t\t\tconst state = modules[j + 1];\n\t\t\tif (indexMap === undefined) {\n\t\t\t\tlet i = 0;\n\t\t\t\tfor (; i < length; i += 2) {\n\t\t\t\t\tif (modules[i] === m) {\n\t\t\t\t\t\tconst merged = modules[i + 1];\n\t\t\t\t\t\tif (merged === true) continue outer;\n\t\t\t\t\t\tmodules[i + 1] = ModuleGraphConnection.addConnectionStates(\n\t\t\t\t\t\t\tmerged,\n\t\t\t\t\t\t\tstate\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmodules[length] = m;\n\t\t\t\tlength++;\n\t\t\t\tmodules[length] = state;\n\t\t\t\tlength++;\n\t\t\t\tif (length > 30) {\n\t\t\t\t\t// To avoid worse case performance, we will use an index map for\n\t\t\t\t\t// linear cost access, which allows to maintain O(n) complexity\n\t\t\t\t\t// while keeping allocations down to a minimum\n\t\t\t\t\tindexMap = new Map();\n\t\t\t\t\tfor (let i = 0; i < length; i += 2) {\n\t\t\t\t\t\tindexMap.set(modules[i], i + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst idx = indexMap.get(m);\n\t\t\t\tif (idx !== undefined) {\n\t\t\t\t\tconst merged = modules[idx];\n\t\t\t\t\tif (merged === true) continue outer;\n\t\t\t\t\tmodules[idx] = ModuleGraphConnection.addConnectionStates(\n\t\t\t\t\t\tmerged,\n\t\t\t\t\t\tstate\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tmodules[length] = m;\n\t\t\t\t\tlength++;\n\t\t\t\t\tmodules[length] = state;\n\t\t\t\t\tindexMap.set(m, length);\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmodules.length = length;\n\t}\n};\n\n/**\n *\n * @param {Logger} logger a logger\n * @param {Compilation} compilation the compilation\n * @param {Map<Entrypoint, Module[]>} inputEntrypointsAndModules chunk groups which are processed with the modules\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here\n */\nconst visitModules = (\n\tlogger,\n\tcompilation,\n\tinputEntrypointsAndModules,\n\tchunkGroupInfoMap,\n\tblockConnections,\n\tblocksWithNestedBlocks,\n\tallCreatedChunkGroups\n) => {\n\tconst { moduleGraph, chunkGraph, moduleMemCaches } = compilation;\n\n\tconst blockModulesRuntimeMap = new Map();\n\n\t/** @type {RuntimeSpec | false} */\n\tlet blockModulesMapRuntime = false;\n\tlet blockModulesMap;\n\n\t/**\n\t *\n\t * @param {DependenciesBlock} block block\n\t * @param {RuntimeSpec} runtime runtime\n\t * @returns {(Module | ConnectionState)[]} block modules in flatten tuples\n\t */\n\tconst getBlockModules = (block, runtime) => {\n\t\tif (blockModulesMapRuntime !== runtime) {\n\t\t\tblockModulesMap = blockModulesRuntimeMap.get(runtime);\n\t\t\tif (blockModulesMap === undefined) {\n\t\t\t\tblockModulesMap = new Map();\n\t\t\t\tblockModulesRuntimeMap.set(runtime, blockModulesMap);\n\t\t\t}\n\t\t}\n\t\tlet blockModules = blockModulesMap.get(block);\n\t\tif (blockModules !== undefined) return blockModules;\n\t\tconst module = /** @type {Module} */ (block.getRootBlock());\n\t\tconst memCache = moduleMemCaches && moduleMemCaches.get(module);\n\t\tif (memCache !== undefined) {\n\t\t\tconst map = memCache.provide(\n\t\t\t\t\"bundleChunkGraph.blockModules\",\n\t\t\t\truntime,\n\t\t\t\t() => {\n\t\t\t\t\tlogger.time(\"visitModules: prepare\");\n\t\t\t\t\tconst map = new Map();\n\t\t\t\t\textractBlockModules(module, moduleGraph, runtime, map);\n\t\t\t\t\tlogger.timeAggregate(\"visitModules: prepare\");\n\t\t\t\t\treturn map;\n\t\t\t\t}\n\t\t\t);\n\t\t\tfor (const [block, blockModules] of map)\n\t\t\t\tblockModulesMap.set(block, blockModules);\n\t\t\treturn map.get(block);\n\t\t} else {\n\t\t\tlogger.time(\"visitModules: prepare\");\n\t\t\textractBlockModules(module, moduleGraph, runtime, blockModulesMap);\n\t\t\tblockModules = blockModulesMap.get(block);\n\t\t\tlogger.timeAggregate(\"visitModules: prepare\");\n\t\t\treturn blockModules;\n\t\t}\n\t};\n\n\tlet statProcessedQueueItems = 0;\n\tlet statProcessedBlocks = 0;\n\tlet statConnectedChunkGroups = 0;\n\tlet statProcessedChunkGroupsForMerging = 0;\n\tlet statMergedAvailableModuleSets = 0;\n\tlet statForkedAvailableModules = 0;\n\tlet statForkedAvailableModulesCount = 0;\n\tlet statForkedAvailableModulesCountPlus = 0;\n\tlet statForkedMergedModulesCount = 0;\n\tlet statForkedMergedModulesCountPlus = 0;\n\tlet statForkedResultModulesCount = 0;\n\tlet statChunkGroupInfoUpdated = 0;\n\tlet statChildChunkGroupsReconnected = 0;\n\n\tlet nextChunkGroupIndex = 0;\n\tlet nextFreeModulePreOrderIndex = 0;\n\tlet nextFreeModulePostOrderIndex = 0;\n\n\t/** @type {Map<DependenciesBlock, ChunkGroupInfo>} */\n\tconst blockChunkGroups = new Map();\n\n\t/** @type {Map<string, ChunkGroupInfo>} */\n\tconst namedChunkGroups = new Map();\n\n\t/** @type {Map<string, ChunkGroupInfo>} */\n\tconst namedAsyncEntrypoints = new Map();\n\n\tconst ADD_AND_ENTER_ENTRY_MODULE = 0;\n\tconst ADD_AND_ENTER_MODULE = 1;\n\tconst ENTER_MODULE = 2;\n\tconst PROCESS_BLOCK = 3;\n\tconst PROCESS_ENTRY_BLOCK = 4;\n\tconst LEAVE_MODULE = 5;\n\n\t/** @type {QueueItem[]} */\n\tlet queue = [];\n\n\t/** @type {Map<ChunkGroupInfo, Set<ChunkGroupInfo>>} */\n\tconst queueConnect = new Map();\n\t/** @type {Set<ChunkGroupInfo>} */\n\tconst chunkGroupsForCombining = new Set();\n\n\t// Fill queue with entrypoint modules\n\t// Create ChunkGroupInfo for entrypoints\n\tfor (const [chunkGroup, modules] of inputEntrypointsAndModules) {\n\t\tconst runtime = getEntryRuntime(\n\t\t\tcompilation,\n\t\t\tchunkGroup.name,\n\t\t\tchunkGroup.options\n\t\t);\n\t\t/** @type {ChunkGroupInfo} */\n\t\tconst chunkGroupInfo = {\n\t\t\tchunkGroup,\n\t\t\truntime,\n\t\t\tminAvailableModules: undefined,\n\t\t\tminAvailableModulesOwned: false,\n\t\t\tavailableModulesToBeMerged: [],\n\t\t\tskippedItems: undefined,\n\t\t\tresultingAvailableModules: undefined,\n\t\t\tchildren: undefined,\n\t\t\tavailableSources: undefined,\n\t\t\tavailableChildren: undefined,\n\t\t\tpreOrderIndex: 0,\n\t\t\tpostOrderIndex: 0,\n\t\t\tchunkLoading:\n\t\t\t\tchunkGroup.options.chunkLoading !== undefined\n\t\t\t\t\t? chunkGroup.options.chunkLoading !== false\n\t\t\t\t\t: compilation.outputOptions.chunkLoading !== false,\n\t\t\tasyncChunks:\n\t\t\t\tchunkGroup.options.asyncChunks !== undefined\n\t\t\t\t\t? chunkGroup.options.asyncChunks\n\t\t\t\t\t: compilation.outputOptions.asyncChunks !== false\n\t\t};\n\t\tchunkGroup.index = nextChunkGroupIndex++;\n\t\tif (chunkGroup.getNumberOfParents() > 0) {\n\t\t\t// minAvailableModules for child entrypoints are unknown yet, set to undefined.\n\t\t\t// This means no module is added until other sets are merged into\n\t\t\t// this minAvailableModules (by the parent entrypoints)\n\t\t\tconst skippedItems = new Set();\n\t\t\tfor (const module of modules) {\n\t\t\t\tskippedItems.add(module);\n\t\t\t}\n\t\t\tchunkGroupInfo.skippedItems = skippedItems;\n\t\t\tchunkGroupsForCombining.add(chunkGroupInfo);\n\t\t} else {\n\t\t\t// The application may start here: We start with an empty list of available modules\n\t\t\tchunkGroupInfo.minAvailableModules = EMPTY_SET;\n\t\t\tconst chunk = chunkGroup.getEntrypointChunk();\n\t\t\tfor (const module of modules) {\n\t\t\t\tqueue.push({\n\t\t\t\t\taction: ADD_AND_ENTER_MODULE,\n\t\t\t\t\tblock: module,\n\t\t\t\t\tmodule,\n\t\t\t\t\tchunk,\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\tchunkGroupInfo\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tchunkGroupInfoMap.set(chunkGroup, chunkGroupInfo);\n\t\tif (chunkGroup.name) {\n\t\t\tnamedChunkGroups.set(chunkGroup.name, chunkGroupInfo);\n\t\t}\n\t}\n\t// Fill availableSources with parent-child dependencies between entrypoints\n\tfor (const chunkGroupInfo of chunkGroupsForCombining) {\n\t\tconst { chunkGroup } = chunkGroupInfo;\n\t\tchunkGroupInfo.availableSources = new Set();\n\t\tfor (const parent of chunkGroup.parentsIterable) {\n\t\t\tconst parentChunkGroupInfo = chunkGroupInfoMap.get(parent);\n\t\t\tchunkGroupInfo.availableSources.add(parentChunkGroupInfo);\n\t\t\tif (parentChunkGroupInfo.availableChildren === undefined) {\n\t\t\t\tparentChunkGroupInfo.availableChildren = new Set();\n\t\t\t}\n\t\t\tparentChunkGroupInfo.availableChildren.add(chunkGroupInfo);\n\t\t}\n\t}\n\t// pop() is used to read from the queue\n\t// so it need to be reversed to be iterated in\n\t// correct order\n\tqueue.reverse();\n\n\t/** @type {Set<ChunkGroupInfo>} */\n\tconst outdatedChunkGroupInfo = new Set();\n\t/** @type {Set<ChunkGroupInfo>} */\n\tconst chunkGroupsForMerging = new Set();\n\t/** @type {QueueItem[]} */\n\tlet queueDelayed = [];\n\n\t/** @type {[Module, ConnectionState][]} */\n\tconst skipConnectionBuffer = [];\n\t/** @type {Module[]} */\n\tconst skipBuffer = [];\n\t/** @type {QueueItem[]} */\n\tconst queueBuffer = [];\n\n\t/** @type {Module} */\n\tlet module;\n\t/** @type {Chunk} */\n\tlet chunk;\n\t/** @type {ChunkGroup} */\n\tlet chunkGroup;\n\t/** @type {DependenciesBlock} */\n\tlet block;\n\t/** @type {ChunkGroupInfo} */\n\tlet chunkGroupInfo;\n\n\t// For each async Block in graph\n\t/**\n\t * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n\t * @returns {void}\n\t */\n\tconst iteratorBlock = b => {\n\t\t// 1. We create a chunk group with single chunk in it for this Block\n\t\t// but only once (blockChunkGroups map)\n\t\tlet cgi = blockChunkGroups.get(b);\n\t\t/** @type {ChunkGroup} */\n\t\tlet c;\n\t\t/** @type {Entrypoint} */\n\t\tlet entrypoint;\n\t\tconst entryOptions = b.groupOptions && b.groupOptions.entryOptions;\n\t\tif (cgi === undefined) {\n\t\t\tconst chunkName = (b.groupOptions && b.groupOptions.name) || b.chunkName;\n\t\t\tif (entryOptions) {\n\t\t\t\tcgi = namedAsyncEntrypoints.get(chunkName);\n\t\t\t\tif (!cgi) {\n\t\t\t\t\tentrypoint = compilation.addAsyncEntrypoint(\n\t\t\t\t\t\tentryOptions,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tb.loc,\n\t\t\t\t\t\tb.request\n\t\t\t\t\t);\n\t\t\t\t\tentrypoint.index = nextChunkGroupIndex++;\n\t\t\t\t\tcgi = {\n\t\t\t\t\t\tchunkGroup: entrypoint,\n\t\t\t\t\t\truntime: entrypoint.options.runtime || entrypoint.name,\n\t\t\t\t\t\tminAvailableModules: EMPTY_SET,\n\t\t\t\t\t\tminAvailableModulesOwned: false,\n\t\t\t\t\t\tavailableModulesToBeMerged: [],\n\t\t\t\t\t\tskippedItems: undefined,\n\t\t\t\t\t\tresultingAvailableModules: undefined,\n\t\t\t\t\t\tchildren: undefined,\n\t\t\t\t\t\tavailableSources: undefined,\n\t\t\t\t\t\tavailableChildren: undefined,\n\t\t\t\t\t\tpreOrderIndex: 0,\n\t\t\t\t\t\tpostOrderIndex: 0,\n\t\t\t\t\t\tchunkLoading:\n\t\t\t\t\t\t\tentryOptions.chunkLoading !== undefined\n\t\t\t\t\t\t\t\t? entryOptions.chunkLoading !== false\n\t\t\t\t\t\t\t\t: chunkGroupInfo.chunkLoading,\n\t\t\t\t\t\tasyncChunks:\n\t\t\t\t\t\t\tentryOptions.asyncChunks !== undefined\n\t\t\t\t\t\t\t\t? entryOptions.asyncChunks\n\t\t\t\t\t\t\t\t: chunkGroupInfo.asyncChunks\n\t\t\t\t\t};\n\t\t\t\t\tchunkGroupInfoMap.set(entrypoint, cgi);\n\n\t\t\t\t\tchunkGraph.connectBlockAndChunkGroup(b, entrypoint);\n\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\tnamedAsyncEntrypoints.set(chunkName, cgi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tentrypoint = /** @type {Entrypoint} */ (cgi.chunkGroup);\n\t\t\t\t\t// TODO merge entryOptions\n\t\t\t\t\tentrypoint.addOrigin(module, b.loc, b.request);\n\t\t\t\t\tchunkGraph.connectBlockAndChunkGroup(b, entrypoint);\n\t\t\t\t}\n\n\t\t\t\t// 2. We enqueue the DependenciesBlock for traversal\n\t\t\t\tqueueDelayed.push({\n\t\t\t\t\taction: PROCESS_ENTRY_BLOCK,\n\t\t\t\t\tblock: b,\n\t\t\t\t\tmodule: module,\n\t\t\t\t\tchunk: entrypoint.chunks[0],\n\t\t\t\t\tchunkGroup: entrypoint,\n\t\t\t\t\tchunkGroupInfo: cgi\n\t\t\t\t});\n\t\t\t} else if (!chunkGroupInfo.asyncChunks || !chunkGroupInfo.chunkLoading) {\n\t\t\t\t// Just queue the block into the current chunk group\n\t\t\t\tqueue.push({\n\t\t\t\t\taction: PROCESS_BLOCK,\n\t\t\t\t\tblock: b,\n\t\t\t\t\tmodule: module,\n\t\t\t\t\tchunk,\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\tchunkGroupInfo\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcgi = chunkName && namedChunkGroups.get(chunkName);\n\t\t\t\tif (!cgi) {\n\t\t\t\t\tc = compilation.addChunkInGroup(\n\t\t\t\t\t\tb.groupOptions || b.chunkName,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tb.loc,\n\t\t\t\t\t\tb.request\n\t\t\t\t\t);\n\t\t\t\t\tc.index = nextChunkGroupIndex++;\n\t\t\t\t\tcgi = {\n\t\t\t\t\t\tchunkGroup: c,\n\t\t\t\t\t\truntime: chunkGroupInfo.runtime,\n\t\t\t\t\t\tminAvailableModules: undefined,\n\t\t\t\t\t\tminAvailableModulesOwned: undefined,\n\t\t\t\t\t\tavailableModulesToBeMerged: [],\n\t\t\t\t\t\tskippedItems: undefined,\n\t\t\t\t\t\tresultingAvailableModules: undefined,\n\t\t\t\t\t\tchildren: undefined,\n\t\t\t\t\t\tavailableSources: undefined,\n\t\t\t\t\t\tavailableChildren: undefined,\n\t\t\t\t\t\tpreOrderIndex: 0,\n\t\t\t\t\t\tpostOrderIndex: 0,\n\t\t\t\t\t\tchunkLoading: chunkGroupInfo.chunkLoading,\n\t\t\t\t\t\tasyncChunks: chunkGroupInfo.asyncChunks\n\t\t\t\t\t};\n\t\t\t\t\tallCreatedChunkGroups.add(c);\n\t\t\t\t\tchunkGroupInfoMap.set(c, cgi);\n\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\tnamedChunkGroups.set(chunkName, cgi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tc = cgi.chunkGroup;\n\t\t\t\t\tif (c.isInitial()) {\n\t\t\t\t\t\tcompilation.errors.push(\n\t\t\t\t\t\t\tnew AsyncDependencyToInitialChunkError(chunkName, module, b.loc)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tc = chunkGroup;\n\t\t\t\t\t}\n\t\t\t\t\tc.addOptions(b.groupOptions);\n\t\t\t\t\tc.addOrigin(module, b.loc, b.request);\n\t\t\t\t}\n\t\t\t\tblockConnections.set(b, []);\n\t\t\t}\n\t\t\tblockChunkGroups.set(b, cgi);\n\t\t} else if (entryOptions) {\n\t\t\tentrypoint = /** @type {Entrypoint} */ (cgi.chunkGroup);\n\t\t} else {\n\t\t\tc = cgi.chunkGroup;\n\t\t}\n\n\t\tif (c !== undefined) {\n\t\t\t// 2. We store the connection for the block\n\t\t\t// to connect it later if needed\n\t\t\tblockConnections.get(b).push({\n\t\t\t\toriginChunkGroupInfo: chunkGroupInfo,\n\t\t\t\tchunkGroup: c\n\t\t\t});\n\n\t\t\t// 3. We enqueue the chunk group info creation/updating\n\t\t\tlet connectList = queueConnect.get(chunkGroupInfo);\n\t\t\tif (connectList === undefined) {\n\t\t\t\tconnectList = new Set();\n\t\t\t\tqueueConnect.set(chunkGroupInfo, connectList);\n\t\t\t}\n\t\t\tconnectList.add(cgi);\n\n\t\t\t// TODO check if this really need to be done for each traversal\n\t\t\t// or if it is enough when it's queued when created\n\t\t\t// 4. We enqueue the DependenciesBlock for traversal\n\t\t\tqueueDelayed.push({\n\t\t\t\taction: PROCESS_BLOCK,\n\t\t\t\tblock: b,\n\t\t\t\tmodule: module,\n\t\t\t\tchunk: c.chunks[0],\n\t\t\t\tchunkGroup: c,\n\t\t\t\tchunkGroupInfo: cgi\n\t\t\t});\n\t\t} else if (entrypoint !== undefined) {\n\t\t\tchunkGroupInfo.chunkGroup.addAsyncEntrypoint(entrypoint);\n\t\t}\n\t};\n\n\t/**\n\t * @param {DependenciesBlock} block the block\n\t * @returns {void}\n\t */\n\tconst processBlock = block => {\n\t\tstatProcessedBlocks++;\n\t\t// get prepared block info\n\t\tconst blockModules = getBlockModules(block, chunkGroupInfo.runtime);\n\n\t\tif (blockModules !== undefined) {\n\t\t\tconst { minAvailableModules } = chunkGroupInfo;\n\t\t\t// Buffer items because order need to be reversed to get indices correct\n\t\t\t// Traverse all referenced modules\n\t\t\tfor (let i = 0; i < blockModules.length; i += 2) {\n\t\t\t\tconst refModule = /** @type {Module} */ (blockModules[i]);\n\t\t\t\tif (chunkGraph.isModuleInChunk(refModule, chunk)) {\n\t\t\t\t\t// skip early if already connected\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst activeState = /** @type {ConnectionState} */ (\n\t\t\t\t\tblockModules[i + 1]\n\t\t\t\t);\n\t\t\t\tif (activeState !== true) {\n\t\t\t\t\tskipConnectionBuffer.push([refModule, activeState]);\n\t\t\t\t\tif (activeState === false) continue;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tactiveState === true &&\n\t\t\t\t\t(minAvailableModules.has(refModule) ||\n\t\t\t\t\t\tminAvailableModules.plus.has(refModule))\n\t\t\t\t) {\n\t\t\t\t\t// already in parent chunks, skip it for now\n\t\t\t\t\tskipBuffer.push(refModule);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// enqueue, then add and enter to be in the correct order\n\t\t\t\t// this is relevant with circular dependencies\n\t\t\t\tqueueBuffer.push({\n\t\t\t\t\taction: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\n\t\t\t\t\tblock: refModule,\n\t\t\t\t\tmodule: refModule,\n\t\t\t\t\tchunk,\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\tchunkGroupInfo\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Add buffered items in reverse order\n\t\t\tif (skipConnectionBuffer.length > 0) {\n\t\t\t\tlet { skippedModuleConnections } = chunkGroupInfo;\n\t\t\t\tif (skippedModuleConnections === undefined) {\n\t\t\t\t\tchunkGroupInfo.skippedModuleConnections = skippedModuleConnections =\n\t\t\t\t\t\tnew Set();\n\t\t\t\t}\n\t\t\t\tfor (let i = skipConnectionBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\tskippedModuleConnections.add(skipConnectionBuffer[i]);\n\t\t\t\t}\n\t\t\t\tskipConnectionBuffer.length = 0;\n\t\t\t}\n\t\t\tif (skipBuffer.length > 0) {\n\t\t\t\tlet { skippedItems } = chunkGroupInfo;\n\t\t\t\tif (skippedItems === undefined) {\n\t\t\t\t\tchunkGroupInfo.skippedItems = skippedItems = new Set();\n\t\t\t\t}\n\t\t\t\tfor (let i = skipBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\tskippedItems.add(skipBuffer[i]);\n\t\t\t\t}\n\t\t\t\tskipBuffer.length = 0;\n\t\t\t}\n\t\t\tif (queueBuffer.length > 0) {\n\t\t\t\tfor (let i = queueBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\tqueue.push(queueBuffer[i]);\n\t\t\t\t}\n\t\t\t\tqueueBuffer.length = 0;\n\t\t\t}\n\t\t}\n\n\t\t// Traverse all Blocks\n\t\tfor (const b of block.blocks) {\n\t\t\titeratorBlock(b);\n\t\t}\n\n\t\tif (block.blocks.length > 0 && module !== block) {\n\t\t\tblocksWithNestedBlocks.add(block);\n\t\t}\n\t};\n\n\t/**\n\t * @param {DependenciesBlock} block the block\n\t * @returns {void}\n\t */\n\tconst processEntryBlock = block => {\n\t\tstatProcessedBlocks++;\n\t\t// get prepared block info\n\t\tconst blockModules = getBlockModules(block, chunkGroupInfo.runtime);\n\n\t\tif (blockModules !== undefined) {\n\t\t\t// Traverse all referenced modules\n\t\t\tfor (let i = 0; i < blockModules.length; i += 2) {\n\t\t\t\tconst refModule = /** @type {Module} */ (blockModules[i]);\n\t\t\t\tconst activeState = /** @type {ConnectionState} */ (\n\t\t\t\t\tblockModules[i + 1]\n\t\t\t\t);\n\t\t\t\t// enqueue, then add and enter to be in the correct order\n\t\t\t\t// this is relevant with circular dependencies\n\t\t\t\tqueueBuffer.push({\n\t\t\t\t\taction:\n\t\t\t\t\t\tactiveState === true ? ADD_AND_ENTER_ENTRY_MODULE : PROCESS_BLOCK,\n\t\t\t\t\tblock: refModule,\n\t\t\t\t\tmodule: refModule,\n\t\t\t\t\tchunk,\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\tchunkGroupInfo\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Add buffered items in reverse order\n\t\t\tif (queueBuffer.length > 0) {\n\t\t\t\tfor (let i = queueBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\tqueue.push(queueBuffer[i]);\n\t\t\t\t}\n\t\t\t\tqueueBuffer.length = 0;\n\t\t\t}\n\t\t}\n\n\t\t// Traverse all Blocks\n\t\tfor (const b of block.blocks) {\n\t\t\titeratorBlock(b);\n\t\t}\n\n\t\tif (block.blocks.length > 0 && module !== block) {\n\t\t\tblocksWithNestedBlocks.add(block);\n\t\t}\n\t};\n\n\tconst processQueue = () => {\n\t\twhile (queue.length) {\n\t\t\tstatProcessedQueueItems++;\n\t\t\tconst queueItem = queue.pop();\n\t\t\tmodule = queueItem.module;\n\t\t\tblock = queueItem.block;\n\t\t\tchunk = queueItem.chunk;\n\t\t\tchunkGroup = queueItem.chunkGroup;\n\t\t\tchunkGroupInfo = queueItem.chunkGroupInfo;\n\n\t\t\tswitch (queueItem.action) {\n\t\t\t\tcase ADD_AND_ENTER_ENTRY_MODULE:\n\t\t\t\t\tchunkGraph.connectChunkAndEntryModule(\n\t\t\t\t\t\tchunk,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t/** @type {Entrypoint} */ (chunkGroup)\n\t\t\t\t\t);\n\t\t\t\t// fallthrough\n\t\t\t\tcase ADD_AND_ENTER_MODULE: {\n\t\t\t\t\tif (chunkGraph.isModuleInChunk(module, chunk)) {\n\t\t\t\t\t\t// already connected, skip it\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// We connect Module and Chunk\n\t\t\t\t\tchunkGraph.connectChunkAndModule(chunk, module);\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\t\tcase ENTER_MODULE: {\n\t\t\t\t\tconst index = chunkGroup.getModulePreOrderIndex(module);\n\t\t\t\t\tif (index === undefined) {\n\t\t\t\t\t\tchunkGroup.setModulePreOrderIndex(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tchunkGroupInfo.preOrderIndex++\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tmoduleGraph.setPreOrderIndexIfUnset(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tnextFreeModulePreOrderIndex\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tnextFreeModulePreOrderIndex++;\n\t\t\t\t\t}\n\n\t\t\t\t\t// reuse queueItem\n\t\t\t\t\tqueueItem.action = LEAVE_MODULE;\n\t\t\t\t\tqueue.push(queueItem);\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\t\tcase PROCESS_BLOCK: {\n\t\t\t\t\tprocessBlock(block);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase PROCESS_ENTRY_BLOCK: {\n\t\t\t\t\tprocessEntryBlock(block);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase LEAVE_MODULE: {\n\t\t\t\t\tconst index = chunkGroup.getModulePostOrderIndex(module);\n\t\t\t\t\tif (index === undefined) {\n\t\t\t\t\t\tchunkGroup.setModulePostOrderIndex(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tchunkGroupInfo.postOrderIndex++\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tmoduleGraph.setPostOrderIndexIfUnset(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tnextFreeModulePostOrderIndex\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tnextFreeModulePostOrderIndex++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tconst calculateResultingAvailableModules = chunkGroupInfo => {\n\t\tif (chunkGroupInfo.resultingAvailableModules)\n\t\t\treturn chunkGroupInfo.resultingAvailableModules;\n\n\t\tconst minAvailableModules = chunkGroupInfo.minAvailableModules;\n\n\t\t// Create a new Set of available modules at this point\n\t\t// We want to be as lazy as possible. There are multiple ways doing this:\n\t\t// Note that resultingAvailableModules is stored as \"(a) + (b)\" as it's a ModuleSetPlus\n\t\t// - resultingAvailableModules = (modules of chunk) + (minAvailableModules + minAvailableModules.plus)\n\t\t// - resultingAvailableModules = (minAvailableModules + modules of chunk) + (minAvailableModules.plus)\n\t\t// We choose one depending on the size of minAvailableModules vs minAvailableModules.plus\n\n\t\tlet resultingAvailableModules;\n\t\tif (minAvailableModules.size > minAvailableModules.plus.size) {\n\t\t\t// resultingAvailableModules = (modules of chunk) + (minAvailableModules + minAvailableModules.plus)\n\t\t\tresultingAvailableModules =\n\t\t\t\t/** @type {Set<Module> & {plus: Set<Module>}} */ (new Set());\n\t\t\tfor (const module of minAvailableModules.plus)\n\t\t\t\tminAvailableModules.add(module);\n\t\t\tminAvailableModules.plus = EMPTY_SET;\n\t\t\tresultingAvailableModules.plus = minAvailableModules;\n\t\t\tchunkGroupInfo.minAvailableModulesOwned = false;\n\t\t} else {\n\t\t\t// resultingAvailableModules = (minAvailableModules + modules of chunk) + (minAvailableModules.plus)\n\t\t\tresultingAvailableModules =\n\t\t\t\t/** @type {Set<Module> & {plus: Set<Module>}} */ (\n\t\t\t\t\tnew Set(minAvailableModules)\n\t\t\t\t);\n\t\t\tresultingAvailableModules.plus = minAvailableModules.plus;\n\t\t}\n\n\t\t// add the modules from the chunk group to the set\n\t\tfor (const chunk of chunkGroupInfo.chunkGroup.chunks) {\n\t\t\tfor (const m of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\t\tresultingAvailableModules.add(m);\n\t\t\t}\n\t\t}\n\t\treturn (chunkGroupInfo.resultingAvailableModules =\n\t\t\tresultingAvailableModules);\n\t};\n\n\tconst processConnectQueue = () => {\n\t\t// Figure out new parents for chunk groups\n\t\t// to get new available modules for these children\n\t\tfor (const [chunkGroupInfo, targets] of queueConnect) {\n\t\t\t// 1. Add new targets to the list of children\n\t\t\tif (chunkGroupInfo.children === undefined) {\n\t\t\t\tchunkGroupInfo.children = targets;\n\t\t\t} else {\n\t\t\t\tfor (const target of targets) {\n\t\t\t\t\tchunkGroupInfo.children.add(target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 2. Calculate resulting available modules\n\t\t\tconst resultingAvailableModules =\n\t\t\t\tcalculateResultingAvailableModules(chunkGroupInfo);\n\n\t\t\tconst runtime = chunkGroupInfo.runtime;\n\n\t\t\t// 3. Update chunk group info\n\t\t\tfor (const target of targets) {\n\t\t\t\ttarget.availableModulesToBeMerged.push(resultingAvailableModules);\n\t\t\t\tchunkGroupsForMerging.add(target);\n\t\t\t\tconst oldRuntime = target.runtime;\n\t\t\t\tconst newRuntime = mergeRuntime(oldRuntime, runtime);\n\t\t\t\tif (oldRuntime !== newRuntime) {\n\t\t\t\t\ttarget.runtime = newRuntime;\n\t\t\t\t\toutdatedChunkGroupInfo.add(target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatConnectedChunkGroups += targets.size;\n\t\t}\n\t\tqueueConnect.clear();\n\t};\n\n\tconst processChunkGroupsForMerging = () => {\n\t\tstatProcessedChunkGroupsForMerging += chunkGroupsForMerging.size;\n\n\t\t// Execute the merge\n\t\tfor (const info of chunkGroupsForMerging) {\n\t\t\tconst availableModulesToBeMerged = info.availableModulesToBeMerged;\n\t\t\tlet cachedMinAvailableModules = info.minAvailableModules;\n\n\t\t\tstatMergedAvailableModuleSets += availableModulesToBeMerged.length;\n\n\t\t\t// 1. Get minimal available modules\n\t\t\t// It doesn't make sense to traverse a chunk again with more available modules.\n\t\t\t// This step calculates the minimal available modules and skips traversal when\n\t\t\t// the list didn't shrink.\n\t\t\tif (availableModulesToBeMerged.length > 1) {\n\t\t\t\tavailableModulesToBeMerged.sort(bySetSize);\n\t\t\t}\n\t\t\tlet changed = false;\n\t\t\tmerge: for (const availableModules of availableModulesToBeMerged) {\n\t\t\t\tif (cachedMinAvailableModules === undefined) {\n\t\t\t\t\tcachedMinAvailableModules = availableModules;\n\t\t\t\t\tinfo.minAvailableModules = cachedMinAvailableModules;\n\t\t\t\t\tinfo.minAvailableModulesOwned = false;\n\t\t\t\t\tchanged = true;\n\t\t\t\t} else {\n\t\t\t\t\tif (info.minAvailableModulesOwned) {\n\t\t\t\t\t\t// We own it and can modify it\n\t\t\t\t\t\tif (cachedMinAvailableModules.plus === availableModules.plus) {\n\t\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\n\t\t\t\t\t\t\t\tif (!availableModules.has(m)) {\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.delete(m);\n\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\n\t\t\t\t\t\t\t\tif (!availableModules.has(m) && !availableModules.plus.has(m)) {\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.delete(m);\n\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const m of cachedMinAvailableModules.plus) {\n\t\t\t\t\t\t\t\tif (!availableModules.has(m) && !availableModules.plus.has(m)) {\n\t\t\t\t\t\t\t\t\t// We can't remove modules from the plus part\n\t\t\t\t\t\t\t\t\t// so we need to merge plus into the normal part to allow modifying it\n\t\t\t\t\t\t\t\t\tconst iterator =\n\t\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.plus[Symbol.iterator]();\n\t\t\t\t\t\t\t\t\t// fast forward add all modules until m\n\t\t\t\t\t\t\t\t\t/** @type {IteratorResult<Module>} */\n\t\t\t\t\t\t\t\t\tlet it;\n\t\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\t\tif (module === m) break;\n\t\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.add(module);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// check the remaining modules before adding\n\t\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\tavailableModules.has(module) ||\n\t\t\t\t\t\t\t\t\t\t\tavailableModules.plus.has(module)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.add(module);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.plus = EMPTY_SET;\n\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\tcontinue merge;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (cachedMinAvailableModules.plus === availableModules.plus) {\n\t\t\t\t\t\t// Common and fast case when the plus part is shared\n\t\t\t\t\t\t// We only need to care about the normal part\n\t\t\t\t\t\tif (availableModules.size < cachedMinAvailableModules.size) {\n\t\t\t\t\t\t\t// the new availableModules is smaller so it's faster to\n\t\t\t\t\t\t\t// fork from the new availableModules\n\t\t\t\t\t\t\tstatForkedAvailableModules++;\n\t\t\t\t\t\t\tstatForkedAvailableModulesCount += availableModules.size;\n\t\t\t\t\t\t\tstatForkedMergedModulesCount += cachedMinAvailableModules.size;\n\t\t\t\t\t\t\t// construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\t\t\t\t\t\t\tconst newSet = /** @type {ModuleSetPlus} */ (new Set());\n\t\t\t\t\t\t\tnewSet.plus = availableModules.plus;\n\t\t\t\t\t\t\tfor (const m of availableModules) {\n\t\t\t\t\t\t\t\tif (cachedMinAvailableModules.has(m)) {\n\t\t\t\t\t\t\t\t\tnewSet.add(m);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstatForkedResultModulesCount += newSet.size;\n\t\t\t\t\t\t\tcachedMinAvailableModules = newSet;\n\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = true;\n\t\t\t\t\t\t\tinfo.minAvailableModules = newSet;\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\tcontinue merge;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\n\t\t\t\t\t\t\tif (!availableModules.has(m)) {\n\t\t\t\t\t\t\t\t// cachedMinAvailableModules need to be modified\n\t\t\t\t\t\t\t\t// but we don't own it\n\t\t\t\t\t\t\t\tstatForkedAvailableModules++;\n\t\t\t\t\t\t\t\tstatForkedAvailableModulesCount +=\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.size;\n\t\t\t\t\t\t\t\tstatForkedMergedModulesCount += availableModules.size;\n\t\t\t\t\t\t\t\t// construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\t\t\t\t\t\t\t\t// as the plus part is equal we can just take over this one\n\t\t\t\t\t\t\t\tconst newSet = /** @type {ModuleSetPlus} */ (new Set());\n\t\t\t\t\t\t\t\tnewSet.plus = availableModules.plus;\n\t\t\t\t\t\t\t\tconst iterator = cachedMinAvailableModules[Symbol.iterator]();\n\t\t\t\t\t\t\t\t// fast forward add all modules until m\n\t\t\t\t\t\t\t\t/** @type {IteratorResult<Module>} */\n\t\t\t\t\t\t\t\tlet it;\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\tif (module === m) break;\n\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// check the remaining modules before adding\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\tif (availableModules.has(module)) {\n\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstatForkedResultModulesCount += newSet.size;\n\t\t\t\t\t\t\t\tcachedMinAvailableModules = newSet;\n\t\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = true;\n\t\t\t\t\t\t\t\tinfo.minAvailableModules = newSet;\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\tcontinue merge;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\n\t\t\t\t\t\t\tif (!availableModules.has(m) && !availableModules.plus.has(m)) {\n\t\t\t\t\t\t\t\t// cachedMinAvailableModules need to be modified\n\t\t\t\t\t\t\t\t// but we don't own it\n\t\t\t\t\t\t\t\tstatForkedAvailableModules++;\n\t\t\t\t\t\t\t\tstatForkedAvailableModulesCount +=\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.size;\n\t\t\t\t\t\t\t\tstatForkedAvailableModulesCountPlus +=\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.plus.size;\n\t\t\t\t\t\t\t\tstatForkedMergedModulesCount += availableModules.size;\n\t\t\t\t\t\t\t\tstatForkedMergedModulesCountPlus += availableModules.plus.size;\n\t\t\t\t\t\t\t\t// construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\t\t\t\t\t\t\t\tconst newSet = /** @type {ModuleSetPlus} */ (new Set());\n\t\t\t\t\t\t\t\tnewSet.plus = EMPTY_SET;\n\t\t\t\t\t\t\t\tconst iterator = cachedMinAvailableModules[Symbol.iterator]();\n\t\t\t\t\t\t\t\t// fast forward add all modules until m\n\t\t\t\t\t\t\t\t/** @type {IteratorResult<Module>} */\n\t\t\t\t\t\t\t\tlet it;\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\tif (module === m) break;\n\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// check the remaining modules before adding\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tavailableModules.has(module) ||\n\t\t\t\t\t\t\t\t\t\tavailableModules.plus.has(module)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// also check all modules in cachedMinAvailableModules.plus\n\t\t\t\t\t\t\t\tfor (const module of cachedMinAvailableModules.plus) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tavailableModules.has(module) ||\n\t\t\t\t\t\t\t\t\t\tavailableModules.plus.has(module)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstatForkedResultModulesCount += newSet.size;\n\t\t\t\t\t\t\t\tcachedMinAvailableModules = newSet;\n\t\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = true;\n\t\t\t\t\t\t\t\tinfo.minAvailableModules = newSet;\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\tcontinue merge;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const m of cachedMinAvailableModules.plus) {\n\t\t\t\t\t\t\tif (!availableModules.has(m) && !availableModules.plus.has(m)) {\n\t\t\t\t\t\t\t\t// cachedMinAvailableModules need to be modified\n\t\t\t\t\t\t\t\t// but we don't own it\n\t\t\t\t\t\t\t\tstatForkedAvailableModules++;\n\t\t\t\t\t\t\t\tstatForkedAvailableModulesCount +=\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.size;\n\t\t\t\t\t\t\t\tstatForkedAvailableModulesCountPlus +=\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.plus.size;\n\t\t\t\t\t\t\t\tstatForkedMergedModulesCount += availableModules.size;\n\t\t\t\t\t\t\t\tstatForkedMergedModulesCountPlus += availableModules.plus.size;\n\t\t\t\t\t\t\t\t// construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\t\t\t\t\t\t\t\t// we already know that all modules directly from cachedMinAvailableModules are in availableModules too\n\t\t\t\t\t\t\t\tconst newSet = /** @type {ModuleSetPlus} */ (\n\t\t\t\t\t\t\t\t\tnew Set(cachedMinAvailableModules)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tnewSet.plus = EMPTY_SET;\n\t\t\t\t\t\t\t\tconst iterator =\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.plus[Symbol.iterator]();\n\t\t\t\t\t\t\t\t// fast forward add all modules until m\n\t\t\t\t\t\t\t\t/** @type {IteratorResult<Module>} */\n\t\t\t\t\t\t\t\tlet it;\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\tif (module === m) break;\n\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// check the remaining modules before adding\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tavailableModules.has(module) ||\n\t\t\t\t\t\t\t\t\t\tavailableModules.plus.has(module)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstatForkedResultModulesCount += newSet.size;\n\t\t\t\t\t\t\t\tcachedMinAvailableModules = newSet;\n\t\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = true;\n\t\t\t\t\t\t\t\tinfo.minAvailableModules = newSet;\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\tcontinue merge;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tavailableModulesToBeMerged.length = 0;\n\t\t\tif (changed) {\n\t\t\t\tinfo.resultingAvailableModules = undefined;\n\t\t\t\toutdatedChunkGroupInfo.add(info);\n\t\t\t}\n\t\t}\n\t\tchunkGroupsForMerging.clear();\n\t};\n\n\tconst processChunkGroupsForCombining = () => {\n\t\tfor (const info of chunkGroupsForCombining) {\n\t\t\tfor (const source of info.availableSources) {\n\t\t\t\tif (!source.minAvailableModules) {\n\t\t\t\t\tchunkGroupsForCombining.delete(info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const info of chunkGroupsForCombining) {\n\t\t\tconst availableModules = /** @type {ModuleSetPlus} */ (new Set());\n\t\t\tavailableModules.plus = EMPTY_SET;\n\t\t\tconst mergeSet = set => {\n\t\t\t\tif (set.size > availableModules.plus.size) {\n\t\t\t\t\tfor (const item of availableModules.plus) availableModules.add(item);\n\t\t\t\t\tavailableModules.plus = set;\n\t\t\t\t} else {\n\t\t\t\t\tfor (const item of set) availableModules.add(item);\n\t\t\t\t}\n\t\t\t};\n\t\t\t// combine minAvailableModules from all resultingAvailableModules\n\t\t\tfor (const source of info.availableSources) {\n\t\t\t\tconst resultingAvailableModules =\n\t\t\t\t\tcalculateResultingAvailableModules(source);\n\t\t\t\tmergeSet(resultingAvailableModules);\n\t\t\t\tmergeSet(resultingAvailableModules.plus);\n\t\t\t}\n\t\t\tinfo.minAvailableModules = availableModules;\n\t\t\tinfo.minAvailableModulesOwned = false;\n\t\t\tinfo.resultingAvailableModules = undefined;\n\t\t\toutdatedChunkGroupInfo.add(info);\n\t\t}\n\t\tchunkGroupsForCombining.clear();\n\t};\n\n\tconst processOutdatedChunkGroupInfo = () => {\n\t\tstatChunkGroupInfoUpdated += outdatedChunkGroupInfo.size;\n\t\t// Revisit skipped elements\n\t\tfor (const info of outdatedChunkGroupInfo) {\n\t\t\t// 1. Reconsider skipped items\n\t\t\tif (info.skippedItems !== undefined) {\n\t\t\t\tconst { minAvailableModules } = info;\n\t\t\t\tfor (const module of info.skippedItems) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!minAvailableModules.has(module) &&\n\t\t\t\t\t\t!minAvailableModules.plus.has(module)\n\t\t\t\t\t) {\n\t\t\t\t\t\tqueue.push({\n\t\t\t\t\t\t\taction: ADD_AND_ENTER_MODULE,\n\t\t\t\t\t\t\tblock: module,\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tchunk: info.chunkGroup.chunks[0],\n\t\t\t\t\t\t\tchunkGroup: info.chunkGroup,\n\t\t\t\t\t\t\tchunkGroupInfo: info\n\t\t\t\t\t\t});\n\t\t\t\t\t\tinfo.skippedItems.delete(module);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 2. Reconsider skipped connections\n\t\t\tif (info.skippedModuleConnections !== undefined) {\n\t\t\t\tconst { minAvailableModules } = info;\n\t\t\t\tfor (const entry of info.skippedModuleConnections) {\n\t\t\t\t\tconst [module, activeState] = entry;\n\t\t\t\t\tif (activeState === false) continue;\n\t\t\t\t\tif (activeState === true) {\n\t\t\t\t\t\tinfo.skippedModuleConnections.delete(entry);\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tactiveState === true &&\n\t\t\t\t\t\t(minAvailableModules.has(module) ||\n\t\t\t\t\t\t\tminAvailableModules.plus.has(module))\n\t\t\t\t\t) {\n\t\t\t\t\t\tinfo.skippedItems.add(module);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tqueue.push({\n\t\t\t\t\t\taction: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\n\t\t\t\t\t\tblock: module,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tchunk: info.chunkGroup.chunks[0],\n\t\t\t\t\t\tchunkGroup: info.chunkGroup,\n\t\t\t\t\t\tchunkGroupInfo: info\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 2. Reconsider children chunk groups\n\t\t\tif (info.children !== undefined) {\n\t\t\t\tstatChildChunkGroupsReconnected += info.children.size;\n\t\t\t\tfor (const cgi of info.children) {\n\t\t\t\t\tlet connectList = queueConnect.get(info);\n\t\t\t\t\tif (connectList === undefined) {\n\t\t\t\t\t\tconnectList = new Set();\n\t\t\t\t\t\tqueueConnect.set(info, connectList);\n\t\t\t\t\t}\n\t\t\t\t\tconnectList.add(cgi);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 3. Reconsider chunk groups for combining\n\t\t\tif (info.availableChildren !== undefined) {\n\t\t\t\tfor (const cgi of info.availableChildren) {\n\t\t\t\t\tchunkGroupsForCombining.add(cgi);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\toutdatedChunkGroupInfo.clear();\n\t};\n\n\t// Iterative traversal of the Module graph\n\t// Recursive would be simpler to write but could result in Stack Overflows\n\twhile (queue.length || queueConnect.size) {\n\t\tlogger.time(\"visitModules: visiting\");\n\t\tprocessQueue();\n\t\tlogger.timeAggregateEnd(\"visitModules: prepare\");\n\t\tlogger.timeEnd(\"visitModules: visiting\");\n\n\t\tif (chunkGroupsForCombining.size > 0) {\n\t\t\tlogger.time(\"visitModules: combine available modules\");\n\t\t\tprocessChunkGroupsForCombining();\n\t\t\tlogger.timeEnd(\"visitModules: combine available modules\");\n\t\t}\n\n\t\tif (queueConnect.size > 0) {\n\t\t\tlogger.time(\"visitModules: calculating available modules\");\n\t\t\tprocessConnectQueue();\n\t\t\tlogger.timeEnd(\"visitModules: calculating available modules\");\n\n\t\t\tif (chunkGroupsForMerging.size > 0) {\n\t\t\t\tlogger.time(\"visitModules: merging available modules\");\n\t\t\t\tprocessChunkGroupsForMerging();\n\t\t\t\tlogger.timeEnd(\"visitModules: merging available modules\");\n\t\t\t}\n\t\t}\n\n\t\tif (outdatedChunkGroupInfo.size > 0) {\n\t\t\tlogger.time(\"visitModules: check modules for revisit\");\n\t\t\tprocessOutdatedChunkGroupInfo();\n\t\t\tlogger.timeEnd(\"visitModules: check modules for revisit\");\n\t\t}\n\n\t\t// Run queueDelayed when all items of the queue are processed\n\t\t// This is important to get the global indexing correct\n\t\t// Async blocks should be processed after all sync blocks are processed\n\t\tif (queue.length === 0) {\n\t\t\tconst tempQueue = queue;\n\t\t\tqueue = queueDelayed.reverse();\n\t\t\tqueueDelayed = tempQueue;\n\t\t}\n\t}\n\n\tlogger.log(\n\t\t`${statProcessedQueueItems} queue items processed (${statProcessedBlocks} blocks)`\n\t);\n\tlogger.log(`${statConnectedChunkGroups} chunk groups connected`);\n\tlogger.log(\n\t\t`${statProcessedChunkGroupsForMerging} chunk groups processed for merging (${statMergedAvailableModuleSets} module sets, ${statForkedAvailableModules} forked, ${statForkedAvailableModulesCount} + ${statForkedAvailableModulesCountPlus} modules forked, ${statForkedMergedModulesCount} + ${statForkedMergedModulesCountPlus} modules merged into fork, ${statForkedResultModulesCount} resulting modules)`\n\t);\n\tlogger.log(\n\t\t`${statChunkGroupInfoUpdated} chunk group info updated (${statChildChunkGroupsReconnected} already connected chunk groups reconnected)`\n\t);\n};\n\n/**\n *\n * @param {Compilation} compilation the compilation\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n */\nconst connectChunkGroups = (\n\tcompilation,\n\tblocksWithNestedBlocks,\n\tblockConnections,\n\tchunkGroupInfoMap\n) => {\n\tconst { chunkGraph } = compilation;\n\n\t/**\n\t * Helper function to check if all modules of a chunk are available\n\t *\n\t * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n\t * @param {ModuleSetPlus} availableModules the comparator set\n\t * @returns {boolean} return true if all modules of a chunk are available\n\t */\n\tconst areModulesAvailable = (chunkGroup, availableModules) => {\n\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\tfor (const module of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\t\tif (!availableModules.has(module) && !availableModules.plus.has(module))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t// For each edge in the basic chunk graph\n\tfor (const [block, connections] of blockConnections) {\n\t\t// 1. Check if connection is needed\n\t\t// When none of the dependencies need to be connected\n\t\t// we can skip all of them\n\t\t// It's not possible to filter each item so it doesn't create inconsistent\n\t\t// connections and modules can only create one version\n\t\t// TODO maybe decide this per runtime\n\t\tif (\n\t\t\t// TODO is this needed?\n\t\t\t!blocksWithNestedBlocks.has(block) &&\n\t\t\tconnections.every(({ chunkGroup, originChunkGroupInfo }) =>\n\t\t\t\tareModulesAvailable(\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\toriginChunkGroupInfo.resultingAvailableModules\n\t\t\t\t)\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// 2. Foreach edge\n\t\tfor (let i = 0; i < connections.length; i++) {\n\t\t\tconst { chunkGroup, originChunkGroupInfo } = connections[i];\n\n\t\t\t// 3. Connect block with chunk\n\t\t\tchunkGraph.connectBlockAndChunkGroup(block, chunkGroup);\n\n\t\t\t// 4. Connect chunk with parent\n\t\t\tconnectChunkGroupParentAndChild(\n\t\t\t\toriginChunkGroupInfo.chunkGroup,\n\t\t\t\tchunkGroup\n\t\t\t);\n\t\t}\n\t}\n};\n\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\nconst cleanupUnconnectedGroups = (compilation, allCreatedChunkGroups) => {\n\tconst { chunkGraph } = compilation;\n\n\tfor (const chunkGroup of allCreatedChunkGroups) {\n\t\tif (chunkGroup.getNumberOfParents() === 0) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tcompilation.chunks.delete(chunk);\n\t\t\t\tchunkGraph.disconnectChunk(chunk);\n\t\t\t}\n\t\t\tchunkGraph.disconnectChunkGroup(chunkGroup);\n\t\t\tchunkGroup.remove();\n\t\t}\n\t}\n};\n\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {Map<Entrypoint, Module[]>} inputEntrypointsAndModules chunk groups which are processed with the modules\n * @returns {void}\n */\nconst buildChunkGraph = (compilation, inputEntrypointsAndModules) => {\n\tconst logger = compilation.getLogger(\"webpack.buildChunkGraph\");\n\n\t// SHARED STATE\n\n\t/** @type {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} */\n\tconst blockConnections = new Map();\n\n\t/** @type {Set<ChunkGroup>} */\n\tconst allCreatedChunkGroups = new Set();\n\n\t/** @type {Map<ChunkGroup, ChunkGroupInfo>} */\n\tconst chunkGroupInfoMap = new Map();\n\n\t/** @type {Set<DependenciesBlock>} */\n\tconst blocksWithNestedBlocks = new Set();\n\n\t// PART ONE\n\n\tlogger.time(\"visitModules\");\n\tvisitModules(\n\t\tlogger,\n\t\tcompilation,\n\t\tinputEntrypointsAndModules,\n\t\tchunkGroupInfoMap,\n\t\tblockConnections,\n\t\tblocksWithNestedBlocks,\n\t\tallCreatedChunkGroups\n\t);\n\tlogger.timeEnd(\"visitModules\");\n\n\t// PART TWO\n\n\tlogger.time(\"connectChunkGroups\");\n\tconnectChunkGroups(\n\t\tcompilation,\n\t\tblocksWithNestedBlocks,\n\t\tblockConnections,\n\t\tchunkGroupInfoMap\n\t);\n\tlogger.timeEnd(\"connectChunkGroups\");\n\n\tfor (const [chunkGroup, chunkGroupInfo] of chunkGroupInfoMap) {\n\t\tfor (const chunk of chunkGroup.chunks)\n\t\t\tchunk.runtime = mergeRuntime(chunk.runtime, chunkGroupInfo.runtime);\n\t}\n\n\t// Cleanup work\n\n\tlogger.time(\"cleanup\");\n\tcleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n\tlogger.timeEnd(\"cleanup\");\n};\n\nmodule.exports = buildChunkGraph;\n"]},"metadata":{},"sourceType":"script"}