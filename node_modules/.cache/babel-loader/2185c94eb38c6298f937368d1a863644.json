{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\n\nconst {\n  SyncHook,\n  MultiHook\n} = require(\"tapable\");\n\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\n\nconst MultiStats = require(\"./MultiStats\");\n\nconst MultiWatching = require(\"./MultiWatching\");\n\nconst ArrayQueue = require(\"./util/ArrayQueue\");\n/** @template T @typedef {import(\"tapable\").AsyncSeriesHook<T>} AsyncSeriesHook<T> */\n\n/** @template T @template R @typedef {import(\"tapable\").SyncBailHook<T, R>} SyncBailHook<T, R> */\n\n/** @typedef {import(\"../declarations/WebpackOptions\").WatchOptions} WatchOptions */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./Stats\")} Stats */\n\n/** @typedef {import(\"./Watching\")} Watching */\n\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n\n/** @typedef {import(\"./util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n\n/** @typedef {import(\"./util/fs\").WatchFileSystem} WatchFileSystem */\n\n/**\n * @template T\n * @callback Callback\n * @param {(Error | null)=} err\n * @param {T=} result\n */\n\n/**\n * @callback RunWithDependenciesHandler\n * @param {Compiler} compiler\n * @param {Callback<MultiStats>} callback\n */\n\n/**\n * @typedef {Object} MultiCompilerOptions\n * @property {number=} parallelism how many Compilers are allows to run at the same time in parallel\n */\n\n\nmodule.exports = class MultiCompiler {\n  /**\n   * @param {Compiler[] | Record<string, Compiler>} compilers child compilers\n   * @param {MultiCompilerOptions} options options\n   */\n  constructor(compilers, options) {\n    if (!Array.isArray(compilers)) {\n      compilers = Object.keys(compilers).map(name => {\n        compilers[name].name = name;\n        return compilers[name];\n      });\n    }\n\n    this.hooks = Object.freeze({\n      /** @type {SyncHook<[MultiStats]>} */\n      done: new SyncHook([\"stats\"]),\n\n      /** @type {MultiHook<SyncHook<[string | null, number]>>} */\n      invalid: new MultiHook(compilers.map(c => c.hooks.invalid)),\n\n      /** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n      run: new MultiHook(compilers.map(c => c.hooks.run)),\n\n      /** @type {SyncHook<[]>} */\n      watchClose: new SyncHook([]),\n\n      /** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n      watchRun: new MultiHook(compilers.map(c => c.hooks.watchRun)),\n\n      /** @type {MultiHook<SyncBailHook<[string, string, any[]], true>>} */\n      infrastructureLog: new MultiHook(compilers.map(c => c.hooks.infrastructureLog))\n    });\n    this.compilers = compilers;\n    /** @type {MultiCompilerOptions} */\n\n    this._options = {\n      parallelism: options.parallelism || Infinity\n    };\n    /** @type {WeakMap<Compiler, string[]>} */\n\n    this.dependencies = new WeakMap();\n    this.running = false;\n    /** @type {Stats[]} */\n\n    const compilerStats = this.compilers.map(() => null);\n    let doneCompilers = 0;\n\n    for (let index = 0; index < this.compilers.length; index++) {\n      const compiler = this.compilers[index];\n      const compilerIndex = index;\n      let compilerDone = false;\n      compiler.hooks.done.tap(\"MultiCompiler\", stats => {\n        if (!compilerDone) {\n          compilerDone = true;\n          doneCompilers++;\n        }\n\n        compilerStats[compilerIndex] = stats;\n\n        if (doneCompilers === this.compilers.length) {\n          this.hooks.done.call(new MultiStats(compilerStats));\n        }\n      });\n      compiler.hooks.invalid.tap(\"MultiCompiler\", () => {\n        if (compilerDone) {\n          compilerDone = false;\n          doneCompilers--;\n        }\n      });\n    }\n  }\n\n  get options() {\n    return Object.assign(this.compilers.map(c => c.options), this._options);\n  }\n\n  get outputPath() {\n    let commonPath = this.compilers[0].outputPath;\n\n    for (const compiler of this.compilers) {\n      while (compiler.outputPath.indexOf(commonPath) !== 0 && /[/\\\\]/.test(commonPath)) {\n        commonPath = commonPath.replace(/[/\\\\][^/\\\\]*$/, \"\");\n      }\n    }\n\n    if (!commonPath && this.compilers[0].outputPath[0] === \"/\") return \"/\";\n    return commonPath;\n  }\n\n  get inputFileSystem() {\n    throw new Error(\"Cannot read inputFileSystem of a MultiCompiler\");\n  }\n\n  get outputFileSystem() {\n    throw new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n  }\n\n  get watchFileSystem() {\n    throw new Error(\"Cannot read watchFileSystem of a MultiCompiler\");\n  }\n\n  get intermediateFileSystem() {\n    throw new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n  }\n  /**\n   * @param {InputFileSystem} value the new input file system\n   */\n\n\n  set inputFileSystem(value) {\n    for (const compiler of this.compilers) {\n      compiler.inputFileSystem = value;\n    }\n  }\n  /**\n   * @param {OutputFileSystem} value the new output file system\n   */\n\n\n  set outputFileSystem(value) {\n    for (const compiler of this.compilers) {\n      compiler.outputFileSystem = value;\n    }\n  }\n  /**\n   * @param {WatchFileSystem} value the new watch file system\n   */\n\n\n  set watchFileSystem(value) {\n    for (const compiler of this.compilers) {\n      compiler.watchFileSystem = value;\n    }\n  }\n  /**\n   * @param {IntermediateFileSystem} value the new intermediate file system\n   */\n\n\n  set intermediateFileSystem(value) {\n    for (const compiler of this.compilers) {\n      compiler.intermediateFileSystem = value;\n    }\n  }\n\n  getInfrastructureLogger(name) {\n    return this.compilers[0].getInfrastructureLogger(name);\n  }\n  /**\n   * @param {Compiler} compiler the child compiler\n   * @param {string[]} dependencies its dependencies\n   * @returns {void}\n   */\n\n\n  setDependencies(compiler, dependencies) {\n    this.dependencies.set(compiler, dependencies);\n  }\n  /**\n   * @param {Callback<MultiStats>} callback signals when the validation is complete\n   * @returns {boolean} true if the dependencies are valid\n   */\n\n\n  validateDependencies(callback) {\n    /** @type {Set<{source: Compiler, target: Compiler}>} */\n    const edges = new Set();\n    /** @type {string[]} */\n\n    const missing = [];\n\n    const targetFound = compiler => {\n      for (const edge of edges) {\n        if (edge.target === compiler) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    const sortEdges = (e1, e2) => {\n      return e1.source.name.localeCompare(e2.source.name) || e1.target.name.localeCompare(e2.target.name);\n    };\n\n    for (const source of this.compilers) {\n      const dependencies = this.dependencies.get(source);\n\n      if (dependencies) {\n        for (const dep of dependencies) {\n          const target = this.compilers.find(c => c.name === dep);\n\n          if (!target) {\n            missing.push(dep);\n          } else {\n            edges.add({\n              source,\n              target\n            });\n          }\n        }\n      }\n    }\n    /** @type {string[]} */\n\n\n    const errors = missing.map(m => `Compiler dependency \\`${m}\\` not found.`);\n    const stack = this.compilers.filter(c => !targetFound(c));\n\n    while (stack.length > 0) {\n      const current = stack.pop();\n\n      for (const edge of edges) {\n        if (edge.source === current) {\n          edges.delete(edge);\n          const target = edge.target;\n\n          if (!targetFound(target)) {\n            stack.push(target);\n          }\n        }\n      }\n    }\n\n    if (edges.size > 0) {\n      /** @type {string[]} */\n      const lines = Array.from(edges).sort(sortEdges).map(edge => `${edge.source.name} -> ${edge.target.name}`);\n      lines.unshift(\"Circular dependency found in compiler dependencies.\");\n      errors.unshift(lines.join(\"\\n\"));\n    }\n\n    if (errors.length > 0) {\n      const message = errors.join(\"\\n\");\n      callback(new Error(message));\n      return false;\n    }\n\n    return true;\n  } // TODO webpack 6 remove\n\n  /**\n   * @deprecated This method should have been private\n   * @param {Compiler[]} compilers the child compilers\n   * @param {RunWithDependenciesHandler} fn a handler to run for each compiler\n   * @param {Callback<MultiStats>} callback the compiler's handler\n   * @returns {void}\n   */\n\n\n  runWithDependencies(compilers, fn, callback) {\n    const fulfilledNames = new Set();\n    let remainingCompilers = compilers;\n\n    const isDependencyFulfilled = d => fulfilledNames.has(d);\n\n    const getReadyCompilers = () => {\n      let readyCompilers = [];\n      let list = remainingCompilers;\n      remainingCompilers = [];\n\n      for (const c of list) {\n        const dependencies = this.dependencies.get(c);\n        const ready = !dependencies || dependencies.every(isDependencyFulfilled);\n\n        if (ready) {\n          readyCompilers.push(c);\n        } else {\n          remainingCompilers.push(c);\n        }\n      }\n\n      return readyCompilers;\n    };\n\n    const runCompilers = callback => {\n      if (remainingCompilers.length === 0) return callback();\n      asyncLib.map(getReadyCompilers(), (compiler, callback) => {\n        fn(compiler, err => {\n          if (err) return callback(err);\n          fulfilledNames.add(compiler.name);\n          runCompilers(callback);\n        });\n      }, callback);\n    };\n\n    runCompilers(callback);\n  }\n  /**\n   * @template SetupResult\n   * @param {function(Compiler, number, Callback<Stats>, function(): boolean, function(): void, function(): void): SetupResult} setup setup a single compiler\n   * @param {function(Compiler, SetupResult, Callback<Stats>): void} run run/continue a single compiler\n   * @param {Callback<MultiStats>} callback callback when all compilers are done, result includes Stats of all changed compilers\n   * @returns {SetupResult[]} result of setup\n   */\n\n\n  _runGraph(setup, run, callback) {\n    /** @typedef {{ compiler: Compiler, setupResult: SetupResult, result: Stats, state: \"pending\" | \"blocked\" | \"queued\" | \"starting\" | \"running\" | \"running-outdated\" | \"done\", children: Node[], parents: Node[] }} Node */\n    // State transitions for nodes:\n    // -> blocked (initial)\n    // blocked -> starting [running++] (when all parents done)\n    // queued -> starting [running++] (when processing the queue)\n    // starting -> running (when run has been called)\n    // running -> done [running--] (when compilation is done)\n    // done -> pending (when invalidated from file change)\n    // pending -> blocked [add to queue] (when invalidated from aggregated changes)\n    // done -> blocked [add to queue] (when invalidated, from parent invalidation)\n    // running -> running-outdated (when invalidated, either from change or parent invalidation)\n    // running-outdated -> blocked [running--] (when compilation is done)\n\n    /** @type {Node[]} */\n    const nodes = this.compilers.map(compiler => ({\n      compiler,\n      setupResult: undefined,\n      result: undefined,\n      state: \"blocked\",\n      children: [],\n      parents: []\n    }));\n    /** @type {Map<string, Node>} */\n\n    const compilerToNode = new Map();\n\n    for (const node of nodes) compilerToNode.set(node.compiler.name, node);\n\n    for (const node of nodes) {\n      const dependencies = this.dependencies.get(node.compiler);\n      if (!dependencies) continue;\n\n      for (const dep of dependencies) {\n        const parent = compilerToNode.get(dep);\n        node.parents.push(parent);\n        parent.children.push(node);\n      }\n    }\n    /** @type {ArrayQueue<Node>} */\n\n\n    const queue = new ArrayQueue();\n\n    for (const node of nodes) {\n      if (node.parents.length === 0) {\n        node.state = \"queued\";\n        queue.enqueue(node);\n      }\n    }\n\n    let errored = false;\n    let running = 0;\n    const parallelism = this._options.parallelism;\n    /**\n     * @param {Node} node node\n     * @param {Error=} err error\n     * @param {Stats=} stats result\n     * @returns {void}\n     */\n\n    const nodeDone = (node, err, stats) => {\n      if (errored) return;\n\n      if (err) {\n        errored = true;\n        return asyncLib.each(nodes, (node, callback) => {\n          if (node.compiler.watching) {\n            node.compiler.watching.close(callback);\n          } else {\n            callback();\n          }\n        }, () => callback(err));\n      }\n\n      node.result = stats;\n      running--;\n\n      if (node.state === \"running\") {\n        node.state = \"done\";\n\n        for (const child of node.children) {\n          if (child.state === \"blocked\") queue.enqueue(child);\n        }\n      } else if (node.state === \"running-outdated\") {\n        node.state = \"blocked\";\n        queue.enqueue(node);\n      }\n\n      processQueue();\n    };\n    /**\n     * @param {Node} node node\n     * @returns {void}\n     */\n\n\n    const nodeInvalidFromParent = node => {\n      if (node.state === \"done\") {\n        node.state = \"blocked\";\n      } else if (node.state === \"running\") {\n        node.state = \"running-outdated\";\n      }\n\n      for (const child of node.children) {\n        nodeInvalidFromParent(child);\n      }\n    };\n    /**\n     * @param {Node} node node\n     * @returns {void}\n     */\n\n\n    const nodeInvalid = node => {\n      if (node.state === \"done\") {\n        node.state = \"pending\";\n      } else if (node.state === \"running\") {\n        node.state = \"running-outdated\";\n      }\n\n      for (const child of node.children) {\n        nodeInvalidFromParent(child);\n      }\n    };\n    /**\n     * @param {Node} node node\n     * @returns {void}\n     */\n\n\n    const nodeChange = node => {\n      nodeInvalid(node);\n\n      if (node.state === \"pending\") {\n        node.state = \"blocked\";\n      }\n\n      if (node.state === \"blocked\") {\n        queue.enqueue(node);\n        processQueue();\n      }\n    };\n\n    const setupResults = [];\n    nodes.forEach((node, i) => {\n      setupResults.push(node.setupResult = setup(node.compiler, i, nodeDone.bind(null, node), () => node.state !== \"starting\" && node.state !== \"running\", () => nodeChange(node), () => nodeInvalid(node)));\n    });\n    let processing = true;\n\n    const processQueue = () => {\n      if (processing) return;\n      processing = true;\n      process.nextTick(processQueueWorker);\n    };\n\n    const processQueueWorker = () => {\n      while (running < parallelism && queue.length > 0 && !errored) {\n        const node = queue.dequeue();\n\n        if (node.state === \"queued\" || node.state === \"blocked\" && node.parents.every(p => p.state === \"done\")) {\n          running++;\n          node.state = \"starting\";\n          run(node.compiler, node.setupResult, nodeDone.bind(null, node));\n          node.state = \"running\";\n        }\n      }\n\n      processing = false;\n\n      if (!errored && running === 0 && nodes.every(node => node.state === \"done\")) {\n        const stats = [];\n\n        for (const node of nodes) {\n          const result = node.result;\n\n          if (result) {\n            node.result = undefined;\n            stats.push(result);\n          }\n        }\n\n        if (stats.length > 0) {\n          callback(null, new MultiStats(stats));\n        }\n      }\n    };\n\n    processQueueWorker();\n    return setupResults;\n  }\n  /**\n   * @param {WatchOptions|WatchOptions[]} watchOptions the watcher's options\n   * @param {Callback<MultiStats>} handler signals when the call finishes\n   * @returns {MultiWatching} a compiler watcher\n   */\n\n\n  watch(watchOptions, handler) {\n    if (this.running) {\n      return handler(new ConcurrentCompilationError());\n    }\n\n    this.running = true;\n\n    if (this.validateDependencies(handler)) {\n      const watchings = this._runGraph((compiler, idx, callback, isBlocked, setChanged, setInvalid) => {\n        const watching = compiler.watch(Array.isArray(watchOptions) ? watchOptions[idx] : watchOptions, callback);\n\n        if (watching) {\n          watching._onInvalid = setInvalid;\n          watching._onChange = setChanged;\n          watching._isBlocked = isBlocked;\n        }\n\n        return watching;\n      }, (compiler, watching, callback) => {\n        if (compiler.watching !== watching) return;\n        if (!watching.running) watching.invalidate();\n      }, handler);\n\n      return new MultiWatching(watchings, this);\n    }\n\n    return new MultiWatching([], this);\n  }\n  /**\n   * @param {Callback<MultiStats>} callback signals when the call finishes\n   * @returns {void}\n   */\n\n\n  run(callback) {\n    if (this.running) {\n      return callback(new ConcurrentCompilationError());\n    }\n\n    this.running = true;\n\n    if (this.validateDependencies(callback)) {\n      this._runGraph(() => {}, (compiler, setupResult, callback) => compiler.run(callback), (err, stats) => {\n        this.running = false;\n\n        if (callback !== undefined) {\n          return callback(err, stats);\n        }\n      });\n    }\n  }\n\n  purgeInputFileSystem() {\n    for (const compiler of this.compilers) {\n      if (compiler.inputFileSystem && compiler.inputFileSystem.purge) {\n        compiler.inputFileSystem.purge();\n      }\n    }\n  }\n  /**\n   * @param {Callback<void>} callback signals when the compiler closes\n   * @returns {void}\n   */\n\n\n  close(callback) {\n    asyncLib.each(this.compilers, (compiler, callback) => {\n      compiler.close(callback);\n    }, callback);\n  }\n\n};","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/MultiCompiler.js"],"names":["asyncLib","require","SyncHook","MultiHook","ConcurrentCompilationError","MultiStats","MultiWatching","ArrayQueue","module","exports","MultiCompiler","constructor","compilers","options","Array","isArray","Object","keys","map","name","hooks","freeze","done","invalid","c","run","watchClose","watchRun","infrastructureLog","_options","parallelism","Infinity","dependencies","WeakMap","running","compilerStats","doneCompilers","index","length","compiler","compilerIndex","compilerDone","tap","stats","call","assign","outputPath","commonPath","indexOf","test","replace","inputFileSystem","Error","outputFileSystem","watchFileSystem","intermediateFileSystem","value","getInfrastructureLogger","setDependencies","set","validateDependencies","callback","edges","Set","missing","targetFound","edge","target","sortEdges","e1","e2","source","localeCompare","get","dep","find","push","add","errors","m","stack","filter","current","pop","delete","size","lines","from","sort","unshift","join","message","runWithDependencies","fn","fulfilledNames","remainingCompilers","isDependencyFulfilled","d","has","getReadyCompilers","readyCompilers","list","ready","every","runCompilers","err","_runGraph","setup","nodes","setupResult","undefined","result","state","children","parents","compilerToNode","Map","node","parent","queue","enqueue","errored","nodeDone","each","watching","close","child","processQueue","nodeInvalidFromParent","nodeInvalid","nodeChange","setupResults","forEach","i","bind","processing","process","nextTick","processQueueWorker","dequeue","p","watch","watchOptions","handler","watchings","idx","isBlocked","setChanged","setInvalid","_onInvalid","_onChange","_isBlocked","invalidate","purgeInputFileSystem","purge"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst { SyncHook, MultiHook } = require(\"tapable\");\n\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\nconst MultiStats = require(\"./MultiStats\");\nconst MultiWatching = require(\"./MultiWatching\");\nconst ArrayQueue = require(\"./util/ArrayQueue\");\n\n/** @template T @typedef {import(\"tapable\").AsyncSeriesHook<T>} AsyncSeriesHook<T> */\n/** @template T @template R @typedef {import(\"tapable\").SyncBailHook<T, R>} SyncBailHook<T, R> */\n/** @typedef {import(\"../declarations/WebpackOptions\").WatchOptions} WatchOptions */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Stats\")} Stats */\n/** @typedef {import(\"./Watching\")} Watching */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n/** @typedef {import(\"./util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n/** @typedef {import(\"./util/fs\").WatchFileSystem} WatchFileSystem */\n\n/**\n * @template T\n * @callback Callback\n * @param {(Error | null)=} err\n * @param {T=} result\n */\n\n/**\n * @callback RunWithDependenciesHandler\n * @param {Compiler} compiler\n * @param {Callback<MultiStats>} callback\n */\n\n/**\n * @typedef {Object} MultiCompilerOptions\n * @property {number=} parallelism how many Compilers are allows to run at the same time in parallel\n */\n\nmodule.exports = class MultiCompiler {\n\t/**\n\t * @param {Compiler[] | Record<string, Compiler>} compilers child compilers\n\t * @param {MultiCompilerOptions} options options\n\t */\n\tconstructor(compilers, options) {\n\t\tif (!Array.isArray(compilers)) {\n\t\t\tcompilers = Object.keys(compilers).map(name => {\n\t\t\t\tcompilers[name].name = name;\n\t\t\t\treturn compilers[name];\n\t\t\t});\n\t\t}\n\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {SyncHook<[MultiStats]>} */\n\t\t\tdone: new SyncHook([\"stats\"]),\n\t\t\t/** @type {MultiHook<SyncHook<[string | null, number]>>} */\n\t\t\tinvalid: new MultiHook(compilers.map(c => c.hooks.invalid)),\n\t\t\t/** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n\t\t\trun: new MultiHook(compilers.map(c => c.hooks.run)),\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\twatchClose: new SyncHook([]),\n\t\t\t/** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n\t\t\twatchRun: new MultiHook(compilers.map(c => c.hooks.watchRun)),\n\t\t\t/** @type {MultiHook<SyncBailHook<[string, string, any[]], true>>} */\n\t\t\tinfrastructureLog: new MultiHook(\n\t\t\t\tcompilers.map(c => c.hooks.infrastructureLog)\n\t\t\t)\n\t\t});\n\t\tthis.compilers = compilers;\n\t\t/** @type {MultiCompilerOptions} */\n\t\tthis._options = {\n\t\t\tparallelism: options.parallelism || Infinity\n\t\t};\n\t\t/** @type {WeakMap<Compiler, string[]>} */\n\t\tthis.dependencies = new WeakMap();\n\t\tthis.running = false;\n\n\t\t/** @type {Stats[]} */\n\t\tconst compilerStats = this.compilers.map(() => null);\n\t\tlet doneCompilers = 0;\n\t\tfor (let index = 0; index < this.compilers.length; index++) {\n\t\t\tconst compiler = this.compilers[index];\n\t\t\tconst compilerIndex = index;\n\t\t\tlet compilerDone = false;\n\t\t\tcompiler.hooks.done.tap(\"MultiCompiler\", stats => {\n\t\t\t\tif (!compilerDone) {\n\t\t\t\t\tcompilerDone = true;\n\t\t\t\t\tdoneCompilers++;\n\t\t\t\t}\n\t\t\t\tcompilerStats[compilerIndex] = stats;\n\t\t\t\tif (doneCompilers === this.compilers.length) {\n\t\t\t\t\tthis.hooks.done.call(new MultiStats(compilerStats));\n\t\t\t\t}\n\t\t\t});\n\t\t\tcompiler.hooks.invalid.tap(\"MultiCompiler\", () => {\n\t\t\t\tif (compilerDone) {\n\t\t\t\t\tcompilerDone = false;\n\t\t\t\t\tdoneCompilers--;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tget options() {\n\t\treturn Object.assign(\n\t\t\tthis.compilers.map(c => c.options),\n\t\t\tthis._options\n\t\t);\n\t}\n\n\tget outputPath() {\n\t\tlet commonPath = this.compilers[0].outputPath;\n\t\tfor (const compiler of this.compilers) {\n\t\t\twhile (\n\t\t\t\tcompiler.outputPath.indexOf(commonPath) !== 0 &&\n\t\t\t\t/[/\\\\]/.test(commonPath)\n\t\t\t) {\n\t\t\t\tcommonPath = commonPath.replace(/[/\\\\][^/\\\\]*$/, \"\");\n\t\t\t}\n\t\t}\n\n\t\tif (!commonPath && this.compilers[0].outputPath[0] === \"/\") return \"/\";\n\t\treturn commonPath;\n\t}\n\n\tget inputFileSystem() {\n\t\tthrow new Error(\"Cannot read inputFileSystem of a MultiCompiler\");\n\t}\n\n\tget outputFileSystem() {\n\t\tthrow new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n\t}\n\n\tget watchFileSystem() {\n\t\tthrow new Error(\"Cannot read watchFileSystem of a MultiCompiler\");\n\t}\n\n\tget intermediateFileSystem() {\n\t\tthrow new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n\t}\n\n\t/**\n\t * @param {InputFileSystem} value the new input file system\n\t */\n\tset inputFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.inputFileSystem = value;\n\t\t}\n\t}\n\n\t/**\n\t * @param {OutputFileSystem} value the new output file system\n\t */\n\tset outputFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.outputFileSystem = value;\n\t\t}\n\t}\n\n\t/**\n\t * @param {WatchFileSystem} value the new watch file system\n\t */\n\tset watchFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.watchFileSystem = value;\n\t\t}\n\t}\n\n\t/**\n\t * @param {IntermediateFileSystem} value the new intermediate file system\n\t */\n\tset intermediateFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.intermediateFileSystem = value;\n\t\t}\n\t}\n\n\tgetInfrastructureLogger(name) {\n\t\treturn this.compilers[0].getInfrastructureLogger(name);\n\t}\n\n\t/**\n\t * @param {Compiler} compiler the child compiler\n\t * @param {string[]} dependencies its dependencies\n\t * @returns {void}\n\t */\n\tsetDependencies(compiler, dependencies) {\n\t\tthis.dependencies.set(compiler, dependencies);\n\t}\n\n\t/**\n\t * @param {Callback<MultiStats>} callback signals when the validation is complete\n\t * @returns {boolean} true if the dependencies are valid\n\t */\n\tvalidateDependencies(callback) {\n\t\t/** @type {Set<{source: Compiler, target: Compiler}>} */\n\t\tconst edges = new Set();\n\t\t/** @type {string[]} */\n\t\tconst missing = [];\n\t\tconst targetFound = compiler => {\n\t\t\tfor (const edge of edges) {\n\t\t\t\tif (edge.target === compiler) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tconst sortEdges = (e1, e2) => {\n\t\t\treturn (\n\t\t\t\te1.source.name.localeCompare(e2.source.name) ||\n\t\t\t\te1.target.name.localeCompare(e2.target.name)\n\t\t\t);\n\t\t};\n\t\tfor (const source of this.compilers) {\n\t\t\tconst dependencies = this.dependencies.get(source);\n\t\t\tif (dependencies) {\n\t\t\t\tfor (const dep of dependencies) {\n\t\t\t\t\tconst target = this.compilers.find(c => c.name === dep);\n\t\t\t\t\tif (!target) {\n\t\t\t\t\t\tmissing.push(dep);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tedges.add({\n\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\ttarget\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/** @type {string[]} */\n\t\tconst errors = missing.map(m => `Compiler dependency \\`${m}\\` not found.`);\n\t\tconst stack = this.compilers.filter(c => !targetFound(c));\n\t\twhile (stack.length > 0) {\n\t\t\tconst current = stack.pop();\n\t\t\tfor (const edge of edges) {\n\t\t\t\tif (edge.source === current) {\n\t\t\t\t\tedges.delete(edge);\n\t\t\t\t\tconst target = edge.target;\n\t\t\t\t\tif (!targetFound(target)) {\n\t\t\t\t\t\tstack.push(target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (edges.size > 0) {\n\t\t\t/** @type {string[]} */\n\t\t\tconst lines = Array.from(edges)\n\t\t\t\t.sort(sortEdges)\n\t\t\t\t.map(edge => `${edge.source.name} -> ${edge.target.name}`);\n\t\t\tlines.unshift(\"Circular dependency found in compiler dependencies.\");\n\t\t\terrors.unshift(lines.join(\"\\n\"));\n\t\t}\n\t\tif (errors.length > 0) {\n\t\t\tconst message = errors.join(\"\\n\");\n\t\t\tcallback(new Error(message));\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t// TODO webpack 6 remove\n\t/**\n\t * @deprecated This method should have been private\n\t * @param {Compiler[]} compilers the child compilers\n\t * @param {RunWithDependenciesHandler} fn a handler to run for each compiler\n\t * @param {Callback<MultiStats>} callback the compiler's handler\n\t * @returns {void}\n\t */\n\trunWithDependencies(compilers, fn, callback) {\n\t\tconst fulfilledNames = new Set();\n\t\tlet remainingCompilers = compilers;\n\t\tconst isDependencyFulfilled = d => fulfilledNames.has(d);\n\t\tconst getReadyCompilers = () => {\n\t\t\tlet readyCompilers = [];\n\t\t\tlet list = remainingCompilers;\n\t\t\tremainingCompilers = [];\n\t\t\tfor (const c of list) {\n\t\t\t\tconst dependencies = this.dependencies.get(c);\n\t\t\t\tconst ready =\n\t\t\t\t\t!dependencies || dependencies.every(isDependencyFulfilled);\n\t\t\t\tif (ready) {\n\t\t\t\t\treadyCompilers.push(c);\n\t\t\t\t} else {\n\t\t\t\t\tremainingCompilers.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn readyCompilers;\n\t\t};\n\t\tconst runCompilers = callback => {\n\t\t\tif (remainingCompilers.length === 0) return callback();\n\t\t\tasyncLib.map(\n\t\t\t\tgetReadyCompilers(),\n\t\t\t\t(compiler, callback) => {\n\t\t\t\t\tfn(compiler, err => {\n\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\tfulfilledNames.add(compiler.name);\n\t\t\t\t\t\trunCompilers(callback);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tcallback\n\t\t\t);\n\t\t};\n\t\trunCompilers(callback);\n\t}\n\n\t/**\n\t * @template SetupResult\n\t * @param {function(Compiler, number, Callback<Stats>, function(): boolean, function(): void, function(): void): SetupResult} setup setup a single compiler\n\t * @param {function(Compiler, SetupResult, Callback<Stats>): void} run run/continue a single compiler\n\t * @param {Callback<MultiStats>} callback callback when all compilers are done, result includes Stats of all changed compilers\n\t * @returns {SetupResult[]} result of setup\n\t */\n\t_runGraph(setup, run, callback) {\n\t\t/** @typedef {{ compiler: Compiler, setupResult: SetupResult, result: Stats, state: \"pending\" | \"blocked\" | \"queued\" | \"starting\" | \"running\" | \"running-outdated\" | \"done\", children: Node[], parents: Node[] }} Node */\n\n\t\t// State transitions for nodes:\n\t\t// -> blocked (initial)\n\t\t// blocked -> starting [running++] (when all parents done)\n\t\t// queued -> starting [running++] (when processing the queue)\n\t\t// starting -> running (when run has been called)\n\t\t// running -> done [running--] (when compilation is done)\n\t\t// done -> pending (when invalidated from file change)\n\t\t// pending -> blocked [add to queue] (when invalidated from aggregated changes)\n\t\t// done -> blocked [add to queue] (when invalidated, from parent invalidation)\n\t\t// running -> running-outdated (when invalidated, either from change or parent invalidation)\n\t\t// running-outdated -> blocked [running--] (when compilation is done)\n\n\t\t/** @type {Node[]} */\n\t\tconst nodes = this.compilers.map(compiler => ({\n\t\t\tcompiler,\n\t\t\tsetupResult: undefined,\n\t\t\tresult: undefined,\n\t\t\tstate: \"blocked\",\n\t\t\tchildren: [],\n\t\t\tparents: []\n\t\t}));\n\t\t/** @type {Map<string, Node>} */\n\t\tconst compilerToNode = new Map();\n\t\tfor (const node of nodes) compilerToNode.set(node.compiler.name, node);\n\t\tfor (const node of nodes) {\n\t\t\tconst dependencies = this.dependencies.get(node.compiler);\n\t\t\tif (!dependencies) continue;\n\t\t\tfor (const dep of dependencies) {\n\t\t\t\tconst parent = compilerToNode.get(dep);\n\t\t\t\tnode.parents.push(parent);\n\t\t\t\tparent.children.push(node);\n\t\t\t}\n\t\t}\n\t\t/** @type {ArrayQueue<Node>} */\n\t\tconst queue = new ArrayQueue();\n\t\tfor (const node of nodes) {\n\t\t\tif (node.parents.length === 0) {\n\t\t\t\tnode.state = \"queued\";\n\t\t\t\tqueue.enqueue(node);\n\t\t\t}\n\t\t}\n\t\tlet errored = false;\n\t\tlet running = 0;\n\t\tconst parallelism = this._options.parallelism;\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @param {Error=} err error\n\t\t * @param {Stats=} stats result\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeDone = (node, err, stats) => {\n\t\t\tif (errored) return;\n\t\t\tif (err) {\n\t\t\t\terrored = true;\n\t\t\t\treturn asyncLib.each(\n\t\t\t\t\tnodes,\n\t\t\t\t\t(node, callback) => {\n\t\t\t\t\t\tif (node.compiler.watching) {\n\t\t\t\t\t\t\tnode.compiler.watching.close(callback);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t() => callback(err)\n\t\t\t\t);\n\t\t\t}\n\t\t\tnode.result = stats;\n\t\t\trunning--;\n\t\t\tif (node.state === \"running\") {\n\t\t\t\tnode.state = \"done\";\n\t\t\t\tfor (const child of node.children) {\n\t\t\t\t\tif (child.state === \"blocked\") queue.enqueue(child);\n\t\t\t\t}\n\t\t\t} else if (node.state === \"running-outdated\") {\n\t\t\t\tnode.state = \"blocked\";\n\t\t\t\tqueue.enqueue(node);\n\t\t\t}\n\t\t\tprocessQueue();\n\t\t};\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeInvalidFromParent = node => {\n\t\t\tif (node.state === \"done\") {\n\t\t\t\tnode.state = \"blocked\";\n\t\t\t} else if (node.state === \"running\") {\n\t\t\t\tnode.state = \"running-outdated\";\n\t\t\t}\n\t\t\tfor (const child of node.children) {\n\t\t\t\tnodeInvalidFromParent(child);\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeInvalid = node => {\n\t\t\tif (node.state === \"done\") {\n\t\t\t\tnode.state = \"pending\";\n\t\t\t} else if (node.state === \"running\") {\n\t\t\t\tnode.state = \"running-outdated\";\n\t\t\t}\n\t\t\tfor (const child of node.children) {\n\t\t\t\tnodeInvalidFromParent(child);\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeChange = node => {\n\t\t\tnodeInvalid(node);\n\t\t\tif (node.state === \"pending\") {\n\t\t\t\tnode.state = \"blocked\";\n\t\t\t}\n\t\t\tif (node.state === \"blocked\") {\n\t\t\t\tqueue.enqueue(node);\n\t\t\t\tprocessQueue();\n\t\t\t}\n\t\t};\n\n\t\tconst setupResults = [];\n\t\tnodes.forEach((node, i) => {\n\t\t\tsetupResults.push(\n\t\t\t\t(node.setupResult = setup(\n\t\t\t\t\tnode.compiler,\n\t\t\t\t\ti,\n\t\t\t\t\tnodeDone.bind(null, node),\n\t\t\t\t\t() => node.state !== \"starting\" && node.state !== \"running\",\n\t\t\t\t\t() => nodeChange(node),\n\t\t\t\t\t() => nodeInvalid(node)\n\t\t\t\t))\n\t\t\t);\n\t\t});\n\t\tlet processing = true;\n\t\tconst processQueue = () => {\n\t\t\tif (processing) return;\n\t\t\tprocessing = true;\n\t\t\tprocess.nextTick(processQueueWorker);\n\t\t};\n\t\tconst processQueueWorker = () => {\n\t\t\twhile (running < parallelism && queue.length > 0 && !errored) {\n\t\t\t\tconst node = queue.dequeue();\n\t\t\t\tif (\n\t\t\t\t\tnode.state === \"queued\" ||\n\t\t\t\t\t(node.state === \"blocked\" &&\n\t\t\t\t\t\tnode.parents.every(p => p.state === \"done\"))\n\t\t\t\t) {\n\t\t\t\t\trunning++;\n\t\t\t\t\tnode.state = \"starting\";\n\t\t\t\t\trun(node.compiler, node.setupResult, nodeDone.bind(null, node));\n\t\t\t\t\tnode.state = \"running\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tprocessing = false;\n\t\t\tif (\n\t\t\t\t!errored &&\n\t\t\t\trunning === 0 &&\n\t\t\t\tnodes.every(node => node.state === \"done\")\n\t\t\t) {\n\t\t\t\tconst stats = [];\n\t\t\t\tfor (const node of nodes) {\n\t\t\t\t\tconst result = node.result;\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tnode.result = undefined;\n\t\t\t\t\t\tstats.push(result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (stats.length > 0) {\n\t\t\t\t\tcallback(null, new MultiStats(stats));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tprocessQueueWorker();\n\t\treturn setupResults;\n\t}\n\n\t/**\n\t * @param {WatchOptions|WatchOptions[]} watchOptions the watcher's options\n\t * @param {Callback<MultiStats>} handler signals when the call finishes\n\t * @returns {MultiWatching} a compiler watcher\n\t */\n\twatch(watchOptions, handler) {\n\t\tif (this.running) {\n\t\t\treturn handler(new ConcurrentCompilationError());\n\t\t}\n\t\tthis.running = true;\n\n\t\tif (this.validateDependencies(handler)) {\n\t\t\tconst watchings = this._runGraph(\n\t\t\t\t(compiler, idx, callback, isBlocked, setChanged, setInvalid) => {\n\t\t\t\t\tconst watching = compiler.watch(\n\t\t\t\t\t\tArray.isArray(watchOptions) ? watchOptions[idx] : watchOptions,\n\t\t\t\t\t\tcallback\n\t\t\t\t\t);\n\t\t\t\t\tif (watching) {\n\t\t\t\t\t\twatching._onInvalid = setInvalid;\n\t\t\t\t\t\twatching._onChange = setChanged;\n\t\t\t\t\t\twatching._isBlocked = isBlocked;\n\t\t\t\t\t}\n\t\t\t\t\treturn watching;\n\t\t\t\t},\n\t\t\t\t(compiler, watching, callback) => {\n\t\t\t\t\tif (compiler.watching !== watching) return;\n\t\t\t\t\tif (!watching.running) watching.invalidate();\n\t\t\t\t},\n\t\t\t\thandler\n\t\t\t);\n\t\t\treturn new MultiWatching(watchings, this);\n\t\t}\n\n\t\treturn new MultiWatching([], this);\n\t}\n\n\t/**\n\t * @param {Callback<MultiStats>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\trun(callback) {\n\t\tif (this.running) {\n\t\t\treturn callback(new ConcurrentCompilationError());\n\t\t}\n\t\tthis.running = true;\n\n\t\tif (this.validateDependencies(callback)) {\n\t\t\tthis._runGraph(\n\t\t\t\t() => {},\n\t\t\t\t(compiler, setupResult, callback) => compiler.run(callback),\n\t\t\t\t(err, stats) => {\n\t\t\t\t\tthis.running = false;\n\n\t\t\t\t\tif (callback !== undefined) {\n\t\t\t\t\t\treturn callback(err, stats);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n\n\tpurgeInputFileSystem() {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tif (compiler.inputFileSystem && compiler.inputFileSystem.purge) {\n\t\t\t\tcompiler.inputFileSystem.purge();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the compiler closes\n\t * @returns {void}\n\t */\n\tclose(callback) {\n\t\tasyncLib.each(\n\t\t\tthis.compilers,\n\t\t\t(compiler, callback) => {\n\t\t\t\tcompiler.close(callback);\n\t\t\t},\n\t\t\tcallback\n\t\t);\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}