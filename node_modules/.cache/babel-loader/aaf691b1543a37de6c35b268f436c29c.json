{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst {\n  EventEmitter\n} = require(\"events\");\n\nconst reducePlan = require(\"./reducePlan\");\n\nconst IS_OSX = require(\"os\").platform() === \"darwin\";\nconst IS_WIN = require(\"os\").platform() === \"win32\";\nconst SUPPORTS_RECURSIVE_WATCHING = IS_OSX || IS_WIN;\nconst watcherLimit = +process.env.WATCHPACK_WATCHER_LIMIT || (IS_OSX ? 2000 : 10000);\nconst recursiveWatcherLogging = !!process.env.WATCHPACK_RECURSIVE_WATCHER_LOGGING;\nlet isBatch = false;\nlet watcherCount = 0;\n/** @type {Map<Watcher, string>} */\n\nconst pendingWatchers = new Map();\n/** @type {Map<string, RecursiveWatcher>} */\n\nconst recursiveWatchers = new Map();\n/** @type {Map<string, DirectWatcher>} */\n\nconst directWatchers = new Map();\n/** @type {Map<Watcher, RecursiveWatcher | DirectWatcher>} */\n\nconst underlyingWatcher = new Map();\n\nclass DirectWatcher {\n  constructor(filePath) {\n    this.filePath = filePath;\n    this.watchers = new Set();\n    this.watcher = undefined;\n\n    try {\n      const watcher = fs.watch(filePath);\n      this.watcher = watcher;\n      watcher.on(\"change\", (type, filename) => {\n        for (const w of this.watchers) {\n          w.emit(\"change\", type, filename);\n        }\n      });\n      watcher.on(\"error\", error => {\n        for (const w of this.watchers) {\n          w.emit(\"error\", error);\n        }\n      });\n    } catch (err) {\n      process.nextTick(() => {\n        for (const w of this.watchers) {\n          w.emit(\"error\", err);\n        }\n      });\n    }\n\n    watcherCount++;\n  }\n\n  add(watcher) {\n    underlyingWatcher.set(watcher, this);\n    this.watchers.add(watcher);\n  }\n\n  remove(watcher) {\n    this.watchers.delete(watcher);\n\n    if (this.watchers.size === 0) {\n      directWatchers.delete(this.filePath);\n      watcherCount--;\n      if (this.watcher) this.watcher.close();\n    }\n  }\n\n  getWatchers() {\n    return this.watchers;\n  }\n\n}\n\nclass RecursiveWatcher {\n  constructor(rootPath) {\n    this.rootPath = rootPath;\n    /** @type {Map<Watcher, string>} */\n\n    this.mapWatcherToPath = new Map();\n    /** @type {Map<string, Set<Watcher>>} */\n\n    this.mapPathToWatchers = new Map();\n    this.watcher = undefined;\n\n    try {\n      const watcher = fs.watch(rootPath, {\n        recursive: true\n      });\n      this.watcher = watcher;\n      watcher.on(\"change\", (type, filename) => {\n        if (!filename) {\n          if (recursiveWatcherLogging) {\n            process.stderr.write(`[watchpack] dispatch ${type} event in recursive watcher (${this.rootPath}) to all watchers\\n`);\n          }\n\n          for (const w of this.mapWatcherToPath.keys()) {\n            w.emit(\"change\", type);\n          }\n        } else {\n          const dir = path.dirname(filename);\n          const watchers = this.mapPathToWatchers.get(dir);\n\n          if (recursiveWatcherLogging) {\n            process.stderr.write(`[watchpack] dispatch ${type} event in recursive watcher (${this.rootPath}) for '${filename}' to ${watchers ? watchers.size : 0} watchers\\n`);\n          }\n\n          if (watchers === undefined) return;\n\n          for (const w of watchers) {\n            w.emit(\"change\", type, path.basename(filename));\n          }\n        }\n      });\n      watcher.on(\"error\", error => {\n        for (const w of this.mapWatcherToPath.keys()) {\n          w.emit(\"error\", error);\n        }\n      });\n    } catch (err) {\n      process.nextTick(() => {\n        for (const w of this.mapWatcherToPath.keys()) {\n          w.emit(\"error\", err);\n        }\n      });\n    }\n\n    watcherCount++;\n\n    if (recursiveWatcherLogging) {\n      process.stderr.write(`[watchpack] created recursive watcher at ${rootPath}\\n`);\n    }\n  }\n\n  add(filePath, watcher) {\n    underlyingWatcher.set(watcher, this);\n    const subpath = filePath.slice(this.rootPath.length + 1) || \".\";\n    this.mapWatcherToPath.set(watcher, subpath);\n    const set = this.mapPathToWatchers.get(subpath);\n\n    if (set === undefined) {\n      const newSet = new Set();\n      newSet.add(watcher);\n      this.mapPathToWatchers.set(subpath, newSet);\n    } else {\n      set.add(watcher);\n    }\n  }\n\n  remove(watcher) {\n    const subpath = this.mapWatcherToPath.get(watcher);\n    if (!subpath) return;\n    this.mapWatcherToPath.delete(watcher);\n    const set = this.mapPathToWatchers.get(subpath);\n    set.delete(watcher);\n\n    if (set.size === 0) {\n      this.mapPathToWatchers.delete(subpath);\n    }\n\n    if (this.mapWatcherToPath.size === 0) {\n      recursiveWatchers.delete(this.rootPath);\n      watcherCount--;\n      if (this.watcher) this.watcher.close();\n\n      if (recursiveWatcherLogging) {\n        process.stderr.write(`[watchpack] closed recursive watcher at ${this.rootPath}\\n`);\n      }\n    }\n  }\n\n  getWatchers() {\n    return this.mapWatcherToPath;\n  }\n\n}\n\nclass Watcher extends EventEmitter {\n  close() {\n    if (pendingWatchers.has(this)) {\n      pendingWatchers.delete(this);\n      return;\n    }\n\n    const watcher = underlyingWatcher.get(this);\n    watcher.remove(this);\n    underlyingWatcher.delete(this);\n  }\n\n}\n\nconst createDirectWatcher = filePath => {\n  const existing = directWatchers.get(filePath);\n  if (existing !== undefined) return existing;\n  const w = new DirectWatcher(filePath);\n  directWatchers.set(filePath, w);\n  return w;\n};\n\nconst createRecursiveWatcher = rootPath => {\n  const existing = recursiveWatchers.get(rootPath);\n  if (existing !== undefined) return existing;\n  const w = new RecursiveWatcher(rootPath);\n  recursiveWatchers.set(rootPath, w);\n  return w;\n};\n\nconst execute = () => {\n  /** @type {Map<string, Watcher[] | Watcher>} */\n  const map = new Map();\n\n  const addWatcher = (watcher, filePath) => {\n    const entry = map.get(filePath);\n\n    if (entry === undefined) {\n      map.set(filePath, watcher);\n    } else if (Array.isArray(entry)) {\n      entry.push(watcher);\n    } else {\n      map.set(filePath, [entry, watcher]);\n    }\n  };\n\n  for (const [watcher, filePath] of pendingWatchers) {\n    addWatcher(watcher, filePath);\n  }\n\n  pendingWatchers.clear(); // Fast case when we are not reaching the limit\n\n  if (!SUPPORTS_RECURSIVE_WATCHING || watcherLimit - watcherCount >= map.size) {\n    // Create watchers for all entries in the map\n    for (const [filePath, entry] of map) {\n      const w = createDirectWatcher(filePath);\n\n      if (Array.isArray(entry)) {\n        for (const item of entry) w.add(item);\n      } else {\n        w.add(entry);\n      }\n    }\n\n    return;\n  } // Reconsider existing watchers to improving watch plan\n\n\n  for (const watcher of recursiveWatchers.values()) {\n    for (const [w, subpath] of watcher.getWatchers()) {\n      addWatcher(w, path.join(watcher.rootPath, subpath));\n    }\n  }\n\n  for (const watcher of directWatchers.values()) {\n    for (const w of watcher.getWatchers()) {\n      addWatcher(w, watcher.filePath);\n    }\n  } // Merge map entries to keep watcher limit\n  // Create a 10% buffer to be able to enter fast case more often\n\n\n  const plan = reducePlan(map, watcherLimit * 0.9); // Update watchers for all entries in the map\n\n  for (const [filePath, entry] of plan) {\n    if (entry.size === 1) {\n      for (const [watcher, filePath] of entry) {\n        const w = createDirectWatcher(filePath);\n        const old = underlyingWatcher.get(watcher);\n        if (old === w) continue;\n        w.add(watcher);\n        if (old !== undefined) old.remove(watcher);\n      }\n    } else {\n      const filePaths = new Set(entry.values());\n\n      if (filePaths.size > 1) {\n        const w = createRecursiveWatcher(filePath);\n\n        for (const [watcher, watcherPath] of entry) {\n          const old = underlyingWatcher.get(watcher);\n          if (old === w) continue;\n          w.add(watcherPath, watcher);\n          if (old !== undefined) old.remove(watcher);\n        }\n      } else {\n        for (const filePath of filePaths) {\n          const w = createDirectWatcher(filePath);\n\n          for (const watcher of entry.keys()) {\n            const old = underlyingWatcher.get(watcher);\n            if (old === w) continue;\n            w.add(watcher);\n            if (old !== undefined) old.remove(watcher);\n          }\n        }\n      }\n    }\n  }\n};\n\nexports.watch = filePath => {\n  const watcher = new Watcher(); // Find an existing watcher\n\n  const directWatcher = directWatchers.get(filePath);\n\n  if (directWatcher !== undefined) {\n    directWatcher.add(watcher);\n    return watcher;\n  }\n\n  let current = filePath;\n\n  for (;;) {\n    const recursiveWatcher = recursiveWatchers.get(current);\n\n    if (recursiveWatcher !== undefined) {\n      recursiveWatcher.add(filePath, watcher);\n      return watcher;\n    }\n\n    const parent = path.dirname(current);\n    if (parent === current) break;\n    current = parent;\n  } // Queue up watcher for creation\n\n\n  pendingWatchers.set(watcher, filePath);\n  if (!isBatch) execute();\n  return watcher;\n};\n\nexports.batch = fn => {\n  isBatch = true;\n\n  try {\n    fn();\n  } finally {\n    isBatch = false;\n    execute();\n  }\n};\n\nexports.getNumberOfWatchers = () => {\n  return watcherCount;\n};","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/watchpack/lib/watchEventSource.js"],"names":["fs","require","path","EventEmitter","reducePlan","IS_OSX","platform","IS_WIN","SUPPORTS_RECURSIVE_WATCHING","watcherLimit","process","env","WATCHPACK_WATCHER_LIMIT","recursiveWatcherLogging","WATCHPACK_RECURSIVE_WATCHER_LOGGING","isBatch","watcherCount","pendingWatchers","Map","recursiveWatchers","directWatchers","underlyingWatcher","DirectWatcher","constructor","filePath","watchers","Set","watcher","undefined","watch","on","type","filename","w","emit","error","err","nextTick","add","set","remove","delete","size","close","getWatchers","RecursiveWatcher","rootPath","mapWatcherToPath","mapPathToWatchers","recursive","stderr","write","keys","dir","dirname","get","basename","subpath","slice","length","newSet","Watcher","has","createDirectWatcher","existing","createRecursiveWatcher","execute","map","addWatcher","entry","Array","isArray","push","clear","item","values","join","plan","old","filePaths","watcherPath","exports","directWatcher","current","recursiveWatcher","parent","batch","fn","getNumberOfWatchers"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst { EventEmitter } = require(\"events\");\nconst reducePlan = require(\"./reducePlan\");\n\nconst IS_OSX = require(\"os\").platform() === \"darwin\";\nconst IS_WIN = require(\"os\").platform() === \"win32\";\nconst SUPPORTS_RECURSIVE_WATCHING = IS_OSX || IS_WIN;\n\nconst watcherLimit =\n\t+process.env.WATCHPACK_WATCHER_LIMIT || (IS_OSX ? 2000 : 10000);\n\nconst recursiveWatcherLogging = !!process.env\n\t.WATCHPACK_RECURSIVE_WATCHER_LOGGING;\n\nlet isBatch = false;\nlet watcherCount = 0;\n\n/** @type {Map<Watcher, string>} */\nconst pendingWatchers = new Map();\n\n/** @type {Map<string, RecursiveWatcher>} */\nconst recursiveWatchers = new Map();\n\n/** @type {Map<string, DirectWatcher>} */\nconst directWatchers = new Map();\n\n/** @type {Map<Watcher, RecursiveWatcher | DirectWatcher>} */\nconst underlyingWatcher = new Map();\n\nclass DirectWatcher {\n\tconstructor(filePath) {\n\t\tthis.filePath = filePath;\n\t\tthis.watchers = new Set();\n\t\tthis.watcher = undefined;\n\t\ttry {\n\t\t\tconst watcher = fs.watch(filePath);\n\t\t\tthis.watcher = watcher;\n\t\t\twatcher.on(\"change\", (type, filename) => {\n\t\t\t\tfor (const w of this.watchers) {\n\t\t\t\t\tw.emit(\"change\", type, filename);\n\t\t\t\t}\n\t\t\t});\n\t\t\twatcher.on(\"error\", error => {\n\t\t\t\tfor (const w of this.watchers) {\n\t\t\t\t\tw.emit(\"error\", error);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(() => {\n\t\t\t\tfor (const w of this.watchers) {\n\t\t\t\t\tw.emit(\"error\", err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\twatcherCount++;\n\t}\n\n\tadd(watcher) {\n\t\tunderlyingWatcher.set(watcher, this);\n\t\tthis.watchers.add(watcher);\n\t}\n\n\tremove(watcher) {\n\t\tthis.watchers.delete(watcher);\n\t\tif (this.watchers.size === 0) {\n\t\t\tdirectWatchers.delete(this.filePath);\n\t\t\twatcherCount--;\n\t\t\tif (this.watcher) this.watcher.close();\n\t\t}\n\t}\n\n\tgetWatchers() {\n\t\treturn this.watchers;\n\t}\n}\n\nclass RecursiveWatcher {\n\tconstructor(rootPath) {\n\t\tthis.rootPath = rootPath;\n\t\t/** @type {Map<Watcher, string>} */\n\t\tthis.mapWatcherToPath = new Map();\n\t\t/** @type {Map<string, Set<Watcher>>} */\n\t\tthis.mapPathToWatchers = new Map();\n\t\tthis.watcher = undefined;\n\t\ttry {\n\t\t\tconst watcher = fs.watch(rootPath, {\n\t\t\t\trecursive: true\n\t\t\t});\n\t\t\tthis.watcher = watcher;\n\t\t\twatcher.on(\"change\", (type, filename) => {\n\t\t\t\tif (!filename) {\n\t\t\t\t\tif (recursiveWatcherLogging) {\n\t\t\t\t\t\tprocess.stderr.write(\n\t\t\t\t\t\t\t`[watchpack] dispatch ${type} event in recursive watcher (${\n\t\t\t\t\t\t\t\tthis.rootPath\n\t\t\t\t\t\t\t}) to all watchers\\n`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const w of this.mapWatcherToPath.keys()) {\n\t\t\t\t\t\tw.emit(\"change\", type);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst dir = path.dirname(filename);\n\t\t\t\t\tconst watchers = this.mapPathToWatchers.get(dir);\n\t\t\t\t\tif (recursiveWatcherLogging) {\n\t\t\t\t\t\tprocess.stderr.write(\n\t\t\t\t\t\t\t`[watchpack] dispatch ${type} event in recursive watcher (${\n\t\t\t\t\t\t\t\tthis.rootPath\n\t\t\t\t\t\t\t}) for '${filename}' to ${\n\t\t\t\t\t\t\t\twatchers ? watchers.size : 0\n\t\t\t\t\t\t\t} watchers\\n`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (watchers === undefined) return;\n\t\t\t\t\tfor (const w of watchers) {\n\t\t\t\t\t\tw.emit(\"change\", type, path.basename(filename));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\twatcher.on(\"error\", error => {\n\t\t\t\tfor (const w of this.mapWatcherToPath.keys()) {\n\t\t\t\t\tw.emit(\"error\", error);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(() => {\n\t\t\t\tfor (const w of this.mapWatcherToPath.keys()) {\n\t\t\t\t\tw.emit(\"error\", err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\twatcherCount++;\n\t\tif (recursiveWatcherLogging) {\n\t\t\tprocess.stderr.write(\n\t\t\t\t`[watchpack] created recursive watcher at ${rootPath}\\n`\n\t\t\t);\n\t\t}\n\t}\n\n\tadd(filePath, watcher) {\n\t\tunderlyingWatcher.set(watcher, this);\n\t\tconst subpath = filePath.slice(this.rootPath.length + 1) || \".\";\n\t\tthis.mapWatcherToPath.set(watcher, subpath);\n\t\tconst set = this.mapPathToWatchers.get(subpath);\n\t\tif (set === undefined) {\n\t\t\tconst newSet = new Set();\n\t\t\tnewSet.add(watcher);\n\t\t\tthis.mapPathToWatchers.set(subpath, newSet);\n\t\t} else {\n\t\t\tset.add(watcher);\n\t\t}\n\t}\n\n\tremove(watcher) {\n\t\tconst subpath = this.mapWatcherToPath.get(watcher);\n\t\tif (!subpath) return;\n\t\tthis.mapWatcherToPath.delete(watcher);\n\t\tconst set = this.mapPathToWatchers.get(subpath);\n\t\tset.delete(watcher);\n\t\tif (set.size === 0) {\n\t\t\tthis.mapPathToWatchers.delete(subpath);\n\t\t}\n\t\tif (this.mapWatcherToPath.size === 0) {\n\t\t\trecursiveWatchers.delete(this.rootPath);\n\t\t\twatcherCount--;\n\t\t\tif (this.watcher) this.watcher.close();\n\t\t\tif (recursiveWatcherLogging) {\n\t\t\t\tprocess.stderr.write(\n\t\t\t\t\t`[watchpack] closed recursive watcher at ${this.rootPath}\\n`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tgetWatchers() {\n\t\treturn this.mapWatcherToPath;\n\t}\n}\n\nclass Watcher extends EventEmitter {\n\tclose() {\n\t\tif (pendingWatchers.has(this)) {\n\t\t\tpendingWatchers.delete(this);\n\t\t\treturn;\n\t\t}\n\t\tconst watcher = underlyingWatcher.get(this);\n\t\twatcher.remove(this);\n\t\tunderlyingWatcher.delete(this);\n\t}\n}\n\nconst createDirectWatcher = filePath => {\n\tconst existing = directWatchers.get(filePath);\n\tif (existing !== undefined) return existing;\n\tconst w = new DirectWatcher(filePath);\n\tdirectWatchers.set(filePath, w);\n\treturn w;\n};\n\nconst createRecursiveWatcher = rootPath => {\n\tconst existing = recursiveWatchers.get(rootPath);\n\tif (existing !== undefined) return existing;\n\tconst w = new RecursiveWatcher(rootPath);\n\trecursiveWatchers.set(rootPath, w);\n\treturn w;\n};\n\nconst execute = () => {\n\t/** @type {Map<string, Watcher[] | Watcher>} */\n\tconst map = new Map();\n\tconst addWatcher = (watcher, filePath) => {\n\t\tconst entry = map.get(filePath);\n\t\tif (entry === undefined) {\n\t\t\tmap.set(filePath, watcher);\n\t\t} else if (Array.isArray(entry)) {\n\t\t\tentry.push(watcher);\n\t\t} else {\n\t\t\tmap.set(filePath, [entry, watcher]);\n\t\t}\n\t};\n\tfor (const [watcher, filePath] of pendingWatchers) {\n\t\taddWatcher(watcher, filePath);\n\t}\n\tpendingWatchers.clear();\n\n\t// Fast case when we are not reaching the limit\n\tif (!SUPPORTS_RECURSIVE_WATCHING || watcherLimit - watcherCount >= map.size) {\n\t\t// Create watchers for all entries in the map\n\t\tfor (const [filePath, entry] of map) {\n\t\t\tconst w = createDirectWatcher(filePath);\n\t\t\tif (Array.isArray(entry)) {\n\t\t\t\tfor (const item of entry) w.add(item);\n\t\t\t} else {\n\t\t\t\tw.add(entry);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t// Reconsider existing watchers to improving watch plan\n\tfor (const watcher of recursiveWatchers.values()) {\n\t\tfor (const [w, subpath] of watcher.getWatchers()) {\n\t\t\taddWatcher(w, path.join(watcher.rootPath, subpath));\n\t\t}\n\t}\n\tfor (const watcher of directWatchers.values()) {\n\t\tfor (const w of watcher.getWatchers()) {\n\t\t\taddWatcher(w, watcher.filePath);\n\t\t}\n\t}\n\n\t// Merge map entries to keep watcher limit\n\t// Create a 10% buffer to be able to enter fast case more often\n\tconst plan = reducePlan(map, watcherLimit * 0.9);\n\n\t// Update watchers for all entries in the map\n\tfor (const [filePath, entry] of plan) {\n\t\tif (entry.size === 1) {\n\t\t\tfor (const [watcher, filePath] of entry) {\n\t\t\t\tconst w = createDirectWatcher(filePath);\n\t\t\t\tconst old = underlyingWatcher.get(watcher);\n\t\t\t\tif (old === w) continue;\n\t\t\t\tw.add(watcher);\n\t\t\t\tif (old !== undefined) old.remove(watcher);\n\t\t\t}\n\t\t} else {\n\t\t\tconst filePaths = new Set(entry.values());\n\t\t\tif (filePaths.size > 1) {\n\t\t\t\tconst w = createRecursiveWatcher(filePath);\n\t\t\t\tfor (const [watcher, watcherPath] of entry) {\n\t\t\t\t\tconst old = underlyingWatcher.get(watcher);\n\t\t\t\t\tif (old === w) continue;\n\t\t\t\t\tw.add(watcherPath, watcher);\n\t\t\t\t\tif (old !== undefined) old.remove(watcher);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (const filePath of filePaths) {\n\t\t\t\t\tconst w = createDirectWatcher(filePath);\n\t\t\t\t\tfor (const watcher of entry.keys()) {\n\t\t\t\t\t\tconst old = underlyingWatcher.get(watcher);\n\t\t\t\t\t\tif (old === w) continue;\n\t\t\t\t\t\tw.add(watcher);\n\t\t\t\t\t\tif (old !== undefined) old.remove(watcher);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nexports.watch = filePath => {\n\tconst watcher = new Watcher();\n\t// Find an existing watcher\n\tconst directWatcher = directWatchers.get(filePath);\n\tif (directWatcher !== undefined) {\n\t\tdirectWatcher.add(watcher);\n\t\treturn watcher;\n\t}\n\tlet current = filePath;\n\tfor (;;) {\n\t\tconst recursiveWatcher = recursiveWatchers.get(current);\n\t\tif (recursiveWatcher !== undefined) {\n\t\t\trecursiveWatcher.add(filePath, watcher);\n\t\t\treturn watcher;\n\t\t}\n\t\tconst parent = path.dirname(current);\n\t\tif (parent === current) break;\n\t\tcurrent = parent;\n\t}\n\t// Queue up watcher for creation\n\tpendingWatchers.set(watcher, filePath);\n\tif (!isBatch) execute();\n\treturn watcher;\n};\n\nexports.batch = fn => {\n\tisBatch = true;\n\ttry {\n\t\tfn();\n\t} finally {\n\t\tisBatch = false;\n\t\texecute();\n\t}\n};\n\nexports.getNumberOfWatchers = () => {\n\treturn watcherCount;\n};\n"]},"metadata":{},"sourceType":"script"}