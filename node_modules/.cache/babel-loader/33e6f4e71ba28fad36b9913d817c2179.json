{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst makeSerializable = require(\"./makeSerializable.js\");\n/**\n * @template T\n * @param {Set<T>} targetSet set where items should be added\n * @param {Set<Iterable<T>>} toMerge iterables to be merged\n * @returns {void}\n */\n\n\nconst merge = (targetSet, toMerge) => {\n  for (const set of toMerge) {\n    for (const item of set) {\n      targetSet.add(item);\n    }\n  }\n};\n/**\n * @template T\n * @param {Set<Iterable<T>>} targetSet set where iterables should be added\n * @param {Array<LazySet<T>>} toDeepMerge lazy sets to be flattened\n * @returns {void}\n */\n\n\nconst flatten = (targetSet, toDeepMerge) => {\n  for (const set of toDeepMerge) {\n    if (set._set.size > 0) targetSet.add(set._set);\n\n    if (set._needMerge) {\n      for (const mergedSet of set._toMerge) {\n        targetSet.add(mergedSet);\n      }\n\n      flatten(targetSet, set._toDeepMerge);\n    }\n  }\n};\n/**\n * Like Set but with an addAll method to eventually add items from another iterable.\n * Access methods make sure that all delayed operations are executed.\n * Iteration methods deopts to normal Set performance until clear is called again (because of the chance of modifications during iteration).\n * @template T\n */\n\n\nclass LazySet {\n  /**\n   * @param {Iterable<T>=} iterable init iterable\n   */\n  constructor(iterable) {\n    /** @type {Set<T>} */\n    this._set = new Set(iterable);\n    /** @type {Set<Iterable<T>>} */\n\n    this._toMerge = new Set();\n    /** @type {Array<LazySet<T>>} */\n\n    this._toDeepMerge = [];\n    this._needMerge = false;\n    this._deopt = false;\n  }\n\n  _flatten() {\n    flatten(this._toMerge, this._toDeepMerge);\n    this._toDeepMerge.length = 0;\n  }\n\n  _merge() {\n    this._flatten();\n\n    merge(this._set, this._toMerge);\n\n    this._toMerge.clear();\n\n    this._needMerge = false;\n  }\n\n  _isEmpty() {\n    return this._set.size === 0 && this._toMerge.size === 0 && this._toDeepMerge.length === 0;\n  }\n\n  get size() {\n    if (this._needMerge) this._merge();\n    return this._set.size;\n  }\n  /**\n   * @param {T} item an item\n   * @returns {this} itself\n   */\n\n\n  add(item) {\n    this._set.add(item);\n\n    return this;\n  }\n  /**\n   * @param {Iterable<T> | LazySet<T>} iterable a immutable iterable or another immutable LazySet which will eventually be merged into the Set\n   * @returns {this} itself\n   */\n\n\n  addAll(iterable) {\n    if (this._deopt) {\n      const _set = this._set;\n\n      for (const item of iterable) {\n        _set.add(item);\n      }\n    } else {\n      if (iterable instanceof LazySet) {\n        if (iterable._isEmpty()) return this;\n\n        this._toDeepMerge.push(iterable);\n\n        this._needMerge = true;\n\n        if (this._toDeepMerge.length > 100000) {\n          this._flatten();\n        }\n      } else {\n        this._toMerge.add(iterable);\n\n        this._needMerge = true;\n      }\n\n      if (this._toMerge.size > 100000) this._merge();\n    }\n\n    return this;\n  }\n\n  clear() {\n    this._set.clear();\n\n    this._toMerge.clear();\n\n    this._toDeepMerge.length = 0;\n    this._needMerge = false;\n    this._deopt = false;\n  }\n  /**\n   * @param {T} value an item\n   * @returns {boolean} true, if the value was in the Set before\n   */\n\n\n  delete(value) {\n    if (this._needMerge) this._merge();\n    return this._set.delete(value);\n  }\n\n  entries() {\n    this._deopt = true;\n    if (this._needMerge) this._merge();\n    return this._set.entries();\n  }\n  /**\n   * @param {function(T, T, Set<T>): void} callbackFn function called for each entry\n   * @param {any} thisArg this argument for the callbackFn\n   * @returns {void}\n   */\n\n\n  forEach(callbackFn, thisArg) {\n    this._deopt = true;\n    if (this._needMerge) this._merge();\n\n    this._set.forEach(callbackFn, thisArg);\n  }\n  /**\n   * @param {T} item an item\n   * @returns {boolean} true, when the item is in the Set\n   */\n\n\n  has(item) {\n    if (this._needMerge) this._merge();\n    return this._set.has(item);\n  }\n\n  keys() {\n    this._deopt = true;\n    if (this._needMerge) this._merge();\n    return this._set.keys();\n  }\n\n  values() {\n    this._deopt = true;\n    if (this._needMerge) this._merge();\n    return this._set.values();\n  }\n\n  [Symbol.iterator]() {\n    this._deopt = true;\n    if (this._needMerge) this._merge();\n    return this._set[Symbol.iterator]();\n  }\n  /* istanbul ignore next */\n\n\n  get [Symbol.toStringTag]() {\n    return \"LazySet\";\n  }\n\n  serialize(_ref) {\n    let {\n      write\n    } = _ref;\n    if (this._needMerge) this._merge();\n    write(this._set.size);\n\n    for (const item of this._set) write(item);\n  }\n\n  static deserialize(_ref2) {\n    let {\n      read\n    } = _ref2;\n    const count = read();\n    const items = [];\n\n    for (let i = 0; i < count; i++) {\n      items.push(read());\n    }\n\n    return new LazySet(items);\n  }\n\n}\n\nmakeSerializable(LazySet, \"webpack/lib/util/LazySet\");\nmodule.exports = LazySet;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/util/LazySet.js"],"names":["makeSerializable","require","merge","targetSet","toMerge","set","item","add","flatten","toDeepMerge","_set","size","_needMerge","mergedSet","_toMerge","_toDeepMerge","LazySet","constructor","iterable","Set","_deopt","_flatten","length","_merge","clear","_isEmpty","addAll","push","delete","value","entries","forEach","callbackFn","thisArg","has","keys","values","Symbol","iterator","toStringTag","serialize","write","deserialize","read","count","items","i","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst makeSerializable = require(\"./makeSerializable.js\");\n\n/**\n * @template T\n * @param {Set<T>} targetSet set where items should be added\n * @param {Set<Iterable<T>>} toMerge iterables to be merged\n * @returns {void}\n */\nconst merge = (targetSet, toMerge) => {\n\tfor (const set of toMerge) {\n\t\tfor (const item of set) {\n\t\t\ttargetSet.add(item);\n\t\t}\n\t}\n};\n\n/**\n * @template T\n * @param {Set<Iterable<T>>} targetSet set where iterables should be added\n * @param {Array<LazySet<T>>} toDeepMerge lazy sets to be flattened\n * @returns {void}\n */\nconst flatten = (targetSet, toDeepMerge) => {\n\tfor (const set of toDeepMerge) {\n\t\tif (set._set.size > 0) targetSet.add(set._set);\n\t\tif (set._needMerge) {\n\t\t\tfor (const mergedSet of set._toMerge) {\n\t\t\t\ttargetSet.add(mergedSet);\n\t\t\t}\n\t\t\tflatten(targetSet, set._toDeepMerge);\n\t\t}\n\t}\n};\n\n/**\n * Like Set but with an addAll method to eventually add items from another iterable.\n * Access methods make sure that all delayed operations are executed.\n * Iteration methods deopts to normal Set performance until clear is called again (because of the chance of modifications during iteration).\n * @template T\n */\nclass LazySet {\n\t/**\n\t * @param {Iterable<T>=} iterable init iterable\n\t */\n\tconstructor(iterable) {\n\t\t/** @type {Set<T>} */\n\t\tthis._set = new Set(iterable);\n\t\t/** @type {Set<Iterable<T>>} */\n\t\tthis._toMerge = new Set();\n\t\t/** @type {Array<LazySet<T>>} */\n\t\tthis._toDeepMerge = [];\n\t\tthis._needMerge = false;\n\t\tthis._deopt = false;\n\t}\n\n\t_flatten() {\n\t\tflatten(this._toMerge, this._toDeepMerge);\n\t\tthis._toDeepMerge.length = 0;\n\t}\n\n\t_merge() {\n\t\tthis._flatten();\n\t\tmerge(this._set, this._toMerge);\n\t\tthis._toMerge.clear();\n\t\tthis._needMerge = false;\n\t}\n\n\t_isEmpty() {\n\t\treturn (\n\t\t\tthis._set.size === 0 &&\n\t\t\tthis._toMerge.size === 0 &&\n\t\t\tthis._toDeepMerge.length === 0\n\t\t);\n\t}\n\n\tget size() {\n\t\tif (this._needMerge) this._merge();\n\t\treturn this._set.size;\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {this} itself\n\t */\n\tadd(item) {\n\t\tthis._set.add(item);\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {Iterable<T> | LazySet<T>} iterable a immutable iterable or another immutable LazySet which will eventually be merged into the Set\n\t * @returns {this} itself\n\t */\n\taddAll(iterable) {\n\t\tif (this._deopt) {\n\t\t\tconst _set = this._set;\n\t\t\tfor (const item of iterable) {\n\t\t\t\t_set.add(item);\n\t\t\t}\n\t\t} else {\n\t\t\tif (iterable instanceof LazySet) {\n\t\t\t\tif (iterable._isEmpty()) return this;\n\t\t\t\tthis._toDeepMerge.push(iterable);\n\t\t\t\tthis._needMerge = true;\n\t\t\t\tif (this._toDeepMerge.length > 100000) {\n\t\t\t\t\tthis._flatten();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._toMerge.add(iterable);\n\t\t\t\tthis._needMerge = true;\n\t\t\t}\n\t\t\tif (this._toMerge.size > 100000) this._merge();\n\t\t}\n\t\treturn this;\n\t}\n\n\tclear() {\n\t\tthis._set.clear();\n\t\tthis._toMerge.clear();\n\t\tthis._toDeepMerge.length = 0;\n\t\tthis._needMerge = false;\n\t\tthis._deopt = false;\n\t}\n\n\t/**\n\t * @param {T} value an item\n\t * @returns {boolean} true, if the value was in the Set before\n\t */\n\tdelete(value) {\n\t\tif (this._needMerge) this._merge();\n\t\treturn this._set.delete(value);\n\t}\n\n\tentries() {\n\t\tthis._deopt = true;\n\t\tif (this._needMerge) this._merge();\n\t\treturn this._set.entries();\n\t}\n\n\t/**\n\t * @param {function(T, T, Set<T>): void} callbackFn function called for each entry\n\t * @param {any} thisArg this argument for the callbackFn\n\t * @returns {void}\n\t */\n\tforEach(callbackFn, thisArg) {\n\t\tthis._deopt = true;\n\t\tif (this._needMerge) this._merge();\n\t\tthis._set.forEach(callbackFn, thisArg);\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {boolean} true, when the item is in the Set\n\t */\n\thas(item) {\n\t\tif (this._needMerge) this._merge();\n\t\treturn this._set.has(item);\n\t}\n\n\tkeys() {\n\t\tthis._deopt = true;\n\t\tif (this._needMerge) this._merge();\n\t\treturn this._set.keys();\n\t}\n\n\tvalues() {\n\t\tthis._deopt = true;\n\t\tif (this._needMerge) this._merge();\n\t\treturn this._set.values();\n\t}\n\n\t[Symbol.iterator]() {\n\t\tthis._deopt = true;\n\t\tif (this._needMerge) this._merge();\n\t\treturn this._set[Symbol.iterator]();\n\t}\n\n\t/* istanbul ignore next */\n\tget [Symbol.toStringTag]() {\n\t\treturn \"LazySet\";\n\t}\n\n\tserialize({ write }) {\n\t\tif (this._needMerge) this._merge();\n\t\twrite(this._set.size);\n\t\tfor (const item of this._set) write(item);\n\t}\n\n\tstatic deserialize({ read }) {\n\t\tconst count = read();\n\t\tconst items = [];\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\titems.push(read());\n\t\t}\n\t\treturn new LazySet(items);\n\t}\n}\n\nmakeSerializable(LazySet, \"webpack/lib/util/LazySet\");\n\nmodule.exports = LazySet;\n"]},"metadata":{},"sourceType":"script"}