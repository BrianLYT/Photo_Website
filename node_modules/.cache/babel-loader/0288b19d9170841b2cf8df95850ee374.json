{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\"use strict\";\n\nconst {\n  Tracer\n} = require(\"chrome-trace-event\");\n\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\n\nconst {\n  dirname,\n  mkdirpSync\n} = require(\"../util/fs\");\n/** @typedef {import(\"../../declarations/plugins/debug/ProfilingPlugin\").ProfilingPluginOptions} ProfilingPluginOptions */\n\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\n\nconst validate = createSchemaValidation(require(\"../../schemas/plugins/debug/ProfilingPlugin.check.js\"), () => require(\"../../schemas/plugins/debug/ProfilingPlugin.json\"), {\n  name: \"Profiling Plugin\",\n  baseDataPath: \"options\"\n});\nlet inspector = undefined;\n\ntry {\n  // eslint-disable-next-line node/no-unsupported-features/node-builtins\n  inspector = require(\"inspector\");\n} catch (e) {\n  console.log(\"Unable to CPU profile in < node 8.0\");\n}\n\nclass Profiler {\n  constructor(inspector) {\n    this.session = undefined;\n    this.inspector = inspector;\n    this._startTime = 0;\n  }\n\n  hasSession() {\n    return this.session !== undefined;\n  }\n\n  startProfiling() {\n    if (this.inspector === undefined) {\n      return Promise.resolve();\n    }\n\n    try {\n      this.session = new inspector.Session();\n      this.session.connect();\n    } catch (_) {\n      this.session = undefined;\n      return Promise.resolve();\n    }\n\n    const hrtime = process.hrtime();\n    this._startTime = hrtime[0] * 1000000 + Math.round(hrtime[1] / 1000);\n    return Promise.all([this.sendCommand(\"Profiler.setSamplingInterval\", {\n      interval: 100\n    }), this.sendCommand(\"Profiler.enable\"), this.sendCommand(\"Profiler.start\")]);\n  }\n\n  sendCommand(method, params) {\n    if (this.hasSession()) {\n      return new Promise((res, rej) => {\n        return this.session.post(method, params, (err, params) => {\n          if (err !== null) {\n            rej(err);\n          } else {\n            res(params);\n          }\n        });\n      });\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  destroy() {\n    if (this.hasSession()) {\n      this.session.disconnect();\n    }\n\n    return Promise.resolve();\n  }\n\n  stopProfiling() {\n    return this.sendCommand(\"Profiler.stop\").then(_ref => {\n      let {\n        profile\n      } = _ref;\n      const hrtime = process.hrtime();\n      const endTime = hrtime[0] * 1000000 + Math.round(hrtime[1] / 1000);\n\n      if (profile.startTime < this._startTime || profile.endTime > endTime) {\n        // In some cases timestamps mismatch and we need to adjust them\n        // Both process.hrtime and the inspector timestamps claim to be relative\n        // to a unknown point in time. But they do not guarantee that this is the\n        // same point in time.\n        const duration = profile.endTime - profile.startTime;\n        const ownDuration = endTime - this._startTime;\n        const untracked = Math.max(0, ownDuration - duration);\n        profile.startTime = this._startTime + untracked / 2;\n        profile.endTime = endTime - untracked / 2;\n      }\n\n      return {\n        profile\n      };\n    });\n  }\n\n}\n/**\n * an object that wraps Tracer and Profiler with a counter\n * @typedef {Object} Trace\n * @property {Tracer} trace instance of Tracer\n * @property {number} counter Counter\n * @property {Profiler} profiler instance of Profiler\n * @property {Function} end the end function\n */\n\n/**\n * @param {IntermediateFileSystem} fs filesystem used for output\n * @param {string} outputPath The location where to write the log.\n * @returns {Trace} The trace object\n */\n\n\nconst createTrace = (fs, outputPath) => {\n  const trace = new Tracer();\n  const profiler = new Profiler(inspector);\n\n  if (/\\/|\\\\/.test(outputPath)) {\n    const dirPath = dirname(fs, outputPath);\n    mkdirpSync(fs, dirPath);\n  }\n\n  const fsStream = fs.createWriteStream(outputPath);\n  let counter = 0;\n  trace.pipe(fsStream); // These are critical events that need to be inserted so that tools like\n  // chrome dev tools can load the profile.\n\n  trace.instantEvent({\n    name: \"TracingStartedInPage\",\n    id: ++counter,\n    cat: [\"disabled-by-default-devtools.timeline\"],\n    args: {\n      data: {\n        sessionId: \"-1\",\n        page: \"0xfff\",\n        frames: [{\n          frame: \"0xfff\",\n          url: \"webpack\",\n          name: \"\"\n        }]\n      }\n    }\n  });\n  trace.instantEvent({\n    name: \"TracingStartedInBrowser\",\n    id: ++counter,\n    cat: [\"disabled-by-default-devtools.timeline\"],\n    args: {\n      data: {\n        sessionId: \"-1\"\n      }\n    }\n  });\n  return {\n    trace,\n    counter,\n    profiler,\n    end: callback => {\n      trace.push(\"]\"); // Wait until the write stream finishes.\n\n      fsStream.on(\"close\", () => {\n        callback();\n      }); // Tear down the readable trace stream.\n\n      trace.push(null);\n    }\n  };\n};\n\nconst pluginName = \"ProfilingPlugin\";\n\nclass ProfilingPlugin {\n  /**\n   * @param {ProfilingPluginOptions=} options options object\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    validate(options);\n    this.outputPath = options.outputPath || \"events.json\";\n  }\n\n  apply(compiler) {\n    const tracer = createTrace(compiler.intermediateFileSystem, this.outputPath);\n    tracer.profiler.startProfiling(); // Compiler Hooks\n\n    Object.keys(compiler.hooks).forEach(hookName => {\n      const hook = compiler.hooks[hookName];\n\n      if (hook) {\n        hook.intercept(makeInterceptorFor(\"Compiler\", tracer)(hookName));\n      }\n    });\n    Object.keys(compiler.resolverFactory.hooks).forEach(hookName => {\n      const hook = compiler.resolverFactory.hooks[hookName];\n\n      if (hook) {\n        hook.intercept(makeInterceptorFor(\"Resolver\", tracer)(hookName));\n      }\n    });\n    compiler.hooks.compilation.tap(pluginName, (compilation, _ref2) => {\n      let {\n        normalModuleFactory,\n        contextModuleFactory\n      } = _ref2;\n      interceptAllHooksFor(compilation, tracer, \"Compilation\");\n      interceptAllHooksFor(normalModuleFactory, tracer, \"Normal Module Factory\");\n      interceptAllHooksFor(contextModuleFactory, tracer, \"Context Module Factory\");\n      interceptAllParserHooks(normalModuleFactory, tracer);\n      interceptAllJavascriptModulesPluginHooks(compilation, tracer);\n    }); // We need to write out the CPU profile when we are all done.\n\n    compiler.hooks.done.tapAsync({\n      name: pluginName,\n      stage: Infinity\n    }, (stats, callback) => {\n      if (compiler.watchMode) return callback();\n      tracer.profiler.stopProfiling().then(parsedResults => {\n        if (parsedResults === undefined) {\n          tracer.profiler.destroy();\n          tracer.end(callback);\n          return;\n        }\n\n        const cpuStartTime = parsedResults.profile.startTime;\n        const cpuEndTime = parsedResults.profile.endTime;\n        tracer.trace.completeEvent({\n          name: \"TaskQueueManager::ProcessTaskFromWorkQueue\",\n          id: ++tracer.counter,\n          cat: [\"toplevel\"],\n          ts: cpuStartTime,\n          args: {\n            src_file: \"../../ipc/ipc_moji_bootstrap.cc\",\n            src_func: \"Accept\"\n          }\n        });\n        tracer.trace.completeEvent({\n          name: \"EvaluateScript\",\n          id: ++tracer.counter,\n          cat: [\"devtools.timeline\"],\n          ts: cpuStartTime,\n          dur: cpuEndTime - cpuStartTime,\n          args: {\n            data: {\n              url: \"webpack\",\n              lineNumber: 1,\n              columnNumber: 1,\n              frame: \"0xFFF\"\n            }\n          }\n        });\n        tracer.trace.instantEvent({\n          name: \"CpuProfile\",\n          id: ++tracer.counter,\n          cat: [\"disabled-by-default-devtools.timeline\"],\n          ts: cpuEndTime,\n          args: {\n            data: {\n              cpuProfile: parsedResults.profile\n            }\n          }\n        });\n        tracer.profiler.destroy();\n        tracer.end(callback);\n      });\n    });\n  }\n\n}\n\nconst interceptAllHooksFor = (instance, tracer, logLabel) => {\n  if (Reflect.has(instance, \"hooks\")) {\n    Object.keys(instance.hooks).forEach(hookName => {\n      const hook = instance.hooks[hookName];\n\n      if (hook && !hook._fakeHook) {\n        hook.intercept(makeInterceptorFor(logLabel, tracer)(hookName));\n      }\n    });\n  }\n};\n\nconst interceptAllParserHooks = (moduleFactory, tracer) => {\n  const moduleTypes = [\"javascript/auto\", \"javascript/dynamic\", \"javascript/esm\", \"json\", \"webassembly/async\", \"webassembly/sync\"];\n  moduleTypes.forEach(moduleType => {\n    moduleFactory.hooks.parser.for(moduleType).tap(\"ProfilingPlugin\", (parser, parserOpts) => {\n      interceptAllHooksFor(parser, tracer, \"Parser\");\n    });\n  });\n};\n\nconst interceptAllJavascriptModulesPluginHooks = (compilation, tracer) => {\n  interceptAllHooksFor({\n    hooks: require(\"../javascript/JavascriptModulesPlugin\").getCompilationHooks(compilation)\n  }, tracer, \"JavascriptModulesPlugin\");\n};\n\nconst makeInterceptorFor = (instance, tracer) => hookName => ({\n  register: tapInfo => {\n    const {\n      name,\n      type,\n      fn\n    } = tapInfo;\n    const newFn = // Don't tap our own hooks to ensure stream can close cleanly\n    name === pluginName ? fn : makeNewProfiledTapFn(hookName, tracer, {\n      name,\n      type,\n      fn\n    });\n    return { ...tapInfo,\n      fn: newFn\n    };\n  }\n}); // TODO improve typing\n\n/** @typedef {(...args: TODO[]) => void | Promise<TODO>} PluginFunction */\n\n/**\n * @param {string} hookName Name of the hook to profile.\n * @param {Trace} tracer The trace object.\n * @param {object} options Options for the profiled fn.\n * @param {string} options.name Plugin name\n * @param {string} options.type Plugin type (sync | async | promise)\n * @param {PluginFunction} options.fn Plugin function\n * @returns {PluginFunction} Chainable hooked function.\n */\n\n\nconst makeNewProfiledTapFn = (hookName, tracer, _ref3) => {\n  let {\n    name,\n    type,\n    fn\n  } = _ref3;\n  const defaultCategory = [\"blink.user_timing\"];\n\n  switch (type) {\n    case \"promise\":\n      return function () {\n        const id = ++tracer.counter;\n        tracer.trace.begin({\n          name,\n          id,\n          cat: defaultCategory\n        });\n        const promise =\n        /** @type {Promise<*>} */\n        fn(...arguments);\n        return promise.then(r => {\n          tracer.trace.end({\n            name,\n            id,\n            cat: defaultCategory\n          });\n          return r;\n        });\n      };\n\n    case \"async\":\n      return function () {\n        const id = ++tracer.counter;\n        tracer.trace.begin({\n          name,\n          id,\n          cat: defaultCategory\n        });\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        const callback = args.pop();\n        fn(...args, function () {\n          tracer.trace.end({\n            name,\n            id,\n            cat: defaultCategory\n          });\n          callback(...arguments);\n        });\n      };\n\n    case \"sync\":\n      return function () {\n        const id = ++tracer.counter; // Do not instrument ourself due to the CPU\n        // profile needing to be the last event in the trace.\n\n        if (name === pluginName) {\n          return fn(...arguments);\n        }\n\n        tracer.trace.begin({\n          name,\n          id,\n          cat: defaultCategory\n        });\n        let r;\n\n        try {\n          r = fn(...arguments);\n        } catch (error) {\n          tracer.trace.end({\n            name,\n            id,\n            cat: defaultCategory\n          });\n          throw error;\n        }\n\n        tracer.trace.end({\n          name,\n          id,\n          cat: defaultCategory\n        });\n        return r;\n      };\n\n    default:\n      break;\n  }\n};\n\nmodule.exports = ProfilingPlugin;\nmodule.exports.Profiler = Profiler;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/debug/ProfilingPlugin.js"],"names":["Tracer","require","createSchemaValidation","dirname","mkdirpSync","validate","name","baseDataPath","inspector","undefined","e","console","log","Profiler","constructor","session","_startTime","hasSession","startProfiling","Promise","resolve","Session","connect","_","hrtime","process","Math","round","all","sendCommand","interval","method","params","res","rej","post","err","destroy","disconnect","stopProfiling","then","profile","endTime","startTime","duration","ownDuration","untracked","max","createTrace","fs","outputPath","trace","profiler","test","dirPath","fsStream","createWriteStream","counter","pipe","instantEvent","id","cat","args","data","sessionId","page","frames","frame","url","end","callback","push","on","pluginName","ProfilingPlugin","options","apply","compiler","tracer","intermediateFileSystem","Object","keys","hooks","forEach","hookName","hook","intercept","makeInterceptorFor","resolverFactory","compilation","tap","normalModuleFactory","contextModuleFactory","interceptAllHooksFor","interceptAllParserHooks","interceptAllJavascriptModulesPluginHooks","done","tapAsync","stage","Infinity","stats","watchMode","parsedResults","cpuStartTime","cpuEndTime","completeEvent","ts","src_file","src_func","dur","lineNumber","columnNumber","cpuProfile","instance","logLabel","Reflect","has","_fakeHook","moduleFactory","moduleTypes","moduleType","parser","for","parserOpts","getCompilationHooks","register","tapInfo","type","fn","newFn","makeNewProfiledTapFn","defaultCategory","begin","promise","r","pop","error","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst { Tracer } = require(\"chrome-trace-event\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst { dirname, mkdirpSync } = require(\"../util/fs\");\n\n/** @typedef {import(\"../../declarations/plugins/debug/ProfilingPlugin\").ProfilingPluginOptions} ProfilingPluginOptions */\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/debug/ProfilingPlugin.check.js\"),\n\t() => require(\"../../schemas/plugins/debug/ProfilingPlugin.json\"),\n\t{\n\t\tname: \"Profiling Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\nlet inspector = undefined;\n\ntry {\n\t// eslint-disable-next-line node/no-unsupported-features/node-builtins\n\tinspector = require(\"inspector\");\n} catch (e) {\n\tconsole.log(\"Unable to CPU profile in < node 8.0\");\n}\n\nclass Profiler {\n\tconstructor(inspector) {\n\t\tthis.session = undefined;\n\t\tthis.inspector = inspector;\n\t\tthis._startTime = 0;\n\t}\n\n\thasSession() {\n\t\treturn this.session !== undefined;\n\t}\n\n\tstartProfiling() {\n\t\tif (this.inspector === undefined) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\ttry {\n\t\t\tthis.session = new inspector.Session();\n\t\t\tthis.session.connect();\n\t\t} catch (_) {\n\t\t\tthis.session = undefined;\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tconst hrtime = process.hrtime();\n\t\tthis._startTime = hrtime[0] * 1000000 + Math.round(hrtime[1] / 1000);\n\n\t\treturn Promise.all([\n\t\t\tthis.sendCommand(\"Profiler.setSamplingInterval\", {\n\t\t\t\tinterval: 100\n\t\t\t}),\n\t\t\tthis.sendCommand(\"Profiler.enable\"),\n\t\t\tthis.sendCommand(\"Profiler.start\")\n\t\t]);\n\t}\n\n\tsendCommand(method, params) {\n\t\tif (this.hasSession()) {\n\t\t\treturn new Promise((res, rej) => {\n\t\t\t\treturn this.session.post(method, params, (err, params) => {\n\t\t\t\t\tif (err !== null) {\n\t\t\t\t\t\trej(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres(params);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tif (this.hasSession()) {\n\t\t\tthis.session.disconnect();\n\t\t}\n\n\t\treturn Promise.resolve();\n\t}\n\n\tstopProfiling() {\n\t\treturn this.sendCommand(\"Profiler.stop\").then(({ profile }) => {\n\t\t\tconst hrtime = process.hrtime();\n\t\t\tconst endTime = hrtime[0] * 1000000 + Math.round(hrtime[1] / 1000);\n\t\t\tif (profile.startTime < this._startTime || profile.endTime > endTime) {\n\t\t\t\t// In some cases timestamps mismatch and we need to adjust them\n\t\t\t\t// Both process.hrtime and the inspector timestamps claim to be relative\n\t\t\t\t// to a unknown point in time. But they do not guarantee that this is the\n\t\t\t\t// same point in time.\n\t\t\t\tconst duration = profile.endTime - profile.startTime;\n\t\t\t\tconst ownDuration = endTime - this._startTime;\n\t\t\t\tconst untracked = Math.max(0, ownDuration - duration);\n\t\t\t\tprofile.startTime = this._startTime + untracked / 2;\n\t\t\t\tprofile.endTime = endTime - untracked / 2;\n\t\t\t}\n\t\t\treturn { profile };\n\t\t});\n\t}\n}\n\n/**\n * an object that wraps Tracer and Profiler with a counter\n * @typedef {Object} Trace\n * @property {Tracer} trace instance of Tracer\n * @property {number} counter Counter\n * @property {Profiler} profiler instance of Profiler\n * @property {Function} end the end function\n */\n\n/**\n * @param {IntermediateFileSystem} fs filesystem used for output\n * @param {string} outputPath The location where to write the log.\n * @returns {Trace} The trace object\n */\nconst createTrace = (fs, outputPath) => {\n\tconst trace = new Tracer();\n\tconst profiler = new Profiler(inspector);\n\tif (/\\/|\\\\/.test(outputPath)) {\n\t\tconst dirPath = dirname(fs, outputPath);\n\t\tmkdirpSync(fs, dirPath);\n\t}\n\tconst fsStream = fs.createWriteStream(outputPath);\n\n\tlet counter = 0;\n\n\ttrace.pipe(fsStream);\n\t// These are critical events that need to be inserted so that tools like\n\t// chrome dev tools can load the profile.\n\ttrace.instantEvent({\n\t\tname: \"TracingStartedInPage\",\n\t\tid: ++counter,\n\t\tcat: [\"disabled-by-default-devtools.timeline\"],\n\t\targs: {\n\t\t\tdata: {\n\t\t\t\tsessionId: \"-1\",\n\t\t\t\tpage: \"0xfff\",\n\t\t\t\tframes: [\n\t\t\t\t\t{\n\t\t\t\t\t\tframe: \"0xfff\",\n\t\t\t\t\t\turl: \"webpack\",\n\t\t\t\t\t\tname: \"\"\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t}\n\t});\n\n\ttrace.instantEvent({\n\t\tname: \"TracingStartedInBrowser\",\n\t\tid: ++counter,\n\t\tcat: [\"disabled-by-default-devtools.timeline\"],\n\t\targs: {\n\t\t\tdata: {\n\t\t\t\tsessionId: \"-1\"\n\t\t\t}\n\t\t}\n\t});\n\n\treturn {\n\t\ttrace,\n\t\tcounter,\n\t\tprofiler,\n\t\tend: callback => {\n\t\t\ttrace.push(\"]\");\n\t\t\t// Wait until the write stream finishes.\n\t\t\tfsStream.on(\"close\", () => {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t\t// Tear down the readable trace stream.\n\t\t\ttrace.push(null);\n\t\t}\n\t};\n};\n\nconst pluginName = \"ProfilingPlugin\";\n\nclass ProfilingPlugin {\n\t/**\n\t * @param {ProfilingPluginOptions=} options options object\n\t */\n\tconstructor(options = {}) {\n\t\tvalidate(options);\n\t\tthis.outputPath = options.outputPath || \"events.json\";\n\t}\n\n\tapply(compiler) {\n\t\tconst tracer = createTrace(\n\t\t\tcompiler.intermediateFileSystem,\n\t\t\tthis.outputPath\n\t\t);\n\t\ttracer.profiler.startProfiling();\n\n\t\t// Compiler Hooks\n\t\tObject.keys(compiler.hooks).forEach(hookName => {\n\t\t\tconst hook = compiler.hooks[hookName];\n\t\t\tif (hook) {\n\t\t\t\thook.intercept(makeInterceptorFor(\"Compiler\", tracer)(hookName));\n\t\t\t}\n\t\t});\n\n\t\tObject.keys(compiler.resolverFactory.hooks).forEach(hookName => {\n\t\t\tconst hook = compiler.resolverFactory.hooks[hookName];\n\t\t\tif (hook) {\n\t\t\t\thook.intercept(makeInterceptorFor(\"Resolver\", tracer)(hookName));\n\t\t\t}\n\t\t});\n\n\t\tcompiler.hooks.compilation.tap(\n\t\t\tpluginName,\n\t\t\t(compilation, { normalModuleFactory, contextModuleFactory }) => {\n\t\t\t\tinterceptAllHooksFor(compilation, tracer, \"Compilation\");\n\t\t\t\tinterceptAllHooksFor(\n\t\t\t\t\tnormalModuleFactory,\n\t\t\t\t\ttracer,\n\t\t\t\t\t\"Normal Module Factory\"\n\t\t\t\t);\n\t\t\t\tinterceptAllHooksFor(\n\t\t\t\t\tcontextModuleFactory,\n\t\t\t\t\ttracer,\n\t\t\t\t\t\"Context Module Factory\"\n\t\t\t\t);\n\t\t\t\tinterceptAllParserHooks(normalModuleFactory, tracer);\n\t\t\t\tinterceptAllJavascriptModulesPluginHooks(compilation, tracer);\n\t\t\t}\n\t\t);\n\n\t\t// We need to write out the CPU profile when we are all done.\n\t\tcompiler.hooks.done.tapAsync(\n\t\t\t{\n\t\t\t\tname: pluginName,\n\t\t\t\tstage: Infinity\n\t\t\t},\n\t\t\t(stats, callback) => {\n\t\t\t\tif (compiler.watchMode) return callback();\n\t\t\t\ttracer.profiler.stopProfiling().then(parsedResults => {\n\t\t\t\t\tif (parsedResults === undefined) {\n\t\t\t\t\t\ttracer.profiler.destroy();\n\t\t\t\t\t\ttracer.end(callback);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cpuStartTime = parsedResults.profile.startTime;\n\t\t\t\t\tconst cpuEndTime = parsedResults.profile.endTime;\n\n\t\t\t\t\ttracer.trace.completeEvent({\n\t\t\t\t\t\tname: \"TaskQueueManager::ProcessTaskFromWorkQueue\",\n\t\t\t\t\t\tid: ++tracer.counter,\n\t\t\t\t\t\tcat: [\"toplevel\"],\n\t\t\t\t\t\tts: cpuStartTime,\n\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\tsrc_file: \"../../ipc/ipc_moji_bootstrap.cc\",\n\t\t\t\t\t\t\tsrc_func: \"Accept\"\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\ttracer.trace.completeEvent({\n\t\t\t\t\t\tname: \"EvaluateScript\",\n\t\t\t\t\t\tid: ++tracer.counter,\n\t\t\t\t\t\tcat: [\"devtools.timeline\"],\n\t\t\t\t\t\tts: cpuStartTime,\n\t\t\t\t\t\tdur: cpuEndTime - cpuStartTime,\n\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\turl: \"webpack\",\n\t\t\t\t\t\t\t\tlineNumber: 1,\n\t\t\t\t\t\t\t\tcolumnNumber: 1,\n\t\t\t\t\t\t\t\tframe: \"0xFFF\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\ttracer.trace.instantEvent({\n\t\t\t\t\t\tname: \"CpuProfile\",\n\t\t\t\t\t\tid: ++tracer.counter,\n\t\t\t\t\t\tcat: [\"disabled-by-default-devtools.timeline\"],\n\t\t\t\t\t\tts: cpuEndTime,\n\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\tcpuProfile: parsedResults.profile\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\ttracer.profiler.destroy();\n\t\t\t\t\ttracer.end(callback);\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t}\n}\n\nconst interceptAllHooksFor = (instance, tracer, logLabel) => {\n\tif (Reflect.has(instance, \"hooks\")) {\n\t\tObject.keys(instance.hooks).forEach(hookName => {\n\t\t\tconst hook = instance.hooks[hookName];\n\t\t\tif (hook && !hook._fakeHook) {\n\t\t\t\thook.intercept(makeInterceptorFor(logLabel, tracer)(hookName));\n\t\t\t}\n\t\t});\n\t}\n};\n\nconst interceptAllParserHooks = (moduleFactory, tracer) => {\n\tconst moduleTypes = [\n\t\t\"javascript/auto\",\n\t\t\"javascript/dynamic\",\n\t\t\"javascript/esm\",\n\t\t\"json\",\n\t\t\"webassembly/async\",\n\t\t\"webassembly/sync\"\n\t];\n\n\tmoduleTypes.forEach(moduleType => {\n\t\tmoduleFactory.hooks.parser\n\t\t\t.for(moduleType)\n\t\t\t.tap(\"ProfilingPlugin\", (parser, parserOpts) => {\n\t\t\t\tinterceptAllHooksFor(parser, tracer, \"Parser\");\n\t\t\t});\n\t});\n};\n\nconst interceptAllJavascriptModulesPluginHooks = (compilation, tracer) => {\n\tinterceptAllHooksFor(\n\t\t{\n\t\t\thooks:\n\t\t\t\trequire(\"../javascript/JavascriptModulesPlugin\").getCompilationHooks(\n\t\t\t\t\tcompilation\n\t\t\t\t)\n\t\t},\n\t\ttracer,\n\t\t\"JavascriptModulesPlugin\"\n\t);\n};\n\nconst makeInterceptorFor = (instance, tracer) => hookName => ({\n\tregister: tapInfo => {\n\t\tconst { name, type, fn } = tapInfo;\n\t\tconst newFn =\n\t\t\t// Don't tap our own hooks to ensure stream can close cleanly\n\t\t\tname === pluginName\n\t\t\t\t? fn\n\t\t\t\t: makeNewProfiledTapFn(hookName, tracer, {\n\t\t\t\t\t\tname,\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\tfn\n\t\t\t\t  });\n\t\treturn {\n\t\t\t...tapInfo,\n\t\t\tfn: newFn\n\t\t};\n\t}\n});\n\n// TODO improve typing\n/** @typedef {(...args: TODO[]) => void | Promise<TODO>} PluginFunction */\n\n/**\n * @param {string} hookName Name of the hook to profile.\n * @param {Trace} tracer The trace object.\n * @param {object} options Options for the profiled fn.\n * @param {string} options.name Plugin name\n * @param {string} options.type Plugin type (sync | async | promise)\n * @param {PluginFunction} options.fn Plugin function\n * @returns {PluginFunction} Chainable hooked function.\n */\nconst makeNewProfiledTapFn = (hookName, tracer, { name, type, fn }) => {\n\tconst defaultCategory = [\"blink.user_timing\"];\n\n\tswitch (type) {\n\t\tcase \"promise\":\n\t\t\treturn (...args) => {\n\t\t\t\tconst id = ++tracer.counter;\n\t\t\t\ttracer.trace.begin({\n\t\t\t\t\tname,\n\t\t\t\t\tid,\n\t\t\t\t\tcat: defaultCategory\n\t\t\t\t});\n\t\t\t\tconst promise = /** @type {Promise<*>} */ (fn(...args));\n\t\t\t\treturn promise.then(r => {\n\t\t\t\t\ttracer.trace.end({\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tcat: defaultCategory\n\t\t\t\t\t});\n\t\t\t\t\treturn r;\n\t\t\t\t});\n\t\t\t};\n\t\tcase \"async\":\n\t\t\treturn (...args) => {\n\t\t\t\tconst id = ++tracer.counter;\n\t\t\t\ttracer.trace.begin({\n\t\t\t\t\tname,\n\t\t\t\t\tid,\n\t\t\t\t\tcat: defaultCategory\n\t\t\t\t});\n\t\t\t\tconst callback = args.pop();\n\t\t\t\tfn(...args, (...r) => {\n\t\t\t\t\ttracer.trace.end({\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tcat: defaultCategory\n\t\t\t\t\t});\n\t\t\t\t\tcallback(...r);\n\t\t\t\t});\n\t\t\t};\n\t\tcase \"sync\":\n\t\t\treturn (...args) => {\n\t\t\t\tconst id = ++tracer.counter;\n\t\t\t\t// Do not instrument ourself due to the CPU\n\t\t\t\t// profile needing to be the last event in the trace.\n\t\t\t\tif (name === pluginName) {\n\t\t\t\t\treturn fn(...args);\n\t\t\t\t}\n\n\t\t\t\ttracer.trace.begin({\n\t\t\t\t\tname,\n\t\t\t\t\tid,\n\t\t\t\t\tcat: defaultCategory\n\t\t\t\t});\n\t\t\t\tlet r;\n\t\t\t\ttry {\n\t\t\t\t\tr = fn(...args);\n\t\t\t\t} catch (error) {\n\t\t\t\t\ttracer.trace.end({\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tcat: defaultCategory\n\t\t\t\t\t});\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t\ttracer.trace.end({\n\t\t\t\t\tname,\n\t\t\t\t\tid,\n\t\t\t\t\tcat: defaultCategory\n\t\t\t\t});\n\t\t\t\treturn r;\n\t\t\t};\n\t\tdefault:\n\t\t\tbreak;\n\t}\n};\n\nmodule.exports = ProfilingPlugin;\nmodule.exports.Profiler = Profiler;\n"]},"metadata":{},"sourceType":"script"}