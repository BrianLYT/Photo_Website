{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst path = require(\"path\");\n\nconst CHAR_HASH = \"#\".charCodeAt(0);\nconst CHAR_SLASH = \"/\".charCodeAt(0);\nconst CHAR_BACKSLASH = \"\\\\\".charCodeAt(0);\nconst CHAR_A = \"A\".charCodeAt(0);\nconst CHAR_Z = \"Z\".charCodeAt(0);\nconst CHAR_LOWER_A = \"a\".charCodeAt(0);\nconst CHAR_LOWER_Z = \"z\".charCodeAt(0);\nconst CHAR_DOT = \".\".charCodeAt(0);\nconst CHAR_COLON = \":\".charCodeAt(0);\nconst posixNormalize = path.posix.normalize;\nconst winNormalize = path.win32.normalize;\n/**\n * @enum {number}\n */\n\nconst PathType = Object.freeze({\n  Empty: 0,\n  Normal: 1,\n  Relative: 2,\n  AbsoluteWin: 3,\n  AbsolutePosix: 4,\n  Internal: 5\n});\nexports.PathType = PathType;\n/**\n * @param {string} p a path\n * @returns {PathType} type of path\n */\n\nconst getType = p => {\n  switch (p.length) {\n    case 0:\n      return PathType.Empty;\n\n    case 1:\n      {\n        const c0 = p.charCodeAt(0);\n\n        switch (c0) {\n          case CHAR_DOT:\n            return PathType.Relative;\n\n          case CHAR_SLASH:\n            return PathType.AbsolutePosix;\n\n          case CHAR_HASH:\n            return PathType.Internal;\n        }\n\n        return PathType.Normal;\n      }\n\n    case 2:\n      {\n        const c0 = p.charCodeAt(0);\n\n        switch (c0) {\n          case CHAR_DOT:\n            {\n              const c1 = p.charCodeAt(1);\n\n              switch (c1) {\n                case CHAR_DOT:\n                case CHAR_SLASH:\n                  return PathType.Relative;\n              }\n\n              return PathType.Normal;\n            }\n\n          case CHAR_SLASH:\n            return PathType.AbsolutePosix;\n\n          case CHAR_HASH:\n            return PathType.Internal;\n        }\n\n        const c1 = p.charCodeAt(1);\n\n        if (c1 === CHAR_COLON) {\n          if (c0 >= CHAR_A && c0 <= CHAR_Z || c0 >= CHAR_LOWER_A && c0 <= CHAR_LOWER_Z) {\n            return PathType.AbsoluteWin;\n          }\n        }\n\n        return PathType.Normal;\n      }\n  }\n\n  const c0 = p.charCodeAt(0);\n\n  switch (c0) {\n    case CHAR_DOT:\n      {\n        const c1 = p.charCodeAt(1);\n\n        switch (c1) {\n          case CHAR_SLASH:\n            return PathType.Relative;\n\n          case CHAR_DOT:\n            {\n              const c2 = p.charCodeAt(2);\n              if (c2 === CHAR_SLASH) return PathType.Relative;\n              return PathType.Normal;\n            }\n        }\n\n        return PathType.Normal;\n      }\n\n    case CHAR_SLASH:\n      return PathType.AbsolutePosix;\n\n    case CHAR_HASH:\n      return PathType.Internal;\n  }\n\n  const c1 = p.charCodeAt(1);\n\n  if (c1 === CHAR_COLON) {\n    const c2 = p.charCodeAt(2);\n\n    if ((c2 === CHAR_BACKSLASH || c2 === CHAR_SLASH) && (c0 >= CHAR_A && c0 <= CHAR_Z || c0 >= CHAR_LOWER_A && c0 <= CHAR_LOWER_Z)) {\n      return PathType.AbsoluteWin;\n    }\n  }\n\n  return PathType.Normal;\n};\n\nexports.getType = getType;\n/**\n * @param {string} p a path\n * @returns {string} the normalized path\n */\n\nconst normalize = p => {\n  switch (getType(p)) {\n    case PathType.Empty:\n      return p;\n\n    case PathType.AbsoluteWin:\n      return winNormalize(p);\n\n    case PathType.Relative:\n      {\n        const r = posixNormalize(p);\n        return getType(r) === PathType.Relative ? r : `./${r}`;\n      }\n  }\n\n  return posixNormalize(p);\n};\n\nexports.normalize = normalize;\n/**\n * @param {string} rootPath the root path\n * @param {string | undefined} request the request path\n * @returns {string} the joined path\n */\n\nconst join = (rootPath, request) => {\n  if (!request) return normalize(rootPath);\n  const requestType = getType(request);\n\n  switch (requestType) {\n    case PathType.AbsolutePosix:\n      return posixNormalize(request);\n\n    case PathType.AbsoluteWin:\n      return winNormalize(request);\n  }\n\n  switch (getType(rootPath)) {\n    case PathType.Normal:\n    case PathType.Relative:\n    case PathType.AbsolutePosix:\n      return posixNormalize(`${rootPath}/${request}`);\n\n    case PathType.AbsoluteWin:\n      return winNormalize(`${rootPath}\\\\${request}`);\n  }\n\n  switch (requestType) {\n    case PathType.Empty:\n      return rootPath;\n\n    case PathType.Relative:\n      {\n        const r = posixNormalize(rootPath);\n        return getType(r) === PathType.Relative ? r : `./${r}`;\n      }\n  }\n\n  return posixNormalize(rootPath);\n};\n\nexports.join = join;\nconst joinCache = new Map();\n/**\n * @param {string} rootPath the root path\n * @param {string | undefined} request the request path\n * @returns {string} the joined path\n */\n\nconst cachedJoin = (rootPath, request) => {\n  let cacheEntry;\n  let cache = joinCache.get(rootPath);\n\n  if (cache === undefined) {\n    joinCache.set(rootPath, cache = new Map());\n  } else {\n    cacheEntry = cache.get(request);\n    if (cacheEntry !== undefined) return cacheEntry;\n  }\n\n  cacheEntry = join(rootPath, request);\n  cache.set(request, cacheEntry);\n  return cacheEntry;\n};\n\nexports.cachedJoin = cachedJoin;\n\nconst checkExportsFieldTarget = relativePath => {\n  let lastNonSlashIndex = 2;\n  let slashIndex = relativePath.indexOf(\"/\", 2);\n  let cd = 0;\n\n  while (slashIndex !== -1) {\n    const folder = relativePath.slice(lastNonSlashIndex, slashIndex);\n\n    switch (folder) {\n      case \"..\":\n        {\n          cd--;\n          if (cd < 0) return new Error(`Trying to access out of package scope. Requesting ${relativePath}`);\n          break;\n        }\n\n      default:\n        cd++;\n        break;\n    }\n\n    lastNonSlashIndex = slashIndex + 1;\n    slashIndex = relativePath.indexOf(\"/\", lastNonSlashIndex);\n  }\n};\n\nexports.checkExportsFieldTarget = checkExportsFieldTarget;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/enhanced-resolve/lib/util/path.js"],"names":["path","require","CHAR_HASH","charCodeAt","CHAR_SLASH","CHAR_BACKSLASH","CHAR_A","CHAR_Z","CHAR_LOWER_A","CHAR_LOWER_Z","CHAR_DOT","CHAR_COLON","posixNormalize","posix","normalize","winNormalize","win32","PathType","Object","freeze","Empty","Normal","Relative","AbsoluteWin","AbsolutePosix","Internal","exports","getType","p","length","c0","c1","c2","r","join","rootPath","request","requestType","joinCache","Map","cachedJoin","cacheEntry","cache","get","undefined","set","checkExportsFieldTarget","relativePath","lastNonSlashIndex","slashIndex","indexOf","cd","folder","slice","Error"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AAEA,MAAMC,SAAS,GAAG,IAAIC,UAAJ,CAAe,CAAf,CAAlB;AACA,MAAMC,UAAU,GAAG,IAAID,UAAJ,CAAe,CAAf,CAAnB;AACA,MAAME,cAAc,GAAG,KAAKF,UAAL,CAAgB,CAAhB,CAAvB;AACA,MAAMG,MAAM,GAAG,IAAIH,UAAJ,CAAe,CAAf,CAAf;AACA,MAAMI,MAAM,GAAG,IAAIJ,UAAJ,CAAe,CAAf,CAAf;AACA,MAAMK,YAAY,GAAG,IAAIL,UAAJ,CAAe,CAAf,CAArB;AACA,MAAMM,YAAY,GAAG,IAAIN,UAAJ,CAAe,CAAf,CAArB;AACA,MAAMO,QAAQ,GAAG,IAAIP,UAAJ,CAAe,CAAf,CAAjB;AACA,MAAMQ,UAAU,GAAG,IAAIR,UAAJ,CAAe,CAAf,CAAnB;AAEA,MAAMS,cAAc,GAAGZ,IAAI,CAACa,KAAL,CAAWC,SAAlC;AACA,MAAMC,YAAY,GAAGf,IAAI,CAACgB,KAAL,CAAWF,SAAhC;AAEA;AACA;AACA;;AACA,MAAMG,QAAQ,GAAGC,MAAM,CAACC,MAAP,CAAc;AAC9BC,EAAAA,KAAK,EAAE,CADuB;AAE9BC,EAAAA,MAAM,EAAE,CAFsB;AAG9BC,EAAAA,QAAQ,EAAE,CAHoB;AAI9BC,EAAAA,WAAW,EAAE,CAJiB;AAK9BC,EAAAA,aAAa,EAAE,CALe;AAM9BC,EAAAA,QAAQ,EAAE;AANoB,CAAd,CAAjB;AAQAC,OAAO,CAACT,QAAR,GAAmBA,QAAnB;AAEA;AACA;AACA;AACA;;AACA,MAAMU,OAAO,GAAGC,CAAC,IAAI;AACpB,UAAQA,CAAC,CAACC,MAAV;AACC,SAAK,CAAL;AACC,aAAOZ,QAAQ,CAACG,KAAhB;;AACD,SAAK,CAAL;AAAQ;AACP,cAAMU,EAAE,GAAGF,CAAC,CAACzB,UAAF,CAAa,CAAb,CAAX;;AACA,gBAAQ2B,EAAR;AACC,eAAKpB,QAAL;AACC,mBAAOO,QAAQ,CAACK,QAAhB;;AACD,eAAKlB,UAAL;AACC,mBAAOa,QAAQ,CAACO,aAAhB;;AACD,eAAKtB,SAAL;AACC,mBAAOe,QAAQ,CAACQ,QAAhB;AANF;;AAQA,eAAOR,QAAQ,CAACI,MAAhB;AACA;;AACD,SAAK,CAAL;AAAQ;AACP,cAAMS,EAAE,GAAGF,CAAC,CAACzB,UAAF,CAAa,CAAb,CAAX;;AACA,gBAAQ2B,EAAR;AACC,eAAKpB,QAAL;AAAe;AACd,oBAAMqB,EAAE,GAAGH,CAAC,CAACzB,UAAF,CAAa,CAAb,CAAX;;AACA,sBAAQ4B,EAAR;AACC,qBAAKrB,QAAL;AACA,qBAAKN,UAAL;AACC,yBAAOa,QAAQ,CAACK,QAAhB;AAHF;;AAKA,qBAAOL,QAAQ,CAACI,MAAhB;AACA;;AACD,eAAKjB,UAAL;AACC,mBAAOa,QAAQ,CAACO,aAAhB;;AACD,eAAKtB,SAAL;AACC,mBAAOe,QAAQ,CAACQ,QAAhB;AAbF;;AAeA,cAAMM,EAAE,GAAGH,CAAC,CAACzB,UAAF,CAAa,CAAb,CAAX;;AACA,YAAI4B,EAAE,KAAKpB,UAAX,EAAuB;AACtB,cACEmB,EAAE,IAAIxB,MAAN,IAAgBwB,EAAE,IAAIvB,MAAvB,IACCuB,EAAE,IAAItB,YAAN,IAAsBsB,EAAE,IAAIrB,YAF9B,EAGE;AACD,mBAAOQ,QAAQ,CAACM,WAAhB;AACA;AACD;;AACD,eAAON,QAAQ,CAACI,MAAhB;AACA;AA1CF;;AA4CA,QAAMS,EAAE,GAAGF,CAAC,CAACzB,UAAF,CAAa,CAAb,CAAX;;AACA,UAAQ2B,EAAR;AACC,SAAKpB,QAAL;AAAe;AACd,cAAMqB,EAAE,GAAGH,CAAC,CAACzB,UAAF,CAAa,CAAb,CAAX;;AACA,gBAAQ4B,EAAR;AACC,eAAK3B,UAAL;AACC,mBAAOa,QAAQ,CAACK,QAAhB;;AACD,eAAKZ,QAAL;AAAe;AACd,oBAAMsB,EAAE,GAAGJ,CAAC,CAACzB,UAAF,CAAa,CAAb,CAAX;AACA,kBAAI6B,EAAE,KAAK5B,UAAX,EAAuB,OAAOa,QAAQ,CAACK,QAAhB;AACvB,qBAAOL,QAAQ,CAACI,MAAhB;AACA;AAPF;;AASA,eAAOJ,QAAQ,CAACI,MAAhB;AACA;;AACD,SAAKjB,UAAL;AACC,aAAOa,QAAQ,CAACO,aAAhB;;AACD,SAAKtB,SAAL;AACC,aAAOe,QAAQ,CAACQ,QAAhB;AAjBF;;AAmBA,QAAMM,EAAE,GAAGH,CAAC,CAACzB,UAAF,CAAa,CAAb,CAAX;;AACA,MAAI4B,EAAE,KAAKpB,UAAX,EAAuB;AACtB,UAAMqB,EAAE,GAAGJ,CAAC,CAACzB,UAAF,CAAa,CAAb,CAAX;;AACA,QACC,CAAC6B,EAAE,KAAK3B,cAAP,IAAyB2B,EAAE,KAAK5B,UAAjC,MACE0B,EAAE,IAAIxB,MAAN,IAAgBwB,EAAE,IAAIvB,MAAvB,IACCuB,EAAE,IAAItB,YAAN,IAAsBsB,EAAE,IAAIrB,YAF9B,CADD,EAIE;AACD,aAAOQ,QAAQ,CAACM,WAAhB;AACA;AACD;;AACD,SAAON,QAAQ,CAACI,MAAhB;AACA,CA7ED;;AA8EAK,OAAO,CAACC,OAAR,GAAkBA,OAAlB;AAEA;AACA;AACA;AACA;;AACA,MAAMb,SAAS,GAAGc,CAAC,IAAI;AACtB,UAAQD,OAAO,CAACC,CAAD,CAAf;AACC,SAAKX,QAAQ,CAACG,KAAd;AACC,aAAOQ,CAAP;;AACD,SAAKX,QAAQ,CAACM,WAAd;AACC,aAAOR,YAAY,CAACa,CAAD,CAAnB;;AACD,SAAKX,QAAQ,CAACK,QAAd;AAAwB;AACvB,cAAMW,CAAC,GAAGrB,cAAc,CAACgB,CAAD,CAAxB;AACA,eAAOD,OAAO,CAACM,CAAD,CAAP,KAAehB,QAAQ,CAACK,QAAxB,GAAmCW,CAAnC,GAAwC,KAAIA,CAAE,EAArD;AACA;AARF;;AAUA,SAAOrB,cAAc,CAACgB,CAAD,CAArB;AACA,CAZD;;AAaAF,OAAO,CAACZ,SAAR,GAAoBA,SAApB;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAMoB,IAAI,GAAG,CAACC,QAAD,EAAWC,OAAX,KAAuB;AACnC,MAAI,CAACA,OAAL,EAAc,OAAOtB,SAAS,CAACqB,QAAD,CAAhB;AACd,QAAME,WAAW,GAAGV,OAAO,CAACS,OAAD,CAA3B;;AACA,UAAQC,WAAR;AACC,SAAKpB,QAAQ,CAACO,aAAd;AACC,aAAOZ,cAAc,CAACwB,OAAD,CAArB;;AACD,SAAKnB,QAAQ,CAACM,WAAd;AACC,aAAOR,YAAY,CAACqB,OAAD,CAAnB;AAJF;;AAMA,UAAQT,OAAO,CAACQ,QAAD,CAAf;AACC,SAAKlB,QAAQ,CAACI,MAAd;AACA,SAAKJ,QAAQ,CAACK,QAAd;AACA,SAAKL,QAAQ,CAACO,aAAd;AACC,aAAOZ,cAAc,CAAE,GAAEuB,QAAS,IAAGC,OAAQ,EAAxB,CAArB;;AACD,SAAKnB,QAAQ,CAACM,WAAd;AACC,aAAOR,YAAY,CAAE,GAAEoB,QAAS,KAAIC,OAAQ,EAAzB,CAAnB;AANF;;AAQA,UAAQC,WAAR;AACC,SAAKpB,QAAQ,CAACG,KAAd;AACC,aAAOe,QAAP;;AACD,SAAKlB,QAAQ,CAACK,QAAd;AAAwB;AACvB,cAAMW,CAAC,GAAGrB,cAAc,CAACuB,QAAD,CAAxB;AACA,eAAOR,OAAO,CAACM,CAAD,CAAP,KAAehB,QAAQ,CAACK,QAAxB,GAAmCW,CAAnC,GAAwC,KAAIA,CAAE,EAArD;AACA;AANF;;AAQA,SAAOrB,cAAc,CAACuB,QAAD,CAArB;AACA,CA1BD;;AA2BAT,OAAO,CAACQ,IAAR,GAAeA,IAAf;AAEA,MAAMI,SAAS,GAAG,IAAIC,GAAJ,EAAlB;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAMC,UAAU,GAAG,CAACL,QAAD,EAAWC,OAAX,KAAuB;AACzC,MAAIK,UAAJ;AACA,MAAIC,KAAK,GAAGJ,SAAS,CAACK,GAAV,CAAcR,QAAd,CAAZ;;AACA,MAAIO,KAAK,KAAKE,SAAd,EAAyB;AACxBN,IAAAA,SAAS,CAACO,GAAV,CAAcV,QAAd,EAAyBO,KAAK,GAAG,IAAIH,GAAJ,EAAjC;AACA,GAFD,MAEO;AACNE,IAAAA,UAAU,GAAGC,KAAK,CAACC,GAAN,CAAUP,OAAV,CAAb;AACA,QAAIK,UAAU,KAAKG,SAAnB,EAA8B,OAAOH,UAAP;AAC9B;;AACDA,EAAAA,UAAU,GAAGP,IAAI,CAACC,QAAD,EAAWC,OAAX,CAAjB;AACAM,EAAAA,KAAK,CAACG,GAAN,CAAUT,OAAV,EAAmBK,UAAnB;AACA,SAAOA,UAAP;AACA,CAZD;;AAaAf,OAAO,CAACc,UAAR,GAAqBA,UAArB;;AAEA,MAAMM,uBAAuB,GAAGC,YAAY,IAAI;AAC/C,MAAIC,iBAAiB,GAAG,CAAxB;AACA,MAAIC,UAAU,GAAGF,YAAY,CAACG,OAAb,CAAqB,GAArB,EAA0B,CAA1B,CAAjB;AACA,MAAIC,EAAE,GAAG,CAAT;;AAEA,SAAOF,UAAU,KAAK,CAAC,CAAvB,EAA0B;AACzB,UAAMG,MAAM,GAAGL,YAAY,CAACM,KAAb,CAAmBL,iBAAnB,EAAsCC,UAAtC,CAAf;;AAEA,YAAQG,MAAR;AACC,WAAK,IAAL;AAAW;AACVD,UAAAA,EAAE;AACF,cAAIA,EAAE,GAAG,CAAT,EACC,OAAO,IAAIG,KAAJ,CACL,qDAAoDP,YAAa,EAD5D,CAAP;AAGD;AACA;;AACD;AACCI,QAAAA,EAAE;AACF;AAXF;;AAcAH,IAAAA,iBAAiB,GAAGC,UAAU,GAAG,CAAjC;AACAA,IAAAA,UAAU,GAAGF,YAAY,CAACG,OAAb,CAAqB,GAArB,EAA0BF,iBAA1B,CAAb;AACA;AACD,CAzBD;;AA0BAtB,OAAO,CAACoB,uBAAR,GAAkCA,uBAAlC","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\n\nconst CHAR_HASH = \"#\".charCodeAt(0);\nconst CHAR_SLASH = \"/\".charCodeAt(0);\nconst CHAR_BACKSLASH = \"\\\\\".charCodeAt(0);\nconst CHAR_A = \"A\".charCodeAt(0);\nconst CHAR_Z = \"Z\".charCodeAt(0);\nconst CHAR_LOWER_A = \"a\".charCodeAt(0);\nconst CHAR_LOWER_Z = \"z\".charCodeAt(0);\nconst CHAR_DOT = \".\".charCodeAt(0);\nconst CHAR_COLON = \":\".charCodeAt(0);\n\nconst posixNormalize = path.posix.normalize;\nconst winNormalize = path.win32.normalize;\n\n/**\n * @enum {number}\n */\nconst PathType = Object.freeze({\n\tEmpty: 0,\n\tNormal: 1,\n\tRelative: 2,\n\tAbsoluteWin: 3,\n\tAbsolutePosix: 4,\n\tInternal: 5\n});\nexports.PathType = PathType;\n\n/**\n * @param {string} p a path\n * @returns {PathType} type of path\n */\nconst getType = p => {\n\tswitch (p.length) {\n\t\tcase 0:\n\t\t\treturn PathType.Empty;\n\t\tcase 1: {\n\t\t\tconst c0 = p.charCodeAt(0);\n\t\t\tswitch (c0) {\n\t\t\t\tcase CHAR_DOT:\n\t\t\t\t\treturn PathType.Relative;\n\t\t\t\tcase CHAR_SLASH:\n\t\t\t\t\treturn PathType.AbsolutePosix;\n\t\t\t\tcase CHAR_HASH:\n\t\t\t\t\treturn PathType.Internal;\n\t\t\t}\n\t\t\treturn PathType.Normal;\n\t\t}\n\t\tcase 2: {\n\t\t\tconst c0 = p.charCodeAt(0);\n\t\t\tswitch (c0) {\n\t\t\t\tcase CHAR_DOT: {\n\t\t\t\t\tconst c1 = p.charCodeAt(1);\n\t\t\t\t\tswitch (c1) {\n\t\t\t\t\t\tcase CHAR_DOT:\n\t\t\t\t\t\tcase CHAR_SLASH:\n\t\t\t\t\t\t\treturn PathType.Relative;\n\t\t\t\t\t}\n\t\t\t\t\treturn PathType.Normal;\n\t\t\t\t}\n\t\t\t\tcase CHAR_SLASH:\n\t\t\t\t\treturn PathType.AbsolutePosix;\n\t\t\t\tcase CHAR_HASH:\n\t\t\t\t\treturn PathType.Internal;\n\t\t\t}\n\t\t\tconst c1 = p.charCodeAt(1);\n\t\t\tif (c1 === CHAR_COLON) {\n\t\t\t\tif (\n\t\t\t\t\t(c0 >= CHAR_A && c0 <= CHAR_Z) ||\n\t\t\t\t\t(c0 >= CHAR_LOWER_A && c0 <= CHAR_LOWER_Z)\n\t\t\t\t) {\n\t\t\t\t\treturn PathType.AbsoluteWin;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn PathType.Normal;\n\t\t}\n\t}\n\tconst c0 = p.charCodeAt(0);\n\tswitch (c0) {\n\t\tcase CHAR_DOT: {\n\t\t\tconst c1 = p.charCodeAt(1);\n\t\t\tswitch (c1) {\n\t\t\t\tcase CHAR_SLASH:\n\t\t\t\t\treturn PathType.Relative;\n\t\t\t\tcase CHAR_DOT: {\n\t\t\t\t\tconst c2 = p.charCodeAt(2);\n\t\t\t\t\tif (c2 === CHAR_SLASH) return PathType.Relative;\n\t\t\t\t\treturn PathType.Normal;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn PathType.Normal;\n\t\t}\n\t\tcase CHAR_SLASH:\n\t\t\treturn PathType.AbsolutePosix;\n\t\tcase CHAR_HASH:\n\t\t\treturn PathType.Internal;\n\t}\n\tconst c1 = p.charCodeAt(1);\n\tif (c1 === CHAR_COLON) {\n\t\tconst c2 = p.charCodeAt(2);\n\t\tif (\n\t\t\t(c2 === CHAR_BACKSLASH || c2 === CHAR_SLASH) &&\n\t\t\t((c0 >= CHAR_A && c0 <= CHAR_Z) ||\n\t\t\t\t(c0 >= CHAR_LOWER_A && c0 <= CHAR_LOWER_Z))\n\t\t) {\n\t\t\treturn PathType.AbsoluteWin;\n\t\t}\n\t}\n\treturn PathType.Normal;\n};\nexports.getType = getType;\n\n/**\n * @param {string} p a path\n * @returns {string} the normalized path\n */\nconst normalize = p => {\n\tswitch (getType(p)) {\n\t\tcase PathType.Empty:\n\t\t\treturn p;\n\t\tcase PathType.AbsoluteWin:\n\t\t\treturn winNormalize(p);\n\t\tcase PathType.Relative: {\n\t\t\tconst r = posixNormalize(p);\n\t\t\treturn getType(r) === PathType.Relative ? r : `./${r}`;\n\t\t}\n\t}\n\treturn posixNormalize(p);\n};\nexports.normalize = normalize;\n\n/**\n * @param {string} rootPath the root path\n * @param {string | undefined} request the request path\n * @returns {string} the joined path\n */\nconst join = (rootPath, request) => {\n\tif (!request) return normalize(rootPath);\n\tconst requestType = getType(request);\n\tswitch (requestType) {\n\t\tcase PathType.AbsolutePosix:\n\t\t\treturn posixNormalize(request);\n\t\tcase PathType.AbsoluteWin:\n\t\t\treturn winNormalize(request);\n\t}\n\tswitch (getType(rootPath)) {\n\t\tcase PathType.Normal:\n\t\tcase PathType.Relative:\n\t\tcase PathType.AbsolutePosix:\n\t\t\treturn posixNormalize(`${rootPath}/${request}`);\n\t\tcase PathType.AbsoluteWin:\n\t\t\treturn winNormalize(`${rootPath}\\\\${request}`);\n\t}\n\tswitch (requestType) {\n\t\tcase PathType.Empty:\n\t\t\treturn rootPath;\n\t\tcase PathType.Relative: {\n\t\t\tconst r = posixNormalize(rootPath);\n\t\t\treturn getType(r) === PathType.Relative ? r : `./${r}`;\n\t\t}\n\t}\n\treturn posixNormalize(rootPath);\n};\nexports.join = join;\n\nconst joinCache = new Map();\n\n/**\n * @param {string} rootPath the root path\n * @param {string | undefined} request the request path\n * @returns {string} the joined path\n */\nconst cachedJoin = (rootPath, request) => {\n\tlet cacheEntry;\n\tlet cache = joinCache.get(rootPath);\n\tif (cache === undefined) {\n\t\tjoinCache.set(rootPath, (cache = new Map()));\n\t} else {\n\t\tcacheEntry = cache.get(request);\n\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t}\n\tcacheEntry = join(rootPath, request);\n\tcache.set(request, cacheEntry);\n\treturn cacheEntry;\n};\nexports.cachedJoin = cachedJoin;\n\nconst checkExportsFieldTarget = relativePath => {\n\tlet lastNonSlashIndex = 2;\n\tlet slashIndex = relativePath.indexOf(\"/\", 2);\n\tlet cd = 0;\n\n\twhile (slashIndex !== -1) {\n\t\tconst folder = relativePath.slice(lastNonSlashIndex, slashIndex);\n\n\t\tswitch (folder) {\n\t\t\tcase \"..\": {\n\t\t\t\tcd--;\n\t\t\t\tif (cd < 0)\n\t\t\t\t\treturn new Error(\n\t\t\t\t\t\t`Trying to access out of package scope. Requesting ${relativePath}`\n\t\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tcd++;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlastNonSlashIndex = slashIndex + 1;\n\t\tslashIndex = relativePath.indexOf(\"/\", lastNonSlashIndex);\n\t}\n};\nexports.checkExportsFieldTarget = checkExportsFieldTarget;\n"]},"metadata":{},"sourceType":"script"}