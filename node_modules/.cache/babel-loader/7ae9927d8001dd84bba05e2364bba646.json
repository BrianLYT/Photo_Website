{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\n\nconst RuntimeModule = require(\"../RuntimeModule\");\n\nconst Template = require(\"../Template\");\n\nconst {\n  compareModulesByIdentifier\n} = require(\"../util/comparators\");\n\nconst WebAssemblyUtils = require(\"./WebAssemblyUtils\");\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n// TODO webpack 6 remove the whole folder\n// Get all wasm modules\n\n\nconst getAllWasmModules = (moduleGraph, chunkGraph, chunk) => {\n  const wasmModules = chunk.getAllAsyncChunks();\n  const array = [];\n\n  for (const chunk of wasmModules) {\n    for (const m of chunkGraph.getOrderedChunkModulesIterable(chunk, compareModulesByIdentifier)) {\n      if (m.type.startsWith(\"webassembly\")) {\n        array.push(m);\n      }\n    }\n  }\n\n  return array;\n};\n/**\n * generates the import object function for a module\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Module} module the module\n * @param {boolean} mangle mangle imports\n * @param {string[]} declarations array where declarations are pushed to\n * @param {RuntimeSpec} runtime the runtime\n * @returns {string} source code\n */\n\n\nconst generateImportObject = (chunkGraph, module, mangle, declarations, runtime) => {\n  const moduleGraph = chunkGraph.moduleGraph;\n  const waitForInstances = new Map();\n  const properties = [];\n  const usedWasmDependencies = WebAssemblyUtils.getUsedDependencies(moduleGraph, module, mangle);\n\n  for (const usedDep of usedWasmDependencies) {\n    const dep = usedDep.dependency;\n    const importedModule = moduleGraph.getModule(dep);\n    const exportName = dep.name;\n    const usedName = importedModule && moduleGraph.getExportsInfo(importedModule).getUsedName(exportName, runtime);\n    const description = dep.description;\n    const direct = dep.onlyDirectImport;\n    const module = usedDep.module;\n    const name = usedDep.name;\n\n    if (direct) {\n      const instanceVar = `m${waitForInstances.size}`;\n      waitForInstances.set(instanceVar, chunkGraph.getModuleId(importedModule));\n      properties.push({\n        module,\n        name,\n        value: `${instanceVar}[${JSON.stringify(usedName)}]`\n      });\n    } else {\n      const params = description.signature.params.map((param, k) => \"p\" + k + param.valtype);\n      const mod = `${RuntimeGlobals.moduleCache}[${JSON.stringify(chunkGraph.getModuleId(importedModule))}]`;\n      const modExports = `${mod}.exports`;\n      const cache = `wasmImportedFuncCache${declarations.length}`;\n      declarations.push(`var ${cache};`);\n      properties.push({\n        module,\n        name,\n        value: Template.asString([(importedModule.type.startsWith(\"webassembly\") ? `${mod} ? ${modExports}[${JSON.stringify(usedName)}] : ` : \"\") + `function(${params}) {`, Template.indent([`if(${cache} === undefined) ${cache} = ${modExports};`, `return ${cache}[${JSON.stringify(usedName)}](${params});`]), \"}\"])\n      });\n    }\n  }\n\n  let importObject;\n\n  if (mangle) {\n    importObject = [\"return {\", Template.indent([properties.map(p => `${JSON.stringify(p.name)}: ${p.value}`).join(\",\\n\")]), \"};\"];\n  } else {\n    const propertiesByModule = new Map();\n\n    for (const p of properties) {\n      let list = propertiesByModule.get(p.module);\n\n      if (list === undefined) {\n        propertiesByModule.set(p.module, list = []);\n      }\n\n      list.push(p);\n    }\n\n    importObject = [\"return {\", Template.indent([Array.from(propertiesByModule, _ref => {\n      let [module, list] = _ref;\n      return Template.asString([`${JSON.stringify(module)}: {`, Template.indent([list.map(p => `${JSON.stringify(p.name)}: ${p.value}`).join(\",\\n\")]), \"}\"]);\n    }).join(\",\\n\")]), \"};\"];\n  }\n\n  const moduleIdStringified = JSON.stringify(chunkGraph.getModuleId(module));\n\n  if (waitForInstances.size === 1) {\n    const moduleId = Array.from(waitForInstances.values())[0];\n    const promise = `installedWasmModules[${JSON.stringify(moduleId)}]`;\n    const variable = Array.from(waitForInstances.keys())[0];\n    return Template.asString([`${moduleIdStringified}: function() {`, Template.indent([`return promiseResolve().then(function() { return ${promise}; }).then(function(${variable}) {`, Template.indent(importObject), \"});\"]), \"},\"]);\n  } else if (waitForInstances.size > 0) {\n    const promises = Array.from(waitForInstances.values(), id => `installedWasmModules[${JSON.stringify(id)}]`).join(\", \");\n    const variables = Array.from(waitForInstances.keys(), (name, i) => `${name} = array[${i}]`).join(\", \");\n    return Template.asString([`${moduleIdStringified}: function() {`, Template.indent([`return promiseResolve().then(function() { return Promise.all([${promises}]); }).then(function(array) {`, Template.indent([`var ${variables};`, ...importObject]), \"});\"]), \"},\"]);\n  } else {\n    return Template.asString([`${moduleIdStringified}: function() {`, Template.indent(importObject), \"},\"]);\n  }\n};\n\nclass WasmChunkLoadingRuntimeModule extends RuntimeModule {\n  constructor(_ref2) {\n    let {\n      generateLoadBinaryCode,\n      supportsStreaming,\n      mangleImports,\n      runtimeRequirements\n    } = _ref2;\n    super(\"wasm chunk loading\", RuntimeModule.STAGE_ATTACH);\n    this.generateLoadBinaryCode = generateLoadBinaryCode;\n    this.supportsStreaming = supportsStreaming;\n    this.mangleImports = mangleImports;\n    this._runtimeRequirements = runtimeRequirements;\n  }\n  /**\n   * @returns {string} runtime code\n   */\n\n\n  generate() {\n    const {\n      chunkGraph,\n      compilation,\n      chunk,\n      mangleImports\n    } = this;\n    const {\n      moduleGraph,\n      outputOptions\n    } = compilation;\n    const fn = RuntimeGlobals.ensureChunkHandlers;\n\n    const withHmr = this._runtimeRequirements.has(RuntimeGlobals.hmrDownloadUpdateHandlers);\n\n    const wasmModules = getAllWasmModules(moduleGraph, chunkGraph, chunk);\n    const declarations = [];\n    const importObjects = wasmModules.map(module => {\n      return generateImportObject(chunkGraph, module, this.mangleImports, declarations, chunk.runtime);\n    });\n    const chunkModuleIdMap = chunkGraph.getChunkModuleIdMap(chunk, m => m.type.startsWith(\"webassembly\"));\n\n    const createImportObject = content => mangleImports ? `{ ${JSON.stringify(WebAssemblyUtils.MANGLED_MODULE)}: ${content} }` : content;\n\n    const wasmModuleSrcPath = compilation.getPath(JSON.stringify(outputOptions.webassemblyModuleFilename), {\n      hash: `\" + ${RuntimeGlobals.getFullHash}() + \"`,\n      hashWithLength: length => `\" + ${RuntimeGlobals.getFullHash}}().slice(0, ${length}) + \"`,\n      module: {\n        id: '\" + wasmModuleId + \"',\n        hash: `\" + ${JSON.stringify(chunkGraph.getChunkModuleRenderedHashMap(chunk, m => m.type.startsWith(\"webassembly\")))}[chunkId][wasmModuleId] + \"`,\n\n        hashWithLength(length) {\n          return `\" + ${JSON.stringify(chunkGraph.getChunkModuleRenderedHashMap(chunk, m => m.type.startsWith(\"webassembly\"), length))}[chunkId][wasmModuleId] + \"`;\n        }\n\n      },\n      runtime: chunk.runtime\n    });\n    const stateExpression = withHmr ? `${RuntimeGlobals.hmrRuntimeStatePrefix}_wasm` : undefined;\n    return Template.asString([\"// object to store loaded and loading wasm modules\", `var installedWasmModules = ${stateExpression ? `${stateExpression} = ${stateExpression} || ` : \"\"}{};`, \"\", // This function is used to delay reading the installed wasm module promises\n    // by a microtask. Sorting them doesn't help because there are edge cases where\n    // sorting is not possible (modules splitted into different chunks).\n    // So we not even trying and solve this by a microtask delay.\n    \"function promiseResolve() { return Promise.resolve(); }\", \"\", Template.asString(declarations), \"var wasmImportObjects = {\", Template.indent(importObjects), \"};\", \"\", `var wasmModuleMap = ${JSON.stringify(chunkModuleIdMap, undefined, \"\\t\")};`, \"\", \"// object with all WebAssembly.instance exports\", `${RuntimeGlobals.wasmInstances} = {};`, \"\", \"// Fetch + compile chunk loading for webassembly\", `${fn}.wasm = function(chunkId, promises) {`, Template.indent([\"\", `var wasmModules = wasmModuleMap[chunkId] || [];`, \"\", \"wasmModules.forEach(function(wasmModuleId, idx) {\", Template.indent([\"var installedWasmModuleData = installedWasmModules[wasmModuleId];\", \"\", '// a Promise means \"currently loading\" or \"already loaded\".', \"if(installedWasmModuleData)\", Template.indent([\"promises.push(installedWasmModuleData);\"]), \"else {\", Template.indent([`var importObject = wasmImportObjects[wasmModuleId]();`, `var req = ${this.generateLoadBinaryCode(wasmModuleSrcPath)};`, \"var promise;\", this.supportsStreaming ? Template.asString([\"if(importObject && typeof importObject.then === 'function' && typeof WebAssembly.compileStreaming === 'function') {\", Template.indent([\"promise = Promise.all([WebAssembly.compileStreaming(req), importObject]).then(function(items) {\", Template.indent([`return WebAssembly.instantiate(items[0], ${createImportObject(\"items[1]\")});`]), \"});\"]), \"} else if(typeof WebAssembly.instantiateStreaming === 'function') {\", Template.indent([`promise = WebAssembly.instantiateStreaming(req, ${createImportObject(\"importObject\")});`])]) : Template.asString([\"if(importObject && typeof importObject.then === 'function') {\", Template.indent([\"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\", \"promise = Promise.all([\", Template.indent([\"bytesPromise.then(function(bytes) { return WebAssembly.compile(bytes); }),\", \"importObject\"]), \"]).then(function(items) {\", Template.indent([`return WebAssembly.instantiate(items[0], ${createImportObject(\"items[1]\")});`]), \"});\"])]), \"} else {\", Template.indent([\"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\", \"promise = bytesPromise.then(function(bytes) {\", Template.indent([`return WebAssembly.instantiate(bytes, ${createImportObject(\"importObject\")});`]), \"});\"]), \"}\", \"promises.push(installedWasmModules[wasmModuleId] = promise.then(function(res) {\", Template.indent([`return ${RuntimeGlobals.wasmInstances}[wasmModuleId] = (res.instance || res).exports;`]), \"}));\"]), \"}\"]), \"});\"]), \"};\"]);\n  }\n\n}\n\nmodule.exports = WasmChunkLoadingRuntimeModule;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/wasm-sync/WasmChunkLoadingRuntimeModule.js"],"names":["RuntimeGlobals","require","RuntimeModule","Template","compareModulesByIdentifier","WebAssemblyUtils","getAllWasmModules","moduleGraph","chunkGraph","chunk","wasmModules","getAllAsyncChunks","array","m","getOrderedChunkModulesIterable","type","startsWith","push","generateImportObject","module","mangle","declarations","runtime","waitForInstances","Map","properties","usedWasmDependencies","getUsedDependencies","usedDep","dep","dependency","importedModule","getModule","exportName","name","usedName","getExportsInfo","getUsedName","description","direct","onlyDirectImport","instanceVar","size","set","getModuleId","value","JSON","stringify","params","signature","map","param","k","valtype","mod","moduleCache","modExports","cache","length","asString","indent","importObject","p","join","propertiesByModule","list","get","undefined","Array","from","moduleIdStringified","moduleId","values","promise","variable","keys","promises","id","variables","i","WasmChunkLoadingRuntimeModule","constructor","generateLoadBinaryCode","supportsStreaming","mangleImports","runtimeRequirements","STAGE_ATTACH","_runtimeRequirements","generate","compilation","outputOptions","fn","ensureChunkHandlers","withHmr","has","hmrDownloadUpdateHandlers","importObjects","chunkModuleIdMap","getChunkModuleIdMap","createImportObject","content","MANGLED_MODULE","wasmModuleSrcPath","getPath","webassemblyModuleFilename","hash","getFullHash","hashWithLength","getChunkModuleRenderedHashMap","stateExpression","hmrRuntimeStatePrefix","wasmInstances","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst RuntimeModule = require(\"../RuntimeModule\");\nconst Template = require(\"../Template\");\nconst { compareModulesByIdentifier } = require(\"../util/comparators\");\nconst WebAssemblyUtils = require(\"./WebAssemblyUtils\");\n\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n// TODO webpack 6 remove the whole folder\n\n// Get all wasm modules\nconst getAllWasmModules = (moduleGraph, chunkGraph, chunk) => {\n\tconst wasmModules = chunk.getAllAsyncChunks();\n\tconst array = [];\n\tfor (const chunk of wasmModules) {\n\t\tfor (const m of chunkGraph.getOrderedChunkModulesIterable(\n\t\t\tchunk,\n\t\t\tcompareModulesByIdentifier\n\t\t)) {\n\t\t\tif (m.type.startsWith(\"webassembly\")) {\n\t\t\t\tarray.push(m);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn array;\n};\n\n/**\n * generates the import object function for a module\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Module} module the module\n * @param {boolean} mangle mangle imports\n * @param {string[]} declarations array where declarations are pushed to\n * @param {RuntimeSpec} runtime the runtime\n * @returns {string} source code\n */\nconst generateImportObject = (\n\tchunkGraph,\n\tmodule,\n\tmangle,\n\tdeclarations,\n\truntime\n) => {\n\tconst moduleGraph = chunkGraph.moduleGraph;\n\tconst waitForInstances = new Map();\n\tconst properties = [];\n\tconst usedWasmDependencies = WebAssemblyUtils.getUsedDependencies(\n\t\tmoduleGraph,\n\t\tmodule,\n\t\tmangle\n\t);\n\tfor (const usedDep of usedWasmDependencies) {\n\t\tconst dep = usedDep.dependency;\n\t\tconst importedModule = moduleGraph.getModule(dep);\n\t\tconst exportName = dep.name;\n\t\tconst usedName =\n\t\t\timportedModule &&\n\t\t\tmoduleGraph\n\t\t\t\t.getExportsInfo(importedModule)\n\t\t\t\t.getUsedName(exportName, runtime);\n\t\tconst description = dep.description;\n\t\tconst direct = dep.onlyDirectImport;\n\n\t\tconst module = usedDep.module;\n\t\tconst name = usedDep.name;\n\n\t\tif (direct) {\n\t\t\tconst instanceVar = `m${waitForInstances.size}`;\n\t\t\twaitForInstances.set(instanceVar, chunkGraph.getModuleId(importedModule));\n\t\t\tproperties.push({\n\t\t\t\tmodule,\n\t\t\t\tname,\n\t\t\t\tvalue: `${instanceVar}[${JSON.stringify(usedName)}]`\n\t\t\t});\n\t\t} else {\n\t\t\tconst params = description.signature.params.map(\n\t\t\t\t(param, k) => \"p\" + k + param.valtype\n\t\t\t);\n\n\t\t\tconst mod = `${RuntimeGlobals.moduleCache}[${JSON.stringify(\n\t\t\t\tchunkGraph.getModuleId(importedModule)\n\t\t\t)}]`;\n\t\t\tconst modExports = `${mod}.exports`;\n\n\t\t\tconst cache = `wasmImportedFuncCache${declarations.length}`;\n\t\t\tdeclarations.push(`var ${cache};`);\n\n\t\t\tproperties.push({\n\t\t\t\tmodule,\n\t\t\t\tname,\n\t\t\t\tvalue: Template.asString([\n\t\t\t\t\t(importedModule.type.startsWith(\"webassembly\")\n\t\t\t\t\t\t? `${mod} ? ${modExports}[${JSON.stringify(usedName)}] : `\n\t\t\t\t\t\t: \"\") + `function(${params}) {`,\n\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t`if(${cache} === undefined) ${cache} = ${modExports};`,\n\t\t\t\t\t\t`return ${cache}[${JSON.stringify(usedName)}](${params});`\n\t\t\t\t\t]),\n\t\t\t\t\t\"}\"\n\t\t\t\t])\n\t\t\t});\n\t\t}\n\t}\n\n\tlet importObject;\n\tif (mangle) {\n\t\timportObject = [\n\t\t\t\"return {\",\n\t\t\tTemplate.indent([\n\t\t\t\tproperties.map(p => `${JSON.stringify(p.name)}: ${p.value}`).join(\",\\n\")\n\t\t\t]),\n\t\t\t\"};\"\n\t\t];\n\t} else {\n\t\tconst propertiesByModule = new Map();\n\t\tfor (const p of properties) {\n\t\t\tlet list = propertiesByModule.get(p.module);\n\t\t\tif (list === undefined) {\n\t\t\t\tpropertiesByModule.set(p.module, (list = []));\n\t\t\t}\n\t\t\tlist.push(p);\n\t\t}\n\t\timportObject = [\n\t\t\t\"return {\",\n\t\t\tTemplate.indent([\n\t\t\t\tArray.from(propertiesByModule, ([module, list]) => {\n\t\t\t\t\treturn Template.asString([\n\t\t\t\t\t\t`${JSON.stringify(module)}: {`,\n\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\tlist.map(p => `${JSON.stringify(p.name)}: ${p.value}`).join(\",\\n\")\n\t\t\t\t\t\t]),\n\t\t\t\t\t\t\"}\"\n\t\t\t\t\t]);\n\t\t\t\t}).join(\",\\n\")\n\t\t\t]),\n\t\t\t\"};\"\n\t\t];\n\t}\n\n\tconst moduleIdStringified = JSON.stringify(chunkGraph.getModuleId(module));\n\tif (waitForInstances.size === 1) {\n\t\tconst moduleId = Array.from(waitForInstances.values())[0];\n\t\tconst promise = `installedWasmModules[${JSON.stringify(moduleId)}]`;\n\t\tconst variable = Array.from(waitForInstances.keys())[0];\n\t\treturn Template.asString([\n\t\t\t`${moduleIdStringified}: function() {`,\n\t\t\tTemplate.indent([\n\t\t\t\t`return promiseResolve().then(function() { return ${promise}; }).then(function(${variable}) {`,\n\t\t\t\tTemplate.indent(importObject),\n\t\t\t\t\"});\"\n\t\t\t]),\n\t\t\t\"},\"\n\t\t]);\n\t} else if (waitForInstances.size > 0) {\n\t\tconst promises = Array.from(\n\t\t\twaitForInstances.values(),\n\t\t\tid => `installedWasmModules[${JSON.stringify(id)}]`\n\t\t).join(\", \");\n\t\tconst variables = Array.from(\n\t\t\twaitForInstances.keys(),\n\t\t\t(name, i) => `${name} = array[${i}]`\n\t\t).join(\", \");\n\t\treturn Template.asString([\n\t\t\t`${moduleIdStringified}: function() {`,\n\t\t\tTemplate.indent([\n\t\t\t\t`return promiseResolve().then(function() { return Promise.all([${promises}]); }).then(function(array) {`,\n\t\t\t\tTemplate.indent([`var ${variables};`, ...importObject]),\n\t\t\t\t\"});\"\n\t\t\t]),\n\t\t\t\"},\"\n\t\t]);\n\t} else {\n\t\treturn Template.asString([\n\t\t\t`${moduleIdStringified}: function() {`,\n\t\t\tTemplate.indent(importObject),\n\t\t\t\"},\"\n\t\t]);\n\t}\n};\n\nclass WasmChunkLoadingRuntimeModule extends RuntimeModule {\n\tconstructor({\n\t\tgenerateLoadBinaryCode,\n\t\tsupportsStreaming,\n\t\tmangleImports,\n\t\truntimeRequirements\n\t}) {\n\t\tsuper(\"wasm chunk loading\", RuntimeModule.STAGE_ATTACH);\n\t\tthis.generateLoadBinaryCode = generateLoadBinaryCode;\n\t\tthis.supportsStreaming = supportsStreaming;\n\t\tthis.mangleImports = mangleImports;\n\t\tthis._runtimeRequirements = runtimeRequirements;\n\t}\n\n\t/**\n\t * @returns {string} runtime code\n\t */\n\tgenerate() {\n\t\tconst { chunkGraph, compilation, chunk, mangleImports } = this;\n\t\tconst { moduleGraph, outputOptions } = compilation;\n\t\tconst fn = RuntimeGlobals.ensureChunkHandlers;\n\t\tconst withHmr = this._runtimeRequirements.has(\n\t\t\tRuntimeGlobals.hmrDownloadUpdateHandlers\n\t\t);\n\t\tconst wasmModules = getAllWasmModules(moduleGraph, chunkGraph, chunk);\n\t\tconst declarations = [];\n\t\tconst importObjects = wasmModules.map(module => {\n\t\t\treturn generateImportObject(\n\t\t\t\tchunkGraph,\n\t\t\t\tmodule,\n\t\t\t\tthis.mangleImports,\n\t\t\t\tdeclarations,\n\t\t\t\tchunk.runtime\n\t\t\t);\n\t\t});\n\t\tconst chunkModuleIdMap = chunkGraph.getChunkModuleIdMap(chunk, m =>\n\t\t\tm.type.startsWith(\"webassembly\")\n\t\t);\n\t\tconst createImportObject = content =>\n\t\t\tmangleImports\n\t\t\t\t? `{ ${JSON.stringify(WebAssemblyUtils.MANGLED_MODULE)}: ${content} }`\n\t\t\t\t: content;\n\t\tconst wasmModuleSrcPath = compilation.getPath(\n\t\t\tJSON.stringify(outputOptions.webassemblyModuleFilename),\n\t\t\t{\n\t\t\t\thash: `\" + ${RuntimeGlobals.getFullHash}() + \"`,\n\t\t\t\thashWithLength: length =>\n\t\t\t\t\t`\" + ${RuntimeGlobals.getFullHash}}().slice(0, ${length}) + \"`,\n\t\t\t\tmodule: {\n\t\t\t\t\tid: '\" + wasmModuleId + \"',\n\t\t\t\t\thash: `\" + ${JSON.stringify(\n\t\t\t\t\t\tchunkGraph.getChunkModuleRenderedHashMap(chunk, m =>\n\t\t\t\t\t\t\tm.type.startsWith(\"webassembly\")\n\t\t\t\t\t\t)\n\t\t\t\t\t)}[chunkId][wasmModuleId] + \"`,\n\t\t\t\t\thashWithLength(length) {\n\t\t\t\t\t\treturn `\" + ${JSON.stringify(\n\t\t\t\t\t\t\tchunkGraph.getChunkModuleRenderedHashMap(\n\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\tm => m.type.startsWith(\"webassembly\"),\n\t\t\t\t\t\t\t\tlength\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)}[chunkId][wasmModuleId] + \"`;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\truntime: chunk.runtime\n\t\t\t}\n\t\t);\n\n\t\tconst stateExpression = withHmr\n\t\t\t? `${RuntimeGlobals.hmrRuntimeStatePrefix}_wasm`\n\t\t\t: undefined;\n\n\t\treturn Template.asString([\n\t\t\t\"// object to store loaded and loading wasm modules\",\n\t\t\t`var installedWasmModules = ${\n\t\t\t\tstateExpression ? `${stateExpression} = ${stateExpression} || ` : \"\"\n\t\t\t}{};`,\n\t\t\t\"\",\n\t\t\t// This function is used to delay reading the installed wasm module promises\n\t\t\t// by a microtask. Sorting them doesn't help because there are edge cases where\n\t\t\t// sorting is not possible (modules splitted into different chunks).\n\t\t\t// So we not even trying and solve this by a microtask delay.\n\t\t\t\"function promiseResolve() { return Promise.resolve(); }\",\n\t\t\t\"\",\n\t\t\tTemplate.asString(declarations),\n\t\t\t\"var wasmImportObjects = {\",\n\t\t\tTemplate.indent(importObjects),\n\t\t\t\"};\",\n\t\t\t\"\",\n\t\t\t`var wasmModuleMap = ${JSON.stringify(\n\t\t\t\tchunkModuleIdMap,\n\t\t\t\tundefined,\n\t\t\t\t\"\\t\"\n\t\t\t)};`,\n\t\t\t\"\",\n\t\t\t\"// object with all WebAssembly.instance exports\",\n\t\t\t`${RuntimeGlobals.wasmInstances} = {};`,\n\t\t\t\"\",\n\t\t\t\"// Fetch + compile chunk loading for webassembly\",\n\t\t\t`${fn}.wasm = function(chunkId, promises) {`,\n\t\t\tTemplate.indent([\n\t\t\t\t\"\",\n\t\t\t\t`var wasmModules = wasmModuleMap[chunkId] || [];`,\n\t\t\t\t\"\",\n\t\t\t\t\"wasmModules.forEach(function(wasmModuleId, idx) {\",\n\t\t\t\tTemplate.indent([\n\t\t\t\t\t\"var installedWasmModuleData = installedWasmModules[wasmModuleId];\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t'// a Promise means \"currently loading\" or \"already loaded\".',\n\t\t\t\t\t\"if(installedWasmModuleData)\",\n\t\t\t\t\tTemplate.indent([\"promises.push(installedWasmModuleData);\"]),\n\t\t\t\t\t\"else {\",\n\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t`var importObject = wasmImportObjects[wasmModuleId]();`,\n\t\t\t\t\t\t`var req = ${this.generateLoadBinaryCode(wasmModuleSrcPath)};`,\n\t\t\t\t\t\t\"var promise;\",\n\t\t\t\t\t\tthis.supportsStreaming\n\t\t\t\t\t\t\t? Template.asString([\n\t\t\t\t\t\t\t\t\t\"if(importObject && typeof importObject.then === 'function' && typeof WebAssembly.compileStreaming === 'function') {\",\n\t\t\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t\t\t\"promise = Promise.all([WebAssembly.compileStreaming(req), importObject]).then(function(items) {\",\n\t\t\t\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t\t\t\t`return WebAssembly.instantiate(items[0], ${createImportObject(\n\t\t\t\t\t\t\t\t\t\t\t\t\"items[1]\"\n\t\t\t\t\t\t\t\t\t\t\t)});`\n\t\t\t\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t\t\t\t\"});\"\n\t\t\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t\t\t\"} else if(typeof WebAssembly.instantiateStreaming === 'function') {\",\n\t\t\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t\t\t`promise = WebAssembly.instantiateStreaming(req, ${createImportObject(\n\t\t\t\t\t\t\t\t\t\t\t\"importObject\"\n\t\t\t\t\t\t\t\t\t\t)});`\n\t\t\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\t  ])\n\t\t\t\t\t\t\t: Template.asString([\n\t\t\t\t\t\t\t\t\t\"if(importObject && typeof importObject.then === 'function') {\",\n\t\t\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t\t\t\"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\",\n\t\t\t\t\t\t\t\t\t\t\"promise = Promise.all([\",\n\t\t\t\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t\t\t\t\"bytesPromise.then(function(bytes) { return WebAssembly.compile(bytes); }),\",\n\t\t\t\t\t\t\t\t\t\t\t\"importObject\"\n\t\t\t\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t\t\t\t\"]).then(function(items) {\",\n\t\t\t\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t\t\t\t`return WebAssembly.instantiate(items[0], ${createImportObject(\n\t\t\t\t\t\t\t\t\t\t\t\t\"items[1]\"\n\t\t\t\t\t\t\t\t\t\t\t)});`\n\t\t\t\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t\t\t\t\"});\"\n\t\t\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\t  ]),\n\t\t\t\t\t\t\"} else {\",\n\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\",\n\t\t\t\t\t\t\t\"promise = bytesPromise.then(function(bytes) {\",\n\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t`return WebAssembly.instantiate(bytes, ${createImportObject(\n\t\t\t\t\t\t\t\t\t\"importObject\"\n\t\t\t\t\t\t\t\t)});`\n\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t\"});\"\n\t\t\t\t\t\t]),\n\t\t\t\t\t\t\"}\",\n\t\t\t\t\t\t\"promises.push(installedWasmModules[wasmModuleId] = promise.then(function(res) {\",\n\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t`return ${RuntimeGlobals.wasmInstances}[wasmModuleId] = (res.instance || res).exports;`\n\t\t\t\t\t\t]),\n\t\t\t\t\t\t\"}));\"\n\t\t\t\t\t]),\n\t\t\t\t\t\"}\"\n\t\t\t\t]),\n\t\t\t\t\"});\"\n\t\t\t]),\n\t\t\t\"};\"\n\t\t]);\n\t}\n}\n\nmodule.exports = WasmChunkLoadingRuntimeModule;\n"]},"metadata":{},"sourceType":"script"}