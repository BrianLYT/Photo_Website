{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  provide\n} = require(\"./util/MapHelpers\");\n\nconst {\n  first\n} = require(\"./util/SetHelpers\");\n\nconst createHash = require(\"./util/createHash\");\n\nconst {\n  runtimeToString,\n  RuntimeSpecMap\n} = require(\"./util/runtime\");\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./Module\").CodeGenerationResult} CodeGenerationResult */\n\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n\nclass CodeGenerationResults {\n  /**\n   * @param {string | Hash} hashFunction the hash function to use\n   */\n  constructor() {\n    let hashFunction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"md4\";\n\n    /** @type {Map<Module, RuntimeSpecMap<CodeGenerationResult>>} */\n    this.map = new Map();\n    this._hashFunction = hashFunction;\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @returns {CodeGenerationResult} the CodeGenerationResult\n   */\n\n\n  get(module, runtime) {\n    const entry = this.map.get(module);\n\n    if (entry === undefined) {\n      throw new Error(`No code generation entry for ${module.identifier()} (existing entries: ${Array.from(this.map.keys(), m => m.identifier()).join(\", \")})`);\n    }\n\n    if (runtime === undefined) {\n      if (entry.size > 1) {\n        const results = new Set(entry.values());\n\n        if (results.size !== 1) {\n          throw new Error(`No unique code generation entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(entry.keys(), r => runtimeToString(r)).join(\", \")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \"global\").`);\n        }\n\n        return first(results);\n      }\n\n      return entry.values().next().value;\n    }\n\n    const result = entry.get(runtime);\n\n    if (result === undefined) {\n      throw new Error(`No code generation entry for runtime ${runtimeToString(runtime)} for ${module.identifier()} (existing runtimes: ${Array.from(entry.keys(), r => runtimeToString(r)).join(\", \")})`);\n    }\n\n    return result;\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @returns {boolean} true, when we have data for this\n   */\n\n\n  has(module, runtime) {\n    const entry = this.map.get(module);\n\n    if (entry === undefined) {\n      return false;\n    }\n\n    if (runtime !== undefined) {\n      return entry.has(runtime);\n    } else if (entry.size > 1) {\n      const results = new Set(entry.values());\n      return results.size === 1;\n    } else {\n      return entry.size === 1;\n    }\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @param {string} sourceType the source type\n   * @returns {Source} a source\n   */\n\n\n  getSource(module, runtime, sourceType) {\n    return this.get(module, runtime).sources.get(sourceType);\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @returns {ReadonlySet<string>} runtime requirements\n   */\n\n\n  getRuntimeRequirements(module, runtime) {\n    return this.get(module, runtime).runtimeRequirements;\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @param {string} key data key\n   * @returns {any} data generated by code generation\n   */\n\n\n  getData(module, runtime, key) {\n    const data = this.get(module, runtime).data;\n    return data === undefined ? undefined : data.get(key);\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @returns {any} hash of the code generation\n   */\n\n\n  getHash(module, runtime) {\n    const info = this.get(module, runtime);\n    if (info.hash !== undefined) return info.hash;\n    const hash = createHash(this._hashFunction);\n\n    for (const [type, source] of info.sources) {\n      hash.update(type);\n      source.updateHash(hash);\n    }\n\n    if (info.runtimeRequirements) {\n      for (const rr of info.runtimeRequirements) hash.update(rr);\n    }\n\n    return info.hash =\n    /** @type {string} */\n    hash.digest(\"hex\");\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @param {CodeGenerationResult} result result from module\n   * @returns {void}\n   */\n\n\n  add(module, runtime, result) {\n    const map = provide(this.map, module, () => new RuntimeSpecMap());\n    map.set(runtime, result);\n  }\n\n}\n\nmodule.exports = CodeGenerationResults;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/CodeGenerationResults.js"],"names":["provide","require","first","createHash","runtimeToString","RuntimeSpecMap","CodeGenerationResults","constructor","hashFunction","map","Map","_hashFunction","get","module","runtime","entry","undefined","Error","identifier","Array","from","keys","m","join","size","results","Set","values","r","next","value","result","has","getSource","sourceType","sources","getRuntimeRequirements","runtimeRequirements","getData","key","data","getHash","info","hash","type","source","update","updateHash","rr","digest","add","set","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { provide } = require(\"./util/MapHelpers\");\nconst { first } = require(\"./util/SetHelpers\");\nconst createHash = require(\"./util/createHash\");\nconst { runtimeToString, RuntimeSpecMap } = require(\"./util/runtime\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./Module\").CodeGenerationResult} CodeGenerationResult */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\nclass CodeGenerationResults {\n\t/**\n\t * @param {string | Hash} hashFunction the hash function to use\n\t */\n\tconstructor(hashFunction = \"md4\") {\n\t\t/** @type {Map<Module, RuntimeSpecMap<CodeGenerationResult>>} */\n\t\tthis.map = new Map();\n\t\tthis._hashFunction = hashFunction;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @returns {CodeGenerationResult} the CodeGenerationResult\n\t */\n\tget(module, runtime) {\n\t\tconst entry = this.map.get(module);\n\t\tif (entry === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t`No code generation entry for ${module.identifier()} (existing entries: ${Array.from(\n\t\t\t\t\tthis.map.keys(),\n\t\t\t\t\tm => m.identifier()\n\t\t\t\t).join(\", \")})`\n\t\t\t);\n\t\t}\n\t\tif (runtime === undefined) {\n\t\t\tif (entry.size > 1) {\n\t\t\t\tconst results = new Set(entry.values());\n\t\t\t\tif (results.size !== 1) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`No unique code generation entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(\n\t\t\t\t\t\t\tentry.keys(),\n\t\t\t\t\t\t\tr => runtimeToString(r)\n\t\t\t\t\t\t).join(\", \")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \"global\").`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn first(results);\n\t\t\t}\n\t\t\treturn entry.values().next().value;\n\t\t}\n\t\tconst result = entry.get(runtime);\n\t\tif (result === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t`No code generation entry for runtime ${runtimeToString(\n\t\t\t\t\truntime\n\t\t\t\t)} for ${module.identifier()} (existing runtimes: ${Array.from(\n\t\t\t\t\tentry.keys(),\n\t\t\t\t\tr => runtimeToString(r)\n\t\t\t\t).join(\", \")})`\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @returns {boolean} true, when we have data for this\n\t */\n\thas(module, runtime) {\n\t\tconst entry = this.map.get(module);\n\t\tif (entry === undefined) {\n\t\t\treturn false;\n\t\t}\n\t\tif (runtime !== undefined) {\n\t\t\treturn entry.has(runtime);\n\t\t} else if (entry.size > 1) {\n\t\t\tconst results = new Set(entry.values());\n\t\t\treturn results.size === 1;\n\t\t} else {\n\t\t\treturn entry.size === 1;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @param {string} sourceType the source type\n\t * @returns {Source} a source\n\t */\n\tgetSource(module, runtime, sourceType) {\n\t\treturn this.get(module, runtime).sources.get(sourceType);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetRuntimeRequirements(module, runtime) {\n\t\treturn this.get(module, runtime).runtimeRequirements;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @param {string} key data key\n\t * @returns {any} data generated by code generation\n\t */\n\tgetData(module, runtime, key) {\n\t\tconst data = this.get(module, runtime).data;\n\t\treturn data === undefined ? undefined : data.get(key);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @returns {any} hash of the code generation\n\t */\n\tgetHash(module, runtime) {\n\t\tconst info = this.get(module, runtime);\n\t\tif (info.hash !== undefined) return info.hash;\n\t\tconst hash = createHash(this._hashFunction);\n\t\tfor (const [type, source] of info.sources) {\n\t\t\thash.update(type);\n\t\t\tsource.updateHash(hash);\n\t\t}\n\t\tif (info.runtimeRequirements) {\n\t\t\tfor (const rr of info.runtimeRequirements) hash.update(rr);\n\t\t}\n\t\treturn (info.hash = /** @type {string} */ (hash.digest(\"hex\")));\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @param {CodeGenerationResult} result result from module\n\t * @returns {void}\n\t */\n\tadd(module, runtime, result) {\n\t\tconst map = provide(this.map, module, () => new RuntimeSpecMap());\n\t\tmap.set(runtime, result);\n\t}\n}\n\nmodule.exports = CodeGenerationResults;\n"]},"metadata":{},"sourceType":"script"}