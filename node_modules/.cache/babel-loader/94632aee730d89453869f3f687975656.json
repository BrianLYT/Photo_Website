{"ast":null,"code":"import * as encoder from \"./encoder\";\nexport function encodeNode(n) {\n  switch (n.type) {\n    case \"ModuleImport\":\n      // $FlowIgnore: ModuleImport ensure that the node is well formated\n      return encoder.encodeModuleImport(n);\n\n    case \"SectionMetadata\":\n      // $FlowIgnore: SectionMetadata ensure that the node is well formated\n      return encoder.encodeSectionMetadata(n);\n\n    case \"CallInstruction\":\n      // $FlowIgnore: SectionMetadata ensure that the node is well formated\n      return encoder.encodeCallInstruction(n);\n\n    case \"CallIndirectInstruction\":\n      // $FlowIgnore: SectionMetadata ensure that the node is well formated\n      return encoder.encodeCallIndirectInstruction(n);\n\n    case \"TypeInstruction\":\n      return encoder.encodeTypeInstruction(n);\n\n    case \"Instr\":\n      // $FlowIgnore\n      return encoder.encodeInstr(n);\n\n    case \"ModuleExport\":\n      // $FlowIgnore: SectionMetadata ensure that the node is well formated\n      return encoder.encodeModuleExport(n);\n\n    case \"Global\":\n      // $FlowIgnore\n      return encoder.encodeGlobal(n);\n\n    case \"Func\":\n      return encoder.encodeFuncBody(n);\n\n    case \"IndexInFuncSection\":\n      return encoder.encodeIndexInFuncSection(n);\n\n    case \"StringLiteral\":\n      return encoder.encodeStringLiteral(n);\n\n    case \"Elem\":\n      return encoder.encodeElem(n);\n\n    default:\n      throw new Error(\"Unsupported encoding for node of type: \" + JSON.stringify(n.type));\n  }\n}\nexport var encodeU32 = encoder.encodeU32;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/@webassemblyjs/wasm-gen/esm/index.js"],"names":["encoder","encodeNode","n","type","encodeModuleImport","encodeSectionMetadata","encodeCallInstruction","encodeCallIndirectInstruction","encodeTypeInstruction","encodeInstr","encodeModuleExport","encodeGlobal","encodeFuncBody","encodeIndexInFuncSection","encodeStringLiteral","encodeElem","Error","JSON","stringify","encodeU32"],"mappings":"AAAA,OAAO,KAAKA,OAAZ,MAAyB,WAAzB;AACA,OAAO,SAASC,UAAT,CAAoBC,CAApB,EAAuB;AAC5B,UAAQA,CAAC,CAACC,IAAV;AACE,SAAK,cAAL;AACE;AACA,aAAOH,OAAO,CAACI,kBAAR,CAA2BF,CAA3B,CAAP;;AAEF,SAAK,iBAAL;AACE;AACA,aAAOF,OAAO,CAACK,qBAAR,CAA8BH,CAA9B,CAAP;;AAEF,SAAK,iBAAL;AACE;AACA,aAAOF,OAAO,CAACM,qBAAR,CAA8BJ,CAA9B,CAAP;;AAEF,SAAK,yBAAL;AACE;AACA,aAAOF,OAAO,CAACO,6BAAR,CAAsCL,CAAtC,CAAP;;AAEF,SAAK,iBAAL;AACE,aAAOF,OAAO,CAACQ,qBAAR,CAA8BN,CAA9B,CAAP;;AAEF,SAAK,OAAL;AACE;AACA,aAAOF,OAAO,CAACS,WAAR,CAAoBP,CAApB,CAAP;;AAEF,SAAK,cAAL;AACE;AACA,aAAOF,OAAO,CAACU,kBAAR,CAA2BR,CAA3B,CAAP;;AAEF,SAAK,QAAL;AACE;AACA,aAAOF,OAAO,CAACW,YAAR,CAAqBT,CAArB,CAAP;;AAEF,SAAK,MAAL;AACE,aAAOF,OAAO,CAACY,cAAR,CAAuBV,CAAvB,CAAP;;AAEF,SAAK,oBAAL;AACE,aAAOF,OAAO,CAACa,wBAAR,CAAiCX,CAAjC,CAAP;;AAEF,SAAK,eAAL;AACE,aAAOF,OAAO,CAACc,mBAAR,CAA4BZ,CAA5B,CAAP;;AAEF,SAAK,MAAL;AACE,aAAOF,OAAO,CAACe,UAAR,CAAmBb,CAAnB,CAAP;;AAEF;AACE,YAAM,IAAIc,KAAJ,CAAU,4CAA4CC,IAAI,CAACC,SAAL,CAAehB,CAAC,CAACC,IAAjB,CAAtD,CAAN;AA7CJ;AA+CD;AACD,OAAO,IAAIgB,SAAS,GAAGnB,OAAO,CAACmB,SAAxB","sourcesContent":["import * as encoder from \"./encoder\";\nexport function encodeNode(n) {\n  switch (n.type) {\n    case \"ModuleImport\":\n      // $FlowIgnore: ModuleImport ensure that the node is well formated\n      return encoder.encodeModuleImport(n);\n\n    case \"SectionMetadata\":\n      // $FlowIgnore: SectionMetadata ensure that the node is well formated\n      return encoder.encodeSectionMetadata(n);\n\n    case \"CallInstruction\":\n      // $FlowIgnore: SectionMetadata ensure that the node is well formated\n      return encoder.encodeCallInstruction(n);\n\n    case \"CallIndirectInstruction\":\n      // $FlowIgnore: SectionMetadata ensure that the node is well formated\n      return encoder.encodeCallIndirectInstruction(n);\n\n    case \"TypeInstruction\":\n      return encoder.encodeTypeInstruction(n);\n\n    case \"Instr\":\n      // $FlowIgnore\n      return encoder.encodeInstr(n);\n\n    case \"ModuleExport\":\n      // $FlowIgnore: SectionMetadata ensure that the node is well formated\n      return encoder.encodeModuleExport(n);\n\n    case \"Global\":\n      // $FlowIgnore\n      return encoder.encodeGlobal(n);\n\n    case \"Func\":\n      return encoder.encodeFuncBody(n);\n\n    case \"IndexInFuncSection\":\n      return encoder.encodeIndexInFuncSection(n);\n\n    case \"StringLiteral\":\n      return encoder.encodeStringLiteral(n);\n\n    case \"Elem\":\n      return encoder.encodeElem(n);\n\n    default:\n      throw new Error(\"Unsupported encoding for node of type: \" + JSON.stringify(n.type));\n  }\n}\nexport var encodeU32 = encoder.encodeU32;"]},"metadata":{},"sourceType":"module"}