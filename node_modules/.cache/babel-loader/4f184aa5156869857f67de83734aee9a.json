{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * Priority queue that processes tasks in natural ordering (lower priority first)\n * accoridng to the priority computed by the function passed in the constructor.\n *\n * FIFO ordering isn't guaranteed for tasks with the same priority.\n *\n * Worker specific tasks with the same priority as a non-worker specific task\n * are always processed first.\n */\n\n\nclass PriorityQueue {\n  constructor(_computePriority) {\n    _defineProperty(this, '_queue', []);\n\n    _defineProperty(this, '_sharedQueue', new MinHeap());\n\n    this._computePriority = _computePriority;\n  }\n\n  enqueue(task, workerId) {\n    if (workerId == null) {\n      this._enqueue(task, this._sharedQueue);\n    } else {\n      const queue = this._getWorkerQueue(workerId);\n\n      this._enqueue(task, queue);\n    }\n  }\n\n  _enqueue(task, queue) {\n    const item = {\n      priority: this._computePriority(task.request[2], ...task.request[3]),\n      task\n    };\n    queue.add(item);\n  }\n\n  dequeue(workerId) {\n    const workerQueue = this._getWorkerQueue(workerId);\n\n    const workerTop = workerQueue.peek();\n\n    const sharedTop = this._sharedQueue.peek(); // use the task from the worker queue if there's no task in the shared queue\n    // or if the priority of the worker queue is smaller or equal to the\n    // priority of the top task in the shared queue. The tasks of the\n    // worker specific queue are preferred because no other worker can pick this\n    // specific task up.\n\n\n    if (sharedTop == null || workerTop != null && workerTop.priority <= sharedTop.priority) {\n      var _workerQueue$poll$tas, _workerQueue$poll;\n\n      return (_workerQueue$poll$tas = (_workerQueue$poll = workerQueue.poll()) === null || _workerQueue$poll === void 0 ? void 0 : _workerQueue$poll.task) !== null && _workerQueue$poll$tas !== void 0 ? _workerQueue$poll$tas : null;\n    }\n\n    return this._sharedQueue.poll().task;\n  }\n\n  _getWorkerQueue(workerId) {\n    let queue = this._queue[workerId];\n\n    if (queue == null) {\n      queue = this._queue[workerId] = new MinHeap();\n    }\n\n    return queue;\n  }\n\n}\n\nexports.default = PriorityQueue;\n\nclass MinHeap {\n  constructor() {\n    _defineProperty(this, '_heap', []);\n  }\n\n  peek() {\n    var _this$_heap$;\n\n    return (_this$_heap$ = this._heap[0]) !== null && _this$_heap$ !== void 0 ? _this$_heap$ : null;\n  }\n\n  add(item) {\n    const nodes = this._heap;\n    nodes.push(item);\n\n    if (nodes.length === 1) {\n      return;\n    }\n\n    let currentIndex = nodes.length - 1; // Bubble up the added node as long as the parent is bigger\n\n    while (currentIndex > 0) {\n      const parentIndex = Math.floor((currentIndex + 1) / 2) - 1;\n      const parent = nodes[parentIndex];\n\n      if (parent.priority <= item.priority) {\n        break;\n      }\n\n      nodes[currentIndex] = parent;\n      nodes[parentIndex] = item;\n      currentIndex = parentIndex;\n    }\n  }\n\n  poll() {\n    const nodes = this._heap;\n    const result = nodes[0];\n    const lastElement = nodes.pop(); // heap was empty or removed the last element\n\n    if (result == null || nodes.length === 0) {\n      return result !== null && result !== void 0 ? result : null;\n    }\n\n    let index = 0;\n    nodes[0] = lastElement !== null && lastElement !== void 0 ? lastElement : null;\n    const element = nodes[0];\n\n    while (true) {\n      let swapIndex = null;\n      const rightChildIndex = (index + 1) * 2;\n      const leftChildIndex = rightChildIndex - 1;\n      const rightChild = nodes[rightChildIndex];\n      const leftChild = nodes[leftChildIndex]; // if the left child is smaller, swap with the left\n\n      if (leftChild != null && leftChild.priority < element.priority) {\n        swapIndex = leftChildIndex;\n      } // If the right child is smaller or the right child is smaller than the left\n      // then swap with the right child\n\n\n      if (rightChild != null && rightChild.priority < (swapIndex == null ? element : leftChild).priority) {\n        swapIndex = rightChildIndex;\n      }\n\n      if (swapIndex == null) {\n        break;\n      }\n\n      nodes[index] = nodes[swapIndex];\n      nodes[swapIndex] = element;\n      index = swapIndex;\n    }\n\n    return result;\n  }\n\n}","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/jest-worker/build/PriorityQueue.js"],"names":["Object","defineProperty","exports","value","default","_defineProperty","obj","key","enumerable","configurable","writable","PriorityQueue","constructor","_computePriority","MinHeap","enqueue","task","workerId","_enqueue","_sharedQueue","queue","_getWorkerQueue","item","priority","request","add","dequeue","workerQueue","workerTop","peek","sharedTop","_workerQueue$poll$tas","_workerQueue$poll","poll","_queue","_this$_heap$","_heap","nodes","push","length","currentIndex","parentIndex","Math","floor","parent","result","lastElement","pop","index","element","swapIndex","rightChildIndex","leftChildIndex","rightChild","leftChild"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * Priority queue that processes tasks in natural ordering (lower priority first)\n * accoridng to the priority computed by the function passed in the constructor.\n *\n * FIFO ordering isn't guaranteed for tasks with the same priority.\n *\n * Worker specific tasks with the same priority as a non-worker specific task\n * are always processed first.\n */\nclass PriorityQueue {\n  constructor(_computePriority) {\n    _defineProperty(this, '_queue', []);\n\n    _defineProperty(this, '_sharedQueue', new MinHeap());\n\n    this._computePriority = _computePriority;\n  }\n\n  enqueue(task, workerId) {\n    if (workerId == null) {\n      this._enqueue(task, this._sharedQueue);\n    } else {\n      const queue = this._getWorkerQueue(workerId);\n\n      this._enqueue(task, queue);\n    }\n  }\n\n  _enqueue(task, queue) {\n    const item = {\n      priority: this._computePriority(task.request[2], ...task.request[3]),\n      task\n    };\n    queue.add(item);\n  }\n\n  dequeue(workerId) {\n    const workerQueue = this._getWorkerQueue(workerId);\n\n    const workerTop = workerQueue.peek();\n\n    const sharedTop = this._sharedQueue.peek(); // use the task from the worker queue if there's no task in the shared queue\n    // or if the priority of the worker queue is smaller or equal to the\n    // priority of the top task in the shared queue. The tasks of the\n    // worker specific queue are preferred because no other worker can pick this\n    // specific task up.\n\n    if (\n      sharedTop == null ||\n      (workerTop != null && workerTop.priority <= sharedTop.priority)\n    ) {\n      var _workerQueue$poll$tas, _workerQueue$poll;\n\n      return (_workerQueue$poll$tas =\n        (_workerQueue$poll = workerQueue.poll()) === null ||\n        _workerQueue$poll === void 0\n          ? void 0\n          : _workerQueue$poll.task) !== null && _workerQueue$poll$tas !== void 0\n        ? _workerQueue$poll$tas\n        : null;\n    }\n\n    return this._sharedQueue.poll().task;\n  }\n\n  _getWorkerQueue(workerId) {\n    let queue = this._queue[workerId];\n\n    if (queue == null) {\n      queue = this._queue[workerId] = new MinHeap();\n    }\n\n    return queue;\n  }\n}\n\nexports.default = PriorityQueue;\n\nclass MinHeap {\n  constructor() {\n    _defineProperty(this, '_heap', []);\n  }\n\n  peek() {\n    var _this$_heap$;\n\n    return (_this$_heap$ = this._heap[0]) !== null && _this$_heap$ !== void 0\n      ? _this$_heap$\n      : null;\n  }\n\n  add(item) {\n    const nodes = this._heap;\n    nodes.push(item);\n\n    if (nodes.length === 1) {\n      return;\n    }\n\n    let currentIndex = nodes.length - 1; // Bubble up the added node as long as the parent is bigger\n\n    while (currentIndex > 0) {\n      const parentIndex = Math.floor((currentIndex + 1) / 2) - 1;\n      const parent = nodes[parentIndex];\n\n      if (parent.priority <= item.priority) {\n        break;\n      }\n\n      nodes[currentIndex] = parent;\n      nodes[parentIndex] = item;\n      currentIndex = parentIndex;\n    }\n  }\n\n  poll() {\n    const nodes = this._heap;\n    const result = nodes[0];\n    const lastElement = nodes.pop(); // heap was empty or removed the last element\n\n    if (result == null || nodes.length === 0) {\n      return result !== null && result !== void 0 ? result : null;\n    }\n\n    let index = 0;\n    nodes[0] =\n      lastElement !== null && lastElement !== void 0 ? lastElement : null;\n    const element = nodes[0];\n\n    while (true) {\n      let swapIndex = null;\n      const rightChildIndex = (index + 1) * 2;\n      const leftChildIndex = rightChildIndex - 1;\n      const rightChild = nodes[rightChildIndex];\n      const leftChild = nodes[leftChildIndex]; // if the left child is smaller, swap with the left\n\n      if (leftChild != null && leftChild.priority < element.priority) {\n        swapIndex = leftChildIndex;\n      } // If the right child is smaller or the right child is smaller than the left\n      // then swap with the right child\n\n      if (\n        rightChild != null &&\n        rightChild.priority < (swapIndex == null ? element : leftChild).priority\n      ) {\n        swapIndex = rightChildIndex;\n      }\n\n      if (swapIndex == null) {\n        break;\n      }\n\n      nodes[index] = nodes[swapIndex];\n      nodes[swapIndex] = element;\n      index = swapIndex;\n    }\n\n    return result;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}