{"ast":null,"code":"function _sliceIterator(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _slicedToArray(arr, i) {\n  if (Array.isArray(arr)) {\n    return arr;\n  } else if (Symbol.iterator in Object(arr)) {\n    return _sliceIterator(arr, i);\n  } else {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n}\n\nimport { encodeNode } from \"@webassemblyjs/wasm-gen\";\nimport { encodeU32 } from \"@webassemblyjs/wasm-gen/lib/encoder\";\nimport { isFunc, isGlobal, assertHasLoc, orderedInsertNode, getSectionMetadata, traverse, getEndOfSection } from \"@webassemblyjs/ast\";\nimport { resizeSectionByteSize, resizeSectionVecSize, createEmptySection, removeSections } from \"@webassemblyjs/helper-wasm-section\";\nimport { overrideBytesInBuffer } from \"@webassemblyjs/helper-buffer\";\nimport { getSectionForNode } from \"@webassemblyjs/helper-wasm-bytecode\";\n\nfunction shiftLocNodeByDelta(node, delta) {\n  assertHasLoc(node); // $FlowIgnore: assertHasLoc ensures that\n\n  node.loc.start.column += delta; // $FlowIgnore: assertHasLoc ensures that\n\n  node.loc.end.column += delta;\n}\n\nfunction applyUpdate(ast, uint8Buffer, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      oldNode = _ref2[0],\n      newNode = _ref2[1];\n\n  var deltaElements = 0;\n  assertHasLoc(oldNode);\n  var sectionName = getSectionForNode(newNode);\n  var replacementByteArray = encodeNode(newNode);\n  /**\n   * Replace new node as bytes\n   */\n\n  uint8Buffer = overrideBytesInBuffer(uint8Buffer, // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.start.column, // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.end.column, replacementByteArray);\n  /**\n   * Update function body size if needed\n   */\n\n  if (sectionName === \"code\") {\n    // Find the parent func\n    traverse(ast, {\n      Func: function Func(_ref3) {\n        var node = _ref3.node;\n        var funcHasThisIntr = node.body.find(function (n) {\n          return n === newNode;\n        }) !== undefined; // Update func's body size if needed\n\n        if (funcHasThisIntr === true) {\n          // These are the old functions locations informations\n          assertHasLoc(node);\n          var oldNodeSize = encodeNode(oldNode).length;\n          var bodySizeDeltaBytes = replacementByteArray.length - oldNodeSize;\n\n          if (bodySizeDeltaBytes !== 0) {\n            var newValue = node.metadata.bodySize + bodySizeDeltaBytes;\n            var newByteArray = encodeU32(newValue); // function body size byte\n            // FIXME(sven): only handles one byte u32\n\n            var start = node.loc.start.column;\n            var end = start + 1;\n            uint8Buffer = overrideBytesInBuffer(uint8Buffer, start, end, newByteArray);\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Update section size\n   */\n\n\n  var deltaBytes = replacementByteArray.length - ( // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.end.column - oldNode.loc.start.column); // Init location informations\n\n  newNode.loc = {\n    start: {\n      line: -1,\n      column: -1\n    },\n    end: {\n      line: -1,\n      column: -1\n    }\n  }; // Update new node end position\n  // $FlowIgnore: assertHasLoc ensures that\n\n  newNode.loc.start.column = oldNode.loc.start.column; // $FlowIgnore: assertHasLoc ensures that\n\n  newNode.loc.end.column = // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.start.column + replacementByteArray.length;\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\n\nfunction applyDelete(ast, uint8Buffer, node) {\n  var deltaElements = -1; // since we removed an element\n\n  assertHasLoc(node);\n  var sectionName = getSectionForNode(node);\n\n  if (sectionName === \"start\") {\n    var sectionMetadata = getSectionMetadata(ast, \"start\");\n    /**\n     * The start section only contains one element,\n     * we need to remove the whole section\n     */\n\n    uint8Buffer = removeSections(ast, uint8Buffer, \"start\");\n\n    var _deltaBytes = -(sectionMetadata.size.value + 1);\n    /* section id */\n\n\n    return {\n      uint8Buffer: uint8Buffer,\n      deltaBytes: _deltaBytes,\n      deltaElements: deltaElements\n    };\n  } // replacement is nothing\n\n\n  var replacement = [];\n  uint8Buffer = overrideBytesInBuffer(uint8Buffer, // $FlowIgnore: assertHasLoc ensures that\n  node.loc.start.column, // $FlowIgnore: assertHasLoc ensures that\n  node.loc.end.column, replacement);\n  /**\n   * Update section\n   */\n  // $FlowIgnore: assertHasLoc ensures that\n\n  var deltaBytes = -(node.loc.end.column - node.loc.start.column);\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\n\nfunction applyAdd(ast, uint8Buffer, node) {\n  var deltaElements = +1; // since we added an element\n\n  var sectionName = getSectionForNode(node);\n  var sectionMetadata = getSectionMetadata(ast, sectionName); // Section doesn't exists, we create an empty one\n\n  if (typeof sectionMetadata === \"undefined\") {\n    var res = createEmptySection(ast, uint8Buffer, sectionName);\n    uint8Buffer = res.uint8Buffer;\n    sectionMetadata = res.sectionMetadata;\n  }\n  /**\n   * check that the expressions were ended\n   */\n\n\n  if (isFunc(node)) {\n    // $FlowIgnore\n    var body = node.body;\n\n    if (body.length === 0 || body[body.length - 1].id !== \"end\") {\n      throw new Error(\"expressions must be ended\");\n    }\n  }\n\n  if (isGlobal(node)) {\n    // $FlowIgnore\n    var body = node.init;\n\n    if (body.length === 0 || body[body.length - 1].id !== \"end\") {\n      throw new Error(\"expressions must be ended\");\n    }\n  }\n  /**\n   * Add nodes\n   */\n\n\n  var newByteArray = encodeNode(node); // The size of the section doesn't include the storage of the size itself\n  // we need to manually add it here\n\n  var start = getEndOfSection(sectionMetadata);\n  var end = start;\n  /**\n   * Update section\n   */\n\n  var deltaBytes = newByteArray.length;\n  uint8Buffer = overrideBytesInBuffer(uint8Buffer, start, end, newByteArray);\n  node.loc = {\n    start: {\n      line: -1,\n      column: start\n    },\n    end: {\n      line: -1,\n      column: start + deltaBytes\n    }\n  }; // for func add the additional metadata in the AST\n\n  if (node.type === \"Func\") {\n    // the size is the first byte\n    // FIXME(sven): handle LEB128 correctly here\n    var bodySize = newByteArray[0];\n    node.metadata = {\n      bodySize: bodySize\n    };\n  }\n\n  if (node.type !== \"IndexInFuncSection\") {\n    orderedInsertNode(ast.body[0], node);\n  }\n\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\n\nexport function applyOperations(ast, uint8Buffer, ops) {\n  ops.forEach(function (op) {\n    var state;\n    var sectionName;\n\n    switch (op.kind) {\n      case \"update\":\n        state = applyUpdate(ast, uint8Buffer, [op.oldNode, op.node]);\n        sectionName = getSectionForNode(op.node);\n        break;\n\n      case \"delete\":\n        state = applyDelete(ast, uint8Buffer, op.node);\n        sectionName = getSectionForNode(op.node);\n        break;\n\n      case \"add\":\n        state = applyAdd(ast, uint8Buffer, op.node);\n        sectionName = getSectionForNode(op.node);\n        break;\n\n      default:\n        throw new Error(\"Unknown operation\");\n    }\n    /**\n     * Resize section vec size.\n     * If the length of the LEB-encoded size changes, this can change\n     * the byte length of the section and the offset for nodes in the\n     * section. So we do this first before resizing section byte size\n     * or shifting following operations' nodes.\n     */\n\n\n    if (state.deltaElements !== 0 && sectionName !== \"start\") {\n      var oldBufferLength = state.uint8Buffer.length;\n      state.uint8Buffer = resizeSectionVecSize(ast, state.uint8Buffer, sectionName, state.deltaElements); // Infer bytes added/removed by comparing buffer lengths\n\n      state.deltaBytes += state.uint8Buffer.length - oldBufferLength;\n    }\n    /**\n     * Resize section byte size.\n     * If the length of the LEB-encoded size changes, this can change\n     * the offset for nodes in the section. So we do this before\n     * shifting following operations' nodes.\n     */\n\n\n    if (state.deltaBytes !== 0 && sectionName !== \"start\") {\n      var _oldBufferLength = state.uint8Buffer.length;\n      state.uint8Buffer = resizeSectionByteSize(ast, state.uint8Buffer, sectionName, state.deltaBytes); // Infer bytes added/removed by comparing buffer lengths\n\n      state.deltaBytes += state.uint8Buffer.length - _oldBufferLength;\n    }\n    /**\n     * Shift following operation's nodes\n     */\n\n\n    if (state.deltaBytes !== 0) {\n      ops.forEach(function (op) {\n        // We don't need to handle add ops, they are positioning independent\n        switch (op.kind) {\n          case \"update\":\n            shiftLocNodeByDelta(op.oldNode, state.deltaBytes);\n            break;\n\n          case \"delete\":\n            shiftLocNodeByDelta(op.node, state.deltaBytes);\n            break;\n        }\n      });\n    }\n\n    uint8Buffer = state.uint8Buffer;\n  });\n  return uint8Buffer;\n}","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/@webassemblyjs/wasm-edit/esm/apply.js"],"names":["_sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","_slicedToArray","Array","isArray","Object","TypeError","encodeNode","encodeU32","isFunc","isGlobal","assertHasLoc","orderedInsertNode","getSectionMetadata","traverse","getEndOfSection","resizeSectionByteSize","resizeSectionVecSize","createEmptySection","removeSections","overrideBytesInBuffer","getSectionForNode","shiftLocNodeByDelta","node","delta","loc","start","column","end","applyUpdate","ast","uint8Buffer","_ref","_ref2","oldNode","newNode","deltaElements","sectionName","replacementByteArray","Func","_ref3","funcHasThisIntr","body","find","n","oldNodeSize","bodySizeDeltaBytes","newValue","metadata","bodySize","newByteArray","deltaBytes","line","applyDelete","sectionMetadata","_deltaBytes","size","replacement","applyAdd","res","id","Error","init","type","applyOperations","ops","forEach","op","state","kind","oldBufferLength","_oldBufferLength"],"mappings":"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","sourcesContent":["function _sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return _sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }\n\nimport { encodeNode } from \"@webassemblyjs/wasm-gen\";\nimport { encodeU32 } from \"@webassemblyjs/wasm-gen/lib/encoder\";\nimport { isFunc, isGlobal, assertHasLoc, orderedInsertNode, getSectionMetadata, traverse, getEndOfSection } from \"@webassemblyjs/ast\";\nimport { resizeSectionByteSize, resizeSectionVecSize, createEmptySection, removeSections } from \"@webassemblyjs/helper-wasm-section\";\nimport { overrideBytesInBuffer } from \"@webassemblyjs/helper-buffer\";\nimport { getSectionForNode } from \"@webassemblyjs/helper-wasm-bytecode\";\n\nfunction shiftLocNodeByDelta(node, delta) {\n  assertHasLoc(node); // $FlowIgnore: assertHasLoc ensures that\n\n  node.loc.start.column += delta; // $FlowIgnore: assertHasLoc ensures that\n\n  node.loc.end.column += delta;\n}\n\nfunction applyUpdate(ast, uint8Buffer, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      oldNode = _ref2[0],\n      newNode = _ref2[1];\n\n  var deltaElements = 0;\n  assertHasLoc(oldNode);\n  var sectionName = getSectionForNode(newNode);\n  var replacementByteArray = encodeNode(newNode);\n  /**\n   * Replace new node as bytes\n   */\n\n  uint8Buffer = overrideBytesInBuffer(uint8Buffer, // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.start.column, // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.end.column, replacementByteArray);\n  /**\n   * Update function body size if needed\n   */\n\n  if (sectionName === \"code\") {\n    // Find the parent func\n    traverse(ast, {\n      Func: function Func(_ref3) {\n        var node = _ref3.node;\n        var funcHasThisIntr = node.body.find(function (n) {\n          return n === newNode;\n        }) !== undefined; // Update func's body size if needed\n\n        if (funcHasThisIntr === true) {\n          // These are the old functions locations informations\n          assertHasLoc(node);\n          var oldNodeSize = encodeNode(oldNode).length;\n          var bodySizeDeltaBytes = replacementByteArray.length - oldNodeSize;\n\n          if (bodySizeDeltaBytes !== 0) {\n            var newValue = node.metadata.bodySize + bodySizeDeltaBytes;\n            var newByteArray = encodeU32(newValue); // function body size byte\n            // FIXME(sven): only handles one byte u32\n\n            var start = node.loc.start.column;\n            var end = start + 1;\n            uint8Buffer = overrideBytesInBuffer(uint8Buffer, start, end, newByteArray);\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Update section size\n   */\n\n\n  var deltaBytes = replacementByteArray.length - ( // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.end.column - oldNode.loc.start.column); // Init location informations\n\n  newNode.loc = {\n    start: {\n      line: -1,\n      column: -1\n    },\n    end: {\n      line: -1,\n      column: -1\n    }\n  }; // Update new node end position\n  // $FlowIgnore: assertHasLoc ensures that\n\n  newNode.loc.start.column = oldNode.loc.start.column; // $FlowIgnore: assertHasLoc ensures that\n\n  newNode.loc.end.column = // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.start.column + replacementByteArray.length;\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\n\nfunction applyDelete(ast, uint8Buffer, node) {\n  var deltaElements = -1; // since we removed an element\n\n  assertHasLoc(node);\n  var sectionName = getSectionForNode(node);\n\n  if (sectionName === \"start\") {\n    var sectionMetadata = getSectionMetadata(ast, \"start\");\n    /**\n     * The start section only contains one element,\n     * we need to remove the whole section\n     */\n\n    uint8Buffer = removeSections(ast, uint8Buffer, \"start\");\n\n    var _deltaBytes = -(sectionMetadata.size.value + 1);\n    /* section id */\n\n\n    return {\n      uint8Buffer: uint8Buffer,\n      deltaBytes: _deltaBytes,\n      deltaElements: deltaElements\n    };\n  } // replacement is nothing\n\n\n  var replacement = [];\n  uint8Buffer = overrideBytesInBuffer(uint8Buffer, // $FlowIgnore: assertHasLoc ensures that\n  node.loc.start.column, // $FlowIgnore: assertHasLoc ensures that\n  node.loc.end.column, replacement);\n  /**\n   * Update section\n   */\n  // $FlowIgnore: assertHasLoc ensures that\n\n  var deltaBytes = -(node.loc.end.column - node.loc.start.column);\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\n\nfunction applyAdd(ast, uint8Buffer, node) {\n  var deltaElements = +1; // since we added an element\n\n  var sectionName = getSectionForNode(node);\n  var sectionMetadata = getSectionMetadata(ast, sectionName); // Section doesn't exists, we create an empty one\n\n  if (typeof sectionMetadata === \"undefined\") {\n    var res = createEmptySection(ast, uint8Buffer, sectionName);\n    uint8Buffer = res.uint8Buffer;\n    sectionMetadata = res.sectionMetadata;\n  }\n  /**\n   * check that the expressions were ended\n   */\n\n\n  if (isFunc(node)) {\n    // $FlowIgnore\n    var body = node.body;\n\n    if (body.length === 0 || body[body.length - 1].id !== \"end\") {\n      throw new Error(\"expressions must be ended\");\n    }\n  }\n\n  if (isGlobal(node)) {\n    // $FlowIgnore\n    var body = node.init;\n\n    if (body.length === 0 || body[body.length - 1].id !== \"end\") {\n      throw new Error(\"expressions must be ended\");\n    }\n  }\n  /**\n   * Add nodes\n   */\n\n\n  var newByteArray = encodeNode(node); // The size of the section doesn't include the storage of the size itself\n  // we need to manually add it here\n\n  var start = getEndOfSection(sectionMetadata);\n  var end = start;\n  /**\n   * Update section\n   */\n\n  var deltaBytes = newByteArray.length;\n  uint8Buffer = overrideBytesInBuffer(uint8Buffer, start, end, newByteArray);\n  node.loc = {\n    start: {\n      line: -1,\n      column: start\n    },\n    end: {\n      line: -1,\n      column: start + deltaBytes\n    }\n  }; // for func add the additional metadata in the AST\n\n  if (node.type === \"Func\") {\n    // the size is the first byte\n    // FIXME(sven): handle LEB128 correctly here\n    var bodySize = newByteArray[0];\n    node.metadata = {\n      bodySize: bodySize\n    };\n  }\n\n  if (node.type !== \"IndexInFuncSection\") {\n    orderedInsertNode(ast.body[0], node);\n  }\n\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\n\nexport function applyOperations(ast, uint8Buffer, ops) {\n  ops.forEach(function (op) {\n    var state;\n    var sectionName;\n\n    switch (op.kind) {\n      case \"update\":\n        state = applyUpdate(ast, uint8Buffer, [op.oldNode, op.node]);\n        sectionName = getSectionForNode(op.node);\n        break;\n\n      case \"delete\":\n        state = applyDelete(ast, uint8Buffer, op.node);\n        sectionName = getSectionForNode(op.node);\n        break;\n\n      case \"add\":\n        state = applyAdd(ast, uint8Buffer, op.node);\n        sectionName = getSectionForNode(op.node);\n        break;\n\n      default:\n        throw new Error(\"Unknown operation\");\n    }\n    /**\n     * Resize section vec size.\n     * If the length of the LEB-encoded size changes, this can change\n     * the byte length of the section and the offset for nodes in the\n     * section. So we do this first before resizing section byte size\n     * or shifting following operations' nodes.\n     */\n\n\n    if (state.deltaElements !== 0 && sectionName !== \"start\") {\n      var oldBufferLength = state.uint8Buffer.length;\n      state.uint8Buffer = resizeSectionVecSize(ast, state.uint8Buffer, sectionName, state.deltaElements); // Infer bytes added/removed by comparing buffer lengths\n\n      state.deltaBytes += state.uint8Buffer.length - oldBufferLength;\n    }\n    /**\n     * Resize section byte size.\n     * If the length of the LEB-encoded size changes, this can change\n     * the offset for nodes in the section. So we do this before\n     * shifting following operations' nodes.\n     */\n\n\n    if (state.deltaBytes !== 0 && sectionName !== \"start\") {\n      var _oldBufferLength = state.uint8Buffer.length;\n      state.uint8Buffer = resizeSectionByteSize(ast, state.uint8Buffer, sectionName, state.deltaBytes); // Infer bytes added/removed by comparing buffer lengths\n\n      state.deltaBytes += state.uint8Buffer.length - _oldBufferLength;\n    }\n    /**\n     * Shift following operation's nodes\n     */\n\n\n    if (state.deltaBytes !== 0) {\n      ops.forEach(function (op) {\n        // We don't need to handle add ops, they are positioning independent\n        switch (op.kind) {\n          case \"update\":\n            shiftLocNodeByDelta(op.oldNode, state.deltaBytes);\n            break;\n\n          case \"delete\":\n            shiftLocNodeByDelta(op.node, state.deltaBytes);\n            break;\n        }\n      });\n    }\n\n    uint8Buffer = state.uint8Buffer;\n  });\n  return uint8Buffer;\n}"]},"metadata":{},"sourceType":"module"}