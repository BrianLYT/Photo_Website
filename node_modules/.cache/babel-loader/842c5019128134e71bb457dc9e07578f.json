{"ast":null,"code":"\"use strict\";\n/**\n * @typedef {[number, boolean]} RangeValue\n */\n\n/**\n * @callback RangeValueCallback\n * @param {RangeValue} rangeValue\n * @returns {boolean}\n */\n\nclass Range {\n  /**\n   * @param {\"left\" | \"right\"} side\n   * @param {boolean} exclusive\n   * @returns {\">\" | \">=\" | \"<\" | \"<=\"}\n   */\n  static getOperator(side, exclusive) {\n    if (side === \"left\") {\n      return exclusive ? \">\" : \">=\";\n    }\n\n    return exclusive ? \"<\" : \"<=\";\n  }\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n\n\n  static formatRight(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatLeft(value, !logic, !exclusive);\n    }\n\n    return `should be ${Range.getOperator(\"right\", exclusive)} ${value}`;\n  }\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n\n\n  static formatLeft(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatRight(value, !logic, !exclusive);\n    }\n\n    return `should be ${Range.getOperator(\"left\", exclusive)} ${value}`;\n  }\n  /**\n   * @param {number} start left side value\n   * @param {number} end right side value\n   * @param {boolean} startExclusive is range exclusive from left side\n   * @param {boolean} endExclusive is range exclusive from right side\n   * @param {boolean} logic is not logic applied\n   * @returns {string}\n   */\n\n\n  static formatRange(start, end, startExclusive, endExclusive, logic) {\n    let result = \"should be\";\n    result += ` ${Range.getOperator(logic ? \"left\" : \"right\", logic ? startExclusive : !startExclusive)} ${start} `;\n    result += logic ? \"and\" : \"or\";\n    result += ` ${Range.getOperator(logic ? \"right\" : \"left\", logic ? endExclusive : !endExclusive)} ${end}`;\n    return result;\n  }\n  /**\n   * @param {Array<RangeValue>} values\n   * @param {boolean} logic is not logic applied\n   * @return {RangeValue} computed value and it's exclusive flag\n   */\n\n\n  static getRangeValue(values, logic) {\n    let minMax = logic ? Infinity : -Infinity;\n    let j = -1;\n    const predicate = logic ?\n    /** @type {RangeValueCallback} */\n    _ref => {\n      let [value] = _ref;\n      return value <= minMax;\n    } :\n    /** @type {RangeValueCallback} */\n    _ref2 => {\n      let [value] = _ref2;\n      return value >= minMax;\n    };\n\n    for (let i = 0; i < values.length; i++) {\n      if (predicate(values[i])) {\n        [minMax] = values[i];\n        j = i;\n      }\n    }\n\n    if (j > -1) {\n      return values[j];\n    }\n\n    return [Infinity, true];\n  }\n\n  constructor() {\n    /** @type {Array<RangeValue>} */\n    this._left = [];\n    /** @type {Array<RangeValue>} */\n\n    this._right = [];\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n\n  left(value) {\n    let exclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    this._left.push([value, exclusive]);\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n\n  right(value) {\n    let exclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    this._right.push([value, exclusive]);\n  }\n  /**\n   * @param {boolean} logic is not logic applied\n   * @return {string} \"smart\" range string representation\n   */\n\n\n  format() {\n    let logic = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const [start, leftExclusive] = Range.getRangeValue(this._left, logic);\n    const [end, rightExclusive] = Range.getRangeValue(this._right, !logic);\n\n    if (!Number.isFinite(start) && !Number.isFinite(end)) {\n      return \"\";\n    }\n\n    const realStart = leftExclusive ? start + 1 : start;\n    const realEnd = rightExclusive ? end - 1 : end; // e.g. 5 < x < 7, 5 < x <= 6, 6 <= x <= 6\n\n    if (realStart === realEnd) {\n      return `should be ${logic ? \"\" : \"!\"}= ${realStart}`;\n    } // e.g. 4 < x < ∞\n\n\n    if (Number.isFinite(start) && !Number.isFinite(end)) {\n      return Range.formatLeft(start, logic, leftExclusive);\n    } // e.g. ∞ < x < 4\n\n\n    if (!Number.isFinite(start) && Number.isFinite(end)) {\n      return Range.formatRight(end, logic, rightExclusive);\n    }\n\n    return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);\n  }\n\n}\n\nmodule.exports = Range;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/schema-utils/dist/util/Range.js"],"names":["Range","getOperator","side","exclusive","formatRight","value","logic","formatLeft","formatRange","start","end","startExclusive","endExclusive","result","getRangeValue","values","minMax","Infinity","j","predicate","i","length","constructor","_left","_right","left","push","right","format","leftExclusive","rightExclusive","Number","isFinite","realStart","realEnd","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/**\n * @typedef {[number, boolean]} RangeValue\n */\n\n/**\n * @callback RangeValueCallback\n * @param {RangeValue} rangeValue\n * @returns {boolean}\n */\nclass Range {\n  /**\n   * @param {\"left\" | \"right\"} side\n   * @param {boolean} exclusive\n   * @returns {\">\" | \">=\" | \"<\" | \"<=\"}\n   */\n  static getOperator(side, exclusive) {\n    if (side === \"left\") {\n      return exclusive ? \">\" : \">=\";\n    }\n\n    return exclusive ? \"<\" : \"<=\";\n  }\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n\n\n  static formatRight(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatLeft(value, !logic, !exclusive);\n    }\n\n    return `should be ${Range.getOperator(\"right\", exclusive)} ${value}`;\n  }\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n\n\n  static formatLeft(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatRight(value, !logic, !exclusive);\n    }\n\n    return `should be ${Range.getOperator(\"left\", exclusive)} ${value}`;\n  }\n  /**\n   * @param {number} start left side value\n   * @param {number} end right side value\n   * @param {boolean} startExclusive is range exclusive from left side\n   * @param {boolean} endExclusive is range exclusive from right side\n   * @param {boolean} logic is not logic applied\n   * @returns {string}\n   */\n\n\n  static formatRange(start, end, startExclusive, endExclusive, logic) {\n    let result = \"should be\";\n    result += ` ${Range.getOperator(logic ? \"left\" : \"right\", logic ? startExclusive : !startExclusive)} ${start} `;\n    result += logic ? \"and\" : \"or\";\n    result += ` ${Range.getOperator(logic ? \"right\" : \"left\", logic ? endExclusive : !endExclusive)} ${end}`;\n    return result;\n  }\n  /**\n   * @param {Array<RangeValue>} values\n   * @param {boolean} logic is not logic applied\n   * @return {RangeValue} computed value and it's exclusive flag\n   */\n\n\n  static getRangeValue(values, logic) {\n    let minMax = logic ? Infinity : -Infinity;\n    let j = -1;\n    const predicate = logic ?\n    /** @type {RangeValueCallback} */\n    ([value]) => value <= minMax :\n    /** @type {RangeValueCallback} */\n    ([value]) => value >= minMax;\n\n    for (let i = 0; i < values.length; i++) {\n      if (predicate(values[i])) {\n        [minMax] = values[i];\n        j = i;\n      }\n    }\n\n    if (j > -1) {\n      return values[j];\n    }\n\n    return [Infinity, true];\n  }\n\n  constructor() {\n    /** @type {Array<RangeValue>} */\n    this._left = [];\n    /** @type {Array<RangeValue>} */\n\n    this._right = [];\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n\n  left(value, exclusive = false) {\n    this._left.push([value, exclusive]);\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n\n  right(value, exclusive = false) {\n    this._right.push([value, exclusive]);\n  }\n  /**\n   * @param {boolean} logic is not logic applied\n   * @return {string} \"smart\" range string representation\n   */\n\n\n  format(logic = true) {\n    const [start, leftExclusive] = Range.getRangeValue(this._left, logic);\n    const [end, rightExclusive] = Range.getRangeValue(this._right, !logic);\n\n    if (!Number.isFinite(start) && !Number.isFinite(end)) {\n      return \"\";\n    }\n\n    const realStart = leftExclusive ? start + 1 : start;\n    const realEnd = rightExclusive ? end - 1 : end; // e.g. 5 < x < 7, 5 < x <= 6, 6 <= x <= 6\n\n    if (realStart === realEnd) {\n      return `should be ${logic ? \"\" : \"!\"}= ${realStart}`;\n    } // e.g. 4 < x < ∞\n\n\n    if (Number.isFinite(start) && !Number.isFinite(end)) {\n      return Range.formatLeft(start, logic, leftExclusive);\n    } // e.g. ∞ < x < 4\n\n\n    if (!Number.isFinite(start) && Number.isFinite(end)) {\n      return Range.formatRight(end, logic, rightExclusive);\n    }\n\n    return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);\n  }\n\n}\n\nmodule.exports = Range;"]},"metadata":{},"sourceType":"script"}