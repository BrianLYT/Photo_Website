{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/** @type {WeakMap<object, WeakMap<object, object>>} */\n\nconst mergeCache = new WeakMap();\n/** @type {WeakMap<object, Map<string, Map<string|number|boolean, object>>>} */\n\nconst setPropertyCache = new WeakMap();\nconst DELETE = Symbol(\"DELETE\");\nconst DYNAMIC_INFO = Symbol(\"cleverMerge dynamic info\");\n/**\n * Merges two given objects and caches the result to avoid computation if same objects passed as arguments again.\n * @template T\n * @template O\n * @example\n * // performs cleverMerge(first, second), stores the result in WeakMap and returns result\n * cachedCleverMerge({a: 1}, {a: 2})\n * {a: 2}\n *  // when same arguments passed, gets the result from WeakMap and returns it.\n * cachedCleverMerge({a: 1}, {a: 2})\n * {a: 2}\n * @param {T} first first object\n * @param {O} second second object\n * @returns {T & O | T | O} merged object of first and second object\n */\n\nconst cachedCleverMerge = (first, second) => {\n  if (second === undefined) return first;\n  if (first === undefined) return second;\n  if (typeof second !== \"object\" || second === null) return second;\n  if (typeof first !== \"object\" || first === null) return first;\n  let innerCache = mergeCache.get(first);\n\n  if (innerCache === undefined) {\n    innerCache = new WeakMap();\n    mergeCache.set(first, innerCache);\n  }\n\n  const prevMerge = innerCache.get(second);\n  if (prevMerge !== undefined) return prevMerge;\n\n  const newMerge = _cleverMerge(first, second, true);\n\n  innerCache.set(second, newMerge);\n  return newMerge;\n};\n/**\n * @template T\n * @param {Partial<T>} obj object\n * @param {string} property property\n * @param {string|number|boolean} value assignment value\n * @returns {T} new object\n */\n\n\nconst cachedSetProperty = (obj, property, value) => {\n  let mapByProperty = setPropertyCache.get(obj);\n\n  if (mapByProperty === undefined) {\n    mapByProperty = new Map();\n    setPropertyCache.set(obj, mapByProperty);\n  }\n\n  let mapByValue = mapByProperty.get(property);\n\n  if (mapByValue === undefined) {\n    mapByValue = new Map();\n    mapByProperty.set(property, mapByValue);\n  }\n\n  let result = mapByValue.get(value);\n  if (result) return result;\n  result = { ...obj,\n    [property]: value\n  };\n  mapByValue.set(value, result);\n  return result;\n};\n/**\n * @typedef {Object} ObjectParsedPropertyEntry\n * @property {any | undefined} base base value\n * @property {string | undefined} byProperty the name of the selector property\n * @property {Map<string, any>} byValues value depending on selector property, merged with base\n */\n\n/**\n * @typedef {Object} ParsedObject\n * @property {Map<string, ObjectParsedPropertyEntry>} static static properties (key is property name)\n * @property {{ byProperty: string, fn: Function } | undefined} dynamic dynamic part\n */\n\n/** @type {WeakMap<object, ParsedObject>} */\n\n\nconst parseCache = new WeakMap();\n/**\n * @param {object} obj the object\n * @returns {ParsedObject} parsed object\n */\n\nconst cachedParseObject = obj => {\n  const entry = parseCache.get(obj);\n  if (entry !== undefined) return entry;\n  const result = parseObject(obj);\n  parseCache.set(obj, result);\n  return result;\n};\n/**\n * @param {object} obj the object\n * @returns {ParsedObject} parsed object\n */\n\n\nconst parseObject = obj => {\n  const info = new Map();\n  let dynamicInfo;\n\n  const getInfo = p => {\n    const entry = info.get(p);\n    if (entry !== undefined) return entry;\n    const newEntry = {\n      base: undefined,\n      byProperty: undefined,\n      byValues: undefined\n    };\n    info.set(p, newEntry);\n    return newEntry;\n  };\n\n  for (const key of Object.keys(obj)) {\n    if (key.startsWith(\"by\")) {\n      const byProperty = key;\n      const byObj = obj[byProperty];\n\n      if (typeof byObj === \"object\") {\n        for (const byValue of Object.keys(byObj)) {\n          const obj = byObj[byValue];\n\n          for (const key of Object.keys(obj)) {\n            const entry = getInfo(key);\n\n            if (entry.byProperty === undefined) {\n              entry.byProperty = byProperty;\n              entry.byValues = new Map();\n            } else if (entry.byProperty !== byProperty) {\n              throw new Error(`${byProperty} and ${entry.byProperty} for a single property is not supported`);\n            }\n\n            entry.byValues.set(byValue, obj[key]);\n\n            if (byValue === \"default\") {\n              for (const otherByValue of Object.keys(byObj)) {\n                if (!entry.byValues.has(otherByValue)) entry.byValues.set(otherByValue, undefined);\n              }\n            }\n          }\n        }\n      } else if (typeof byObj === \"function\") {\n        if (dynamicInfo === undefined) {\n          dynamicInfo = {\n            byProperty: key,\n            fn: byObj\n          };\n        } else {\n          throw new Error(`${key} and ${dynamicInfo.byProperty} when both are functions is not supported`);\n        }\n      } else {\n        const entry = getInfo(key);\n        entry.base = obj[key];\n      }\n    } else {\n      const entry = getInfo(key);\n      entry.base = obj[key];\n    }\n  }\n\n  return {\n    static: info,\n    dynamic: dynamicInfo\n  };\n};\n/**\n * @param {Map<string, ObjectParsedPropertyEntry>} info static properties (key is property name)\n * @param {{ byProperty: string, fn: Function } | undefined} dynamicInfo dynamic part\n * @returns {object} the object\n */\n\n\nconst serializeObject = (info, dynamicInfo) => {\n  const obj = {}; // Setup byProperty structure\n\n  for (const entry of info.values()) {\n    if (entry.byProperty !== undefined) {\n      const byObj = obj[entry.byProperty] = obj[entry.byProperty] || {};\n\n      for (const byValue of entry.byValues.keys()) {\n        byObj[byValue] = byObj[byValue] || {};\n      }\n    }\n  }\n\n  for (const [key, entry] of info) {\n    if (entry.base !== undefined) {\n      obj[key] = entry.base;\n    } // Fill byProperty structure\n\n\n    if (entry.byProperty !== undefined) {\n      const byObj = obj[entry.byProperty] = obj[entry.byProperty] || {};\n\n      for (const byValue of Object.keys(byObj)) {\n        const value = getFromByValues(entry.byValues, byValue);\n        if (value !== undefined) byObj[byValue][key] = value;\n      }\n    }\n  }\n\n  if (dynamicInfo !== undefined) {\n    obj[dynamicInfo.byProperty] = dynamicInfo.fn;\n  }\n\n  return obj;\n};\n\nconst VALUE_TYPE_UNDEFINED = 0;\nconst VALUE_TYPE_ATOM = 1;\nconst VALUE_TYPE_ARRAY_EXTEND = 2;\nconst VALUE_TYPE_OBJECT = 3;\nconst VALUE_TYPE_DELETE = 4;\n/**\n * @param {any} value a single value\n * @returns {VALUE_TYPE_UNDEFINED | VALUE_TYPE_ATOM | VALUE_TYPE_ARRAY_EXTEND | VALUE_TYPE_OBJECT | VALUE_TYPE_DELETE} value type\n */\n\nconst getValueType = value => {\n  if (value === undefined) {\n    return VALUE_TYPE_UNDEFINED;\n  } else if (value === DELETE) {\n    return VALUE_TYPE_DELETE;\n  } else if (Array.isArray(value)) {\n    if (value.lastIndexOf(\"...\") !== -1) return VALUE_TYPE_ARRAY_EXTEND;\n    return VALUE_TYPE_ATOM;\n  } else if (typeof value === \"object\" && value !== null && (!value.constructor || value.constructor === Object)) {\n    return VALUE_TYPE_OBJECT;\n  }\n\n  return VALUE_TYPE_ATOM;\n};\n/**\n * Merges two objects. Objects are deeply clever merged.\n * Arrays might reference the old value with \"...\".\n * Non-object values take preference over object values.\n * @template T\n * @template O\n * @param {T} first first object\n * @param {O} second second object\n * @returns {T & O | T | O} merged object of first and second object\n */\n\n\nconst cleverMerge = (first, second) => {\n  if (second === undefined) return first;\n  if (first === undefined) return second;\n  if (typeof second !== \"object\" || second === null) return second;\n  if (typeof first !== \"object\" || first === null) return first;\n  return _cleverMerge(first, second, false);\n};\n/**\n * Merges two objects. Objects are deeply clever merged.\n * @param {object} first first object\n * @param {object} second second object\n * @param {boolean} internalCaching should parsing of objects and nested merges be cached\n * @returns {object} merged object of first and second object\n */\n\n\nconst _cleverMerge = function (first, second) {\n  let internalCaching = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const firstObject = internalCaching ? cachedParseObject(first) : parseObject(first);\n  const {\n    static: firstInfo,\n    dynamic: firstDynamicInfo\n  } = firstObject; // If the first argument has a dynamic part we modify the dynamic part to merge the second argument\n\n  if (firstDynamicInfo !== undefined) {\n    let {\n      byProperty,\n      fn\n    } = firstDynamicInfo;\n    const fnInfo = fn[DYNAMIC_INFO];\n\n    if (fnInfo) {\n      second = internalCaching ? cachedCleverMerge(fnInfo[1], second) : cleverMerge(fnInfo[1], second);\n      fn = fnInfo[0];\n    }\n\n    const newFn = function () {\n      const fnResult = fn(...arguments);\n      return internalCaching ? cachedCleverMerge(fnResult, second) : cleverMerge(fnResult, second);\n    };\n\n    newFn[DYNAMIC_INFO] = [fn, second];\n    return serializeObject(firstObject.static, {\n      byProperty,\n      fn: newFn\n    });\n  } // If the first part is static only, we merge the static parts and keep the dynamic part of the second argument\n\n\n  const secondObject = internalCaching ? cachedParseObject(second) : parseObject(second);\n  const {\n    static: secondInfo,\n    dynamic: secondDynamicInfo\n  } = secondObject;\n  /** @type {Map<string, ObjectParsedPropertyEntry>} */\n\n  const resultInfo = new Map();\n\n  for (const [key, firstEntry] of firstInfo) {\n    const secondEntry = secondInfo.get(key);\n    const entry = secondEntry !== undefined ? mergeEntries(firstEntry, secondEntry, internalCaching) : firstEntry;\n    resultInfo.set(key, entry);\n  }\n\n  for (const [key, secondEntry] of secondInfo) {\n    if (!firstInfo.has(key)) {\n      resultInfo.set(key, secondEntry);\n    }\n  }\n\n  return serializeObject(resultInfo, secondDynamicInfo);\n};\n/**\n * @param {ObjectParsedPropertyEntry} firstEntry a\n * @param {ObjectParsedPropertyEntry} secondEntry b\n * @param {boolean} internalCaching should parsing of objects and nested merges be cached\n * @returns {ObjectParsedPropertyEntry} new entry\n */\n\n\nconst mergeEntries = (firstEntry, secondEntry, internalCaching) => {\n  switch (getValueType(secondEntry.base)) {\n    case VALUE_TYPE_ATOM:\n    case VALUE_TYPE_DELETE:\n      // No need to consider firstEntry at all\n      // second value override everything\n      // = second.base + second.byProperty\n      return secondEntry;\n\n    case VALUE_TYPE_UNDEFINED:\n      if (!firstEntry.byProperty) {\n        // = first.base + second.byProperty\n        return {\n          base: firstEntry.base,\n          byProperty: secondEntry.byProperty,\n          byValues: secondEntry.byValues\n        };\n      } else if (firstEntry.byProperty !== secondEntry.byProperty) {\n        throw new Error(`${firstEntry.byProperty} and ${secondEntry.byProperty} for a single property is not supported`);\n      } else {\n        // = first.base + (first.byProperty + second.byProperty)\n        // need to merge first and second byValues\n        const newByValues = new Map(firstEntry.byValues);\n\n        for (const [key, value] of secondEntry.byValues) {\n          const firstValue = getFromByValues(firstEntry.byValues, key);\n          newByValues.set(key, mergeSingleValue(firstValue, value, internalCaching));\n        }\n\n        return {\n          base: firstEntry.base,\n          byProperty: firstEntry.byProperty,\n          byValues: newByValues\n        };\n      }\n\n    default:\n      {\n        if (!firstEntry.byProperty) {\n          // The simple case\n          // = (first.base + second.base) + second.byProperty\n          return {\n            base: mergeSingleValue(firstEntry.base, secondEntry.base, internalCaching),\n            byProperty: secondEntry.byProperty,\n            byValues: secondEntry.byValues\n          };\n        }\n\n        let newBase;\n        const intermediateByValues = new Map(firstEntry.byValues);\n\n        for (const [key, value] of intermediateByValues) {\n          intermediateByValues.set(key, mergeSingleValue(value, secondEntry.base, internalCaching));\n        }\n\n        if (Array.from(firstEntry.byValues.values()).every(value => {\n          const type = getValueType(value);\n          return type === VALUE_TYPE_ATOM || type === VALUE_TYPE_DELETE;\n        })) {\n          // = (first.base + second.base) + ((first.byProperty + second.base) + second.byProperty)\n          newBase = mergeSingleValue(firstEntry.base, secondEntry.base, internalCaching);\n        } else {\n          // = first.base + ((first.byProperty (+default) + second.base) + second.byProperty)\n          newBase = firstEntry.base;\n          if (!intermediateByValues.has(\"default\")) intermediateByValues.set(\"default\", secondEntry.base);\n        }\n\n        if (!secondEntry.byProperty) {\n          // = first.base + (first.byProperty + second.base)\n          return {\n            base: newBase,\n            byProperty: firstEntry.byProperty,\n            byValues: intermediateByValues\n          };\n        } else if (firstEntry.byProperty !== secondEntry.byProperty) {\n          throw new Error(`${firstEntry.byProperty} and ${secondEntry.byProperty} for a single property is not supported`);\n        }\n\n        const newByValues = new Map(intermediateByValues);\n\n        for (const [key, value] of secondEntry.byValues) {\n          const firstValue = getFromByValues(intermediateByValues, key);\n          newByValues.set(key, mergeSingleValue(firstValue, value, internalCaching));\n        }\n\n        return {\n          base: newBase,\n          byProperty: firstEntry.byProperty,\n          byValues: newByValues\n        };\n      }\n  }\n};\n/**\n * @param {Map<string, any>} byValues all values\n * @param {string} key value of the selector\n * @returns {any | undefined} value\n */\n\n\nconst getFromByValues = (byValues, key) => {\n  if (key !== \"default\" && byValues.has(key)) {\n    return byValues.get(key);\n  }\n\n  return byValues.get(\"default\");\n};\n/**\n * @param {any} a value\n * @param {any} b value\n * @param {boolean} internalCaching should parsing of objects and nested merges be cached\n * @returns {any} value\n */\n\n\nconst mergeSingleValue = (a, b, internalCaching) => {\n  const bType = getValueType(b);\n  const aType = getValueType(a);\n\n  switch (bType) {\n    case VALUE_TYPE_DELETE:\n    case VALUE_TYPE_ATOM:\n      return b;\n\n    case VALUE_TYPE_OBJECT:\n      {\n        return aType !== VALUE_TYPE_OBJECT ? b : internalCaching ? cachedCleverMerge(a, b) : cleverMerge(a, b);\n      }\n\n    case VALUE_TYPE_UNDEFINED:\n      return a;\n\n    case VALUE_TYPE_ARRAY_EXTEND:\n      switch (aType !== VALUE_TYPE_ATOM ? aType : Array.isArray(a) ? VALUE_TYPE_ARRAY_EXTEND : VALUE_TYPE_OBJECT) {\n        case VALUE_TYPE_UNDEFINED:\n          return b;\n\n        case VALUE_TYPE_DELETE:\n          return b.filter(item => item !== \"...\");\n\n        case VALUE_TYPE_ARRAY_EXTEND:\n          {\n            const newArray = [];\n\n            for (const item of b) {\n              if (item === \"...\") {\n                for (const item of a) {\n                  newArray.push(item);\n                }\n              } else {\n                newArray.push(item);\n              }\n            }\n\n            return newArray;\n          }\n\n        case VALUE_TYPE_OBJECT:\n          return b.map(item => item === \"...\" ? a : item);\n\n        default:\n          throw new Error(\"Not implemented\");\n      }\n\n    default:\n      throw new Error(\"Not implemented\");\n  }\n};\n/**\n * @template T\n * @param {T} obj the object\n * @returns {T} the object without operations like \"...\" or DELETE\n */\n\n\nconst removeOperations = obj => {\n  const newObj =\n  /** @type {T} */\n  {};\n\n  for (const key of Object.keys(obj)) {\n    const value = obj[key];\n    const type = getValueType(value);\n\n    switch (type) {\n      case VALUE_TYPE_UNDEFINED:\n      case VALUE_TYPE_DELETE:\n        break;\n\n      case VALUE_TYPE_OBJECT:\n        newObj[key] = removeOperations(value);\n        break;\n\n      case VALUE_TYPE_ARRAY_EXTEND:\n        newObj[key] = value.filter(i => i !== \"...\");\n        break;\n\n      default:\n        newObj[key] = value;\n        break;\n    }\n  }\n\n  return newObj;\n};\n/**\n * @template T\n * @template {string} P\n * @param {T} obj the object\n * @param {P} byProperty the by description\n * @param  {...any} values values\n * @returns {Omit<T, P>} object with merged byProperty\n */\n\n\nconst resolveByProperty = function (obj, byProperty) {\n  if (typeof obj !== \"object\" || obj === null || !(byProperty in obj)) {\n    return obj;\n  }\n\n  const {\n    [byProperty]: _byValue,\n    ..._remaining\n  } =\n  /** @type {object} */\n  obj;\n  const remaining =\n  /** @type {T} */\n  _remaining;\n  const byValue =\n  /** @type {Record<string, T> | function(...any[]): T} */\n  _byValue;\n\n  for (var _len = arguments.length, values = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    values[_key - 2] = arguments[_key];\n  }\n\n  if (typeof byValue === \"object\") {\n    const key = values[0];\n\n    if (key in byValue) {\n      return cachedCleverMerge(remaining, byValue[key]);\n    } else if (\"default\" in byValue) {\n      return cachedCleverMerge(remaining, byValue.default);\n    } else {\n      return (\n        /** @type {T} */\n        remaining\n      );\n    }\n  } else if (typeof byValue === \"function\") {\n    const result = byValue.apply(null, values);\n    return cachedCleverMerge(remaining, resolveByProperty(result, byProperty, ...values));\n  }\n};\n\nexports.cachedSetProperty = cachedSetProperty;\nexports.cachedCleverMerge = cachedCleverMerge;\nexports.cleverMerge = cleverMerge;\nexports.resolveByProperty = resolveByProperty;\nexports.removeOperations = removeOperations;\nexports.DELETE = DELETE;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/util/cleverMerge.js"],"names":["mergeCache","WeakMap","setPropertyCache","DELETE","Symbol","DYNAMIC_INFO","cachedCleverMerge","first","second","undefined","innerCache","get","set","prevMerge","newMerge","_cleverMerge","cachedSetProperty","obj","property","value","mapByProperty","Map","mapByValue","result","parseCache","cachedParseObject","entry","parseObject","info","dynamicInfo","getInfo","p","newEntry","base","byProperty","byValues","key","Object","keys","startsWith","byObj","byValue","Error","otherByValue","has","fn","static","dynamic","serializeObject","values","getFromByValues","VALUE_TYPE_UNDEFINED","VALUE_TYPE_ATOM","VALUE_TYPE_ARRAY_EXTEND","VALUE_TYPE_OBJECT","VALUE_TYPE_DELETE","getValueType","Array","isArray","lastIndexOf","constructor","cleverMerge","internalCaching","firstObject","firstInfo","firstDynamicInfo","fnInfo","newFn","fnResult","secondObject","secondInfo","secondDynamicInfo","resultInfo","firstEntry","secondEntry","mergeEntries","newByValues","firstValue","mergeSingleValue","newBase","intermediateByValues","from","every","type","a","b","bType","aType","filter","item","newArray","push","map","removeOperations","newObj","i","resolveByProperty","_byValue","_remaining","remaining","default","apply","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @type {WeakMap<object, WeakMap<object, object>>} */\nconst mergeCache = new WeakMap();\n/** @type {WeakMap<object, Map<string, Map<string|number|boolean, object>>>} */\nconst setPropertyCache = new WeakMap();\nconst DELETE = Symbol(\"DELETE\");\nconst DYNAMIC_INFO = Symbol(\"cleverMerge dynamic info\");\n\n/**\n * Merges two given objects and caches the result to avoid computation if same objects passed as arguments again.\n * @template T\n * @template O\n * @example\n * // performs cleverMerge(first, second), stores the result in WeakMap and returns result\n * cachedCleverMerge({a: 1}, {a: 2})\n * {a: 2}\n *  // when same arguments passed, gets the result from WeakMap and returns it.\n * cachedCleverMerge({a: 1}, {a: 2})\n * {a: 2}\n * @param {T} first first object\n * @param {O} second second object\n * @returns {T & O | T | O} merged object of first and second object\n */\nconst cachedCleverMerge = (first, second) => {\n\tif (second === undefined) return first;\n\tif (first === undefined) return second;\n\tif (typeof second !== \"object\" || second === null) return second;\n\tif (typeof first !== \"object\" || first === null) return first;\n\n\tlet innerCache = mergeCache.get(first);\n\tif (innerCache === undefined) {\n\t\tinnerCache = new WeakMap();\n\t\tmergeCache.set(first, innerCache);\n\t}\n\tconst prevMerge = innerCache.get(second);\n\tif (prevMerge !== undefined) return prevMerge;\n\tconst newMerge = _cleverMerge(first, second, true);\n\tinnerCache.set(second, newMerge);\n\treturn newMerge;\n};\n\n/**\n * @template T\n * @param {Partial<T>} obj object\n * @param {string} property property\n * @param {string|number|boolean} value assignment value\n * @returns {T} new object\n */\nconst cachedSetProperty = (obj, property, value) => {\n\tlet mapByProperty = setPropertyCache.get(obj);\n\n\tif (mapByProperty === undefined) {\n\t\tmapByProperty = new Map();\n\t\tsetPropertyCache.set(obj, mapByProperty);\n\t}\n\n\tlet mapByValue = mapByProperty.get(property);\n\n\tif (mapByValue === undefined) {\n\t\tmapByValue = new Map();\n\t\tmapByProperty.set(property, mapByValue);\n\t}\n\n\tlet result = mapByValue.get(value);\n\n\tif (result) return result;\n\n\tresult = {\n\t\t...obj,\n\t\t[property]: value\n\t};\n\tmapByValue.set(value, result);\n\n\treturn result;\n};\n\n/**\n * @typedef {Object} ObjectParsedPropertyEntry\n * @property {any | undefined} base base value\n * @property {string | undefined} byProperty the name of the selector property\n * @property {Map<string, any>} byValues value depending on selector property, merged with base\n */\n\n/**\n * @typedef {Object} ParsedObject\n * @property {Map<string, ObjectParsedPropertyEntry>} static static properties (key is property name)\n * @property {{ byProperty: string, fn: Function } | undefined} dynamic dynamic part\n */\n\n/** @type {WeakMap<object, ParsedObject>} */\nconst parseCache = new WeakMap();\n\n/**\n * @param {object} obj the object\n * @returns {ParsedObject} parsed object\n */\nconst cachedParseObject = obj => {\n\tconst entry = parseCache.get(obj);\n\tif (entry !== undefined) return entry;\n\tconst result = parseObject(obj);\n\tparseCache.set(obj, result);\n\treturn result;\n};\n\n/**\n * @param {object} obj the object\n * @returns {ParsedObject} parsed object\n */\nconst parseObject = obj => {\n\tconst info = new Map();\n\tlet dynamicInfo;\n\tconst getInfo = p => {\n\t\tconst entry = info.get(p);\n\t\tif (entry !== undefined) return entry;\n\t\tconst newEntry = {\n\t\t\tbase: undefined,\n\t\t\tbyProperty: undefined,\n\t\t\tbyValues: undefined\n\t\t};\n\t\tinfo.set(p, newEntry);\n\t\treturn newEntry;\n\t};\n\tfor (const key of Object.keys(obj)) {\n\t\tif (key.startsWith(\"by\")) {\n\t\t\tconst byProperty = key;\n\t\t\tconst byObj = obj[byProperty];\n\t\t\tif (typeof byObj === \"object\") {\n\t\t\t\tfor (const byValue of Object.keys(byObj)) {\n\t\t\t\t\tconst obj = byObj[byValue];\n\t\t\t\t\tfor (const key of Object.keys(obj)) {\n\t\t\t\t\t\tconst entry = getInfo(key);\n\t\t\t\t\t\tif (entry.byProperty === undefined) {\n\t\t\t\t\t\t\tentry.byProperty = byProperty;\n\t\t\t\t\t\t\tentry.byValues = new Map();\n\t\t\t\t\t\t} else if (entry.byProperty !== byProperty) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`${byProperty} and ${entry.byProperty} for a single property is not supported`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tentry.byValues.set(byValue, obj[key]);\n\t\t\t\t\t\tif (byValue === \"default\") {\n\t\t\t\t\t\t\tfor (const otherByValue of Object.keys(byObj)) {\n\t\t\t\t\t\t\t\tif (!entry.byValues.has(otherByValue))\n\t\t\t\t\t\t\t\t\tentry.byValues.set(otherByValue, undefined);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (typeof byObj === \"function\") {\n\t\t\t\tif (dynamicInfo === undefined) {\n\t\t\t\t\tdynamicInfo = {\n\t\t\t\t\t\tbyProperty: key,\n\t\t\t\t\t\tfn: byObj\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`${key} and ${dynamicInfo.byProperty} when both are functions is not supported`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst entry = getInfo(key);\n\t\t\t\tentry.base = obj[key];\n\t\t\t}\n\t\t} else {\n\t\t\tconst entry = getInfo(key);\n\t\t\tentry.base = obj[key];\n\t\t}\n\t}\n\treturn {\n\t\tstatic: info,\n\t\tdynamic: dynamicInfo\n\t};\n};\n\n/**\n * @param {Map<string, ObjectParsedPropertyEntry>} info static properties (key is property name)\n * @param {{ byProperty: string, fn: Function } | undefined} dynamicInfo dynamic part\n * @returns {object} the object\n */\nconst serializeObject = (info, dynamicInfo) => {\n\tconst obj = {};\n\t// Setup byProperty structure\n\tfor (const entry of info.values()) {\n\t\tif (entry.byProperty !== undefined) {\n\t\t\tconst byObj = (obj[entry.byProperty] = obj[entry.byProperty] || {});\n\t\t\tfor (const byValue of entry.byValues.keys()) {\n\t\t\t\tbyObj[byValue] = byObj[byValue] || {};\n\t\t\t}\n\t\t}\n\t}\n\tfor (const [key, entry] of info) {\n\t\tif (entry.base !== undefined) {\n\t\t\tobj[key] = entry.base;\n\t\t}\n\t\t// Fill byProperty structure\n\t\tif (entry.byProperty !== undefined) {\n\t\t\tconst byObj = (obj[entry.byProperty] = obj[entry.byProperty] || {});\n\t\t\tfor (const byValue of Object.keys(byObj)) {\n\t\t\t\tconst value = getFromByValues(entry.byValues, byValue);\n\t\t\t\tif (value !== undefined) byObj[byValue][key] = value;\n\t\t\t}\n\t\t}\n\t}\n\tif (dynamicInfo !== undefined) {\n\t\tobj[dynamicInfo.byProperty] = dynamicInfo.fn;\n\t}\n\treturn obj;\n};\n\nconst VALUE_TYPE_UNDEFINED = 0;\nconst VALUE_TYPE_ATOM = 1;\nconst VALUE_TYPE_ARRAY_EXTEND = 2;\nconst VALUE_TYPE_OBJECT = 3;\nconst VALUE_TYPE_DELETE = 4;\n\n/**\n * @param {any} value a single value\n * @returns {VALUE_TYPE_UNDEFINED | VALUE_TYPE_ATOM | VALUE_TYPE_ARRAY_EXTEND | VALUE_TYPE_OBJECT | VALUE_TYPE_DELETE} value type\n */\nconst getValueType = value => {\n\tif (value === undefined) {\n\t\treturn VALUE_TYPE_UNDEFINED;\n\t} else if (value === DELETE) {\n\t\treturn VALUE_TYPE_DELETE;\n\t} else if (Array.isArray(value)) {\n\t\tif (value.lastIndexOf(\"...\") !== -1) return VALUE_TYPE_ARRAY_EXTEND;\n\t\treturn VALUE_TYPE_ATOM;\n\t} else if (\n\t\ttypeof value === \"object\" &&\n\t\tvalue !== null &&\n\t\t(!value.constructor || value.constructor === Object)\n\t) {\n\t\treturn VALUE_TYPE_OBJECT;\n\t}\n\treturn VALUE_TYPE_ATOM;\n};\n\n/**\n * Merges two objects. Objects are deeply clever merged.\n * Arrays might reference the old value with \"...\".\n * Non-object values take preference over object values.\n * @template T\n * @template O\n * @param {T} first first object\n * @param {O} second second object\n * @returns {T & O | T | O} merged object of first and second object\n */\nconst cleverMerge = (first, second) => {\n\tif (second === undefined) return first;\n\tif (first === undefined) return second;\n\tif (typeof second !== \"object\" || second === null) return second;\n\tif (typeof first !== \"object\" || first === null) return first;\n\n\treturn _cleverMerge(first, second, false);\n};\n\n/**\n * Merges two objects. Objects are deeply clever merged.\n * @param {object} first first object\n * @param {object} second second object\n * @param {boolean} internalCaching should parsing of objects and nested merges be cached\n * @returns {object} merged object of first and second object\n */\nconst _cleverMerge = (first, second, internalCaching = false) => {\n\tconst firstObject = internalCaching\n\t\t? cachedParseObject(first)\n\t\t: parseObject(first);\n\tconst { static: firstInfo, dynamic: firstDynamicInfo } = firstObject;\n\n\t// If the first argument has a dynamic part we modify the dynamic part to merge the second argument\n\tif (firstDynamicInfo !== undefined) {\n\t\tlet { byProperty, fn } = firstDynamicInfo;\n\t\tconst fnInfo = fn[DYNAMIC_INFO];\n\t\tif (fnInfo) {\n\t\t\tsecond = internalCaching\n\t\t\t\t? cachedCleverMerge(fnInfo[1], second)\n\t\t\t\t: cleverMerge(fnInfo[1], second);\n\t\t\tfn = fnInfo[0];\n\t\t}\n\t\tconst newFn = (...args) => {\n\t\t\tconst fnResult = fn(...args);\n\t\t\treturn internalCaching\n\t\t\t\t? cachedCleverMerge(fnResult, second)\n\t\t\t\t: cleverMerge(fnResult, second);\n\t\t};\n\t\tnewFn[DYNAMIC_INFO] = [fn, second];\n\t\treturn serializeObject(firstObject.static, { byProperty, fn: newFn });\n\t}\n\n\t// If the first part is static only, we merge the static parts and keep the dynamic part of the second argument\n\tconst secondObject = internalCaching\n\t\t? cachedParseObject(second)\n\t\t: parseObject(second);\n\tconst { static: secondInfo, dynamic: secondDynamicInfo } = secondObject;\n\t/** @type {Map<string, ObjectParsedPropertyEntry>} */\n\tconst resultInfo = new Map();\n\tfor (const [key, firstEntry] of firstInfo) {\n\t\tconst secondEntry = secondInfo.get(key);\n\t\tconst entry =\n\t\t\tsecondEntry !== undefined\n\t\t\t\t? mergeEntries(firstEntry, secondEntry, internalCaching)\n\t\t\t\t: firstEntry;\n\t\tresultInfo.set(key, entry);\n\t}\n\tfor (const [key, secondEntry] of secondInfo) {\n\t\tif (!firstInfo.has(key)) {\n\t\t\tresultInfo.set(key, secondEntry);\n\t\t}\n\t}\n\treturn serializeObject(resultInfo, secondDynamicInfo);\n};\n\n/**\n * @param {ObjectParsedPropertyEntry} firstEntry a\n * @param {ObjectParsedPropertyEntry} secondEntry b\n * @param {boolean} internalCaching should parsing of objects and nested merges be cached\n * @returns {ObjectParsedPropertyEntry} new entry\n */\nconst mergeEntries = (firstEntry, secondEntry, internalCaching) => {\n\tswitch (getValueType(secondEntry.base)) {\n\t\tcase VALUE_TYPE_ATOM:\n\t\tcase VALUE_TYPE_DELETE:\n\t\t\t// No need to consider firstEntry at all\n\t\t\t// second value override everything\n\t\t\t// = second.base + second.byProperty\n\t\t\treturn secondEntry;\n\t\tcase VALUE_TYPE_UNDEFINED:\n\t\t\tif (!firstEntry.byProperty) {\n\t\t\t\t// = first.base + second.byProperty\n\t\t\t\treturn {\n\t\t\t\t\tbase: firstEntry.base,\n\t\t\t\t\tbyProperty: secondEntry.byProperty,\n\t\t\t\t\tbyValues: secondEntry.byValues\n\t\t\t\t};\n\t\t\t} else if (firstEntry.byProperty !== secondEntry.byProperty) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`${firstEntry.byProperty} and ${secondEntry.byProperty} for a single property is not supported`\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// = first.base + (first.byProperty + second.byProperty)\n\t\t\t\t// need to merge first and second byValues\n\t\t\t\tconst newByValues = new Map(firstEntry.byValues);\n\t\t\t\tfor (const [key, value] of secondEntry.byValues) {\n\t\t\t\t\tconst firstValue = getFromByValues(firstEntry.byValues, key);\n\t\t\t\t\tnewByValues.set(\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tmergeSingleValue(firstValue, value, internalCaching)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tbase: firstEntry.base,\n\t\t\t\t\tbyProperty: firstEntry.byProperty,\n\t\t\t\t\tbyValues: newByValues\n\t\t\t\t};\n\t\t\t}\n\t\tdefault: {\n\t\t\tif (!firstEntry.byProperty) {\n\t\t\t\t// The simple case\n\t\t\t\t// = (first.base + second.base) + second.byProperty\n\t\t\t\treturn {\n\t\t\t\t\tbase: mergeSingleValue(\n\t\t\t\t\t\tfirstEntry.base,\n\t\t\t\t\t\tsecondEntry.base,\n\t\t\t\t\t\tinternalCaching\n\t\t\t\t\t),\n\t\t\t\t\tbyProperty: secondEntry.byProperty,\n\t\t\t\t\tbyValues: secondEntry.byValues\n\t\t\t\t};\n\t\t\t}\n\t\t\tlet newBase;\n\t\t\tconst intermediateByValues = new Map(firstEntry.byValues);\n\t\t\tfor (const [key, value] of intermediateByValues) {\n\t\t\t\tintermediateByValues.set(\n\t\t\t\t\tkey,\n\t\t\t\t\tmergeSingleValue(value, secondEntry.base, internalCaching)\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (\n\t\t\t\tArray.from(firstEntry.byValues.values()).every(value => {\n\t\t\t\t\tconst type = getValueType(value);\n\t\t\t\t\treturn type === VALUE_TYPE_ATOM || type === VALUE_TYPE_DELETE;\n\t\t\t\t})\n\t\t\t) {\n\t\t\t\t// = (first.base + second.base) + ((first.byProperty + second.base) + second.byProperty)\n\t\t\t\tnewBase = mergeSingleValue(\n\t\t\t\t\tfirstEntry.base,\n\t\t\t\t\tsecondEntry.base,\n\t\t\t\t\tinternalCaching\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// = first.base + ((first.byProperty (+default) + second.base) + second.byProperty)\n\t\t\t\tnewBase = firstEntry.base;\n\t\t\t\tif (!intermediateByValues.has(\"default\"))\n\t\t\t\t\tintermediateByValues.set(\"default\", secondEntry.base);\n\t\t\t}\n\t\t\tif (!secondEntry.byProperty) {\n\t\t\t\t// = first.base + (first.byProperty + second.base)\n\t\t\t\treturn {\n\t\t\t\t\tbase: newBase,\n\t\t\t\t\tbyProperty: firstEntry.byProperty,\n\t\t\t\t\tbyValues: intermediateByValues\n\t\t\t\t};\n\t\t\t} else if (firstEntry.byProperty !== secondEntry.byProperty) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`${firstEntry.byProperty} and ${secondEntry.byProperty} for a single property is not supported`\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst newByValues = new Map(intermediateByValues);\n\t\t\tfor (const [key, value] of secondEntry.byValues) {\n\t\t\t\tconst firstValue = getFromByValues(intermediateByValues, key);\n\t\t\t\tnewByValues.set(\n\t\t\t\t\tkey,\n\t\t\t\t\tmergeSingleValue(firstValue, value, internalCaching)\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tbase: newBase,\n\t\t\t\tbyProperty: firstEntry.byProperty,\n\t\t\t\tbyValues: newByValues\n\t\t\t};\n\t\t}\n\t}\n};\n\n/**\n * @param {Map<string, any>} byValues all values\n * @param {string} key value of the selector\n * @returns {any | undefined} value\n */\nconst getFromByValues = (byValues, key) => {\n\tif (key !== \"default\" && byValues.has(key)) {\n\t\treturn byValues.get(key);\n\t}\n\treturn byValues.get(\"default\");\n};\n\n/**\n * @param {any} a value\n * @param {any} b value\n * @param {boolean} internalCaching should parsing of objects and nested merges be cached\n * @returns {any} value\n */\nconst mergeSingleValue = (a, b, internalCaching) => {\n\tconst bType = getValueType(b);\n\tconst aType = getValueType(a);\n\tswitch (bType) {\n\t\tcase VALUE_TYPE_DELETE:\n\t\tcase VALUE_TYPE_ATOM:\n\t\t\treturn b;\n\t\tcase VALUE_TYPE_OBJECT: {\n\t\t\treturn aType !== VALUE_TYPE_OBJECT\n\t\t\t\t? b\n\t\t\t\t: internalCaching\n\t\t\t\t? cachedCleverMerge(a, b)\n\t\t\t\t: cleverMerge(a, b);\n\t\t}\n\t\tcase VALUE_TYPE_UNDEFINED:\n\t\t\treturn a;\n\t\tcase VALUE_TYPE_ARRAY_EXTEND:\n\t\t\tswitch (\n\t\t\t\taType !== VALUE_TYPE_ATOM\n\t\t\t\t\t? aType\n\t\t\t\t\t: Array.isArray(a)\n\t\t\t\t\t? VALUE_TYPE_ARRAY_EXTEND\n\t\t\t\t\t: VALUE_TYPE_OBJECT\n\t\t\t) {\n\t\t\t\tcase VALUE_TYPE_UNDEFINED:\n\t\t\t\t\treturn b;\n\t\t\t\tcase VALUE_TYPE_DELETE:\n\t\t\t\t\treturn b.filter(item => item !== \"...\");\n\t\t\t\tcase VALUE_TYPE_ARRAY_EXTEND: {\n\t\t\t\t\tconst newArray = [];\n\t\t\t\t\tfor (const item of b) {\n\t\t\t\t\t\tif (item === \"...\") {\n\t\t\t\t\t\t\tfor (const item of a) {\n\t\t\t\t\t\t\t\tnewArray.push(item);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewArray.push(item);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn newArray;\n\t\t\t\t}\n\t\t\t\tcase VALUE_TYPE_OBJECT:\n\t\t\t\t\treturn b.map(item => (item === \"...\" ? a : item));\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"Not implemented\");\n\t\t\t}\n\t\tdefault:\n\t\t\tthrow new Error(\"Not implemented\");\n\t}\n};\n\n/**\n * @template T\n * @param {T} obj the object\n * @returns {T} the object without operations like \"...\" or DELETE\n */\nconst removeOperations = obj => {\n\tconst newObj = /** @type {T} */ ({});\n\tfor (const key of Object.keys(obj)) {\n\t\tconst value = obj[key];\n\t\tconst type = getValueType(value);\n\t\tswitch (type) {\n\t\t\tcase VALUE_TYPE_UNDEFINED:\n\t\t\tcase VALUE_TYPE_DELETE:\n\t\t\t\tbreak;\n\t\t\tcase VALUE_TYPE_OBJECT:\n\t\t\t\tnewObj[key] = removeOperations(value);\n\t\t\t\tbreak;\n\t\t\tcase VALUE_TYPE_ARRAY_EXTEND:\n\t\t\t\tnewObj[key] = value.filter(i => i !== \"...\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnewObj[key] = value;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn newObj;\n};\n\n/**\n * @template T\n * @template {string} P\n * @param {T} obj the object\n * @param {P} byProperty the by description\n * @param  {...any} values values\n * @returns {Omit<T, P>} object with merged byProperty\n */\nconst resolveByProperty = (obj, byProperty, ...values) => {\n\tif (typeof obj !== \"object\" || obj === null || !(byProperty in obj)) {\n\t\treturn obj;\n\t}\n\tconst { [byProperty]: _byValue, ..._remaining } = /** @type {object} */ (obj);\n\tconst remaining = /** @type {T} */ (_remaining);\n\tconst byValue = /** @type {Record<string, T> | function(...any[]): T} */ (\n\t\t_byValue\n\t);\n\tif (typeof byValue === \"object\") {\n\t\tconst key = values[0];\n\t\tif (key in byValue) {\n\t\t\treturn cachedCleverMerge(remaining, byValue[key]);\n\t\t} else if (\"default\" in byValue) {\n\t\t\treturn cachedCleverMerge(remaining, byValue.default);\n\t\t} else {\n\t\t\treturn /** @type {T} */ (remaining);\n\t\t}\n\t} else if (typeof byValue === \"function\") {\n\t\tconst result = byValue.apply(null, values);\n\t\treturn cachedCleverMerge(\n\t\t\tremaining,\n\t\t\tresolveByProperty(result, byProperty, ...values)\n\t\t);\n\t}\n};\n\nexports.cachedSetProperty = cachedSetProperty;\nexports.cachedCleverMerge = cachedCleverMerge;\nexports.cleverMerge = cleverMerge;\nexports.resolveByProperty = resolveByProperty;\nexports.removeOperations = removeOperations;\nexports.DELETE = DELETE;\n"]},"metadata":{},"sourceType":"script"}