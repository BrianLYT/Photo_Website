{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Cache = require(\"../Cache\");\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../Cache\").Etag} Etag */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Module\")} Module */\n\n\nclass MemoryWithGcCachePlugin {\n  constructor(_ref) {\n    let {\n      maxGenerations\n    } = _ref;\n    this._maxGenerations = maxGenerations;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const maxGenerations = this._maxGenerations;\n    /** @type {Map<string, { etag: Etag | null, data: any }>} */\n\n    const cache = new Map();\n    /** @type {Map<string, { entry: { etag: Etag | null, data: any }, until: number }>} */\n\n    const oldCache = new Map();\n    let generation = 0;\n    let cachePosition = 0;\n    const logger = compiler.getInfrastructureLogger(\"MemoryWithGcCachePlugin\");\n    compiler.hooks.afterDone.tap(\"MemoryWithGcCachePlugin\", () => {\n      generation++;\n      let clearedEntries = 0;\n      let lastClearedIdentifier;\n\n      for (const [identifier, entry] of oldCache) {\n        if (entry.until > generation) break;\n        oldCache.delete(identifier);\n\n        if (cache.get(identifier) === undefined) {\n          cache.delete(identifier);\n          clearedEntries++;\n          lastClearedIdentifier = identifier;\n        }\n      }\n\n      if (clearedEntries > 0 || oldCache.size > 0) {\n        logger.log(`${cache.size - oldCache.size} active entries, ${oldCache.size} recently unused cached entries${clearedEntries > 0 ? `, ${clearedEntries} old unused cache entries removed e. g. ${lastClearedIdentifier}` : \"\"}`);\n      }\n\n      let i = cache.size / maxGenerations | 0;\n      let j = cachePosition >= cache.size ? 0 : cachePosition;\n      cachePosition = j + i;\n\n      for (const [identifier, entry] of cache) {\n        if (j !== 0) {\n          j--;\n          continue;\n        }\n\n        if (entry !== undefined) {\n          // We don't delete the cache entry, but set it to undefined instead\n          // This reserves the location in the data table and avoids rehashing\n          // when constantly adding and removing entries.\n          // It will be deleted when removed from oldCache.\n          cache.set(identifier, undefined);\n          oldCache.delete(identifier);\n          oldCache.set(identifier, {\n            entry,\n            until: generation + maxGenerations\n          });\n          if (i-- === 0) break;\n        }\n      }\n    });\n    compiler.cache.hooks.store.tap({\n      name: \"MemoryWithGcCachePlugin\",\n      stage: Cache.STAGE_MEMORY\n    }, (identifier, etag, data) => {\n      cache.set(identifier, {\n        etag,\n        data\n      });\n    });\n    compiler.cache.hooks.get.tap({\n      name: \"MemoryWithGcCachePlugin\",\n      stage: Cache.STAGE_MEMORY\n    }, (identifier, etag, gotHandlers) => {\n      const cacheEntry = cache.get(identifier);\n\n      if (cacheEntry === null) {\n        return null;\n      } else if (cacheEntry !== undefined) {\n        return cacheEntry.etag === etag ? cacheEntry.data : null;\n      }\n\n      const oldCacheEntry = oldCache.get(identifier);\n\n      if (oldCacheEntry !== undefined) {\n        const cacheEntry = oldCacheEntry.entry;\n\n        if (cacheEntry === null) {\n          oldCache.delete(identifier);\n          cache.set(identifier, cacheEntry);\n          return null;\n        } else {\n          if (cacheEntry.etag !== etag) return null;\n          oldCache.delete(identifier);\n          cache.set(identifier, cacheEntry);\n          return cacheEntry.data;\n        }\n      }\n\n      gotHandlers.push((result, callback) => {\n        if (result === undefined) {\n          cache.set(identifier, null);\n        } else {\n          cache.set(identifier, {\n            etag,\n            data: result\n          });\n        }\n\n        return callback();\n      });\n    });\n    compiler.cache.hooks.shutdown.tap({\n      name: \"MemoryWithGcCachePlugin\",\n      stage: Cache.STAGE_MEMORY\n    }, () => {\n      cache.clear();\n      oldCache.clear();\n    });\n  }\n\n}\n\nmodule.exports = MemoryWithGcCachePlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/cache/MemoryWithGcCachePlugin.js"],"names":["Cache","require","MemoryWithGcCachePlugin","constructor","maxGenerations","_maxGenerations","apply","compiler","cache","Map","oldCache","generation","cachePosition","logger","getInfrastructureLogger","hooks","afterDone","tap","clearedEntries","lastClearedIdentifier","identifier","entry","until","delete","get","undefined","size","log","i","j","set","store","name","stage","STAGE_MEMORY","etag","data","gotHandlers","cacheEntry","oldCacheEntry","push","result","callback","shutdown","clear","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,UAAD,CAArB;AAEA;;AACA;;AACA;;AACA;;;AAEA,MAAMC,uBAAN,CAA8B;AAC7BC,EAAAA,WAAW,OAAqB;AAAA,QAApB;AAAEC,MAAAA;AAAF,KAAoB;AAC/B,SAAKC,eAAL,GAAuBD,cAAvB;AACA;AACD;AACD;AACA;AACA;AACA;;;AACCE,EAAAA,KAAK,CAACC,QAAD,EAAW;AACf,UAAMH,cAAc,GAAG,KAAKC,eAA5B;AACA;;AACA,UAAMG,KAAK,GAAG,IAAIC,GAAJ,EAAd;AACA;;AACA,UAAMC,QAAQ,GAAG,IAAID,GAAJ,EAAjB;AACA,QAAIE,UAAU,GAAG,CAAjB;AACA,QAAIC,aAAa,GAAG,CAApB;AACA,UAAMC,MAAM,GAAGN,QAAQ,CAACO,uBAAT,CAAiC,yBAAjC,CAAf;AACAP,IAAAA,QAAQ,CAACQ,KAAT,CAAeC,SAAf,CAAyBC,GAAzB,CAA6B,yBAA7B,EAAwD,MAAM;AAC7DN,MAAAA,UAAU;AACV,UAAIO,cAAc,GAAG,CAArB;AACA,UAAIC,qBAAJ;;AACA,WAAK,MAAM,CAACC,UAAD,EAAaC,KAAb,CAAX,IAAkCX,QAAlC,EAA4C;AAC3C,YAAIW,KAAK,CAACC,KAAN,GAAcX,UAAlB,EAA8B;AAE9BD,QAAAA,QAAQ,CAACa,MAAT,CAAgBH,UAAhB;;AACA,YAAIZ,KAAK,CAACgB,GAAN,CAAUJ,UAAV,MAA0BK,SAA9B,EAAyC;AACxCjB,UAAAA,KAAK,CAACe,MAAN,CAAaH,UAAb;AACAF,UAAAA,cAAc;AACdC,UAAAA,qBAAqB,GAAGC,UAAxB;AACA;AACD;;AACD,UAAIF,cAAc,GAAG,CAAjB,IAAsBR,QAAQ,CAACgB,IAAT,GAAgB,CAA1C,EAA6C;AAC5Cb,QAAAA,MAAM,CAACc,GAAP,CACE,GAAEnB,KAAK,CAACkB,IAAN,GAAahB,QAAQ,CAACgB,IAAK,oBAC7BhB,QAAQ,CAACgB,IACT,kCACAR,cAAc,GAAG,CAAjB,GACI,KAAIA,cAAe,2CAA0CC,qBAAsB,EADvF,GAEG,EACH,EAPF;AASA;;AACD,UAAIS,CAAC,GAAIpB,KAAK,CAACkB,IAAN,GAAatB,cAAd,GAAgC,CAAxC;AACA,UAAIyB,CAAC,GAAGjB,aAAa,IAAIJ,KAAK,CAACkB,IAAvB,GAA8B,CAA9B,GAAkCd,aAA1C;AACAA,MAAAA,aAAa,GAAGiB,CAAC,GAAGD,CAApB;;AACA,WAAK,MAAM,CAACR,UAAD,EAAaC,KAAb,CAAX,IAAkCb,KAAlC,EAAyC;AACxC,YAAIqB,CAAC,KAAK,CAAV,EAAa;AACZA,UAAAA,CAAC;AACD;AACA;;AACD,YAAIR,KAAK,KAAKI,SAAd,EAAyB;AACxB;AACA;AACA;AACA;AACAjB,UAAAA,KAAK,CAACsB,GAAN,CAAUV,UAAV,EAAsBK,SAAtB;AACAf,UAAAA,QAAQ,CAACa,MAAT,CAAgBH,UAAhB;AACAV,UAAAA,QAAQ,CAACoB,GAAT,CAAaV,UAAb,EAAyB;AACxBC,YAAAA,KADwB;AAExBC,YAAAA,KAAK,EAAEX,UAAU,GAAGP;AAFI,WAAzB;AAIA,cAAIwB,CAAC,OAAO,CAAZ,EAAe;AACf;AACD;AACD,KA/CD;AAgDArB,IAAAA,QAAQ,CAACC,KAAT,CAAeO,KAAf,CAAqBgB,KAArB,CAA2Bd,GAA3B,CACC;AAAEe,MAAAA,IAAI,EAAE,yBAAR;AAAmCC,MAAAA,KAAK,EAAEjC,KAAK,CAACkC;AAAhD,KADD,EAEC,CAACd,UAAD,EAAae,IAAb,EAAmBC,IAAnB,KAA4B;AAC3B5B,MAAAA,KAAK,CAACsB,GAAN,CAAUV,UAAV,EAAsB;AAAEe,QAAAA,IAAF;AAAQC,QAAAA;AAAR,OAAtB;AACA,KAJF;AAMA7B,IAAAA,QAAQ,CAACC,KAAT,CAAeO,KAAf,CAAqBS,GAArB,CAAyBP,GAAzB,CACC;AAAEe,MAAAA,IAAI,EAAE,yBAAR;AAAmCC,MAAAA,KAAK,EAAEjC,KAAK,CAACkC;AAAhD,KADD,EAEC,CAACd,UAAD,EAAae,IAAb,EAAmBE,WAAnB,KAAmC;AAClC,YAAMC,UAAU,GAAG9B,KAAK,CAACgB,GAAN,CAAUJ,UAAV,CAAnB;;AACA,UAAIkB,UAAU,KAAK,IAAnB,EAAyB;AACxB,eAAO,IAAP;AACA,OAFD,MAEO,IAAIA,UAAU,KAAKb,SAAnB,EAA8B;AACpC,eAAOa,UAAU,CAACH,IAAX,KAAoBA,IAApB,GAA2BG,UAAU,CAACF,IAAtC,GAA6C,IAApD;AACA;;AACD,YAAMG,aAAa,GAAG7B,QAAQ,CAACc,GAAT,CAAaJ,UAAb,CAAtB;;AACA,UAAImB,aAAa,KAAKd,SAAtB,EAAiC;AAChC,cAAMa,UAAU,GAAGC,aAAa,CAAClB,KAAjC;;AACA,YAAIiB,UAAU,KAAK,IAAnB,EAAyB;AACxB5B,UAAAA,QAAQ,CAACa,MAAT,CAAgBH,UAAhB;AACAZ,UAAAA,KAAK,CAACsB,GAAN,CAAUV,UAAV,EAAsBkB,UAAtB;AACA,iBAAO,IAAP;AACA,SAJD,MAIO;AACN,cAAIA,UAAU,CAACH,IAAX,KAAoBA,IAAxB,EAA8B,OAAO,IAAP;AAC9BzB,UAAAA,QAAQ,CAACa,MAAT,CAAgBH,UAAhB;AACAZ,UAAAA,KAAK,CAACsB,GAAN,CAAUV,UAAV,EAAsBkB,UAAtB;AACA,iBAAOA,UAAU,CAACF,IAAlB;AACA;AACD;;AACDC,MAAAA,WAAW,CAACG,IAAZ,CAAiB,CAACC,MAAD,EAASC,QAAT,KAAsB;AACtC,YAAID,MAAM,KAAKhB,SAAf,EAA0B;AACzBjB,UAAAA,KAAK,CAACsB,GAAN,CAAUV,UAAV,EAAsB,IAAtB;AACA,SAFD,MAEO;AACNZ,UAAAA,KAAK,CAACsB,GAAN,CAAUV,UAAV,EAAsB;AAAEe,YAAAA,IAAF;AAAQC,YAAAA,IAAI,EAAEK;AAAd,WAAtB;AACA;;AACD,eAAOC,QAAQ,EAAf;AACA,OAPD;AAQA,KA/BF;AAiCAnC,IAAAA,QAAQ,CAACC,KAAT,CAAeO,KAAf,CAAqB4B,QAArB,CAA8B1B,GAA9B,CACC;AAAEe,MAAAA,IAAI,EAAE,yBAAR;AAAmCC,MAAAA,KAAK,EAAEjC,KAAK,CAACkC;AAAhD,KADD,EAEC,MAAM;AACL1B,MAAAA,KAAK,CAACoC,KAAN;AACAlC,MAAAA,QAAQ,CAACkC,KAAT;AACA,KALF;AAOA;;AAhH4B;;AAkH9BC,MAAM,CAACC,OAAP,GAAiB5C,uBAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Cache = require(\"../Cache\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Cache\").Etag} Etag */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\nclass MemoryWithGcCachePlugin {\n\tconstructor({ maxGenerations }) {\n\t\tthis._maxGenerations = maxGenerations;\n\t}\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst maxGenerations = this._maxGenerations;\n\t\t/** @type {Map<string, { etag: Etag | null, data: any }>} */\n\t\tconst cache = new Map();\n\t\t/** @type {Map<string, { entry: { etag: Etag | null, data: any }, until: number }>} */\n\t\tconst oldCache = new Map();\n\t\tlet generation = 0;\n\t\tlet cachePosition = 0;\n\t\tconst logger = compiler.getInfrastructureLogger(\"MemoryWithGcCachePlugin\");\n\t\tcompiler.hooks.afterDone.tap(\"MemoryWithGcCachePlugin\", () => {\n\t\t\tgeneration++;\n\t\t\tlet clearedEntries = 0;\n\t\t\tlet lastClearedIdentifier;\n\t\t\tfor (const [identifier, entry] of oldCache) {\n\t\t\t\tif (entry.until > generation) break;\n\n\t\t\t\toldCache.delete(identifier);\n\t\t\t\tif (cache.get(identifier) === undefined) {\n\t\t\t\t\tcache.delete(identifier);\n\t\t\t\t\tclearedEntries++;\n\t\t\t\t\tlastClearedIdentifier = identifier;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (clearedEntries > 0 || oldCache.size > 0) {\n\t\t\t\tlogger.log(\n\t\t\t\t\t`${cache.size - oldCache.size} active entries, ${\n\t\t\t\t\t\toldCache.size\n\t\t\t\t\t} recently unused cached entries${\n\t\t\t\t\t\tclearedEntries > 0\n\t\t\t\t\t\t\t? `, ${clearedEntries} old unused cache entries removed e. g. ${lastClearedIdentifier}`\n\t\t\t\t\t\t\t: \"\"\n\t\t\t\t\t}`\n\t\t\t\t);\n\t\t\t}\n\t\t\tlet i = (cache.size / maxGenerations) | 0;\n\t\t\tlet j = cachePosition >= cache.size ? 0 : cachePosition;\n\t\t\tcachePosition = j + i;\n\t\t\tfor (const [identifier, entry] of cache) {\n\t\t\t\tif (j !== 0) {\n\t\t\t\t\tj--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (entry !== undefined) {\n\t\t\t\t\t// We don't delete the cache entry, but set it to undefined instead\n\t\t\t\t\t// This reserves the location in the data table and avoids rehashing\n\t\t\t\t\t// when constantly adding and removing entries.\n\t\t\t\t\t// It will be deleted when removed from oldCache.\n\t\t\t\t\tcache.set(identifier, undefined);\n\t\t\t\t\toldCache.delete(identifier);\n\t\t\t\t\toldCache.set(identifier, {\n\t\t\t\t\t\tentry,\n\t\t\t\t\t\tuntil: generation + maxGenerations\n\t\t\t\t\t});\n\t\t\t\t\tif (i-- === 0) break;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tcompiler.cache.hooks.store.tap(\n\t\t\t{ name: \"MemoryWithGcCachePlugin\", stage: Cache.STAGE_MEMORY },\n\t\t\t(identifier, etag, data) => {\n\t\t\t\tcache.set(identifier, { etag, data });\n\t\t\t}\n\t\t);\n\t\tcompiler.cache.hooks.get.tap(\n\t\t\t{ name: \"MemoryWithGcCachePlugin\", stage: Cache.STAGE_MEMORY },\n\t\t\t(identifier, etag, gotHandlers) => {\n\t\t\t\tconst cacheEntry = cache.get(identifier);\n\t\t\t\tif (cacheEntry === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (cacheEntry !== undefined) {\n\t\t\t\t\treturn cacheEntry.etag === etag ? cacheEntry.data : null;\n\t\t\t\t}\n\t\t\t\tconst oldCacheEntry = oldCache.get(identifier);\n\t\t\t\tif (oldCacheEntry !== undefined) {\n\t\t\t\t\tconst cacheEntry = oldCacheEntry.entry;\n\t\t\t\t\tif (cacheEntry === null) {\n\t\t\t\t\t\toldCache.delete(identifier);\n\t\t\t\t\t\tcache.set(identifier, cacheEntry);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (cacheEntry.etag !== etag) return null;\n\t\t\t\t\t\toldCache.delete(identifier);\n\t\t\t\t\t\tcache.set(identifier, cacheEntry);\n\t\t\t\t\t\treturn cacheEntry.data;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgotHandlers.push((result, callback) => {\n\t\t\t\t\tif (result === undefined) {\n\t\t\t\t\t\tcache.set(identifier, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcache.set(identifier, { etag, data: result });\n\t\t\t\t\t}\n\t\t\t\t\treturn callback();\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t\tcompiler.cache.hooks.shutdown.tap(\n\t\t\t{ name: \"MemoryWithGcCachePlugin\", stage: Cache.STAGE_MEMORY },\n\t\t\t() => {\n\t\t\t\tcache.clear();\n\t\t\t\toldCache.clear();\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = MemoryWithGcCachePlugin;\n"]},"metadata":{},"sourceType":"script"}