{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\n\nconst Queue = require(\"./util/Queue\");\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n\n/** @typedef {import(\"./Dependency\")} Dependency */\n\n/** @typedef {import(\"./Dependency\").ExportSpec} ExportSpec */\n\n/** @typedef {import(\"./Dependency\").ExportsSpec} ExportsSpec */\n\n/** @typedef {import(\"./ExportsInfo\")} ExportsInfo */\n\n/** @typedef {import(\"./Module\")} Module */\n\n\nclass FlagDependencyExportsPlugin {\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"FlagDependencyExportsPlugin\", compilation => {\n      const moduleGraph = compilation.moduleGraph;\n      const cache = compilation.getCache(\"FlagDependencyExportsPlugin\");\n      compilation.hooks.finishModules.tapAsync(\"FlagDependencyExportsPlugin\", (modules, callback) => {\n        const logger = compilation.getLogger(\"webpack.FlagDependencyExportsPlugin\");\n        let statRestoredFromMemCache = 0;\n        let statRestoredFromCache = 0;\n        let statNoExports = 0;\n        let statFlaggedUncached = 0;\n        let statNotCached = 0;\n        let statQueueItemsProcessed = 0;\n        const {\n          moduleMemCaches\n        } = compilation;\n        /** @type {Queue<Module>} */\n\n        const queue = new Queue(); // Step 1: Try to restore cached provided export info from cache\n\n        logger.time(\"restore cached provided exports\");\n        asyncLib.each(modules, (module, callback) => {\n          const exportsInfo = moduleGraph.getExportsInfo(module);\n\n          if (!module.buildMeta || !module.buildMeta.exportsType) {\n            if (exportsInfo.otherExportsInfo.provided !== null) {\n              // It's a module without declared exports\n              statNoExports++;\n              exportsInfo.setHasProvideInfo();\n              exportsInfo.setUnknownExportsProvided();\n              return callback();\n            }\n          }\n\n          if (typeof module.buildInfo.hash !== \"string\") {\n            statFlaggedUncached++; // Enqueue uncacheable module for determining the exports\n\n            queue.enqueue(module);\n            exportsInfo.setHasProvideInfo();\n            return callback();\n          }\n\n          const memCache = moduleMemCaches && moduleMemCaches.get(module);\n          const memCacheValue = memCache && memCache.get(this);\n\n          if (memCacheValue !== undefined) {\n            statRestoredFromMemCache++;\n            exportsInfo.restoreProvided(memCacheValue);\n            return callback();\n          }\n\n          cache.get(module.identifier(), module.buildInfo.hash, (err, result) => {\n            if (err) return callback(err);\n\n            if (result !== undefined) {\n              statRestoredFromCache++;\n              exportsInfo.restoreProvided(result);\n            } else {\n              statNotCached++; // Without cached info enqueue module for determining the exports\n\n              queue.enqueue(module);\n              exportsInfo.setHasProvideInfo();\n            }\n\n            callback();\n          });\n        }, err => {\n          logger.timeEnd(\"restore cached provided exports\");\n          if (err) return callback(err);\n          /** @type {Set<Module>} */\n\n          const modulesToStore = new Set();\n          /** @type {Map<Module, Set<Module>>} */\n\n          const dependencies = new Map();\n          /** @type {Module} */\n\n          let module;\n          /** @type {ExportsInfo} */\n\n          let exportsInfo;\n          /** @type {Map<Dependency, ExportsSpec>} */\n\n          const exportsSpecsFromDependencies = new Map();\n          let cacheable = true;\n          let changed = false;\n          /**\n           * @param {DependenciesBlock} depBlock the dependencies block\n           * @returns {void}\n           */\n\n          const processDependenciesBlock = depBlock => {\n            for (const dep of depBlock.dependencies) {\n              processDependency(dep);\n            }\n\n            for (const block of depBlock.blocks) {\n              processDependenciesBlock(block);\n            }\n          };\n          /**\n           * @param {Dependency} dep the dependency\n           * @returns {void}\n           */\n\n\n          const processDependency = dep => {\n            const exportDesc = dep.getExports(moduleGraph);\n            if (!exportDesc) return;\n            exportsSpecsFromDependencies.set(dep, exportDesc);\n          };\n          /**\n           * @param {Dependency} dep dependency\n           * @param {ExportsSpec} exportDesc info\n           * @returns {void}\n           */\n\n\n          const processExportsSpec = (dep, exportDesc) => {\n            const exports = exportDesc.exports;\n            const globalCanMangle = exportDesc.canMangle;\n            const globalFrom = exportDesc.from;\n            const globalPriority = exportDesc.priority;\n            const globalTerminalBinding = exportDesc.terminalBinding || false;\n            const exportDeps = exportDesc.dependencies;\n\n            if (exportDesc.hideExports) {\n              for (const name of exportDesc.hideExports) {\n                const exportInfo = exportsInfo.getExportInfo(name);\n                exportInfo.unsetTarget(dep);\n              }\n            }\n\n            if (exports === true) {\n              // unknown exports\n              if (exportsInfo.setUnknownExportsProvided(globalCanMangle, exportDesc.excludeExports, globalFrom && dep, globalFrom, globalPriority)) {\n                changed = true;\n              }\n            } else if (Array.isArray(exports)) {\n              /**\n               * merge in new exports\n               * @param {ExportsInfo} exportsInfo own exports info\n               * @param {(ExportSpec | string)[]} exports list of exports\n               */\n              const mergeExports = (exportsInfo, exports) => {\n                for (const exportNameOrSpec of exports) {\n                  let name;\n                  let canMangle = globalCanMangle;\n                  let terminalBinding = globalTerminalBinding;\n                  let exports = undefined;\n                  let from = globalFrom;\n                  let fromExport = undefined;\n                  let priority = globalPriority;\n                  let hidden = false;\n\n                  if (typeof exportNameOrSpec === \"string\") {\n                    name = exportNameOrSpec;\n                  } else {\n                    name = exportNameOrSpec.name;\n                    if (exportNameOrSpec.canMangle !== undefined) canMangle = exportNameOrSpec.canMangle;\n                    if (exportNameOrSpec.export !== undefined) fromExport = exportNameOrSpec.export;\n                    if (exportNameOrSpec.exports !== undefined) exports = exportNameOrSpec.exports;\n                    if (exportNameOrSpec.from !== undefined) from = exportNameOrSpec.from;\n                    if (exportNameOrSpec.priority !== undefined) priority = exportNameOrSpec.priority;\n                    if (exportNameOrSpec.terminalBinding !== undefined) terminalBinding = exportNameOrSpec.terminalBinding;\n                    if (exportNameOrSpec.hidden !== undefined) hidden = exportNameOrSpec.hidden;\n                  }\n\n                  const exportInfo = exportsInfo.getExportInfo(name);\n\n                  if (exportInfo.provided === false || exportInfo.provided === null) {\n                    exportInfo.provided = true;\n                    changed = true;\n                  }\n\n                  if (exportInfo.canMangleProvide !== false && canMangle === false) {\n                    exportInfo.canMangleProvide = false;\n                    changed = true;\n                  }\n\n                  if (terminalBinding && !exportInfo.terminalBinding) {\n                    exportInfo.terminalBinding = true;\n                    changed = true;\n                  }\n\n                  if (exports) {\n                    const nestedExportsInfo = exportInfo.createNestedExportsInfo();\n                    mergeExports(nestedExportsInfo, exports);\n                  }\n\n                  if (from && (hidden ? exportInfo.unsetTarget(dep) : exportInfo.setTarget(dep, from, fromExport === undefined ? [name] : fromExport, priority))) {\n                    changed = true;\n                  } // Recalculate target exportsInfo\n\n\n                  const target = exportInfo.getTarget(moduleGraph);\n                  let targetExportsInfo = undefined;\n\n                  if (target) {\n                    const targetModuleExportsInfo = moduleGraph.getExportsInfo(target.module);\n                    targetExportsInfo = targetModuleExportsInfo.getNestedExportsInfo(target.export); // add dependency for this module\n\n                    const set = dependencies.get(target.module);\n\n                    if (set === undefined) {\n                      dependencies.set(target.module, new Set([module]));\n                    } else {\n                      set.add(module);\n                    }\n                  }\n\n                  if (exportInfo.exportsInfoOwned) {\n                    if (exportInfo.exportsInfo.setRedirectNamedTo(targetExportsInfo)) {\n                      changed = true;\n                    }\n                  } else if (exportInfo.exportsInfo !== targetExportsInfo) {\n                    exportInfo.exportsInfo = targetExportsInfo;\n                    changed = true;\n                  }\n                }\n              };\n\n              mergeExports(exportsInfo, exports);\n            } // store dependencies\n\n\n            if (exportDeps) {\n              cacheable = false;\n\n              for (const exportDependency of exportDeps) {\n                // add dependency for this module\n                const set = dependencies.get(exportDependency);\n\n                if (set === undefined) {\n                  dependencies.set(exportDependency, new Set([module]));\n                } else {\n                  set.add(module);\n                }\n              }\n            }\n          };\n\n          const notifyDependencies = () => {\n            const deps = dependencies.get(module);\n\n            if (deps !== undefined) {\n              for (const dep of deps) {\n                queue.enqueue(dep);\n              }\n            }\n          };\n\n          logger.time(\"figure out provided exports\");\n\n          while (queue.length > 0) {\n            module = queue.dequeue();\n            statQueueItemsProcessed++;\n            exportsInfo = moduleGraph.getExportsInfo(module);\n            cacheable = true;\n            changed = false;\n            exportsSpecsFromDependencies.clear();\n            moduleGraph.freeze();\n            processDependenciesBlock(module);\n            moduleGraph.unfreeze();\n\n            for (const [dep, exportsSpec] of exportsSpecsFromDependencies) {\n              processExportsSpec(dep, exportsSpec);\n            }\n\n            if (cacheable) {\n              modulesToStore.add(module);\n            }\n\n            if (changed) {\n              notifyDependencies();\n            }\n          }\n\n          logger.timeEnd(\"figure out provided exports\");\n          logger.log(`${Math.round(100 * (statFlaggedUncached + statNotCached) / (statRestoredFromMemCache + statRestoredFromCache + statNotCached + statFlaggedUncached + statNoExports))}% of exports of modules have been determined (${statNoExports} no declared exports, ${statNotCached} not cached, ${statFlaggedUncached} flagged uncacheable, ${statRestoredFromCache} from cache, ${statRestoredFromMemCache} from mem cache, ${statQueueItemsProcessed - statNotCached - statFlaggedUncached} additional calculations due to dependencies)`);\n          logger.time(\"store provided exports into cache\");\n          asyncLib.each(modulesToStore, (module, callback) => {\n            if (typeof module.buildInfo.hash !== \"string\") {\n              // not cacheable\n              return callback();\n            }\n\n            const cachedData = moduleGraph.getExportsInfo(module).getRestoreProvidedData();\n            const memCache = moduleMemCaches && moduleMemCaches.get(module);\n\n            if (memCache) {\n              memCache.set(this, cachedData);\n            }\n\n            cache.store(module.identifier(), module.buildInfo.hash, cachedData, callback);\n          }, err => {\n            logger.timeEnd(\"store provided exports into cache\");\n            callback(err);\n          });\n        });\n      });\n      /** @type {WeakMap<Module, any>} */\n\n      const providedExportsCache = new WeakMap();\n      compilation.hooks.rebuildModule.tap(\"FlagDependencyExportsPlugin\", module => {\n        providedExportsCache.set(module, moduleGraph.getExportsInfo(module).getRestoreProvidedData());\n      });\n      compilation.hooks.finishRebuildingModule.tap(\"FlagDependencyExportsPlugin\", module => {\n        moduleGraph.getExportsInfo(module).restoreProvided(providedExportsCache.get(module));\n      });\n    });\n  }\n\n}\n\nmodule.exports = FlagDependencyExportsPlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/FlagDependencyExportsPlugin.js"],"names":["asyncLib","require","Queue","FlagDependencyExportsPlugin","apply","compiler","hooks","compilation","tap","moduleGraph","cache","getCache","finishModules","tapAsync","modules","callback","logger","getLogger","statRestoredFromMemCache","statRestoredFromCache","statNoExports","statFlaggedUncached","statNotCached","statQueueItemsProcessed","moduleMemCaches","queue","time","each","module","exportsInfo","getExportsInfo","buildMeta","exportsType","otherExportsInfo","provided","setHasProvideInfo","setUnknownExportsProvided","buildInfo","hash","enqueue","memCache","get","memCacheValue","undefined","restoreProvided","identifier","err","result","timeEnd","modulesToStore","Set","dependencies","Map","exportsSpecsFromDependencies","cacheable","changed","processDependenciesBlock","depBlock","dep","processDependency","block","blocks","exportDesc","getExports","set","processExportsSpec","exports","globalCanMangle","canMangle","globalFrom","from","globalPriority","priority","globalTerminalBinding","terminalBinding","exportDeps","hideExports","name","exportInfo","getExportInfo","unsetTarget","excludeExports","Array","isArray","mergeExports","exportNameOrSpec","fromExport","hidden","export","canMangleProvide","nestedExportsInfo","createNestedExportsInfo","setTarget","target","getTarget","targetExportsInfo","targetModuleExportsInfo","getNestedExportsInfo","add","exportsInfoOwned","setRedirectNamedTo","exportDependency","notifyDependencies","deps","length","dequeue","clear","freeze","unfreeze","exportsSpec","log","Math","round","cachedData","getRestoreProvidedData","store","providedExportsCache","WeakMap","rebuildModule","finishRebuildingModule"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,WAAD,CAAxB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,cAAD,CAArB;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;AAEA,MAAME,2BAAN,CAAkC;AACjC;AACD;AACA;AACA;AACA;AACCC,EAAAA,KAAK,CAACC,QAAD,EAAW;AACfA,IAAAA,QAAQ,CAACC,KAAT,CAAeC,WAAf,CAA2BC,GAA3B,CACC,6BADD,EAECD,WAAW,IAAI;AACd,YAAME,WAAW,GAAGF,WAAW,CAACE,WAAhC;AACA,YAAMC,KAAK,GAAGH,WAAW,CAACI,QAAZ,CAAqB,6BAArB,CAAd;AACAJ,MAAAA,WAAW,CAACD,KAAZ,CAAkBM,aAAlB,CAAgCC,QAAhC,CACC,6BADD,EAEC,CAACC,OAAD,EAAUC,QAAV,KAAuB;AACtB,cAAMC,MAAM,GAAGT,WAAW,CAACU,SAAZ,CACd,qCADc,CAAf;AAGA,YAAIC,wBAAwB,GAAG,CAA/B;AACA,YAAIC,qBAAqB,GAAG,CAA5B;AACA,YAAIC,aAAa,GAAG,CAApB;AACA,YAAIC,mBAAmB,GAAG,CAA1B;AACA,YAAIC,aAAa,GAAG,CAApB;AACA,YAAIC,uBAAuB,GAAG,CAA9B;AAEA,cAAM;AAAEC,UAAAA;AAAF,YAAsBjB,WAA5B;AAEA;;AACA,cAAMkB,KAAK,GAAG,IAAIvB,KAAJ,EAAd,CAdsB,CAgBtB;;AACAc,QAAAA,MAAM,CAACU,IAAP,CAAY,iCAAZ;AACA1B,QAAAA,QAAQ,CAAC2B,IAAT,CACCb,OADD,EAEC,CAACc,MAAD,EAASb,QAAT,KAAsB;AACrB,gBAAMc,WAAW,GAAGpB,WAAW,CAACqB,cAAZ,CAA2BF,MAA3B,CAApB;;AACA,cAAI,CAACA,MAAM,CAACG,SAAR,IAAqB,CAACH,MAAM,CAACG,SAAP,CAAiBC,WAA3C,EAAwD;AACvD,gBAAIH,WAAW,CAACI,gBAAZ,CAA6BC,QAA7B,KAA0C,IAA9C,EAAoD;AACnD;AACAd,cAAAA,aAAa;AACbS,cAAAA,WAAW,CAACM,iBAAZ;AACAN,cAAAA,WAAW,CAACO,yBAAZ;AACA,qBAAOrB,QAAQ,EAAf;AACA;AACD;;AACD,cAAI,OAAOa,MAAM,CAACS,SAAP,CAAiBC,IAAxB,KAAiC,QAArC,EAA+C;AAC9CjB,YAAAA,mBAAmB,GAD2B,CAE9C;;AACAI,YAAAA,KAAK,CAACc,OAAN,CAAcX,MAAd;AACAC,YAAAA,WAAW,CAACM,iBAAZ;AACA,mBAAOpB,QAAQ,EAAf;AACA;;AACD,gBAAMyB,QAAQ,GAAGhB,eAAe,IAAIA,eAAe,CAACiB,GAAhB,CAAoBb,MAApB,CAApC;AACA,gBAAMc,aAAa,GAAGF,QAAQ,IAAIA,QAAQ,CAACC,GAAT,CAAa,IAAb,CAAlC;;AACA,cAAIC,aAAa,KAAKC,SAAtB,EAAiC;AAChCzB,YAAAA,wBAAwB;AACxBW,YAAAA,WAAW,CAACe,eAAZ,CAA4BF,aAA5B;AACA,mBAAO3B,QAAQ,EAAf;AACA;;AACDL,UAAAA,KAAK,CAAC+B,GAAN,CACCb,MAAM,CAACiB,UAAP,EADD,EAECjB,MAAM,CAACS,SAAP,CAAiBC,IAFlB,EAGC,CAACQ,GAAD,EAAMC,MAAN,KAAiB;AAChB,gBAAID,GAAJ,EAAS,OAAO/B,QAAQ,CAAC+B,GAAD,CAAf;;AAET,gBAAIC,MAAM,KAAKJ,SAAf,EAA0B;AACzBxB,cAAAA,qBAAqB;AACrBU,cAAAA,WAAW,CAACe,eAAZ,CAA4BG,MAA5B;AACA,aAHD,MAGO;AACNzB,cAAAA,aAAa,GADP,CAEN;;AACAG,cAAAA,KAAK,CAACc,OAAN,CAAcX,MAAd;AACAC,cAAAA,WAAW,CAACM,iBAAZ;AACA;;AACDpB,YAAAA,QAAQ;AACR,WAhBF;AAkBA,SA7CF,EA8CC+B,GAAG,IAAI;AACN9B,UAAAA,MAAM,CAACgC,OAAP,CAAe,iCAAf;AACA,cAAIF,GAAJ,EAAS,OAAO/B,QAAQ,CAAC+B,GAAD,CAAf;AAET;;AACA,gBAAMG,cAAc,GAAG,IAAIC,GAAJ,EAAvB;AAEA;;AACA,gBAAMC,YAAY,GAAG,IAAIC,GAAJ,EAArB;AAEA;;AACA,cAAIxB,MAAJ;AAEA;;AACA,cAAIC,WAAJ;AAEA;;AACA,gBAAMwB,4BAA4B,GAAG,IAAID,GAAJ,EAArC;AAEA,cAAIE,SAAS,GAAG,IAAhB;AACA,cAAIC,OAAO,GAAG,KAAd;AAEA;AACR;AACA;AACA;;AACQ,gBAAMC,wBAAwB,GAAGC,QAAQ,IAAI;AAC5C,iBAAK,MAAMC,GAAX,IAAkBD,QAAQ,CAACN,YAA3B,EAAyC;AACxCQ,cAAAA,iBAAiB,CAACD,GAAD,CAAjB;AACA;;AACD,iBAAK,MAAME,KAAX,IAAoBH,QAAQ,CAACI,MAA7B,EAAqC;AACpCL,cAAAA,wBAAwB,CAACI,KAAD,CAAxB;AACA;AACD,WAPD;AASA;AACR;AACA;AACA;;;AACQ,gBAAMD,iBAAiB,GAAGD,GAAG,IAAI;AAChC,kBAAMI,UAAU,GAAGJ,GAAG,CAACK,UAAJ,CAAetD,WAAf,CAAnB;AACA,gBAAI,CAACqD,UAAL,EAAiB;AACjBT,YAAAA,4BAA4B,CAACW,GAA7B,CAAiCN,GAAjC,EAAsCI,UAAtC;AACA,WAJD;AAMA;AACR;AACA;AACA;AACA;;;AACQ,gBAAMG,kBAAkB,GAAG,CAACP,GAAD,EAAMI,UAAN,KAAqB;AAC/C,kBAAMI,OAAO,GAAGJ,UAAU,CAACI,OAA3B;AACA,kBAAMC,eAAe,GAAGL,UAAU,CAACM,SAAnC;AACA,kBAAMC,UAAU,GAAGP,UAAU,CAACQ,IAA9B;AACA,kBAAMC,cAAc,GAAGT,UAAU,CAACU,QAAlC;AACA,kBAAMC,qBAAqB,GAC1BX,UAAU,CAACY,eAAX,IAA8B,KAD/B;AAEA,kBAAMC,UAAU,GAAGb,UAAU,CAACX,YAA9B;;AACA,gBAAIW,UAAU,CAACc,WAAf,EAA4B;AAC3B,mBAAK,MAAMC,IAAX,IAAmBf,UAAU,CAACc,WAA9B,EAA2C;AAC1C,sBAAME,UAAU,GAAGjD,WAAW,CAACkD,aAAZ,CAA0BF,IAA1B,CAAnB;AACAC,gBAAAA,UAAU,CAACE,WAAX,CAAuBtB,GAAvB;AACA;AACD;;AACD,gBAAIQ,OAAO,KAAK,IAAhB,EAAsB;AACrB;AACA,kBACCrC,WAAW,CAACO,yBAAZ,CACC+B,eADD,EAECL,UAAU,CAACmB,cAFZ,EAGCZ,UAAU,IAAIX,GAHf,EAICW,UAJD,EAKCE,cALD,CADD,EAQE;AACDhB,gBAAAA,OAAO,GAAG,IAAV;AACA;AACD,aAbD,MAaO,IAAI2B,KAAK,CAACC,OAAN,CAAcjB,OAAd,CAAJ,EAA4B;AAClC;AACV;AACA;AACA;AACA;AACU,oBAAMkB,YAAY,GAAG,CAACvD,WAAD,EAAcqC,OAAd,KAA0B;AAC9C,qBAAK,MAAMmB,gBAAX,IAA+BnB,OAA/B,EAAwC;AACvC,sBAAIW,IAAJ;AACA,sBAAIT,SAAS,GAAGD,eAAhB;AACA,sBAAIO,eAAe,GAAGD,qBAAtB;AACA,sBAAIP,OAAO,GAAGvB,SAAd;AACA,sBAAI2B,IAAI,GAAGD,UAAX;AACA,sBAAIiB,UAAU,GAAG3C,SAAjB;AACA,sBAAI6B,QAAQ,GAAGD,cAAf;AACA,sBAAIgB,MAAM,GAAG,KAAb;;AACA,sBAAI,OAAOF,gBAAP,KAA4B,QAAhC,EAA0C;AACzCR,oBAAAA,IAAI,GAAGQ,gBAAP;AACA,mBAFD,MAEO;AACNR,oBAAAA,IAAI,GAAGQ,gBAAgB,CAACR,IAAxB;AACA,wBAAIQ,gBAAgB,CAACjB,SAAjB,KAA+BzB,SAAnC,EACCyB,SAAS,GAAGiB,gBAAgB,CAACjB,SAA7B;AACD,wBAAIiB,gBAAgB,CAACG,MAAjB,KAA4B7C,SAAhC,EACC2C,UAAU,GAAGD,gBAAgB,CAACG,MAA9B;AACD,wBAAIH,gBAAgB,CAACnB,OAAjB,KAA6BvB,SAAjC,EACCuB,OAAO,GAAGmB,gBAAgB,CAACnB,OAA3B;AACD,wBAAImB,gBAAgB,CAACf,IAAjB,KAA0B3B,SAA9B,EACC2B,IAAI,GAAGe,gBAAgB,CAACf,IAAxB;AACD,wBAAIe,gBAAgB,CAACb,QAAjB,KAA8B7B,SAAlC,EACC6B,QAAQ,GAAGa,gBAAgB,CAACb,QAA5B;AACD,wBAAIa,gBAAgB,CAACX,eAAjB,KAAqC/B,SAAzC,EACC+B,eAAe,GAAGW,gBAAgB,CAACX,eAAnC;AACD,wBAAIW,gBAAgB,CAACE,MAAjB,KAA4B5C,SAAhC,EACC4C,MAAM,GAAGF,gBAAgB,CAACE,MAA1B;AACD;;AACD,wBAAMT,UAAU,GAAGjD,WAAW,CAACkD,aAAZ,CAA0BF,IAA1B,CAAnB;;AAEA,sBACCC,UAAU,CAAC5C,QAAX,KAAwB,KAAxB,IACA4C,UAAU,CAAC5C,QAAX,KAAwB,IAFzB,EAGE;AACD4C,oBAAAA,UAAU,CAAC5C,QAAX,GAAsB,IAAtB;AACAqB,oBAAAA,OAAO,GAAG,IAAV;AACA;;AAED,sBACCuB,UAAU,CAACW,gBAAX,KAAgC,KAAhC,IACArB,SAAS,KAAK,KAFf,EAGE;AACDU,oBAAAA,UAAU,CAACW,gBAAX,GAA8B,KAA9B;AACAlC,oBAAAA,OAAO,GAAG,IAAV;AACA;;AAED,sBAAImB,eAAe,IAAI,CAACI,UAAU,CAACJ,eAAnC,EAAoD;AACnDI,oBAAAA,UAAU,CAACJ,eAAX,GAA6B,IAA7B;AACAnB,oBAAAA,OAAO,GAAG,IAAV;AACA;;AAED,sBAAIW,OAAJ,EAAa;AACZ,0BAAMwB,iBAAiB,GACtBZ,UAAU,CAACa,uBAAX,EADD;AAEAP,oBAAAA,YAAY,CAACM,iBAAD,EAAoBxB,OAApB,CAAZ;AACA;;AAED,sBACCI,IAAI,KACHiB,MAAM,GACJT,UAAU,CAACE,WAAX,CAAuBtB,GAAvB,CADI,GAEJoB,UAAU,CAACc,SAAX,CACAlC,GADA,EAEAY,IAFA,EAGAgB,UAAU,KAAK3C,SAAf,GAA2B,CAACkC,IAAD,CAA3B,GAAoCS,UAHpC,EAIAd,QAJA,CAHC,CADL,EAUE;AACDjB,oBAAAA,OAAO,GAAG,IAAV;AACA,mBArEsC,CAuEvC;;;AACA,wBAAMsC,MAAM,GAAGf,UAAU,CAACgB,SAAX,CAAqBrF,WAArB,CAAf;AACA,sBAAIsF,iBAAiB,GAAGpD,SAAxB;;AACA,sBAAIkD,MAAJ,EAAY;AACX,0BAAMG,uBAAuB,GAC5BvF,WAAW,CAACqB,cAAZ,CAA2B+D,MAAM,CAACjE,MAAlC,CADD;AAEAmE,oBAAAA,iBAAiB,GAChBC,uBAAuB,CAACC,oBAAxB,CACCJ,MAAM,CAACL,MADR,CADD,CAHW,CAOX;;AACA,0BAAMxB,GAAG,GAAGb,YAAY,CAACV,GAAb,CAAiBoD,MAAM,CAACjE,MAAxB,CAAZ;;AACA,wBAAIoC,GAAG,KAAKrB,SAAZ,EAAuB;AACtBQ,sBAAAA,YAAY,CAACa,GAAb,CAAiB6B,MAAM,CAACjE,MAAxB,EAAgC,IAAIsB,GAAJ,CAAQ,CAACtB,MAAD,CAAR,CAAhC;AACA,qBAFD,MAEO;AACNoC,sBAAAA,GAAG,CAACkC,GAAJ,CAAQtE,MAAR;AACA;AACD;;AAED,sBAAIkD,UAAU,CAACqB,gBAAf,EAAiC;AAChC,wBACCrB,UAAU,CAACjD,WAAX,CAAuBuE,kBAAvB,CACCL,iBADD,CADD,EAIE;AACDxC,sBAAAA,OAAO,GAAG,IAAV;AACA;AACD,mBARD,MAQO,IACNuB,UAAU,CAACjD,WAAX,KAA2BkE,iBADrB,EAEL;AACDjB,oBAAAA,UAAU,CAACjD,WAAX,GAAyBkE,iBAAzB;AACAxC,oBAAAA,OAAO,GAAG,IAAV;AACA;AACD;AACD,eA1GD;;AA2GA6B,cAAAA,YAAY,CAACvD,WAAD,EAAcqC,OAAd,CAAZ;AACA,aA7I8C,CA8I/C;;;AACA,gBAAIS,UAAJ,EAAgB;AACfrB,cAAAA,SAAS,GAAG,KAAZ;;AACA,mBAAK,MAAM+C,gBAAX,IAA+B1B,UAA/B,EAA2C;AAC1C;AACA,sBAAMX,GAAG,GAAGb,YAAY,CAACV,GAAb,CAAiB4D,gBAAjB,CAAZ;;AACA,oBAAIrC,GAAG,KAAKrB,SAAZ,EAAuB;AACtBQ,kBAAAA,YAAY,CAACa,GAAb,CAAiBqC,gBAAjB,EAAmC,IAAInD,GAAJ,CAAQ,CAACtB,MAAD,CAAR,CAAnC;AACA,iBAFD,MAEO;AACNoC,kBAAAA,GAAG,CAACkC,GAAJ,CAAQtE,MAAR;AACA;AACD;AACD;AACD,WA3JD;;AA6JA,gBAAM0E,kBAAkB,GAAG,MAAM;AAChC,kBAAMC,IAAI,GAAGpD,YAAY,CAACV,GAAb,CAAiBb,MAAjB,CAAb;;AACA,gBAAI2E,IAAI,KAAK5D,SAAb,EAAwB;AACvB,mBAAK,MAAMe,GAAX,IAAkB6C,IAAlB,EAAwB;AACvB9E,gBAAAA,KAAK,CAACc,OAAN,CAAcmB,GAAd;AACA;AACD;AACD,WAPD;;AASA1C,UAAAA,MAAM,CAACU,IAAP,CAAY,6BAAZ;;AACA,iBAAOD,KAAK,CAAC+E,MAAN,GAAe,CAAtB,EAAyB;AACxB5E,YAAAA,MAAM,GAAGH,KAAK,CAACgF,OAAN,EAAT;AAEAlF,YAAAA,uBAAuB;AAEvBM,YAAAA,WAAW,GAAGpB,WAAW,CAACqB,cAAZ,CAA2BF,MAA3B,CAAd;AAEA0B,YAAAA,SAAS,GAAG,IAAZ;AACAC,YAAAA,OAAO,GAAG,KAAV;AAEAF,YAAAA,4BAA4B,CAACqD,KAA7B;AACAjG,YAAAA,WAAW,CAACkG,MAAZ;AACAnD,YAAAA,wBAAwB,CAAC5B,MAAD,CAAxB;AACAnB,YAAAA,WAAW,CAACmG,QAAZ;;AACA,iBAAK,MAAM,CACVlD,GADU,EAEVmD,WAFU,CAAX,IAGKxD,4BAHL,EAGmC;AAClCY,cAAAA,kBAAkB,CAACP,GAAD,EAAMmD,WAAN,CAAlB;AACA;;AAED,gBAAIvD,SAAJ,EAAe;AACdL,cAAAA,cAAc,CAACiD,GAAf,CAAmBtE,MAAnB;AACA;;AAED,gBAAI2B,OAAJ,EAAa;AACZ+C,cAAAA,kBAAkB;AAClB;AACD;;AACDtF,UAAAA,MAAM,CAACgC,OAAP,CAAe,6BAAf;AAEAhC,UAAAA,MAAM,CAAC8F,GAAP,CACE,GAAEC,IAAI,CAACC,KAAL,CACD,OAAO3F,mBAAmB,GAAGC,aAA7B,CAAD,IACEJ,wBAAwB,GACxBC,qBADA,GAEAG,aAFA,GAGAD,mBAHA,GAIAD,aALF,CADE,CAOD,iDAAgDA,aAAc,yBAAwBE,aAAc,gBAAeD,mBAAoB,yBAAwBF,qBAAsB,gBAAeD,wBAAyB,oBAC9NK,uBAAuB,GACvBD,aADA,GAEAD,mBACA,+CAZF;AAeAL,UAAAA,MAAM,CAACU,IAAP,CAAY,mCAAZ;AACA1B,UAAAA,QAAQ,CAAC2B,IAAT,CACCsB,cADD,EAEC,CAACrB,MAAD,EAASb,QAAT,KAAsB;AACrB,gBAAI,OAAOa,MAAM,CAACS,SAAP,CAAiBC,IAAxB,KAAiC,QAArC,EAA+C;AAC9C;AACA,qBAAOvB,QAAQ,EAAf;AACA;;AACD,kBAAMkG,UAAU,GAAGxG,WAAW,CAC5BqB,cADiB,CACFF,MADE,EAEjBsF,sBAFiB,EAAnB;AAGA,kBAAM1E,QAAQ,GACbhB,eAAe,IAAIA,eAAe,CAACiB,GAAhB,CAAoBb,MAApB,CADpB;;AAEA,gBAAIY,QAAJ,EAAc;AACbA,cAAAA,QAAQ,CAACwB,GAAT,CAAa,IAAb,EAAmBiD,UAAnB;AACA;;AACDvG,YAAAA,KAAK,CAACyG,KAAN,CACCvF,MAAM,CAACiB,UAAP,EADD,EAECjB,MAAM,CAACS,SAAP,CAAiBC,IAFlB,EAGC2E,UAHD,EAIClG,QAJD;AAMA,WArBF,EAsBC+B,GAAG,IAAI;AACN9B,YAAAA,MAAM,CAACgC,OAAP,CAAe,mCAAf;AACAjC,YAAAA,QAAQ,CAAC+B,GAAD,CAAR;AACA,WAzBF;AA2BA,SAjVF;AAmVA,OAvWF;AA0WA;;AACA,YAAMsE,oBAAoB,GAAG,IAAIC,OAAJ,EAA7B;AACA9G,MAAAA,WAAW,CAACD,KAAZ,CAAkBgH,aAAlB,CAAgC9G,GAAhC,CACC,6BADD,EAECoB,MAAM,IAAI;AACTwF,QAAAA,oBAAoB,CAACpD,GAArB,CACCpC,MADD,EAECnB,WAAW,CAACqB,cAAZ,CAA2BF,MAA3B,EAAmCsF,sBAAnC,EAFD;AAIA,OAPF;AASA3G,MAAAA,WAAW,CAACD,KAAZ,CAAkBiH,sBAAlB,CAAyC/G,GAAzC,CACC,6BADD,EAECoB,MAAM,IAAI;AACTnB,QAAAA,WAAW,CACTqB,cADF,CACiBF,MADjB,EAEEgB,eAFF,CAEkBwE,oBAAoB,CAAC3E,GAArB,CAAyBb,MAAzB,CAFlB;AAGA,OANF;AAQA,KAlYF;AAoYA;;AA3YgC;;AA8YlCA,MAAM,CAACsC,OAAP,GAAiB/D,2BAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst Queue = require(\"./util/Queue\");\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Dependency\").ExportSpec} ExportSpec */\n/** @typedef {import(\"./Dependency\").ExportsSpec} ExportsSpec */\n/** @typedef {import(\"./ExportsInfo\")} ExportsInfo */\n/** @typedef {import(\"./Module\")} Module */\n\nclass FlagDependencyExportsPlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"FlagDependencyExportsPlugin\",\n\t\t\tcompilation => {\n\t\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\t\tconst cache = compilation.getCache(\"FlagDependencyExportsPlugin\");\n\t\t\t\tcompilation.hooks.finishModules.tapAsync(\n\t\t\t\t\t\"FlagDependencyExportsPlugin\",\n\t\t\t\t\t(modules, callback) => {\n\t\t\t\t\t\tconst logger = compilation.getLogger(\n\t\t\t\t\t\t\t\"webpack.FlagDependencyExportsPlugin\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\tlet statRestoredFromMemCache = 0;\n\t\t\t\t\t\tlet statRestoredFromCache = 0;\n\t\t\t\t\t\tlet statNoExports = 0;\n\t\t\t\t\t\tlet statFlaggedUncached = 0;\n\t\t\t\t\t\tlet statNotCached = 0;\n\t\t\t\t\t\tlet statQueueItemsProcessed = 0;\n\n\t\t\t\t\t\tconst { moduleMemCaches } = compilation;\n\n\t\t\t\t\t\t/** @type {Queue<Module>} */\n\t\t\t\t\t\tconst queue = new Queue();\n\n\t\t\t\t\t\t// Step 1: Try to restore cached provided export info from cache\n\t\t\t\t\t\tlogger.time(\"restore cached provided exports\");\n\t\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t(module, callback) => {\n\t\t\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\t\t\tif (!module.buildMeta || !module.buildMeta.exportsType) {\n\t\t\t\t\t\t\t\t\tif (exportsInfo.otherExportsInfo.provided !== null) {\n\t\t\t\t\t\t\t\t\t\t// It's a module without declared exports\n\t\t\t\t\t\t\t\t\t\tstatNoExports++;\n\t\t\t\t\t\t\t\t\t\texportsInfo.setHasProvideInfo();\n\t\t\t\t\t\t\t\t\t\texportsInfo.setUnknownExportsProvided();\n\t\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (typeof module.buildInfo.hash !== \"string\") {\n\t\t\t\t\t\t\t\t\tstatFlaggedUncached++;\n\t\t\t\t\t\t\t\t\t// Enqueue uncacheable module for determining the exports\n\t\t\t\t\t\t\t\t\tqueue.enqueue(module);\n\t\t\t\t\t\t\t\t\texportsInfo.setHasProvideInfo();\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst memCache = moduleMemCaches && moduleMemCaches.get(module);\n\t\t\t\t\t\t\t\tconst memCacheValue = memCache && memCache.get(this);\n\t\t\t\t\t\t\t\tif (memCacheValue !== undefined) {\n\t\t\t\t\t\t\t\t\tstatRestoredFromMemCache++;\n\t\t\t\t\t\t\t\t\texportsInfo.restoreProvided(memCacheValue);\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcache.get(\n\t\t\t\t\t\t\t\t\tmodule.identifier(),\n\t\t\t\t\t\t\t\t\tmodule.buildInfo.hash,\n\t\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\t\t\t\t\t\tstatRestoredFromCache++;\n\t\t\t\t\t\t\t\t\t\t\texportsInfo.restoreProvided(result);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tstatNotCached++;\n\t\t\t\t\t\t\t\t\t\t\t// Without cached info enqueue module for determining the exports\n\t\t\t\t\t\t\t\t\t\t\tqueue.enqueue(module);\n\t\t\t\t\t\t\t\t\t\t\texportsInfo.setHasProvideInfo();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\tlogger.timeEnd(\"restore cached provided exports\");\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\t/** @type {Set<Module>} */\n\t\t\t\t\t\t\t\tconst modulesToStore = new Set();\n\n\t\t\t\t\t\t\t\t/** @type {Map<Module, Set<Module>>} */\n\t\t\t\t\t\t\t\tconst dependencies = new Map();\n\n\t\t\t\t\t\t\t\t/** @type {Module} */\n\t\t\t\t\t\t\t\tlet module;\n\n\t\t\t\t\t\t\t\t/** @type {ExportsInfo} */\n\t\t\t\t\t\t\t\tlet exportsInfo;\n\n\t\t\t\t\t\t\t\t/** @type {Map<Dependency, ExportsSpec>} */\n\t\t\t\t\t\t\t\tconst exportsSpecsFromDependencies = new Map();\n\n\t\t\t\t\t\t\t\tlet cacheable = true;\n\t\t\t\t\t\t\t\tlet changed = false;\n\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @param {DependenciesBlock} depBlock the dependencies block\n\t\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst processDependenciesBlock = depBlock => {\n\t\t\t\t\t\t\t\t\tfor (const dep of depBlock.dependencies) {\n\t\t\t\t\t\t\t\t\t\tprocessDependency(dep);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor (const block of depBlock.blocks) {\n\t\t\t\t\t\t\t\t\t\tprocessDependenciesBlock(block);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @param {Dependency} dep the dependency\n\t\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst processDependency = dep => {\n\t\t\t\t\t\t\t\t\tconst exportDesc = dep.getExports(moduleGraph);\n\t\t\t\t\t\t\t\t\tif (!exportDesc) return;\n\t\t\t\t\t\t\t\t\texportsSpecsFromDependencies.set(dep, exportDesc);\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @param {Dependency} dep dependency\n\t\t\t\t\t\t\t\t * @param {ExportsSpec} exportDesc info\n\t\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst processExportsSpec = (dep, exportDesc) => {\n\t\t\t\t\t\t\t\t\tconst exports = exportDesc.exports;\n\t\t\t\t\t\t\t\t\tconst globalCanMangle = exportDesc.canMangle;\n\t\t\t\t\t\t\t\t\tconst globalFrom = exportDesc.from;\n\t\t\t\t\t\t\t\t\tconst globalPriority = exportDesc.priority;\n\t\t\t\t\t\t\t\t\tconst globalTerminalBinding =\n\t\t\t\t\t\t\t\t\t\texportDesc.terminalBinding || false;\n\t\t\t\t\t\t\t\t\tconst exportDeps = exportDesc.dependencies;\n\t\t\t\t\t\t\t\t\tif (exportDesc.hideExports) {\n\t\t\t\t\t\t\t\t\t\tfor (const name of exportDesc.hideExports) {\n\t\t\t\t\t\t\t\t\t\t\tconst exportInfo = exportsInfo.getExportInfo(name);\n\t\t\t\t\t\t\t\t\t\t\texportInfo.unsetTarget(dep);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (exports === true) {\n\t\t\t\t\t\t\t\t\t\t// unknown exports\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\texportsInfo.setUnknownExportsProvided(\n\t\t\t\t\t\t\t\t\t\t\t\tglobalCanMangle,\n\t\t\t\t\t\t\t\t\t\t\t\texportDesc.excludeExports,\n\t\t\t\t\t\t\t\t\t\t\t\tglobalFrom && dep,\n\t\t\t\t\t\t\t\t\t\t\t\tglobalFrom,\n\t\t\t\t\t\t\t\t\t\t\t\tglobalPriority\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (Array.isArray(exports)) {\n\t\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t\t * merge in new exports\n\t\t\t\t\t\t\t\t\t\t * @param {ExportsInfo} exportsInfo own exports info\n\t\t\t\t\t\t\t\t\t\t * @param {(ExportSpec | string)[]} exports list of exports\n\t\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\t\tconst mergeExports = (exportsInfo, exports) => {\n\t\t\t\t\t\t\t\t\t\t\tfor (const exportNameOrSpec of exports) {\n\t\t\t\t\t\t\t\t\t\t\t\tlet name;\n\t\t\t\t\t\t\t\t\t\t\t\tlet canMangle = globalCanMangle;\n\t\t\t\t\t\t\t\t\t\t\t\tlet terminalBinding = globalTerminalBinding;\n\t\t\t\t\t\t\t\t\t\t\t\tlet exports = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\tlet from = globalFrom;\n\t\t\t\t\t\t\t\t\t\t\t\tlet fromExport = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\tlet priority = globalPriority;\n\t\t\t\t\t\t\t\t\t\t\t\tlet hidden = false;\n\t\t\t\t\t\t\t\t\t\t\t\tif (typeof exportNameOrSpec === \"string\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\tname = exportNameOrSpec;\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tname = exportNameOrSpec.name;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.canMangle !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcanMangle = exportNameOrSpec.canMangle;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.export !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfromExport = exportNameOrSpec.export;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.exports !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\texports = exportNameOrSpec.exports;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.from !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfrom = exportNameOrSpec.from;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.priority !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpriority = exportNameOrSpec.priority;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.terminalBinding !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tterminalBinding = exportNameOrSpec.terminalBinding;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.hidden !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thidden = exportNameOrSpec.hidden;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tconst exportInfo = exportsInfo.getExportInfo(name);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.provided === false ||\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.provided === null\n\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.provided = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.canMangleProvide !== false &&\n\t\t\t\t\t\t\t\t\t\t\t\t\tcanMangle === false\n\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.canMangleProvide = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (terminalBinding && !exportInfo.terminalBinding) {\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.terminalBinding = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (exports) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst nestedExportsInfo =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.createNestedExportsInfo();\n\t\t\t\t\t\t\t\t\t\t\t\t\tmergeExports(nestedExportsInfo, exports);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\tfrom &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t(hidden\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? exportInfo.unsetTarget(dep)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: exportInfo.setTarget(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdep,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfrom,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfromExport === undefined ? [name] : fromExport,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpriority\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  ))\n\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Recalculate target exportsInfo\n\t\t\t\t\t\t\t\t\t\t\t\tconst target = exportInfo.getTarget(moduleGraph);\n\t\t\t\t\t\t\t\t\t\t\t\tlet targetExportsInfo = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\tif (target) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst targetModuleExportsInfo =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph.getExportsInfo(target.module);\n\t\t\t\t\t\t\t\t\t\t\t\t\ttargetExportsInfo =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetModuleExportsInfo.getNestedExportsInfo(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget.export\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t// add dependency for this module\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst set = dependencies.get(target.module);\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (set === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdependencies.set(target.module, new Set([module]));\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tset.add(module);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (exportInfo.exportsInfoOwned) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.exportsInfo.setRedirectNamedTo(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetExportsInfo\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.exportsInfo !== targetExportsInfo\n\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.exportsInfo = targetExportsInfo;\n\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tmergeExports(exportsInfo, exports);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// store dependencies\n\t\t\t\t\t\t\t\t\tif (exportDeps) {\n\t\t\t\t\t\t\t\t\t\tcacheable = false;\n\t\t\t\t\t\t\t\t\t\tfor (const exportDependency of exportDeps) {\n\t\t\t\t\t\t\t\t\t\t\t// add dependency for this module\n\t\t\t\t\t\t\t\t\t\t\tconst set = dependencies.get(exportDependency);\n\t\t\t\t\t\t\t\t\t\t\tif (set === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\tdependencies.set(exportDependency, new Set([module]));\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tset.add(module);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tconst notifyDependencies = () => {\n\t\t\t\t\t\t\t\t\tconst deps = dependencies.get(module);\n\t\t\t\t\t\t\t\t\tif (deps !== undefined) {\n\t\t\t\t\t\t\t\t\t\tfor (const dep of deps) {\n\t\t\t\t\t\t\t\t\t\t\tqueue.enqueue(dep);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tlogger.time(\"figure out provided exports\");\n\t\t\t\t\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\t\t\t\t\tmodule = queue.dequeue();\n\n\t\t\t\t\t\t\t\t\tstatQueueItemsProcessed++;\n\n\t\t\t\t\t\t\t\t\texportsInfo = moduleGraph.getExportsInfo(module);\n\n\t\t\t\t\t\t\t\t\tcacheable = true;\n\t\t\t\t\t\t\t\t\tchanged = false;\n\n\t\t\t\t\t\t\t\t\texportsSpecsFromDependencies.clear();\n\t\t\t\t\t\t\t\t\tmoduleGraph.freeze();\n\t\t\t\t\t\t\t\t\tprocessDependenciesBlock(module);\n\t\t\t\t\t\t\t\t\tmoduleGraph.unfreeze();\n\t\t\t\t\t\t\t\t\tfor (const [\n\t\t\t\t\t\t\t\t\t\tdep,\n\t\t\t\t\t\t\t\t\t\texportsSpec\n\t\t\t\t\t\t\t\t\t] of exportsSpecsFromDependencies) {\n\t\t\t\t\t\t\t\t\t\tprocessExportsSpec(dep, exportsSpec);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (cacheable) {\n\t\t\t\t\t\t\t\t\t\tmodulesToStore.add(module);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t\t\t\t\tnotifyDependencies();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlogger.timeEnd(\"figure out provided exports\");\n\n\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t`${Math.round(\n\t\t\t\t\t\t\t\t\t\t(100 * (statFlaggedUncached + statNotCached)) /\n\t\t\t\t\t\t\t\t\t\t\t(statRestoredFromMemCache +\n\t\t\t\t\t\t\t\t\t\t\t\tstatRestoredFromCache +\n\t\t\t\t\t\t\t\t\t\t\t\tstatNotCached +\n\t\t\t\t\t\t\t\t\t\t\t\tstatFlaggedUncached +\n\t\t\t\t\t\t\t\t\t\t\t\tstatNoExports)\n\t\t\t\t\t\t\t\t\t)}% of exports of modules have been determined (${statNoExports} no declared exports, ${statNotCached} not cached, ${statFlaggedUncached} flagged uncacheable, ${statRestoredFromCache} from cache, ${statRestoredFromMemCache} from mem cache, ${\n\t\t\t\t\t\t\t\t\t\tstatQueueItemsProcessed -\n\t\t\t\t\t\t\t\t\t\tstatNotCached -\n\t\t\t\t\t\t\t\t\t\tstatFlaggedUncached\n\t\t\t\t\t\t\t\t\t} additional calculations due to dependencies)`\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tlogger.time(\"store provided exports into cache\");\n\t\t\t\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\t\t\t\tmodulesToStore,\n\t\t\t\t\t\t\t\t\t(module, callback) => {\n\t\t\t\t\t\t\t\t\t\tif (typeof module.buildInfo.hash !== \"string\") {\n\t\t\t\t\t\t\t\t\t\t\t// not cacheable\n\t\t\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst cachedData = moduleGraph\n\t\t\t\t\t\t\t\t\t\t\t.getExportsInfo(module)\n\t\t\t\t\t\t\t\t\t\t\t.getRestoreProvidedData();\n\t\t\t\t\t\t\t\t\t\tconst memCache =\n\t\t\t\t\t\t\t\t\t\t\tmoduleMemCaches && moduleMemCaches.get(module);\n\t\t\t\t\t\t\t\t\t\tif (memCache) {\n\t\t\t\t\t\t\t\t\t\t\tmemCache.set(this, cachedData);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcache.store(\n\t\t\t\t\t\t\t\t\t\t\tmodule.identifier(),\n\t\t\t\t\t\t\t\t\t\t\tmodule.buildInfo.hash,\n\t\t\t\t\t\t\t\t\t\t\tcachedData,\n\t\t\t\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\t\tlogger.timeEnd(\"store provided exports into cache\");\n\t\t\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t/** @type {WeakMap<Module, any>} */\n\t\t\t\tconst providedExportsCache = new WeakMap();\n\t\t\t\tcompilation.hooks.rebuildModule.tap(\n\t\t\t\t\t\"FlagDependencyExportsPlugin\",\n\t\t\t\t\tmodule => {\n\t\t\t\t\t\tprovidedExportsCache.set(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tmoduleGraph.getExportsInfo(module).getRestoreProvidedData()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.finishRebuildingModule.tap(\n\t\t\t\t\t\"FlagDependencyExportsPlugin\",\n\t\t\t\t\tmodule => {\n\t\t\t\t\t\tmoduleGraph\n\t\t\t\t\t\t\t.getExportsInfo(module)\n\t\t\t\t\t\t\t.restoreProvided(providedExportsCache.get(module));\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = FlagDependencyExportsPlugin;\n"]},"metadata":{},"sourceType":"script"}