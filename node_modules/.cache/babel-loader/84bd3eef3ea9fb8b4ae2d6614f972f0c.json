{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst util = require(\"util\");\n\nconst ModuleDependency = require(\"../dependencies/ModuleDependency\");\n\nconst formatLocation = require(\"../formatLocation\");\n\nconst {\n  LogType\n} = require(\"../logging/Logger\");\n\nconst AggressiveSplittingPlugin = require(\"../optimize/AggressiveSplittingPlugin\");\n\nconst SizeLimitsPlugin = require(\"../performance/SizeLimitsPlugin\");\n\nconst {\n  countIterable\n} = require(\"../util/IterableHelpers\");\n\nconst {\n  compareLocations,\n  compareChunksById,\n  compareNumbers,\n  compareIds,\n  concatComparators,\n  compareSelect,\n  compareModulesByIdentifier\n} = require(\"../util/comparators\");\n\nconst {\n  makePathsRelative,\n  parseResource\n} = require(\"../util/identifier\");\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"../ChunkGroup\").OriginRecord} OriginRecord */\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n\n/** @typedef {import(\"../Compilation\").Asset} Asset */\n\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n\n/** @typedef {import(\"../Compilation\").NormalizedStatsOptions} NormalizedStatsOptions */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Dependency\")} Dependency */\n\n/** @typedef {import(\"../Dependency\").DependencyLocation} DependencyLocation */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n\n/** @typedef {import(\"../ModuleProfile\")} ModuleProfile */\n\n/** @typedef {import(\"../RequestShortener\")} RequestShortener */\n\n/** @typedef {import(\"../WebpackError\")} WebpackError */\n\n/** @template T @typedef {import(\"../util/comparators\").Comparator<T>} Comparator<T> */\n\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @typedef {import(\"../util/smartGrouping\").GroupConfig<any, object>} GroupConfig */\n\n/** @typedef {import(\"./StatsFactory\")} StatsFactory */\n\n/** @typedef {import(\"./StatsFactory\").StatsFactoryContext} StatsFactoryContext */\n\n/** @typedef {KnownStatsCompilation & Record<string, any>} StatsCompilation */\n\n/**\n * @typedef {Object} KnownStatsCompilation\n * @property {any=} env\n * @property {string=} name\n * @property {string=} hash\n * @property {string=} version\n * @property {number=} time\n * @property {number=} builtAt\n * @property {boolean=} needAdditionalPass\n * @property {string=} publicPath\n * @property {string=} outputPath\n * @property {Record<string, string[]>=} assetsByChunkName\n * @property {StatsAsset[]=} assets\n * @property {number=} filteredAssets\n * @property {StatsChunk[]=} chunks\n * @property {StatsModule[]=} modules\n * @property {number=} filteredModules\n * @property {Record<string, StatsChunkGroup>=} entrypoints\n * @property {Record<string, StatsChunkGroup>=} namedChunkGroups\n * @property {StatsError[]=} errors\n * @property {number=} errorsCount\n * @property {StatsError[]=} warnings\n * @property {number=} warningsCount\n * @property {StatsCompilation[]=} children\n * @property {Record<string, StatsLogging>=} logging\n */\n\n/** @typedef {KnownStatsLogging & Record<string, any>} StatsLogging */\n\n/**\n * @typedef {Object} KnownStatsLogging\n * @property {StatsLoggingEntry[]} entries\n * @property {number} filteredEntries\n * @property {boolean} debug\n */\n\n/** @typedef {KnownStatsLoggingEntry & Record<string, any>} StatsLoggingEntry */\n\n/**\n * @typedef {Object} KnownStatsLoggingEntry\n * @property {string} type\n * @property {string} message\n * @property {string[]=} trace\n * @property {StatsLoggingEntry[]=} children\n * @property {any[]=} args\n * @property {number=} time\n */\n\n/** @typedef {KnownStatsAsset & Record<string, any>} StatsAsset */\n\n/**\n * @typedef {Object} KnownStatsAsset\n * @property {string} type\n * @property {string} name\n * @property {AssetInfo} info\n * @property {number} size\n * @property {boolean} emitted\n * @property {boolean} comparedForEmit\n * @property {boolean} cached\n * @property {StatsAsset[]=} related\n * @property {(string|number)[]=} chunkNames\n * @property {(string|number)[]=} chunkIdHints\n * @property {(string|number)[]=} chunks\n * @property {(string|number)[]=} auxiliaryChunkNames\n * @property {(string|number)[]=} auxiliaryChunks\n * @property {(string|number)[]=} auxiliaryChunkIdHints\n * @property {number=} filteredRelated\n * @property {boolean=} isOverSizeLimit\n */\n\n/** @typedef {KnownStatsChunkGroup & Record<string, any>} StatsChunkGroup */\n\n/**\n * @typedef {Object} KnownStatsChunkGroup\n * @property {string=} name\n * @property {(string|number)[]=} chunks\n * @property {({ name: string, size?: number })[]=} assets\n * @property {number=} filteredAssets\n * @property {number=} assetsSize\n * @property {({ name: string, size?: number })[]=} auxiliaryAssets\n * @property {number=} filteredAuxiliaryAssets\n * @property {number=} auxiliaryAssetsSize\n * @property {{ [x: string]: StatsChunkGroup[] }=} children\n * @property {{ [x: string]: string[] }=} childAssets\n * @property {boolean=} isOverSizeLimit\n */\n\n/** @typedef {KnownStatsModule & Record<string, any>} StatsModule */\n\n/**\n * @typedef {Object} KnownStatsModule\n * @property {string=} type\n * @property {string=} moduleType\n * @property {string=} layer\n * @property {string=} identifier\n * @property {string=} name\n * @property {string=} nameForCondition\n * @property {number=} index\n * @property {number=} preOrderIndex\n * @property {number=} index2\n * @property {number=} postOrderIndex\n * @property {number=} size\n * @property {{[x: string]: number}=} sizes\n * @property {boolean=} cacheable\n * @property {boolean=} built\n * @property {boolean=} codeGenerated\n * @property {boolean=} buildTimeExecuted\n * @property {boolean=} cached\n * @property {boolean=} optional\n * @property {boolean=} orphan\n * @property {string|number=} id\n * @property {string|number=} issuerId\n * @property {(string|number)[]=} chunks\n * @property {(string|number)[]=} assets\n * @property {boolean=} dependent\n * @property {string=} issuer\n * @property {string=} issuerName\n * @property {StatsModuleIssuer[]=} issuerPath\n * @property {boolean=} failed\n * @property {number=} errors\n * @property {number=} warnings\n * @property {StatsProfile=} profile\n * @property {StatsModuleReason[]=} reasons\n * @property {(boolean | string[])=} usedExports\n * @property {string[]=} providedExports\n * @property {string[]=} optimizationBailout\n * @property {number=} depth\n * @property {StatsModule[]=} modules\n * @property {number=} filteredModules\n * @property {ReturnType<Source[\"source\"]>=} source\n */\n\n/** @typedef {KnownStatsProfile & Record<string, any>} StatsProfile */\n\n/**\n * @typedef {Object} KnownStatsProfile\n * @property {number} total\n * @property {number} resolving\n * @property {number} restoring\n * @property {number} building\n * @property {number} integration\n * @property {number} storing\n * @property {number} additionalResolving\n * @property {number} additionalIntegration\n * @property {number} factory\n * @property {number} dependencies\n */\n\n/** @typedef {KnownStatsModuleIssuer & Record<string, any>} StatsModuleIssuer */\n\n/**\n * @typedef {Object} KnownStatsModuleIssuer\n * @property {string=} identifier\n * @property {string=} name\n * @property {(string|number)=} id\n * @property {StatsProfile=} profile\n */\n\n/** @typedef {KnownStatsModuleReason & Record<string, any>} StatsModuleReason */\n\n/**\n * @typedef {Object} KnownStatsModuleReason\n * @property {string=} moduleIdentifier\n * @property {string=} module\n * @property {string=} moduleName\n * @property {string=} resolvedModuleIdentifier\n * @property {string=} resolvedModule\n * @property {string=} type\n * @property {boolean} active\n * @property {string=} explanation\n * @property {string=} userRequest\n * @property {string=} loc\n * @property {(string|number)=} moduleId\n * @property {(string|number)=} resolvedModuleId\n */\n\n/** @typedef {KnownStatsChunk & Record<string, any>} StatsChunk */\n\n/**\n * @typedef {Object} KnownStatsChunk\n * @property {boolean} rendered\n * @property {boolean} initial\n * @property {boolean} entry\n * @property {boolean} recorded\n * @property {string=} reason\n * @property {number} size\n * @property {Record<string, number>=} sizes\n * @property {string[]=} names\n * @property {string[]=} idHints\n * @property {string[]=} runtime\n * @property {string[]=} files\n * @property {string[]=} auxiliaryFiles\n * @property {string} hash\n * @property {Record<string, (string|number)[]>=} childrenByOrder\n * @property {(string|number)=} id\n * @property {(string|number)[]=} siblings\n * @property {(string|number)[]=} parents\n * @property {(string|number)[]=} children\n * @property {StatsModule[]=} modules\n * @property {number=} filteredModules\n * @property {StatsChunkOrigin[]=} origins\n */\n\n/** @typedef {KnownStatsChunkOrigin & Record<string, any>} StatsChunkOrigin */\n\n/**\n * @typedef {Object} KnownStatsChunkOrigin\n * @property {string=} module\n * @property {string=} moduleIdentifier\n * @property {string=} moduleName\n * @property {string=} loc\n * @property {string=} request\n * @property {(string|number)=} moduleId\n */\n\n/** @typedef {KnownStatsModuleTraceItem & Record<string, any>} StatsModuleTraceItem */\n\n/**\n * @typedef {Object} KnownStatsModuleTraceItem\n * @property {string=} originIdentifier\n * @property {string=} originName\n * @property {string=} moduleIdentifier\n * @property {string=} moduleName\n * @property {StatsModuleTraceDependency[]=} dependencies\n * @property {(string|number)=} originId\n * @property {(string|number)=} moduleId\n */\n\n/** @typedef {KnownStatsModuleTraceDependency & Record<string, any>} StatsModuleTraceDependency */\n\n/**\n * @typedef {Object} KnownStatsModuleTraceDependency\n * @property {string=} loc\n */\n\n/** @typedef {KnownStatsError & Record<string, any>} StatsError */\n\n/**\n * @typedef {Object} KnownStatsError\n * @property {string} message\n * @property {string=} chunkName\n * @property {boolean=} chunkEntry\n * @property {boolean=} chunkInitial\n * @property {string=} file\n * @property {string=} moduleIdentifier\n * @property {string=} moduleName\n * @property {string=} loc\n * @property {string|number=} chunkId\n * @property {string|number=} moduleId\n * @property {StatsModuleTraceItem[]=} moduleTrace\n * @property {any=} details\n * @property {string=} stack\n */\n\n/** @typedef {Asset & { type: string, related: PreprocessedAsset[] }} PreprocessedAsset */\n\n/**\n * @template T\n * @template O\n * @typedef {Record<string, (object: O, data: T, context: StatsFactoryContext, options: NormalizedStatsOptions, factory: StatsFactory) => void>} ExtractorsByOption\n */\n\n/**\n * @typedef {Object} SimpleExtractors\n * @property {ExtractorsByOption<Compilation, StatsCompilation>} compilation\n * @property {ExtractorsByOption<PreprocessedAsset, StatsAsset>} asset\n * @property {ExtractorsByOption<PreprocessedAsset, StatsAsset>} asset$visible\n * @property {ExtractorsByOption<{ name: string, chunkGroup: ChunkGroup }, StatsChunkGroup>} chunkGroup\n * @property {ExtractorsByOption<Module, StatsModule>} module\n * @property {ExtractorsByOption<Module, StatsModule>} module$visible\n * @property {ExtractorsByOption<Module, StatsModuleIssuer>} moduleIssuer\n * @property {ExtractorsByOption<ModuleProfile, StatsProfile>} profile\n * @property {ExtractorsByOption<ModuleGraphConnection, StatsModuleReason>} moduleReason\n * @property {ExtractorsByOption<Chunk, StatsChunk>} chunk\n * @property {ExtractorsByOption<OriginRecord, StatsChunkOrigin>} chunkOrigin\n * @property {ExtractorsByOption<WebpackError, StatsError>} error\n * @property {ExtractorsByOption<WebpackError, StatsError>} warning\n * @property {ExtractorsByOption<{ origin: Module, module: Module }, StatsModuleTraceItem>} moduleTraceItem\n * @property {ExtractorsByOption<Dependency, StatsModuleTraceDependency>} moduleTraceDependency\n */\n\n/**\n * @template T\n * @template I\n * @param {Iterable<T>} items items to select from\n * @param {function(T): Iterable<I>} selector selector function to select values from item\n * @returns {I[]} array of values\n */\n\n\nconst uniqueArray = (items, selector) => {\n  /** @type {Set<I>} */\n  const set = new Set();\n\n  for (const item of items) {\n    for (const i of selector(item)) {\n      set.add(i);\n    }\n  }\n\n  return Array.from(set);\n};\n/**\n * @template T\n * @template I\n * @param {Iterable<T>} items items to select from\n * @param {function(T): Iterable<I>} selector selector function to select values from item\n * @param {Comparator<I>} comparator comparator function\n * @returns {I[]} array of values\n */\n\n\nconst uniqueOrderedArray = (items, selector, comparator) => {\n  return uniqueArray(items, selector).sort(comparator);\n};\n/** @template T @template R @typedef {{ [P in keyof T]: R }} MappedValues<T, R> */\n\n/**\n * @template T\n * @template R\n * @param {T} obj object to be mapped\n * @param {function(T[keyof T], keyof T): R} fn mapping function\n * @returns {MappedValues<T, R>} mapped object\n */\n\n\nconst mapObject = (obj, fn) => {\n  const newObj = Object.create(null);\n\n  for (const key of Object.keys(obj)) {\n    newObj[key] = fn(obj[key],\n    /** @type {keyof T} */\n    key);\n  }\n\n  return newObj;\n};\n/**\n * @param {Compilation} compilation the compilation\n * @param {function(Compilation, string): any[]} getItems get items\n * @returns {number} total number\n */\n\n\nconst countWithChildren = (compilation, getItems) => {\n  let count = getItems(compilation, \"\").length;\n\n  for (const child of compilation.children) {\n    count += countWithChildren(child, (c, type) => getItems(c, `.children[].compilation${type}`));\n  }\n\n  return count;\n};\n/** @type {ExtractorsByOption<WebpackError | string, StatsError>} */\n\n\nconst EXTRACT_ERROR = {\n  _: (object, error, context, _ref) => {\n    let {\n      requestShortener\n    } = _ref;\n\n    // TODO webpack 6 disallow strings in the errors/warnings list\n    if (typeof error === \"string\") {\n      object.message = error;\n    } else {\n      if (error.chunk) {\n        object.chunkName = error.chunk.name;\n        object.chunkEntry = error.chunk.hasRuntime();\n        object.chunkInitial = error.chunk.canBeInitial();\n      }\n\n      if (error.file) {\n        object.file = error.file;\n      }\n\n      if (error.module) {\n        object.moduleIdentifier = error.module.identifier();\n        object.moduleName = error.module.readableIdentifier(requestShortener);\n      }\n\n      if (error.loc) {\n        object.loc = formatLocation(error.loc);\n      }\n\n      object.message = error.message;\n    }\n  },\n  ids: (object, error, _ref2) => {\n    let {\n      compilation: {\n        chunkGraph\n      }\n    } = _ref2;\n\n    if (typeof error !== \"string\") {\n      if (error.chunk) {\n        object.chunkId = error.chunk.id;\n      }\n\n      if (error.module) {\n        object.moduleId = chunkGraph.getModuleId(error.module);\n      }\n    }\n  },\n  moduleTrace: (object, error, context, options, factory) => {\n    if (typeof error !== \"string\" && error.module) {\n      const {\n        type,\n        compilation: {\n          moduleGraph\n        }\n      } = context;\n      /** @type {Set<Module>} */\n\n      const visitedModules = new Set();\n      const moduleTrace = [];\n      let current = error.module;\n\n      while (current) {\n        if (visitedModules.has(current)) break; // circular (technically impossible, but how knows)\n\n        visitedModules.add(current);\n        const origin = moduleGraph.getIssuer(current);\n        if (!origin) break;\n        moduleTrace.push({\n          origin,\n          module: current\n        });\n        current = origin;\n      }\n\n      object.moduleTrace = factory.create(`${type}.moduleTrace`, moduleTrace, context);\n    }\n  },\n  errorDetails: (object, error, _ref3, _ref4) => {\n    let {\n      type,\n      compilation,\n      cachedGetErrors,\n      cachedGetWarnings\n    } = _ref3;\n    let {\n      errorDetails\n    } = _ref4;\n\n    if (typeof error !== \"string\" && (errorDetails === true || type.endsWith(\".error\") && cachedGetErrors(compilation).length < 3)) {\n      object.details = error.details;\n    }\n  },\n  errorStack: (object, error) => {\n    if (typeof error !== \"string\") {\n      object.stack = error.stack;\n    }\n  }\n};\n/** @type {SimpleExtractors} */\n\nconst SIMPLE_EXTRACTORS = {\n  compilation: {\n    _: (object, compilation, context, options) => {\n      if (!context.makePathsRelative) {\n        context.makePathsRelative = makePathsRelative.bindContextCache(compilation.compiler.context, compilation.compiler.root);\n      }\n\n      if (!context.cachedGetErrors) {\n        const map = new WeakMap();\n\n        context.cachedGetErrors = compilation => {\n          return map.get(compilation) || (errors => (map.set(compilation, errors), errors))(compilation.getErrors());\n        };\n      }\n\n      if (!context.cachedGetWarnings) {\n        const map = new WeakMap();\n\n        context.cachedGetWarnings = compilation => {\n          return map.get(compilation) || (warnings => (map.set(compilation, warnings), warnings))(compilation.getWarnings());\n        };\n      }\n\n      if (compilation.name) {\n        object.name = compilation.name;\n      }\n\n      if (compilation.needAdditionalPass) {\n        object.needAdditionalPass = true;\n      }\n\n      const {\n        logging,\n        loggingDebug,\n        loggingTrace\n      } = options;\n\n      if (logging || loggingDebug && loggingDebug.length > 0) {\n        const util = require(\"util\");\n\n        object.logging = {};\n        let acceptedTypes;\n        let collapsedGroups = false;\n\n        switch (logging) {\n          default:\n            acceptedTypes = new Set();\n            break;\n\n          case \"error\":\n            acceptedTypes = new Set([LogType.error]);\n            break;\n\n          case \"warn\":\n            acceptedTypes = new Set([LogType.error, LogType.warn]);\n            break;\n\n          case \"info\":\n            acceptedTypes = new Set([LogType.error, LogType.warn, LogType.info]);\n            break;\n\n          case \"log\":\n            acceptedTypes = new Set([LogType.error, LogType.warn, LogType.info, LogType.log, LogType.group, LogType.groupEnd, LogType.groupCollapsed, LogType.clear]);\n            break;\n\n          case \"verbose\":\n            acceptedTypes = new Set([LogType.error, LogType.warn, LogType.info, LogType.log, LogType.group, LogType.groupEnd, LogType.groupCollapsed, LogType.profile, LogType.profileEnd, LogType.time, LogType.status, LogType.clear]);\n            collapsedGroups = true;\n            break;\n        }\n\n        const cachedMakePathsRelative = makePathsRelative.bindContextCache(options.context, compilation.compiler.root);\n        let depthInCollapsedGroup = 0;\n\n        for (const [origin, logEntries] of compilation.logging) {\n          const debugMode = loggingDebug.some(fn => fn(origin));\n          if (logging === false && !debugMode) continue;\n          /** @type {KnownStatsLoggingEntry[]} */\n\n          const groupStack = [];\n          /** @type {KnownStatsLoggingEntry[]} */\n\n          const rootList = [];\n          let currentList = rootList;\n          let processedLogEntries = 0;\n\n          for (const entry of logEntries) {\n            let type = entry.type;\n            if (!debugMode && !acceptedTypes.has(type)) continue; // Expand groups in verbose and debug modes\n\n            if (type === LogType.groupCollapsed && (debugMode || collapsedGroups)) type = LogType.group;\n\n            if (depthInCollapsedGroup === 0) {\n              processedLogEntries++;\n            }\n\n            if (type === LogType.groupEnd) {\n              groupStack.pop();\n\n              if (groupStack.length > 0) {\n                currentList = groupStack[groupStack.length - 1].children;\n              } else {\n                currentList = rootList;\n              }\n\n              if (depthInCollapsedGroup > 0) depthInCollapsedGroup--;\n              continue;\n            }\n\n            let message = undefined;\n\n            if (entry.type === LogType.time) {\n              message = `${entry.args[0]}: ${entry.args[1] * 1000 + entry.args[2] / 1000000} ms`;\n            } else if (entry.args && entry.args.length > 0) {\n              message = util.format(entry.args[0], ...entry.args.slice(1));\n            }\n            /** @type {KnownStatsLoggingEntry} */\n\n\n            const newEntry = { ...entry,\n              type,\n              message,\n              trace: loggingTrace ? entry.trace : undefined,\n              children: type === LogType.group || type === LogType.groupCollapsed ? [] : undefined\n            };\n            currentList.push(newEntry);\n\n            if (newEntry.children) {\n              groupStack.push(newEntry);\n              currentList = newEntry.children;\n\n              if (depthInCollapsedGroup > 0) {\n                depthInCollapsedGroup++;\n              } else if (type === LogType.groupCollapsed) {\n                depthInCollapsedGroup = 1;\n              }\n            }\n          }\n\n          let name = cachedMakePathsRelative(origin).replace(/\\|/g, \" \");\n\n          if (name in object.logging) {\n            let i = 1;\n\n            while (`${name}#${i}` in object.logging) {\n              i++;\n            }\n\n            name = `${name}#${i}`;\n          }\n\n          object.logging[name] = {\n            entries: rootList,\n            filteredEntries: logEntries.length - processedLogEntries,\n            debug: debugMode\n          };\n        }\n      }\n    },\n    hash: (object, compilation) => {\n      object.hash = compilation.hash;\n    },\n    version: object => {\n      object.version = require(\"../../package.json\").version;\n    },\n    env: (object, compilation, context, _ref5) => {\n      let {\n        _env\n      } = _ref5;\n      object.env = _env;\n    },\n    timings: (object, compilation) => {\n      object.time = compilation.endTime - compilation.startTime;\n    },\n    builtAt: (object, compilation) => {\n      object.builtAt = compilation.endTime;\n    },\n    publicPath: (object, compilation) => {\n      object.publicPath = compilation.getPath(compilation.outputOptions.publicPath);\n    },\n    outputPath: (object, compilation) => {\n      object.outputPath = compilation.outputOptions.path;\n    },\n    assets: (object, compilation, context, options, factory) => {\n      const {\n        type\n      } = context;\n      /** @type {Map<string, Chunk[]>} */\n\n      const compilationFileToChunks = new Map();\n      /** @type {Map<string, Chunk[]>} */\n\n      const compilationAuxiliaryFileToChunks = new Map();\n\n      for (const chunk of compilation.chunks) {\n        for (const file of chunk.files) {\n          let array = compilationFileToChunks.get(file);\n\n          if (array === undefined) {\n            array = [];\n            compilationFileToChunks.set(file, array);\n          }\n\n          array.push(chunk);\n        }\n\n        for (const file of chunk.auxiliaryFiles) {\n          let array = compilationAuxiliaryFileToChunks.get(file);\n\n          if (array === undefined) {\n            array = [];\n            compilationAuxiliaryFileToChunks.set(file, array);\n          }\n\n          array.push(chunk);\n        }\n      }\n      /** @type {Map<string, PreprocessedAsset>} */\n\n\n      const assetMap = new Map();\n      /** @type {Set<PreprocessedAsset>} */\n\n      const assets = new Set();\n\n      for (const asset of compilation.getAssets()) {\n        /** @type {PreprocessedAsset} */\n        const item = { ...asset,\n          type: \"asset\",\n          related: undefined\n        };\n        assets.add(item);\n        assetMap.set(asset.name, item);\n      }\n\n      for (const item of assetMap.values()) {\n        const related = item.info.related;\n        if (!related) continue;\n\n        for (const type of Object.keys(related)) {\n          const relatedEntry = related[type];\n          const deps = Array.isArray(relatedEntry) ? relatedEntry : [relatedEntry];\n\n          for (const dep of deps) {\n            const depItem = assetMap.get(dep);\n            if (!depItem) continue;\n            assets.delete(depItem);\n            depItem.type = type;\n            item.related = item.related || [];\n            item.related.push(depItem);\n          }\n        }\n      }\n\n      object.assetsByChunkName = {};\n\n      for (const [file, chunks] of compilationFileToChunks) {\n        for (const chunk of chunks) {\n          const name = chunk.name;\n          if (!name) continue;\n\n          if (!Object.prototype.hasOwnProperty.call(object.assetsByChunkName, name)) {\n            object.assetsByChunkName[name] = [];\n          }\n\n          object.assetsByChunkName[name].push(file);\n        }\n      }\n\n      const groupedAssets = factory.create(`${type}.assets`, Array.from(assets), { ...context,\n        compilationFileToChunks,\n        compilationAuxiliaryFileToChunks\n      });\n      const limited = spaceLimited(groupedAssets, options.assetsSpace);\n      object.assets = limited.children;\n      object.filteredAssets = limited.filteredChildren;\n    },\n    chunks: (object, compilation, context, options, factory) => {\n      const {\n        type\n      } = context;\n      object.chunks = factory.create(`${type}.chunks`, Array.from(compilation.chunks), context);\n    },\n    modules: (object, compilation, context, options, factory) => {\n      const {\n        type\n      } = context;\n      const array = Array.from(compilation.modules);\n      const groupedModules = factory.create(`${type}.modules`, array, context);\n      const limited = spaceLimited(groupedModules, options.modulesSpace);\n      object.modules = limited.children;\n      object.filteredModules = limited.filteredChildren;\n    },\n    entrypoints: (object, compilation, context, _ref6, factory) => {\n      let {\n        entrypoints,\n        chunkGroups,\n        chunkGroupAuxiliary,\n        chunkGroupChildren\n      } = _ref6;\n      const {\n        type\n      } = context;\n      const array = Array.from(compilation.entrypoints, _ref7 => {\n        let [key, value] = _ref7;\n        return {\n          name: key,\n          chunkGroup: value\n        };\n      });\n\n      if (entrypoints === \"auto\" && !chunkGroups) {\n        if (array.length > 5) return;\n\n        if (!chunkGroupChildren && array.every(_ref8 => {\n          let {\n            chunkGroup\n          } = _ref8;\n          if (chunkGroup.chunks.length !== 1) return false;\n          const chunk = chunkGroup.chunks[0];\n          return chunk.files.size === 1 && (!chunkGroupAuxiliary || chunk.auxiliaryFiles.size === 0);\n        })) {\n          return;\n        }\n      }\n\n      object.entrypoints = factory.create(`${type}.entrypoints`, array, context);\n    },\n    chunkGroups: (object, compilation, context, options, factory) => {\n      const {\n        type\n      } = context;\n      const array = Array.from(compilation.namedChunkGroups, _ref9 => {\n        let [key, value] = _ref9;\n        return {\n          name: key,\n          chunkGroup: value\n        };\n      });\n      object.namedChunkGroups = factory.create(`${type}.namedChunkGroups`, array, context);\n    },\n    errors: (object, compilation, context, options, factory) => {\n      const {\n        type,\n        cachedGetErrors\n      } = context;\n      object.errors = factory.create(`${type}.errors`, cachedGetErrors(compilation), context);\n    },\n    errorsCount: (object, compilation, _ref10) => {\n      let {\n        cachedGetErrors\n      } = _ref10;\n      object.errorsCount = countWithChildren(compilation, c => cachedGetErrors(c));\n    },\n    warnings: (object, compilation, context, options, factory) => {\n      const {\n        type,\n        cachedGetWarnings\n      } = context;\n      object.warnings = factory.create(`${type}.warnings`, cachedGetWarnings(compilation), context);\n    },\n    warningsCount: (object, compilation, context, _ref11, factory) => {\n      let {\n        warningsFilter\n      } = _ref11;\n      const {\n        type,\n        cachedGetWarnings\n      } = context;\n      object.warningsCount = countWithChildren(compilation, (c, childType) => {\n        if (!warningsFilter && warningsFilter.length === 0) return cachedGetWarnings(c);\n        return factory.create(`${type}${childType}.warnings`, cachedGetWarnings(c), context).filter(warning => {\n          const warningString = Object.keys(warning).map(key => `${warning[key]}`).join(\"\\n\");\n          return !warningsFilter.some(filter => filter(warning, warningString));\n        });\n      });\n    },\n    errorDetails: (object, compilation, _ref12, _ref13) => {\n      let {\n        cachedGetErrors,\n        cachedGetWarnings\n      } = _ref12;\n      let {\n        errorDetails,\n        errors,\n        warnings\n      } = _ref13;\n\n      if (errorDetails === \"auto\") {\n        if (warnings) {\n          const warnings = cachedGetWarnings(compilation);\n          object.filteredWarningDetailsCount = warnings.map(e => typeof e !== \"string\" && e.details).filter(Boolean).length;\n        }\n\n        if (errors) {\n          const errors = cachedGetErrors(compilation);\n\n          if (errors.length >= 3) {\n            object.filteredErrorDetailsCount = errors.map(e => typeof e !== \"string\" && e.details).filter(Boolean).length;\n          }\n        }\n      }\n    },\n    children: (object, compilation, context, options, factory) => {\n      const {\n        type\n      } = context;\n      object.children = factory.create(`${type}.children`, compilation.children, context);\n    }\n  },\n  asset: {\n    _: (object, asset, context, options, factory) => {\n      const {\n        compilation\n      } = context;\n      object.type = asset.type;\n      object.name = asset.name;\n      object.size = asset.source.size();\n      object.emitted = compilation.emittedAssets.has(asset.name);\n      object.comparedForEmit = compilation.comparedForEmitAssets.has(asset.name);\n      const cached = !object.emitted && !object.comparedForEmit;\n      object.cached = cached;\n      object.info = asset.info;\n\n      if (!cached || options.cachedAssets) {\n        Object.assign(object, factory.create(`${context.type}$visible`, asset, context));\n      }\n    }\n  },\n  asset$visible: {\n    _: (object, asset, _ref14) => {\n      let {\n        compilation,\n        compilationFileToChunks,\n        compilationAuxiliaryFileToChunks\n      } = _ref14;\n      const chunks = compilationFileToChunks.get(asset.name) || [];\n      const auxiliaryChunks = compilationAuxiliaryFileToChunks.get(asset.name) || [];\n      object.chunkNames = uniqueOrderedArray(chunks, c => c.name ? [c.name] : [], compareIds);\n      object.chunkIdHints = uniqueOrderedArray(chunks, c => Array.from(c.idNameHints), compareIds);\n      object.auxiliaryChunkNames = uniqueOrderedArray(auxiliaryChunks, c => c.name ? [c.name] : [], compareIds);\n      object.auxiliaryChunkIdHints = uniqueOrderedArray(auxiliaryChunks, c => Array.from(c.idNameHints), compareIds);\n      object.filteredRelated = asset.related ? asset.related.length : undefined;\n    },\n    relatedAssets: (object, asset, context, options, factory) => {\n      const {\n        type\n      } = context;\n      object.related = factory.create(`${type.slice(0, -8)}.related`, asset.related, context);\n      object.filteredRelated = asset.related ? asset.related.length - object.related.length : undefined;\n    },\n    ids: (object, asset, _ref15) => {\n      let {\n        compilationFileToChunks,\n        compilationAuxiliaryFileToChunks\n      } = _ref15;\n      const chunks = compilationFileToChunks.get(asset.name) || [];\n      const auxiliaryChunks = compilationAuxiliaryFileToChunks.get(asset.name) || [];\n      object.chunks = uniqueOrderedArray(chunks, c => c.ids, compareIds);\n      object.auxiliaryChunks = uniqueOrderedArray(auxiliaryChunks, c => c.ids, compareIds);\n    },\n    performance: (object, asset) => {\n      object.isOverSizeLimit = SizeLimitsPlugin.isOverSizeLimit(asset.source);\n    }\n  },\n  chunkGroup: {\n    _: (object, _ref16, _ref17, _ref18) => {\n      let {\n        name,\n        chunkGroup\n      } = _ref16;\n      let {\n        compilation,\n        compilation: {\n          moduleGraph,\n          chunkGraph\n        }\n      } = _ref17;\n      let {\n        ids,\n        chunkGroupAuxiliary,\n        chunkGroupChildren,\n        chunkGroupMaxAssets\n      } = _ref18;\n      const children = chunkGroupChildren && chunkGroup.getChildrenByOrders(moduleGraph, chunkGraph);\n      /**\n       * @param {string} name Name\n       * @returns {{ name: string, size: number }} Asset object\n       */\n\n      const toAsset = name => {\n        const asset = compilation.getAsset(name);\n        return {\n          name,\n          size: asset ? asset.info.size : -1\n        };\n      };\n      /** @type {(total: number, asset: { size: number }) => number} */\n\n\n      const sizeReducer = (total, _ref19) => {\n        let {\n          size\n        } = _ref19;\n        return total + size;\n      };\n\n      const assets = uniqueArray(chunkGroup.chunks, c => c.files).map(toAsset);\n      const auxiliaryAssets = uniqueOrderedArray(chunkGroup.chunks, c => c.auxiliaryFiles, compareIds).map(toAsset);\n      const assetsSize = assets.reduce(sizeReducer, 0);\n      const auxiliaryAssetsSize = auxiliaryAssets.reduce(sizeReducer, 0);\n      /** @type {KnownStatsChunkGroup} */\n\n      const statsChunkGroup = {\n        name,\n        chunks: ids ? chunkGroup.chunks.map(c => c.id) : undefined,\n        assets: assets.length <= chunkGroupMaxAssets ? assets : undefined,\n        filteredAssets: assets.length <= chunkGroupMaxAssets ? 0 : assets.length,\n        assetsSize,\n        auxiliaryAssets: chunkGroupAuxiliary && auxiliaryAssets.length <= chunkGroupMaxAssets ? auxiliaryAssets : undefined,\n        filteredAuxiliaryAssets: chunkGroupAuxiliary && auxiliaryAssets.length <= chunkGroupMaxAssets ? 0 : auxiliaryAssets.length,\n        auxiliaryAssetsSize,\n        children: children ? mapObject(children, groups => groups.map(group => {\n          const assets = uniqueArray(group.chunks, c => c.files).map(toAsset);\n          const auxiliaryAssets = uniqueOrderedArray(group.chunks, c => c.auxiliaryFiles, compareIds).map(toAsset);\n          /** @type {KnownStatsChunkGroup} */\n\n          const childStatsChunkGroup = {\n            name: group.name,\n            chunks: ids ? group.chunks.map(c => c.id) : undefined,\n            assets: assets.length <= chunkGroupMaxAssets ? assets : undefined,\n            filteredAssets: assets.length <= chunkGroupMaxAssets ? 0 : assets.length,\n            auxiliaryAssets: chunkGroupAuxiliary && auxiliaryAssets.length <= chunkGroupMaxAssets ? auxiliaryAssets : undefined,\n            filteredAuxiliaryAssets: chunkGroupAuxiliary && auxiliaryAssets.length <= chunkGroupMaxAssets ? 0 : auxiliaryAssets.length\n          };\n          return childStatsChunkGroup;\n        })) : undefined,\n        childAssets: children ? mapObject(children, groups => {\n          /** @type {Set<string>} */\n          const set = new Set();\n\n          for (const group of groups) {\n            for (const chunk of group.chunks) {\n              for (const asset of chunk.files) {\n                set.add(asset);\n              }\n            }\n          }\n\n          return Array.from(set);\n        }) : undefined\n      };\n      Object.assign(object, statsChunkGroup);\n    },\n    performance: (object, _ref20) => {\n      let {\n        chunkGroup\n      } = _ref20;\n      object.isOverSizeLimit = SizeLimitsPlugin.isOverSizeLimit(chunkGroup);\n    }\n  },\n  module: {\n    _: (object, module, context, options, factory) => {\n      const {\n        compilation,\n        type\n      } = context;\n      const built = compilation.builtModules.has(module);\n      const codeGenerated = compilation.codeGeneratedModules.has(module);\n      const buildTimeExecuted = compilation.buildTimeExecutedModules.has(module);\n      /** @type {{[x: string]: number}} */\n\n      const sizes = {};\n\n      for (const sourceType of module.getSourceTypes()) {\n        sizes[sourceType] = module.size(sourceType);\n      }\n      /** @type {KnownStatsModule} */\n\n\n      const statsModule = {\n        type: \"module\",\n        moduleType: module.type,\n        layer: module.layer,\n        size: module.size(),\n        sizes,\n        built,\n        codeGenerated,\n        buildTimeExecuted,\n        cached: !built && !codeGenerated\n      };\n      Object.assign(object, statsModule);\n\n      if (built || codeGenerated || options.cachedModules) {\n        Object.assign(object, factory.create(`${type}$visible`, module, context));\n      }\n    }\n  },\n  module$visible: {\n    _: (object, module, context, _ref21, factory) => {\n      let {\n        requestShortener\n      } = _ref21;\n      const {\n        compilation,\n        type,\n        rootModules\n      } = context;\n      const {\n        moduleGraph\n      } = compilation;\n      /** @type {Module[]} */\n\n      const path = [];\n      const issuer = moduleGraph.getIssuer(module);\n      let current = issuer;\n\n      while (current) {\n        path.push(current);\n        current = moduleGraph.getIssuer(current);\n      }\n\n      path.reverse();\n      const profile = moduleGraph.getProfile(module);\n      const errors = module.getErrors();\n      const errorsCount = errors !== undefined ? countIterable(errors) : 0;\n      const warnings = module.getWarnings();\n      const warningsCount = warnings !== undefined ? countIterable(warnings) : 0;\n      /** @type {{[x: string]: number}} */\n\n      const sizes = {};\n\n      for (const sourceType of module.getSourceTypes()) {\n        sizes[sourceType] = module.size(sourceType);\n      }\n      /** @type {KnownStatsModule} */\n\n\n      const statsModule = {\n        identifier: module.identifier(),\n        name: module.readableIdentifier(requestShortener),\n        nameForCondition: module.nameForCondition(),\n        index: moduleGraph.getPreOrderIndex(module),\n        preOrderIndex: moduleGraph.getPreOrderIndex(module),\n        index2: moduleGraph.getPostOrderIndex(module),\n        postOrderIndex: moduleGraph.getPostOrderIndex(module),\n        cacheable: module.buildInfo.cacheable,\n        optional: module.isOptional(moduleGraph),\n        orphan: !type.endsWith(\"module.modules[].module$visible\") && compilation.chunkGraph.getNumberOfModuleChunks(module) === 0,\n        dependent: rootModules ? !rootModules.has(module) : undefined,\n        issuer: issuer && issuer.identifier(),\n        issuerName: issuer && issuer.readableIdentifier(requestShortener),\n        issuerPath: issuer && factory.create(`${type.slice(0, -8)}.issuerPath`, path, context),\n        failed: errorsCount > 0,\n        errors: errorsCount,\n        warnings: warningsCount\n      };\n      Object.assign(object, statsModule);\n\n      if (profile) {\n        object.profile = factory.create(`${type.slice(0, -8)}.profile`, profile, context);\n      }\n    },\n    ids: (object, module, _ref22) => {\n      let {\n        compilation: {\n          chunkGraph,\n          moduleGraph\n        }\n      } = _ref22;\n      object.id = chunkGraph.getModuleId(module);\n      const issuer = moduleGraph.getIssuer(module);\n      object.issuerId = issuer && chunkGraph.getModuleId(issuer);\n      object.chunks = Array.from(chunkGraph.getOrderedModuleChunksIterable(module, compareChunksById), chunk => chunk.id);\n    },\n    moduleAssets: (object, module) => {\n      object.assets = module.buildInfo.assets ? Object.keys(module.buildInfo.assets) : [];\n    },\n    reasons: (object, module, context, options, factory) => {\n      const {\n        type,\n        compilation: {\n          moduleGraph\n        }\n      } = context;\n      const groupsReasons = factory.create(`${type.slice(0, -8)}.reasons`, Array.from(moduleGraph.getIncomingConnections(module)), context);\n      const limited = spaceLimited(groupsReasons, options.reasonsSpace);\n      object.reasons = limited.children;\n      object.filteredReasons = limited.filteredChildren;\n    },\n    usedExports: (object, module, _ref23) => {\n      let {\n        runtime,\n        compilation: {\n          moduleGraph\n        }\n      } = _ref23;\n      const usedExports = moduleGraph.getUsedExports(module, runtime);\n\n      if (usedExports === null) {\n        object.usedExports = null;\n      } else if (typeof usedExports === \"boolean\") {\n        object.usedExports = usedExports;\n      } else {\n        object.usedExports = Array.from(usedExports);\n      }\n    },\n    providedExports: (object, module, _ref24) => {\n      let {\n        compilation: {\n          moduleGraph\n        }\n      } = _ref24;\n      const providedExports = moduleGraph.getProvidedExports(module);\n      object.providedExports = Array.isArray(providedExports) ? providedExports : null;\n    },\n    optimizationBailout: (object, module, _ref25, _ref26) => {\n      let {\n        compilation: {\n          moduleGraph\n        }\n      } = _ref25;\n      let {\n        requestShortener\n      } = _ref26;\n      object.optimizationBailout = moduleGraph.getOptimizationBailout(module).map(item => {\n        if (typeof item === \"function\") return item(requestShortener);\n        return item;\n      });\n    },\n    depth: (object, module, _ref27) => {\n      let {\n        compilation: {\n          moduleGraph\n        }\n      } = _ref27;\n      object.depth = moduleGraph.getDepth(module);\n    },\n    nestedModules: (object, module, context, options, factory) => {\n      const {\n        type\n      } = context;\n      const innerModules =\n      /** @type {Module & { modules?: Module[] }} */\n      module.modules;\n\n      if (Array.isArray(innerModules)) {\n        const groupedModules = factory.create(`${type.slice(0, -8)}.modules`, innerModules, context);\n        const limited = spaceLimited(groupedModules, options.nestedModulesSpace);\n        object.modules = limited.children;\n        object.filteredModules = limited.filteredChildren;\n      }\n    },\n    source: (object, module) => {\n      const originalSource = module.originalSource();\n\n      if (originalSource) {\n        object.source = originalSource.source();\n      }\n    }\n  },\n  profile: {\n    _: (object, profile) => {\n      /** @type {KnownStatsProfile} */\n      const statsProfile = {\n        total: profile.factory + profile.restoring + profile.integration + profile.building + profile.storing,\n        resolving: profile.factory,\n        restoring: profile.restoring,\n        building: profile.building,\n        integration: profile.integration,\n        storing: profile.storing,\n        additionalResolving: profile.additionalFactories,\n        additionalIntegration: profile.additionalIntegration,\n        // TODO remove this in webpack 6\n        factory: profile.factory,\n        // TODO remove this in webpack 6\n        dependencies: profile.additionalFactories\n      };\n      Object.assign(object, statsProfile);\n    }\n  },\n  moduleIssuer: {\n    _: (object, module, context, _ref28, factory) => {\n      let {\n        requestShortener\n      } = _ref28;\n      const {\n        compilation,\n        type\n      } = context;\n      const {\n        moduleGraph\n      } = compilation;\n      const profile = moduleGraph.getProfile(module);\n      /** @type {KnownStatsModuleIssuer} */\n\n      const statsModuleIssuer = {\n        identifier: module.identifier(),\n        name: module.readableIdentifier(requestShortener)\n      };\n      Object.assign(object, statsModuleIssuer);\n\n      if (profile) {\n        object.profile = factory.create(`${type}.profile`, profile, context);\n      }\n    },\n    ids: (object, module, _ref29) => {\n      let {\n        compilation: {\n          chunkGraph\n        }\n      } = _ref29;\n      object.id = chunkGraph.getModuleId(module);\n    }\n  },\n  moduleReason: {\n    _: (object, reason, _ref30, _ref31) => {\n      let {\n        runtime\n      } = _ref30;\n      let {\n        requestShortener\n      } = _ref31;\n      const dep = reason.dependency;\n      const moduleDep = dep && dep instanceof ModuleDependency ? dep : undefined;\n      /** @type {KnownStatsModuleReason} */\n\n      const statsModuleReason = {\n        moduleIdentifier: reason.originModule ? reason.originModule.identifier() : null,\n        module: reason.originModule ? reason.originModule.readableIdentifier(requestShortener) : null,\n        moduleName: reason.originModule ? reason.originModule.readableIdentifier(requestShortener) : null,\n        resolvedModuleIdentifier: reason.resolvedOriginModule ? reason.resolvedOriginModule.identifier() : null,\n        resolvedModule: reason.resolvedOriginModule ? reason.resolvedOriginModule.readableIdentifier(requestShortener) : null,\n        type: reason.dependency ? reason.dependency.type : null,\n        active: reason.isActive(runtime),\n        explanation: reason.explanation,\n        userRequest: moduleDep && moduleDep.userRequest || null\n      };\n      Object.assign(object, statsModuleReason);\n\n      if (reason.dependency) {\n        const locInfo = formatLocation(reason.dependency.loc);\n\n        if (locInfo) {\n          object.loc = locInfo;\n        }\n      }\n    },\n    ids: (object, reason, _ref32) => {\n      let {\n        compilation: {\n          chunkGraph\n        }\n      } = _ref32;\n      object.moduleId = reason.originModule ? chunkGraph.getModuleId(reason.originModule) : null;\n      object.resolvedModuleId = reason.resolvedOriginModule ? chunkGraph.getModuleId(reason.resolvedOriginModule) : null;\n    }\n  },\n  chunk: {\n    _: (object, chunk, _ref33) => {\n      let {\n        makePathsRelative,\n        compilation: {\n          chunkGraph\n        }\n      } = _ref33;\n      const childIdByOrder = chunk.getChildIdsByOrders(chunkGraph);\n      /** @type {KnownStatsChunk} */\n\n      const statsChunk = {\n        rendered: chunk.rendered,\n        initial: chunk.canBeInitial(),\n        entry: chunk.hasRuntime(),\n        recorded: AggressiveSplittingPlugin.wasChunkRecorded(chunk),\n        reason: chunk.chunkReason,\n        size: chunkGraph.getChunkModulesSize(chunk),\n        sizes: chunkGraph.getChunkModulesSizes(chunk),\n        names: chunk.name ? [chunk.name] : [],\n        idHints: Array.from(chunk.idNameHints),\n        runtime: chunk.runtime === undefined ? undefined : typeof chunk.runtime === \"string\" ? [makePathsRelative(chunk.runtime)] : Array.from(chunk.runtime.sort(), makePathsRelative),\n        files: Array.from(chunk.files),\n        auxiliaryFiles: Array.from(chunk.auxiliaryFiles).sort(compareIds),\n        hash: chunk.renderedHash,\n        childrenByOrder: childIdByOrder\n      };\n      Object.assign(object, statsChunk);\n    },\n    ids: (object, chunk) => {\n      object.id = chunk.id;\n    },\n    chunkRelations: (object, chunk, _ref34) => {\n      let {\n        compilation: {\n          chunkGraph\n        }\n      } = _ref34;\n\n      /** @type {Set<string|number>} */\n      const parents = new Set();\n      /** @type {Set<string|number>} */\n\n      const children = new Set();\n      /** @type {Set<string|number>} */\n\n      const siblings = new Set();\n\n      for (const chunkGroup of chunk.groupsIterable) {\n        for (const parentGroup of chunkGroup.parentsIterable) {\n          for (const chunk of parentGroup.chunks) {\n            parents.add(chunk.id);\n          }\n        }\n\n        for (const childGroup of chunkGroup.childrenIterable) {\n          for (const chunk of childGroup.chunks) {\n            children.add(chunk.id);\n          }\n        }\n\n        for (const sibling of chunkGroup.chunks) {\n          if (sibling !== chunk) siblings.add(sibling.id);\n        }\n      }\n\n      object.siblings = Array.from(siblings).sort(compareIds);\n      object.parents = Array.from(parents).sort(compareIds);\n      object.children = Array.from(children).sort(compareIds);\n    },\n    chunkModules: (object, chunk, context, options, factory) => {\n      const {\n        type,\n        compilation: {\n          chunkGraph\n        }\n      } = context;\n      const array = chunkGraph.getChunkModules(chunk);\n      const groupedModules = factory.create(`${type}.modules`, array, { ...context,\n        runtime: chunk.runtime,\n        rootModules: new Set(chunkGraph.getChunkRootModules(chunk))\n      });\n      const limited = spaceLimited(groupedModules, options.chunkModulesSpace);\n      object.modules = limited.children;\n      object.filteredModules = limited.filteredChildren;\n    },\n    chunkOrigins: (object, chunk, context, options, factory) => {\n      const {\n        type,\n        compilation: {\n          chunkGraph\n        }\n      } = context;\n      /** @type {Set<string>} */\n\n      const originsKeySet = new Set();\n      const origins = [];\n\n      for (const g of chunk.groupsIterable) {\n        origins.push(...g.origins);\n      }\n\n      const array = origins.filter(origin => {\n        const key = [origin.module ? chunkGraph.getModuleId(origin.module) : undefined, formatLocation(origin.loc), origin.request].join();\n        if (originsKeySet.has(key)) return false;\n        originsKeySet.add(key);\n        return true;\n      });\n      object.origins = factory.create(`${type}.origins`, array, context);\n    }\n  },\n  chunkOrigin: {\n    _: (object, origin, context, _ref35) => {\n      let {\n        requestShortener\n      } = _ref35;\n\n      /** @type {KnownStatsChunkOrigin} */\n      const statsChunkOrigin = {\n        module: origin.module ? origin.module.identifier() : \"\",\n        moduleIdentifier: origin.module ? origin.module.identifier() : \"\",\n        moduleName: origin.module ? origin.module.readableIdentifier(requestShortener) : \"\",\n        loc: formatLocation(origin.loc),\n        request: origin.request\n      };\n      Object.assign(object, statsChunkOrigin);\n    },\n    ids: (object, origin, _ref36) => {\n      let {\n        compilation: {\n          chunkGraph\n        }\n      } = _ref36;\n      object.moduleId = origin.module ? chunkGraph.getModuleId(origin.module) : undefined;\n    }\n  },\n  error: EXTRACT_ERROR,\n  warning: EXTRACT_ERROR,\n  moduleTraceItem: {\n    _: (object, _ref37, context, _ref38, factory) => {\n      let {\n        origin,\n        module\n      } = _ref37;\n      let {\n        requestShortener\n      } = _ref38;\n      const {\n        type,\n        compilation: {\n          moduleGraph\n        }\n      } = context;\n      object.originIdentifier = origin.identifier();\n      object.originName = origin.readableIdentifier(requestShortener);\n      object.moduleIdentifier = module.identifier();\n      object.moduleName = module.readableIdentifier(requestShortener);\n      const dependencies = Array.from(moduleGraph.getIncomingConnections(module)).filter(c => c.resolvedOriginModule === origin && c.dependency).map(c => c.dependency);\n      object.dependencies = factory.create(`${type}.dependencies`, Array.from(new Set(dependencies)), context);\n    },\n    ids: (object, _ref39, _ref40) => {\n      let {\n        origin,\n        module\n      } = _ref39;\n      let {\n        compilation: {\n          chunkGraph\n        }\n      } = _ref40;\n      object.originId = chunkGraph.getModuleId(origin);\n      object.moduleId = chunkGraph.getModuleId(module);\n    }\n  },\n  moduleTraceDependency: {\n    _: (object, dependency) => {\n      object.loc = formatLocation(dependency.loc);\n    }\n  }\n};\n/** @type {Record<string, Record<string, (thing: any, context: StatsFactoryContext, options: NormalizedStatsOptions) => boolean | undefined>>} */\n\nconst FILTER = {\n  \"module.reasons\": {\n    \"!orphanModules\": (reason, _ref41) => {\n      let {\n        compilation: {\n          chunkGraph\n        }\n      } = _ref41;\n\n      if (reason.originModule && chunkGraph.getNumberOfModuleChunks(reason.originModule) === 0) {\n        return false;\n      }\n    }\n  }\n};\n/** @type {Record<string, Record<string, (thing: Object, context: StatsFactoryContext, options: NormalizedStatsOptions) => boolean | undefined>>} */\n\nconst FILTER_RESULTS = {\n  \"compilation.warnings\": {\n    warningsFilter: util.deprecate((warning, context, _ref42) => {\n      let {\n        warningsFilter\n      } = _ref42;\n      const warningString = Object.keys(warning).map(key => `${warning[key]}`).join(\"\\n\");\n      return !warningsFilter.some(filter => filter(warning, warningString));\n    }, \"config.stats.warningsFilter is deprecated in favor of config.ignoreWarnings\", \"DEP_WEBPACK_STATS_WARNINGS_FILTER\")\n  }\n};\n/** @type {Record<string, (comparators: Function[], context: StatsFactoryContext) => void>} */\n\nconst MODULES_SORTER = {\n  _: (comparators, _ref43) => {\n    let {\n      compilation: {\n        moduleGraph\n      }\n    } = _ref43;\n    comparators.push(compareSelect(\n    /**\n     * @param {Module} m module\n     * @returns {number} depth\n     */\n    m => moduleGraph.getDepth(m), compareNumbers), compareSelect(\n    /**\n     * @param {Module} m module\n     * @returns {number} index\n     */\n    m => moduleGraph.getPreOrderIndex(m), compareNumbers), compareSelect(\n    /**\n     * @param {Module} m module\n     * @returns {string} identifier\n     */\n    m => m.identifier(), compareIds));\n  }\n};\n/** @type {Record<string, Record<string, (comparators: Function[], context: StatsFactoryContext) => void>>} */\n\nconst SORTERS = {\n  \"compilation.chunks\": {\n    _: comparators => {\n      comparators.push(compareSelect(c => c.id, compareIds));\n    }\n  },\n  \"compilation.modules\": MODULES_SORTER,\n  \"chunk.rootModules\": MODULES_SORTER,\n  \"chunk.modules\": MODULES_SORTER,\n  \"module.modules\": MODULES_SORTER,\n  \"module.reasons\": {\n    _: (comparators, _ref44) => {\n      let {\n        compilation: {\n          chunkGraph\n        }\n      } = _ref44;\n      comparators.push(compareSelect(x => x.originModule, compareModulesByIdentifier));\n      comparators.push(compareSelect(x => x.resolvedOriginModule, compareModulesByIdentifier));\n      comparators.push(compareSelect(x => x.dependency, concatComparators(compareSelect(\n      /**\n       * @param {Dependency} x dependency\n       * @returns {DependencyLocation} location\n       */\n      x => x.loc, compareLocations), compareSelect(x => x.type, compareIds))));\n    }\n  },\n  \"chunk.origins\": {\n    _: (comparators, _ref45) => {\n      let {\n        compilation: {\n          chunkGraph\n        }\n      } = _ref45;\n      comparators.push(compareSelect(origin => origin.module ? chunkGraph.getModuleId(origin.module) : undefined, compareIds), compareSelect(origin => formatLocation(origin.loc), compareIds), compareSelect(origin => origin.request, compareIds));\n    }\n  }\n};\n\nconst getItemSize = item => {\n  // Each item takes 1 line\n  // + the size of the children\n  // + 1 extra line when it has children and filteredChildren\n  return !item.children ? 1 : item.filteredChildren ? 2 + getTotalSize(item.children) : 1 + getTotalSize(item.children);\n};\n\nconst getTotalSize = children => {\n  let size = 0;\n\n  for (const child of children) {\n    size += getItemSize(child);\n  }\n\n  return size;\n};\n\nconst getTotalItems = children => {\n  let count = 0;\n\n  for (const child of children) {\n    if (!child.children && !child.filteredChildren) {\n      count++;\n    } else {\n      if (child.children) count += getTotalItems(child.children);\n      if (child.filteredChildren) count += child.filteredChildren;\n    }\n  }\n\n  return count;\n};\n\nconst collapse = children => {\n  // After collapse each child must take exactly one line\n  const newChildren = [];\n\n  for (const child of children) {\n    if (child.children) {\n      let filteredChildren = child.filteredChildren || 0;\n      filteredChildren += getTotalItems(child.children);\n      newChildren.push({ ...child,\n        children: undefined,\n        filteredChildren\n      });\n    } else {\n      newChildren.push(child);\n    }\n  }\n\n  return newChildren;\n};\n\nconst spaceLimited = function (itemsAndGroups, max) {\n  let filteredChildrenLineReserved = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (max < 1) {\n    return {\n      children: undefined,\n      filteredChildren: getTotalItems(itemsAndGroups)\n    };\n  }\n  /** @type {any[] | undefined} */\n\n\n  let children = undefined;\n  /** @type {number | undefined} */\n\n  let filteredChildren = undefined; // This are the groups, which take 1+ lines each\n\n  const groups = []; // The sizes of the groups are stored in groupSizes\n\n  const groupSizes = []; // This are the items, which take 1 line each\n\n  const items = []; // The total of group sizes\n\n  let groupsSize = 0;\n\n  for (const itemOrGroup of itemsAndGroups) {\n    // is item\n    if (!itemOrGroup.children && !itemOrGroup.filteredChildren) {\n      items.push(itemOrGroup);\n    } else {\n      groups.push(itemOrGroup);\n      const size = getItemSize(itemOrGroup);\n      groupSizes.push(size);\n      groupsSize += size;\n    }\n  }\n\n  if (groupsSize + items.length <= max) {\n    // The total size in the current state fits into the max\n    // keep all\n    children = groups.length > 0 ? groups.concat(items) : items;\n  } else if (groups.length === 0) {\n    // slice items to max\n    // inner space marks that lines for filteredChildren already reserved\n    const limit = max - (filteredChildrenLineReserved ? 0 : 1);\n    filteredChildren = items.length - limit;\n    items.length = limit;\n    children = items;\n  } else {\n    // limit is the size when all groups are collapsed\n    const limit = groups.length + (filteredChildrenLineReserved || items.length === 0 ? 0 : 1);\n\n    if (limit < max) {\n      // calculate how much we are over the size limit\n      // this allows to approach the limit faster\n      let oversize; // If each group would take 1 line the total would be below the maximum\n      // collapse some groups, keep items\n\n      while ((oversize = groupsSize + items.length + (filteredChildren && !filteredChildrenLineReserved ? 1 : 0) - max) > 0) {\n        // Find the maximum group and process only this one\n        const maxGroupSize = Math.max(...groupSizes);\n\n        if (maxGroupSize < items.length) {\n          filteredChildren = items.length;\n          items.length = 0;\n          continue;\n        }\n\n        for (let i = 0; i < groups.length; i++) {\n          if (groupSizes[i] === maxGroupSize) {\n            const group = groups[i]; // run this algorithm recursively and limit the size of the children to\n            // current size - oversize / number of groups\n            // So it should always end up being smaller\n\n            const headerSize = group.filteredChildren ? 2 : 1;\n            const limited = spaceLimited(group.children, maxGroupSize - // we should use ceil to always feet in max\n            Math.ceil(oversize / groups.length) - // we substitute size of group head\n            headerSize, headerSize === 2);\n            groups[i] = { ...group,\n              children: limited.children,\n              filteredChildren: limited.filteredChildren ? (group.filteredChildren || 0) + limited.filteredChildren : group.filteredChildren\n            };\n            const newSize = getItemSize(groups[i]);\n            groupsSize -= maxGroupSize - newSize;\n            groupSizes[i] = newSize;\n            break;\n          }\n        }\n      }\n\n      children = groups.concat(items);\n    } else if (limit === max) {\n      // If we have only enough space to show one line per group and one line for the filtered items\n      // collapse all groups and items\n      children = collapse(groups);\n      filteredChildren = items.length;\n    } else {\n      // If we have no space\n      // collapse complete group\n      filteredChildren = getTotalItems(itemsAndGroups);\n    }\n  }\n\n  return {\n    children,\n    filteredChildren\n  };\n};\n\nconst assetGroup = (children, assets) => {\n  let size = 0;\n\n  for (const asset of children) {\n    size += asset.size;\n  }\n\n  return {\n    size\n  };\n};\n\nconst moduleGroup = (children, modules) => {\n  let size = 0;\n  const sizes = {};\n\n  for (const module of children) {\n    size += module.size;\n\n    for (const key of Object.keys(module.sizes)) {\n      sizes[key] = (sizes[key] || 0) + module.sizes[key];\n    }\n  }\n\n  return {\n    size,\n    sizes\n  };\n};\n\nconst reasonGroup = (children, reasons) => {\n  let active = false;\n\n  for (const reason of children) {\n    active = active || reason.active;\n  }\n\n  return {\n    active\n  };\n};\n\nconst GROUP_EXTENSION_REGEXP = /(\\.[^.]+?)(?:\\?|(?: \\+ \\d+ modules?)?$)/;\nconst GROUP_PATH_REGEXP = /(.+)[/\\\\][^/\\\\]+?(?:\\?|(?: \\+ \\d+ modules?)?$)/;\n/** @type {Record<string, (groupConfigs: GroupConfig[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>} */\n\nconst ASSETS_GROUPERS = {\n  _: (groupConfigs, context, options) => {\n    const groupByFlag = (name, exclude) => {\n      groupConfigs.push({\n        getKeys: asset => {\n          return asset[name] ? [\"1\"] : undefined;\n        },\n        getOptions: () => {\n          return {\n            groupChildren: !exclude,\n            force: exclude\n          };\n        },\n        createGroup: (key, children, assets) => {\n          return exclude ? {\n            type: \"assets by status\",\n            [name]: !!key,\n            filteredChildren: assets.length,\n            ...assetGroup(children, assets)\n          } : {\n            type: \"assets by status\",\n            [name]: !!key,\n            children,\n            ...assetGroup(children, assets)\n          };\n        }\n      });\n    };\n\n    const {\n      groupAssetsByEmitStatus,\n      groupAssetsByPath,\n      groupAssetsByExtension\n    } = options;\n\n    if (groupAssetsByEmitStatus) {\n      groupByFlag(\"emitted\");\n      groupByFlag(\"comparedForEmit\");\n      groupByFlag(\"isOverSizeLimit\");\n    }\n\n    if (groupAssetsByEmitStatus || !options.cachedAssets) {\n      groupByFlag(\"cached\", !options.cachedAssets);\n    }\n\n    if (groupAssetsByPath || groupAssetsByExtension) {\n      groupConfigs.push({\n        getKeys: asset => {\n          const extensionMatch = groupAssetsByExtension && GROUP_EXTENSION_REGEXP.exec(asset.name);\n          const extension = extensionMatch ? extensionMatch[1] : \"\";\n          const pathMatch = groupAssetsByPath && GROUP_PATH_REGEXP.exec(asset.name);\n          const path = pathMatch ? pathMatch[1].split(/[/\\\\]/) : [];\n          const keys = [];\n\n          if (groupAssetsByPath) {\n            keys.push(\".\");\n            if (extension) keys.push(path.length ? `${path.join(\"/\")}/*${extension}` : `*${extension}`);\n\n            while (path.length > 0) {\n              keys.push(path.join(\"/\") + \"/\");\n              path.pop();\n            }\n          } else {\n            if (extension) keys.push(`*${extension}`);\n          }\n\n          return keys;\n        },\n        createGroup: (key, children, assets) => {\n          return {\n            type: groupAssetsByPath ? \"assets by path\" : \"assets by extension\",\n            name: key,\n            children,\n            ...assetGroup(children, assets)\n          };\n        }\n      });\n    }\n  },\n  groupAssetsByInfo: (groupConfigs, context, options) => {\n    const groupByAssetInfoFlag = name => {\n      groupConfigs.push({\n        getKeys: asset => {\n          return asset.info && asset.info[name] ? [\"1\"] : undefined;\n        },\n        createGroup: (key, children, assets) => {\n          return {\n            type: \"assets by info\",\n            info: {\n              [name]: !!key\n            },\n            children,\n            ...assetGroup(children, assets)\n          };\n        }\n      });\n    };\n\n    groupByAssetInfoFlag(\"immutable\");\n    groupByAssetInfoFlag(\"development\");\n    groupByAssetInfoFlag(\"hotModuleReplacement\");\n  },\n  groupAssetsByChunk: (groupConfigs, context, options) => {\n    const groupByNames = name => {\n      groupConfigs.push({\n        getKeys: asset => {\n          return asset[name];\n        },\n        createGroup: (key, children, assets) => {\n          return {\n            type: \"assets by chunk\",\n            [name]: [key],\n            children,\n            ...assetGroup(children, assets)\n          };\n        }\n      });\n    };\n\n    groupByNames(\"chunkNames\");\n    groupByNames(\"auxiliaryChunkNames\");\n    groupByNames(\"chunkIdHints\");\n    groupByNames(\"auxiliaryChunkIdHints\");\n  },\n  excludeAssets: (groupConfigs, context, _ref46) => {\n    let {\n      excludeAssets\n    } = _ref46;\n    groupConfigs.push({\n      getKeys: asset => {\n        const ident = asset.name;\n        const excluded = excludeAssets.some(fn => fn(ident, asset));\n        if (excluded) return [\"excluded\"];\n      },\n      getOptions: () => ({\n        groupChildren: false,\n        force: true\n      }),\n      createGroup: (key, children, assets) => ({\n        type: \"hidden assets\",\n        filteredChildren: assets.length,\n        ...assetGroup(children, assets)\n      })\n    });\n  }\n};\n/** @type {function(\"module\" | \"chunk\" | \"root-of-chunk\" | \"nested\"): Record<string, (groupConfigs: GroupConfig[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>} */\n\nconst MODULES_GROUPERS = type => ({\n  _: (groupConfigs, context, options) => {\n    const groupByFlag = (name, type, exclude) => {\n      groupConfigs.push({\n        getKeys: module => {\n          return module[name] ? [\"1\"] : undefined;\n        },\n        getOptions: () => {\n          return {\n            groupChildren: !exclude,\n            force: exclude\n          };\n        },\n        createGroup: (key, children, modules) => {\n          return {\n            type,\n            [name]: !!key,\n            ...(exclude ? {\n              filteredChildren: modules.length\n            } : {\n              children\n            }),\n            ...moduleGroup(children, modules)\n          };\n        }\n      });\n    };\n\n    const {\n      groupModulesByCacheStatus,\n      groupModulesByLayer,\n      groupModulesByAttributes,\n      groupModulesByType,\n      groupModulesByPath,\n      groupModulesByExtension\n    } = options;\n\n    if (groupModulesByAttributes) {\n      groupByFlag(\"errors\", \"modules with errors\");\n      groupByFlag(\"warnings\", \"modules with warnings\");\n      groupByFlag(\"assets\", \"modules with assets\");\n      groupByFlag(\"optional\", \"optional modules\");\n    }\n\n    if (groupModulesByCacheStatus) {\n      groupByFlag(\"cacheable\", \"cacheable modules\");\n      groupByFlag(\"built\", \"built modules\");\n      groupByFlag(\"codeGenerated\", \"code generated modules\");\n    }\n\n    if (groupModulesByCacheStatus || !options.cachedModules) {\n      groupByFlag(\"cached\", \"cached modules\", !options.cachedModules);\n    }\n\n    if (groupModulesByAttributes || !options.orphanModules) {\n      groupByFlag(\"orphan\", \"orphan modules\", !options.orphanModules);\n    }\n\n    if (groupModulesByAttributes || !options.dependentModules) {\n      groupByFlag(\"dependent\", \"dependent modules\", !options.dependentModules);\n    }\n\n    if (groupModulesByType || !options.runtimeModules) {\n      groupConfigs.push({\n        getKeys: module => {\n          if (!module.moduleType) return;\n\n          if (groupModulesByType) {\n            return [module.moduleType.split(\"/\", 1)[0]];\n          } else if (module.moduleType === \"runtime\") {\n            return [\"runtime\"];\n          }\n        },\n        getOptions: key => {\n          const exclude = key === \"runtime\" && !options.runtimeModules;\n          return {\n            groupChildren: !exclude,\n            force: exclude\n          };\n        },\n        createGroup: (key, children, modules) => {\n          const exclude = key === \"runtime\" && !options.runtimeModules;\n          return {\n            type: `${key} modules`,\n            moduleType: key,\n            ...(exclude ? {\n              filteredChildren: modules.length\n            } : {\n              children\n            }),\n            ...moduleGroup(children, modules)\n          };\n        }\n      });\n    }\n\n    if (groupModulesByLayer) {\n      groupConfigs.push({\n        getKeys: module => {\n          return [module.layer];\n        },\n        createGroup: (key, children, modules) => {\n          return {\n            type: \"modules by layer\",\n            layer: key,\n            children,\n            ...moduleGroup(children, modules)\n          };\n        }\n      });\n    }\n\n    if (groupModulesByPath || groupModulesByExtension) {\n      groupConfigs.push({\n        getKeys: module => {\n          if (!module.name) return;\n          const resource = parseResource(module.name.split(\"!\").pop()).path;\n          const dataUrl = /^data:[^,;]+/.exec(resource);\n          if (dataUrl) return [dataUrl[0]];\n          const extensionMatch = groupModulesByExtension && GROUP_EXTENSION_REGEXP.exec(resource);\n          const extension = extensionMatch ? extensionMatch[1] : \"\";\n          const pathMatch = groupModulesByPath && GROUP_PATH_REGEXP.exec(resource);\n          const path = pathMatch ? pathMatch[1].split(/[/\\\\]/) : [];\n          const keys = [];\n\n          if (groupModulesByPath) {\n            if (extension) keys.push(path.length ? `${path.join(\"/\")}/*${extension}` : `*${extension}`);\n\n            while (path.length > 0) {\n              keys.push(path.join(\"/\") + \"/\");\n              path.pop();\n            }\n          } else {\n            if (extension) keys.push(`*${extension}`);\n          }\n\n          return keys;\n        },\n        createGroup: (key, children, modules) => {\n          const isDataUrl = key.startsWith(\"data:\");\n          return {\n            type: isDataUrl ? \"modules by mime type\" : groupModulesByPath ? \"modules by path\" : \"modules by extension\",\n            name: isDataUrl ? key.slice(\n            /* 'data:'.length */\n            5) : key,\n            children,\n            ...moduleGroup(children, modules)\n          };\n        }\n      });\n    }\n  },\n  excludeModules: (groupConfigs, context, _ref47) => {\n    let {\n      excludeModules\n    } = _ref47;\n    groupConfigs.push({\n      getKeys: module => {\n        const name = module.name;\n\n        if (name) {\n          const excluded = excludeModules.some(fn => fn(name, module, type));\n          if (excluded) return [\"1\"];\n        }\n      },\n      getOptions: () => ({\n        groupChildren: false,\n        force: true\n      }),\n      createGroup: (key, children, modules) => ({\n        type: \"hidden modules\",\n        filteredChildren: children.length,\n        ...moduleGroup(children, modules)\n      })\n    });\n  }\n});\n/** @type {Record<string, Record<string, (groupConfigs: GroupConfig[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>>} */\n\n\nconst RESULT_GROUPERS = {\n  \"compilation.assets\": ASSETS_GROUPERS,\n  \"asset.related\": ASSETS_GROUPERS,\n  \"compilation.modules\": MODULES_GROUPERS(\"module\"),\n  \"chunk.modules\": MODULES_GROUPERS(\"chunk\"),\n  \"chunk.rootModules\": MODULES_GROUPERS(\"root-of-chunk\"),\n  \"module.modules\": MODULES_GROUPERS(\"nested\"),\n  \"module.reasons\": {\n    groupReasonsByOrigin: groupConfigs => {\n      groupConfigs.push({\n        getKeys: reason => {\n          return [reason.module];\n        },\n        createGroup: (key, children, reasons) => {\n          return {\n            type: \"from origin\",\n            module: key,\n            children,\n            ...reasonGroup(children, reasons)\n          };\n        }\n      });\n    }\n  }\n}; // remove a prefixed \"!\" that can be specified to reverse sort order\n\nconst normalizeFieldKey = field => {\n  if (field[0] === \"!\") {\n    return field.substr(1);\n  }\n\n  return field;\n}; // if a field is prefixed by a \"!\" reverse sort order\n\n\nconst sortOrderRegular = field => {\n  if (field[0] === \"!\") {\n    return false;\n  }\n\n  return true;\n};\n/**\n * @param {string} field field name\n * @returns {function(Object, Object): number} comparators\n */\n\n\nconst sortByField = field => {\n  if (!field) {\n    /**\n     * @param {any} a first\n     * @param {any} b second\n     * @returns {-1|0|1} zero\n     */\n    const noSort = (a, b) => 0;\n\n    return noSort;\n  }\n\n  const fieldKey = normalizeFieldKey(field);\n  let sortFn = compareSelect(m => m[fieldKey], compareIds); // if a field is prefixed with a \"!\" the sort is reversed!\n\n  const sortIsRegular = sortOrderRegular(field);\n\n  if (!sortIsRegular) {\n    const oldSortFn = sortFn;\n\n    sortFn = (a, b) => oldSortFn(b, a);\n  }\n\n  return sortFn;\n};\n\nconst ASSET_SORTERS = {\n  /** @type {(comparators: Function[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void} */\n  assetsSort: (comparators, context, _ref48) => {\n    let {\n      assetsSort\n    } = _ref48;\n    comparators.push(sortByField(assetsSort));\n  },\n  _: comparators => {\n    comparators.push(compareSelect(a => a.name, compareIds));\n  }\n};\n/** @type {Record<string, Record<string, (comparators: Function[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>>} */\n\nconst RESULT_SORTERS = {\n  \"compilation.chunks\": {\n    chunksSort: (comparators, context, _ref49) => {\n      let {\n        chunksSort\n      } = _ref49;\n      comparators.push(sortByField(chunksSort));\n    }\n  },\n  \"compilation.modules\": {\n    modulesSort: (comparators, context, _ref50) => {\n      let {\n        modulesSort\n      } = _ref50;\n      comparators.push(sortByField(modulesSort));\n    }\n  },\n  \"chunk.modules\": {\n    chunkModulesSort: (comparators, context, _ref51) => {\n      let {\n        chunkModulesSort\n      } = _ref51;\n      comparators.push(sortByField(chunkModulesSort));\n    }\n  },\n  \"module.modules\": {\n    nestedModulesSort: (comparators, context, _ref52) => {\n      let {\n        nestedModulesSort\n      } = _ref52;\n      comparators.push(sortByField(nestedModulesSort));\n    }\n  },\n  \"compilation.assets\": ASSET_SORTERS,\n  \"asset.related\": ASSET_SORTERS\n};\n/**\n * @param {Record<string, Record<string, Function>>} config the config see above\n * @param {NormalizedStatsOptions} options stats options\n * @param {function(string, Function): void} fn handler function called for every active line in config\n * @returns {void}\n */\n\nconst iterateConfig = (config, options, fn) => {\n  for (const hookFor of Object.keys(config)) {\n    const subConfig = config[hookFor];\n\n    for (const option of Object.keys(subConfig)) {\n      if (option !== \"_\") {\n        if (option.startsWith(\"!\")) {\n          if (options[option.slice(1)]) continue;\n        } else {\n          const value = options[option];\n          if (value === false || value === undefined || Array.isArray(value) && value.length === 0) continue;\n        }\n      }\n\n      fn(hookFor, subConfig[option]);\n    }\n  }\n};\n/** @type {Record<string, string>} */\n\n\nconst ITEM_NAMES = {\n  \"compilation.children[]\": \"compilation\",\n  \"compilation.modules[]\": \"module\",\n  \"compilation.entrypoints[]\": \"chunkGroup\",\n  \"compilation.namedChunkGroups[]\": \"chunkGroup\",\n  \"compilation.errors[]\": \"error\",\n  \"compilation.warnings[]\": \"warning\",\n  \"chunk.modules[]\": \"module\",\n  \"chunk.rootModules[]\": \"module\",\n  \"chunk.origins[]\": \"chunkOrigin\",\n  \"compilation.chunks[]\": \"chunk\",\n  \"compilation.assets[]\": \"asset\",\n  \"asset.related[]\": \"asset\",\n  \"module.issuerPath[]\": \"moduleIssuer\",\n  \"module.reasons[]\": \"moduleReason\",\n  \"module.modules[]\": \"module\",\n  \"module.children[]\": \"module\",\n  \"moduleTrace[]\": \"moduleTraceItem\",\n  \"moduleTraceItem.dependencies[]\": \"moduleTraceDependency\"\n};\n/**\n * @param {Object[]} items items to be merged\n * @returns {Object} an object\n */\n\nconst mergeToObject = items => {\n  const obj = Object.create(null);\n\n  for (const item of items) {\n    obj[item.name] = item;\n  }\n\n  return obj;\n};\n/** @type {Record<string, (items: Object[]) => any>} */\n\n\nconst MERGER = {\n  \"compilation.entrypoints\": mergeToObject,\n  \"compilation.namedChunkGroups\": mergeToObject\n};\n\nclass DefaultStatsFactoryPlugin {\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"DefaultStatsFactoryPlugin\", compilation => {\n      compilation.hooks.statsFactory.tap(\"DefaultStatsFactoryPlugin\", (stats, options, context) => {\n        iterateConfig(SIMPLE_EXTRACTORS, options, (hookFor, fn) => {\n          stats.hooks.extract.for(hookFor).tap(\"DefaultStatsFactoryPlugin\", (obj, data, ctx) => fn(obj, data, ctx, options, stats));\n        });\n        iterateConfig(FILTER, options, (hookFor, fn) => {\n          stats.hooks.filter.for(hookFor).tap(\"DefaultStatsFactoryPlugin\", (item, ctx, idx, i) => fn(item, ctx, options, idx, i));\n        });\n        iterateConfig(FILTER_RESULTS, options, (hookFor, fn) => {\n          stats.hooks.filterResults.for(hookFor).tap(\"DefaultStatsFactoryPlugin\", (item, ctx, idx, i) => fn(item, ctx, options, idx, i));\n        });\n        iterateConfig(SORTERS, options, (hookFor, fn) => {\n          stats.hooks.sort.for(hookFor).tap(\"DefaultStatsFactoryPlugin\", (comparators, ctx) => fn(comparators, ctx, options));\n        });\n        iterateConfig(RESULT_SORTERS, options, (hookFor, fn) => {\n          stats.hooks.sortResults.for(hookFor).tap(\"DefaultStatsFactoryPlugin\", (comparators, ctx) => fn(comparators, ctx, options));\n        });\n        iterateConfig(RESULT_GROUPERS, options, (hookFor, fn) => {\n          stats.hooks.groupResults.for(hookFor).tap(\"DefaultStatsFactoryPlugin\", (groupConfigs, ctx) => fn(groupConfigs, ctx, options));\n        });\n\n        for (const key of Object.keys(ITEM_NAMES)) {\n          const itemName = ITEM_NAMES[key];\n          stats.hooks.getItemName.for(key).tap(\"DefaultStatsFactoryPlugin\", () => itemName);\n        }\n\n        for (const key of Object.keys(MERGER)) {\n          const merger = MERGER[key];\n          stats.hooks.merge.for(key).tap(\"DefaultStatsFactoryPlugin\", merger);\n        }\n\n        if (options.children) {\n          if (Array.isArray(options.children)) {\n            stats.hooks.getItemFactory.for(\"compilation.children[].compilation\").tap(\"DefaultStatsFactoryPlugin\", (comp, _ref53) => {\n              let {\n                _index: idx\n              } = _ref53;\n\n              if (idx < options.children.length) {\n                return compilation.createStatsFactory(compilation.createStatsOptions(options.children[idx], context));\n              }\n            });\n          } else if (options.children !== true) {\n            const childFactory = compilation.createStatsFactory(compilation.createStatsOptions(options.children, context));\n            stats.hooks.getItemFactory.for(\"compilation.children[].compilation\").tap(\"DefaultStatsFactoryPlugin\", () => {\n              return childFactory;\n            });\n          }\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = DefaultStatsFactoryPlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/stats/DefaultStatsFactoryPlugin.js"],"names":["util","require","ModuleDependency","formatLocation","LogType","AggressiveSplittingPlugin","SizeLimitsPlugin","countIterable","compareLocations","compareChunksById","compareNumbers","compareIds","concatComparators","compareSelect","compareModulesByIdentifier","makePathsRelative","parseResource","uniqueArray","items","selector","set","Set","item","i","add","Array","from","uniqueOrderedArray","comparator","sort","mapObject","obj","fn","newObj","Object","create","key","keys","countWithChildren","compilation","getItems","count","length","child","children","c","type","EXTRACT_ERROR","_","object","error","context","requestShortener","message","chunk","chunkName","name","chunkEntry","hasRuntime","chunkInitial","canBeInitial","file","module","moduleIdentifier","identifier","moduleName","readableIdentifier","loc","ids","chunkGraph","chunkId","id","moduleId","getModuleId","moduleTrace","options","factory","moduleGraph","visitedModules","current","has","origin","getIssuer","push","errorDetails","cachedGetErrors","cachedGetWarnings","endsWith","details","errorStack","stack","SIMPLE_EXTRACTORS","bindContextCache","compiler","root","map","WeakMap","get","errors","getErrors","warnings","getWarnings","needAdditionalPass","logging","loggingDebug","loggingTrace","acceptedTypes","collapsedGroups","warn","info","log","group","groupEnd","groupCollapsed","clear","profile","profileEnd","time","status","cachedMakePathsRelative","depthInCollapsedGroup","logEntries","debugMode","some","groupStack","rootList","currentList","processedLogEntries","entry","pop","undefined","args","format","slice","newEntry","trace","replace","entries","filteredEntries","debug","hash","version","env","_env","timings","endTime","startTime","builtAt","publicPath","getPath","outputOptions","outputPath","path","assets","compilationFileToChunks","Map","compilationAuxiliaryFileToChunks","chunks","files","array","auxiliaryFiles","assetMap","asset","getAssets","related","values","relatedEntry","deps","isArray","dep","depItem","delete","assetsByChunkName","prototype","hasOwnProperty","call","groupedAssets","limited","spaceLimited","assetsSpace","filteredAssets","filteredChildren","modules","groupedModules","modulesSpace","filteredModules","entrypoints","chunkGroups","chunkGroupAuxiliary","chunkGroupChildren","value","chunkGroup","every","size","namedChunkGroups","errorsCount","warningsCount","warningsFilter","childType","filter","warning","warningString","join","filteredWarningDetailsCount","e","Boolean","filteredErrorDetailsCount","source","emitted","emittedAssets","comparedForEmit","comparedForEmitAssets","cached","cachedAssets","assign","asset$visible","auxiliaryChunks","chunkNames","chunkIdHints","idNameHints","auxiliaryChunkNames","auxiliaryChunkIdHints","filteredRelated","relatedAssets","performance","isOverSizeLimit","chunkGroupMaxAssets","getChildrenByOrders","toAsset","getAsset","sizeReducer","total","auxiliaryAssets","assetsSize","reduce","auxiliaryAssetsSize","statsChunkGroup","filteredAuxiliaryAssets","groups","childStatsChunkGroup","childAssets","built","builtModules","codeGenerated","codeGeneratedModules","buildTimeExecuted","buildTimeExecutedModules","sizes","sourceType","getSourceTypes","statsModule","moduleType","layer","cachedModules","module$visible","rootModules","issuer","reverse","getProfile","nameForCondition","index","getPreOrderIndex","preOrderIndex","index2","getPostOrderIndex","postOrderIndex","cacheable","buildInfo","optional","isOptional","orphan","getNumberOfModuleChunks","dependent","issuerName","issuerPath","failed","issuerId","getOrderedModuleChunksIterable","moduleAssets","reasons","groupsReasons","getIncomingConnections","reasonsSpace","filteredReasons","usedExports","runtime","getUsedExports","providedExports","getProvidedExports","optimizationBailout","getOptimizationBailout","depth","getDepth","nestedModules","innerModules","nestedModulesSpace","originalSource","statsProfile","restoring","integration","building","storing","resolving","additionalResolving","additionalFactories","additionalIntegration","dependencies","moduleIssuer","statsModuleIssuer","moduleReason","reason","dependency","moduleDep","statsModuleReason","originModule","resolvedModuleIdentifier","resolvedOriginModule","resolvedModule","active","isActive","explanation","userRequest","locInfo","resolvedModuleId","childIdByOrder","getChildIdsByOrders","statsChunk","rendered","initial","recorded","wasChunkRecorded","chunkReason","getChunkModulesSize","getChunkModulesSizes","names","idHints","renderedHash","childrenByOrder","chunkRelations","parents","siblings","groupsIterable","parentGroup","parentsIterable","childGroup","childrenIterable","sibling","chunkModules","getChunkModules","getChunkRootModules","chunkModulesSpace","chunkOrigins","originsKeySet","origins","g","request","chunkOrigin","statsChunkOrigin","moduleTraceItem","originIdentifier","originName","originId","moduleTraceDependency","FILTER","FILTER_RESULTS","deprecate","MODULES_SORTER","comparators","m","SORTERS","x","getItemSize","getTotalSize","getTotalItems","collapse","newChildren","itemsAndGroups","max","filteredChildrenLineReserved","groupSizes","groupsSize","itemOrGroup","concat","limit","oversize","maxGroupSize","Math","headerSize","ceil","newSize","assetGroup","moduleGroup","reasonGroup","GROUP_EXTENSION_REGEXP","GROUP_PATH_REGEXP","ASSETS_GROUPERS","groupConfigs","groupByFlag","exclude","getKeys","getOptions","groupChildren","force","createGroup","groupAssetsByEmitStatus","groupAssetsByPath","groupAssetsByExtension","extensionMatch","exec","extension","pathMatch","split","groupAssetsByInfo","groupByAssetInfoFlag","groupAssetsByChunk","groupByNames","excludeAssets","ident","excluded","MODULES_GROUPERS","groupModulesByCacheStatus","groupModulesByLayer","groupModulesByAttributes","groupModulesByType","groupModulesByPath","groupModulesByExtension","orphanModules","dependentModules","runtimeModules","resource","dataUrl","isDataUrl","startsWith","excludeModules","RESULT_GROUPERS","groupReasonsByOrigin","normalizeFieldKey","field","substr","sortOrderRegular","sortByField","noSort","a","b","fieldKey","sortFn","sortIsRegular","oldSortFn","ASSET_SORTERS","assetsSort","RESULT_SORTERS","chunksSort","modulesSort","chunkModulesSort","nestedModulesSort","iterateConfig","config","hookFor","subConfig","option","ITEM_NAMES","mergeToObject","MERGER","DefaultStatsFactoryPlugin","apply","hooks","tap","statsFactory","stats","extract","for","data","ctx","idx","filterResults","sortResults","groupResults","itemName","getItemName","merger","merge","getItemFactory","comp","_index","createStatsFactory","createStatsOptions","childFactory","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMC,gBAAgB,GAAGD,OAAO,CAAC,kCAAD,CAAhC;;AACA,MAAME,cAAc,GAAGF,OAAO,CAAC,mBAAD,CAA9B;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAcH,OAAO,CAAC,mBAAD,CAA3B;;AACA,MAAMI,yBAAyB,GAAGJ,OAAO,CAAC,uCAAD,CAAzC;;AACA,MAAMK,gBAAgB,GAAGL,OAAO,CAAC,iCAAD,CAAhC;;AACA,MAAM;AAAEM,EAAAA;AAAF,IAAoBN,OAAO,CAAC,yBAAD,CAAjC;;AACA,MAAM;AACLO,EAAAA,gBADK;AAELC,EAAAA,iBAFK;AAGLC,EAAAA,cAHK;AAILC,EAAAA,UAJK;AAKLC,EAAAA,iBALK;AAMLC,EAAAA,aANK;AAOLC,EAAAA;AAPK,IAQFb,OAAO,CAAC,qBAAD,CARX;;AASA,MAAM;AAAEc,EAAAA,iBAAF;AAAqBC,EAAAA;AAArB,IAAuCf,OAAO,CAAC,oBAAD,CAApD;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMgB,WAAW,GAAG,CAACC,KAAD,EAAQC,QAAR,KAAqB;AACxC;AACA,QAAMC,GAAG,GAAG,IAAIC,GAAJ,EAAZ;;AACA,OAAK,MAAMC,IAAX,IAAmBJ,KAAnB,EAA0B;AACzB,SAAK,MAAMK,CAAX,IAAgBJ,QAAQ,CAACG,IAAD,CAAxB,EAAgC;AAC/BF,MAAAA,GAAG,CAACI,GAAJ,CAAQD,CAAR;AACA;AACD;;AACD,SAAOE,KAAK,CAACC,IAAN,CAAWN,GAAX,CAAP;AACA,CATD;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst util = require(\"util\");\nconst ModuleDependency = require(\"../dependencies/ModuleDependency\");\nconst formatLocation = require(\"../formatLocation\");\nconst { LogType } = require(\"../logging/Logger\");\nconst AggressiveSplittingPlugin = require(\"../optimize/AggressiveSplittingPlugin\");\nconst SizeLimitsPlugin = require(\"../performance/SizeLimitsPlugin\");\nconst { countIterable } = require(\"../util/IterableHelpers\");\nconst {\n\tcompareLocations,\n\tcompareChunksById,\n\tcompareNumbers,\n\tcompareIds,\n\tconcatComparators,\n\tcompareSelect,\n\tcompareModulesByIdentifier\n} = require(\"../util/comparators\");\nconst { makePathsRelative, parseResource } = require(\"../util/identifier\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"../ChunkGroup\").OriginRecord} OriginRecord */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compilation\").Asset} Asset */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compilation\").NormalizedStatsOptions} NormalizedStatsOptions */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n/** @typedef {import(\"../ModuleProfile\")} ModuleProfile */\n/** @typedef {import(\"../RequestShortener\")} RequestShortener */\n/** @typedef {import(\"../WebpackError\")} WebpackError */\n/** @template T @typedef {import(\"../util/comparators\").Comparator<T>} Comparator<T> */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n/** @typedef {import(\"../util/smartGrouping\").GroupConfig<any, object>} GroupConfig */\n/** @typedef {import(\"./StatsFactory\")} StatsFactory */\n/** @typedef {import(\"./StatsFactory\").StatsFactoryContext} StatsFactoryContext */\n\n/** @typedef {KnownStatsCompilation & Record<string, any>} StatsCompilation */\n/**\n * @typedef {Object} KnownStatsCompilation\n * @property {any=} env\n * @property {string=} name\n * @property {string=} hash\n * @property {string=} version\n * @property {number=} time\n * @property {number=} builtAt\n * @property {boolean=} needAdditionalPass\n * @property {string=} publicPath\n * @property {string=} outputPath\n * @property {Record<string, string[]>=} assetsByChunkName\n * @property {StatsAsset[]=} assets\n * @property {number=} filteredAssets\n * @property {StatsChunk[]=} chunks\n * @property {StatsModule[]=} modules\n * @property {number=} filteredModules\n * @property {Record<string, StatsChunkGroup>=} entrypoints\n * @property {Record<string, StatsChunkGroup>=} namedChunkGroups\n * @property {StatsError[]=} errors\n * @property {number=} errorsCount\n * @property {StatsError[]=} warnings\n * @property {number=} warningsCount\n * @property {StatsCompilation[]=} children\n * @property {Record<string, StatsLogging>=} logging\n */\n\n/** @typedef {KnownStatsLogging & Record<string, any>} StatsLogging */\n/**\n * @typedef {Object} KnownStatsLogging\n * @property {StatsLoggingEntry[]} entries\n * @property {number} filteredEntries\n * @property {boolean} debug\n */\n\n/** @typedef {KnownStatsLoggingEntry & Record<string, any>} StatsLoggingEntry */\n/**\n * @typedef {Object} KnownStatsLoggingEntry\n * @property {string} type\n * @property {string} message\n * @property {string[]=} trace\n * @property {StatsLoggingEntry[]=} children\n * @property {any[]=} args\n * @property {number=} time\n */\n\n/** @typedef {KnownStatsAsset & Record<string, any>} StatsAsset */\n/**\n * @typedef {Object} KnownStatsAsset\n * @property {string} type\n * @property {string} name\n * @property {AssetInfo} info\n * @property {number} size\n * @property {boolean} emitted\n * @property {boolean} comparedForEmit\n * @property {boolean} cached\n * @property {StatsAsset[]=} related\n * @property {(string|number)[]=} chunkNames\n * @property {(string|number)[]=} chunkIdHints\n * @property {(string|number)[]=} chunks\n * @property {(string|number)[]=} auxiliaryChunkNames\n * @property {(string|number)[]=} auxiliaryChunks\n * @property {(string|number)[]=} auxiliaryChunkIdHints\n * @property {number=} filteredRelated\n * @property {boolean=} isOverSizeLimit\n */\n\n/** @typedef {KnownStatsChunkGroup & Record<string, any>} StatsChunkGroup */\n/**\n * @typedef {Object} KnownStatsChunkGroup\n * @property {string=} name\n * @property {(string|number)[]=} chunks\n * @property {({ name: string, size?: number })[]=} assets\n * @property {number=} filteredAssets\n * @property {number=} assetsSize\n * @property {({ name: string, size?: number })[]=} auxiliaryAssets\n * @property {number=} filteredAuxiliaryAssets\n * @property {number=} auxiliaryAssetsSize\n * @property {{ [x: string]: StatsChunkGroup[] }=} children\n * @property {{ [x: string]: string[] }=} childAssets\n * @property {boolean=} isOverSizeLimit\n */\n\n/** @typedef {KnownStatsModule & Record<string, any>} StatsModule */\n/**\n * @typedef {Object} KnownStatsModule\n * @property {string=} type\n * @property {string=} moduleType\n * @property {string=} layer\n * @property {string=} identifier\n * @property {string=} name\n * @property {string=} nameForCondition\n * @property {number=} index\n * @property {number=} preOrderIndex\n * @property {number=} index2\n * @property {number=} postOrderIndex\n * @property {number=} size\n * @property {{[x: string]: number}=} sizes\n * @property {boolean=} cacheable\n * @property {boolean=} built\n * @property {boolean=} codeGenerated\n * @property {boolean=} buildTimeExecuted\n * @property {boolean=} cached\n * @property {boolean=} optional\n * @property {boolean=} orphan\n * @property {string|number=} id\n * @property {string|number=} issuerId\n * @property {(string|number)[]=} chunks\n * @property {(string|number)[]=} assets\n * @property {boolean=} dependent\n * @property {string=} issuer\n * @property {string=} issuerName\n * @property {StatsModuleIssuer[]=} issuerPath\n * @property {boolean=} failed\n * @property {number=} errors\n * @property {number=} warnings\n * @property {StatsProfile=} profile\n * @property {StatsModuleReason[]=} reasons\n * @property {(boolean | string[])=} usedExports\n * @property {string[]=} providedExports\n * @property {string[]=} optimizationBailout\n * @property {number=} depth\n * @property {StatsModule[]=} modules\n * @property {number=} filteredModules\n * @property {ReturnType<Source[\"source\"]>=} source\n */\n\n/** @typedef {KnownStatsProfile & Record<string, any>} StatsProfile */\n/**\n * @typedef {Object} KnownStatsProfile\n * @property {number} total\n * @property {number} resolving\n * @property {number} restoring\n * @property {number} building\n * @property {number} integration\n * @property {number} storing\n * @property {number} additionalResolving\n * @property {number} additionalIntegration\n * @property {number} factory\n * @property {number} dependencies\n */\n\n/** @typedef {KnownStatsModuleIssuer & Record<string, any>} StatsModuleIssuer */\n/**\n * @typedef {Object} KnownStatsModuleIssuer\n * @property {string=} identifier\n * @property {string=} name\n * @property {(string|number)=} id\n * @property {StatsProfile=} profile\n */\n\n/** @typedef {KnownStatsModuleReason & Record<string, any>} StatsModuleReason */\n/**\n * @typedef {Object} KnownStatsModuleReason\n * @property {string=} moduleIdentifier\n * @property {string=} module\n * @property {string=} moduleName\n * @property {string=} resolvedModuleIdentifier\n * @property {string=} resolvedModule\n * @property {string=} type\n * @property {boolean} active\n * @property {string=} explanation\n * @property {string=} userRequest\n * @property {string=} loc\n * @property {(string|number)=} moduleId\n * @property {(string|number)=} resolvedModuleId\n */\n\n/** @typedef {KnownStatsChunk & Record<string, any>} StatsChunk */\n/**\n * @typedef {Object} KnownStatsChunk\n * @property {boolean} rendered\n * @property {boolean} initial\n * @property {boolean} entry\n * @property {boolean} recorded\n * @property {string=} reason\n * @property {number} size\n * @property {Record<string, number>=} sizes\n * @property {string[]=} names\n * @property {string[]=} idHints\n * @property {string[]=} runtime\n * @property {string[]=} files\n * @property {string[]=} auxiliaryFiles\n * @property {string} hash\n * @property {Record<string, (string|number)[]>=} childrenByOrder\n * @property {(string|number)=} id\n * @property {(string|number)[]=} siblings\n * @property {(string|number)[]=} parents\n * @property {(string|number)[]=} children\n * @property {StatsModule[]=} modules\n * @property {number=} filteredModules\n * @property {StatsChunkOrigin[]=} origins\n */\n\n/** @typedef {KnownStatsChunkOrigin & Record<string, any>} StatsChunkOrigin */\n/**\n * @typedef {Object} KnownStatsChunkOrigin\n * @property {string=} module\n * @property {string=} moduleIdentifier\n * @property {string=} moduleName\n * @property {string=} loc\n * @property {string=} request\n * @property {(string|number)=} moduleId\n */\n\n/** @typedef {KnownStatsModuleTraceItem & Record<string, any>} StatsModuleTraceItem */\n/**\n * @typedef {Object} KnownStatsModuleTraceItem\n * @property {string=} originIdentifier\n * @property {string=} originName\n * @property {string=} moduleIdentifier\n * @property {string=} moduleName\n * @property {StatsModuleTraceDependency[]=} dependencies\n * @property {(string|number)=} originId\n * @property {(string|number)=} moduleId\n */\n\n/** @typedef {KnownStatsModuleTraceDependency & Record<string, any>} StatsModuleTraceDependency */\n/**\n * @typedef {Object} KnownStatsModuleTraceDependency\n * @property {string=} loc\n */\n\n/** @typedef {KnownStatsError & Record<string, any>} StatsError */\n/**\n * @typedef {Object} KnownStatsError\n * @property {string} message\n * @property {string=} chunkName\n * @property {boolean=} chunkEntry\n * @property {boolean=} chunkInitial\n * @property {string=} file\n * @property {string=} moduleIdentifier\n * @property {string=} moduleName\n * @property {string=} loc\n * @property {string|number=} chunkId\n * @property {string|number=} moduleId\n * @property {StatsModuleTraceItem[]=} moduleTrace\n * @property {any=} details\n * @property {string=} stack\n */\n\n/** @typedef {Asset & { type: string, related: PreprocessedAsset[] }} PreprocessedAsset */\n\n/**\n * @template T\n * @template O\n * @typedef {Record<string, (object: O, data: T, context: StatsFactoryContext, options: NormalizedStatsOptions, factory: StatsFactory) => void>} ExtractorsByOption\n */\n\n/**\n * @typedef {Object} SimpleExtractors\n * @property {ExtractorsByOption<Compilation, StatsCompilation>} compilation\n * @property {ExtractorsByOption<PreprocessedAsset, StatsAsset>} asset\n * @property {ExtractorsByOption<PreprocessedAsset, StatsAsset>} asset$visible\n * @property {ExtractorsByOption<{ name: string, chunkGroup: ChunkGroup }, StatsChunkGroup>} chunkGroup\n * @property {ExtractorsByOption<Module, StatsModule>} module\n * @property {ExtractorsByOption<Module, StatsModule>} module$visible\n * @property {ExtractorsByOption<Module, StatsModuleIssuer>} moduleIssuer\n * @property {ExtractorsByOption<ModuleProfile, StatsProfile>} profile\n * @property {ExtractorsByOption<ModuleGraphConnection, StatsModuleReason>} moduleReason\n * @property {ExtractorsByOption<Chunk, StatsChunk>} chunk\n * @property {ExtractorsByOption<OriginRecord, StatsChunkOrigin>} chunkOrigin\n * @property {ExtractorsByOption<WebpackError, StatsError>} error\n * @property {ExtractorsByOption<WebpackError, StatsError>} warning\n * @property {ExtractorsByOption<{ origin: Module, module: Module }, StatsModuleTraceItem>} moduleTraceItem\n * @property {ExtractorsByOption<Dependency, StatsModuleTraceDependency>} moduleTraceDependency\n */\n\n/**\n * @template T\n * @template I\n * @param {Iterable<T>} items items to select from\n * @param {function(T): Iterable<I>} selector selector function to select values from item\n * @returns {I[]} array of values\n */\nconst uniqueArray = (items, selector) => {\n\t/** @type {Set<I>} */\n\tconst set = new Set();\n\tfor (const item of items) {\n\t\tfor (const i of selector(item)) {\n\t\t\tset.add(i);\n\t\t}\n\t}\n\treturn Array.from(set);\n};\n\n/**\n * @template T\n * @template I\n * @param {Iterable<T>} items items to select from\n * @param {function(T): Iterable<I>} selector selector function to select values from item\n * @param {Comparator<I>} comparator comparator function\n * @returns {I[]} array of values\n */\nconst uniqueOrderedArray = (items, selector, comparator) => {\n\treturn uniqueArray(items, selector).sort(comparator);\n};\n\n/** @template T @template R @typedef {{ [P in keyof T]: R }} MappedValues<T, R> */\n\n/**\n * @template T\n * @template R\n * @param {T} obj object to be mapped\n * @param {function(T[keyof T], keyof T): R} fn mapping function\n * @returns {MappedValues<T, R>} mapped object\n */\nconst mapObject = (obj, fn) => {\n\tconst newObj = Object.create(null);\n\tfor (const key of Object.keys(obj)) {\n\t\tnewObj[key] = fn(obj[key], /** @type {keyof T} */ (key));\n\t}\n\treturn newObj;\n};\n\n/**\n * @param {Compilation} compilation the compilation\n * @param {function(Compilation, string): any[]} getItems get items\n * @returns {number} total number\n */\nconst countWithChildren = (compilation, getItems) => {\n\tlet count = getItems(compilation, \"\").length;\n\tfor (const child of compilation.children) {\n\t\tcount += countWithChildren(child, (c, type) =>\n\t\t\tgetItems(c, `.children[].compilation${type}`)\n\t\t);\n\t}\n\treturn count;\n};\n\n/** @type {ExtractorsByOption<WebpackError | string, StatsError>} */\nconst EXTRACT_ERROR = {\n\t_: (object, error, context, { requestShortener }) => {\n\t\t// TODO webpack 6 disallow strings in the errors/warnings list\n\t\tif (typeof error === \"string\") {\n\t\t\tobject.message = error;\n\t\t} else {\n\t\t\tif (error.chunk) {\n\t\t\t\tobject.chunkName = error.chunk.name;\n\t\t\t\tobject.chunkEntry = error.chunk.hasRuntime();\n\t\t\t\tobject.chunkInitial = error.chunk.canBeInitial();\n\t\t\t}\n\t\t\tif (error.file) {\n\t\t\t\tobject.file = error.file;\n\t\t\t}\n\t\t\tif (error.module) {\n\t\t\t\tobject.moduleIdentifier = error.module.identifier();\n\t\t\t\tobject.moduleName = error.module.readableIdentifier(requestShortener);\n\t\t\t}\n\t\t\tif (error.loc) {\n\t\t\t\tobject.loc = formatLocation(error.loc);\n\t\t\t}\n\t\t\tobject.message = error.message;\n\t\t}\n\t},\n\tids: (object, error, { compilation: { chunkGraph } }) => {\n\t\tif (typeof error !== \"string\") {\n\t\t\tif (error.chunk) {\n\t\t\t\tobject.chunkId = error.chunk.id;\n\t\t\t}\n\t\t\tif (error.module) {\n\t\t\t\tobject.moduleId = chunkGraph.getModuleId(error.module);\n\t\t\t}\n\t\t}\n\t},\n\tmoduleTrace: (object, error, context, options, factory) => {\n\t\tif (typeof error !== \"string\" && error.module) {\n\t\t\tconst {\n\t\t\t\ttype,\n\t\t\t\tcompilation: { moduleGraph }\n\t\t\t} = context;\n\t\t\t/** @type {Set<Module>} */\n\t\t\tconst visitedModules = new Set();\n\t\t\tconst moduleTrace = [];\n\t\t\tlet current = error.module;\n\t\t\twhile (current) {\n\t\t\t\tif (visitedModules.has(current)) break; // circular (technically impossible, but how knows)\n\t\t\t\tvisitedModules.add(current);\n\t\t\t\tconst origin = moduleGraph.getIssuer(current);\n\t\t\t\tif (!origin) break;\n\t\t\t\tmoduleTrace.push({ origin, module: current });\n\t\t\t\tcurrent = origin;\n\t\t\t}\n\t\t\tobject.moduleTrace = factory.create(\n\t\t\t\t`${type}.moduleTrace`,\n\t\t\t\tmoduleTrace,\n\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\t},\n\terrorDetails: (\n\t\tobject,\n\t\terror,\n\t\t{ type, compilation, cachedGetErrors, cachedGetWarnings },\n\t\t{ errorDetails }\n\t) => {\n\t\tif (\n\t\t\ttypeof error !== \"string\" &&\n\t\t\t(errorDetails === true ||\n\t\t\t\t(type.endsWith(\".error\") && cachedGetErrors(compilation).length < 3))\n\t\t) {\n\t\t\tobject.details = error.details;\n\t\t}\n\t},\n\terrorStack: (object, error) => {\n\t\tif (typeof error !== \"string\") {\n\t\t\tobject.stack = error.stack;\n\t\t}\n\t}\n};\n\n/** @type {SimpleExtractors} */\nconst SIMPLE_EXTRACTORS = {\n\tcompilation: {\n\t\t_: (object, compilation, context, options) => {\n\t\t\tif (!context.makePathsRelative) {\n\t\t\t\tcontext.makePathsRelative = makePathsRelative.bindContextCache(\n\t\t\t\t\tcompilation.compiler.context,\n\t\t\t\t\tcompilation.compiler.root\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (!context.cachedGetErrors) {\n\t\t\t\tconst map = new WeakMap();\n\t\t\t\tcontext.cachedGetErrors = compilation => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tmap.get(compilation) ||\n\t\t\t\t\t\t(errors => (map.set(compilation, errors), errors))(\n\t\t\t\t\t\t\tcompilation.getErrors()\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (!context.cachedGetWarnings) {\n\t\t\t\tconst map = new WeakMap();\n\t\t\t\tcontext.cachedGetWarnings = compilation => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tmap.get(compilation) ||\n\t\t\t\t\t\t(warnings => (map.set(compilation, warnings), warnings))(\n\t\t\t\t\t\t\tcompilation.getWarnings()\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (compilation.name) {\n\t\t\t\tobject.name = compilation.name;\n\t\t\t}\n\t\t\tif (compilation.needAdditionalPass) {\n\t\t\t\tobject.needAdditionalPass = true;\n\t\t\t}\n\n\t\t\tconst { logging, loggingDebug, loggingTrace } = options;\n\t\t\tif (logging || (loggingDebug && loggingDebug.length > 0)) {\n\t\t\t\tconst util = require(\"util\");\n\t\t\t\tobject.logging = {};\n\t\t\t\tlet acceptedTypes;\n\t\t\t\tlet collapsedGroups = false;\n\t\t\t\tswitch (logging) {\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tacceptedTypes = new Set();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"error\":\n\t\t\t\t\t\tacceptedTypes = new Set([LogType.error]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"warn\":\n\t\t\t\t\t\tacceptedTypes = new Set([LogType.error, LogType.warn]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"info\":\n\t\t\t\t\t\tacceptedTypes = new Set([\n\t\t\t\t\t\t\tLogType.error,\n\t\t\t\t\t\t\tLogType.warn,\n\t\t\t\t\t\t\tLogType.info\n\t\t\t\t\t\t]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"log\":\n\t\t\t\t\t\tacceptedTypes = new Set([\n\t\t\t\t\t\t\tLogType.error,\n\t\t\t\t\t\t\tLogType.warn,\n\t\t\t\t\t\t\tLogType.info,\n\t\t\t\t\t\t\tLogType.log,\n\t\t\t\t\t\t\tLogType.group,\n\t\t\t\t\t\t\tLogType.groupEnd,\n\t\t\t\t\t\t\tLogType.groupCollapsed,\n\t\t\t\t\t\t\tLogType.clear\n\t\t\t\t\t\t]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"verbose\":\n\t\t\t\t\t\tacceptedTypes = new Set([\n\t\t\t\t\t\t\tLogType.error,\n\t\t\t\t\t\t\tLogType.warn,\n\t\t\t\t\t\t\tLogType.info,\n\t\t\t\t\t\t\tLogType.log,\n\t\t\t\t\t\t\tLogType.group,\n\t\t\t\t\t\t\tLogType.groupEnd,\n\t\t\t\t\t\t\tLogType.groupCollapsed,\n\t\t\t\t\t\t\tLogType.profile,\n\t\t\t\t\t\t\tLogType.profileEnd,\n\t\t\t\t\t\t\tLogType.time,\n\t\t\t\t\t\t\tLogType.status,\n\t\t\t\t\t\t\tLogType.clear\n\t\t\t\t\t\t]);\n\t\t\t\t\t\tcollapsedGroups = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst cachedMakePathsRelative = makePathsRelative.bindContextCache(\n\t\t\t\t\toptions.context,\n\t\t\t\t\tcompilation.compiler.root\n\t\t\t\t);\n\t\t\t\tlet depthInCollapsedGroup = 0;\n\t\t\t\tfor (const [origin, logEntries] of compilation.logging) {\n\t\t\t\t\tconst debugMode = loggingDebug.some(fn => fn(origin));\n\t\t\t\t\tif (logging === false && !debugMode) continue;\n\t\t\t\t\t/** @type {KnownStatsLoggingEntry[]} */\n\t\t\t\t\tconst groupStack = [];\n\t\t\t\t\t/** @type {KnownStatsLoggingEntry[]} */\n\t\t\t\t\tconst rootList = [];\n\t\t\t\t\tlet currentList = rootList;\n\t\t\t\t\tlet processedLogEntries = 0;\n\t\t\t\t\tfor (const entry of logEntries) {\n\t\t\t\t\t\tlet type = entry.type;\n\t\t\t\t\t\tif (!debugMode && !acceptedTypes.has(type)) continue;\n\n\t\t\t\t\t\t// Expand groups in verbose and debug modes\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttype === LogType.groupCollapsed &&\n\t\t\t\t\t\t\t(debugMode || collapsedGroups)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\ttype = LogType.group;\n\n\t\t\t\t\t\tif (depthInCollapsedGroup === 0) {\n\t\t\t\t\t\t\tprocessedLogEntries++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (type === LogType.groupEnd) {\n\t\t\t\t\t\t\tgroupStack.pop();\n\t\t\t\t\t\t\tif (groupStack.length > 0) {\n\t\t\t\t\t\t\t\tcurrentList = groupStack[groupStack.length - 1].children;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcurrentList = rootList;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (depthInCollapsedGroup > 0) depthInCollapsedGroup--;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet message = undefined;\n\t\t\t\t\t\tif (entry.type === LogType.time) {\n\t\t\t\t\t\t\tmessage = `${entry.args[0]}: ${\n\t\t\t\t\t\t\t\tentry.args[1] * 1000 + entry.args[2] / 1000000\n\t\t\t\t\t\t\t} ms`;\n\t\t\t\t\t\t} else if (entry.args && entry.args.length > 0) {\n\t\t\t\t\t\t\tmessage = util.format(entry.args[0], ...entry.args.slice(1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/** @type {KnownStatsLoggingEntry} */\n\t\t\t\t\t\tconst newEntry = {\n\t\t\t\t\t\t\t...entry,\n\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t\ttrace: loggingTrace ? entry.trace : undefined,\n\t\t\t\t\t\t\tchildren:\n\t\t\t\t\t\t\t\ttype === LogType.group || type === LogType.groupCollapsed\n\t\t\t\t\t\t\t\t\t? []\n\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t};\n\t\t\t\t\t\tcurrentList.push(newEntry);\n\t\t\t\t\t\tif (newEntry.children) {\n\t\t\t\t\t\t\tgroupStack.push(newEntry);\n\t\t\t\t\t\t\tcurrentList = newEntry.children;\n\t\t\t\t\t\t\tif (depthInCollapsedGroup > 0) {\n\t\t\t\t\t\t\t\tdepthInCollapsedGroup++;\n\t\t\t\t\t\t\t} else if (type === LogType.groupCollapsed) {\n\t\t\t\t\t\t\t\tdepthInCollapsedGroup = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlet name = cachedMakePathsRelative(origin).replace(/\\|/g, \" \");\n\t\t\t\t\tif (name in object.logging) {\n\t\t\t\t\t\tlet i = 1;\n\t\t\t\t\t\twhile (`${name}#${i}` in object.logging) {\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tname = `${name}#${i}`;\n\t\t\t\t\t}\n\t\t\t\t\tobject.logging[name] = {\n\t\t\t\t\t\tentries: rootList,\n\t\t\t\t\t\tfilteredEntries: logEntries.length - processedLogEntries,\n\t\t\t\t\t\tdebug: debugMode\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thash: (object, compilation) => {\n\t\t\tobject.hash = compilation.hash;\n\t\t},\n\t\tversion: object => {\n\t\t\tobject.version = require(\"../../package.json\").version;\n\t\t},\n\t\tenv: (object, compilation, context, { _env }) => {\n\t\t\tobject.env = _env;\n\t\t},\n\t\ttimings: (object, compilation) => {\n\t\t\tobject.time = compilation.endTime - compilation.startTime;\n\t\t},\n\t\tbuiltAt: (object, compilation) => {\n\t\t\tobject.builtAt = compilation.endTime;\n\t\t},\n\t\tpublicPath: (object, compilation) => {\n\t\t\tobject.publicPath = compilation.getPath(\n\t\t\t\tcompilation.outputOptions.publicPath\n\t\t\t);\n\t\t},\n\t\toutputPath: (object, compilation) => {\n\t\t\tobject.outputPath = compilation.outputOptions.path;\n\t\t},\n\t\tassets: (object, compilation, context, options, factory) => {\n\t\t\tconst { type } = context;\n\t\t\t/** @type {Map<string, Chunk[]>} */\n\t\t\tconst compilationFileToChunks = new Map();\n\t\t\t/** @type {Map<string, Chunk[]>} */\n\t\t\tconst compilationAuxiliaryFileToChunks = new Map();\n\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\tfor (const file of chunk.files) {\n\t\t\t\t\tlet array = compilationFileToChunks.get(file);\n\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\tcompilationFileToChunks.set(file, array);\n\t\t\t\t\t}\n\t\t\t\t\tarray.push(chunk);\n\t\t\t\t}\n\t\t\t\tfor (const file of chunk.auxiliaryFiles) {\n\t\t\t\t\tlet array = compilationAuxiliaryFileToChunks.get(file);\n\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\tcompilationAuxiliaryFileToChunks.set(file, array);\n\t\t\t\t\t}\n\t\t\t\t\tarray.push(chunk);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/** @type {Map<string, PreprocessedAsset>} */\n\t\t\tconst assetMap = new Map();\n\t\t\t/** @type {Set<PreprocessedAsset>} */\n\t\t\tconst assets = new Set();\n\t\t\tfor (const asset of compilation.getAssets()) {\n\t\t\t\t/** @type {PreprocessedAsset} */\n\t\t\t\tconst item = {\n\t\t\t\t\t...asset,\n\t\t\t\t\ttype: \"asset\",\n\t\t\t\t\trelated: undefined\n\t\t\t\t};\n\t\t\t\tassets.add(item);\n\t\t\t\tassetMap.set(asset.name, item);\n\t\t\t}\n\t\t\tfor (const item of assetMap.values()) {\n\t\t\t\tconst related = item.info.related;\n\t\t\t\tif (!related) continue;\n\t\t\t\tfor (const type of Object.keys(related)) {\n\t\t\t\t\tconst relatedEntry = related[type];\n\t\t\t\t\tconst deps = Array.isArray(relatedEntry)\n\t\t\t\t\t\t? relatedEntry\n\t\t\t\t\t\t: [relatedEntry];\n\t\t\t\t\tfor (const dep of deps) {\n\t\t\t\t\t\tconst depItem = assetMap.get(dep);\n\t\t\t\t\t\tif (!depItem) continue;\n\t\t\t\t\t\tassets.delete(depItem);\n\t\t\t\t\t\tdepItem.type = type;\n\t\t\t\t\t\titem.related = item.related || [];\n\t\t\t\t\t\titem.related.push(depItem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tobject.assetsByChunkName = {};\n\t\t\tfor (const [file, chunks] of compilationFileToChunks) {\n\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\tconst name = chunk.name;\n\t\t\t\t\tif (!name) continue;\n\t\t\t\t\tif (\n\t\t\t\t\t\t!Object.prototype.hasOwnProperty.call(\n\t\t\t\t\t\t\tobject.assetsByChunkName,\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tobject.assetsByChunkName[name] = [];\n\t\t\t\t\t}\n\t\t\t\t\tobject.assetsByChunkName[name].push(file);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst groupedAssets = factory.create(\n\t\t\t\t`${type}.assets`,\n\t\t\t\tArray.from(assets),\n\t\t\t\t{\n\t\t\t\t\t...context,\n\t\t\t\t\tcompilationFileToChunks,\n\t\t\t\t\tcompilationAuxiliaryFileToChunks\n\t\t\t\t}\n\t\t\t);\n\t\t\tconst limited = spaceLimited(groupedAssets, options.assetsSpace);\n\t\t\tobject.assets = limited.children;\n\t\t\tobject.filteredAssets = limited.filteredChildren;\n\t\t},\n\t\tchunks: (object, compilation, context, options, factory) => {\n\t\t\tconst { type } = context;\n\t\t\tobject.chunks = factory.create(\n\t\t\t\t`${type}.chunks`,\n\t\t\t\tArray.from(compilation.chunks),\n\t\t\t\tcontext\n\t\t\t);\n\t\t},\n\t\tmodules: (object, compilation, context, options, factory) => {\n\t\t\tconst { type } = context;\n\t\t\tconst array = Array.from(compilation.modules);\n\t\t\tconst groupedModules = factory.create(`${type}.modules`, array, context);\n\t\t\tconst limited = spaceLimited(groupedModules, options.modulesSpace);\n\t\t\tobject.modules = limited.children;\n\t\t\tobject.filteredModules = limited.filteredChildren;\n\t\t},\n\t\tentrypoints: (\n\t\t\tobject,\n\t\t\tcompilation,\n\t\t\tcontext,\n\t\t\t{ entrypoints, chunkGroups, chunkGroupAuxiliary, chunkGroupChildren },\n\t\t\tfactory\n\t\t) => {\n\t\t\tconst { type } = context;\n\t\t\tconst array = Array.from(compilation.entrypoints, ([key, value]) => ({\n\t\t\t\tname: key,\n\t\t\t\tchunkGroup: value\n\t\t\t}));\n\t\t\tif (entrypoints === \"auto\" && !chunkGroups) {\n\t\t\t\tif (array.length > 5) return;\n\t\t\t\tif (\n\t\t\t\t\t!chunkGroupChildren &&\n\t\t\t\t\tarray.every(({ chunkGroup }) => {\n\t\t\t\t\t\tif (chunkGroup.chunks.length !== 1) return false;\n\t\t\t\t\t\tconst chunk = chunkGroup.chunks[0];\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\tchunk.files.size === 1 &&\n\t\t\t\t\t\t\t(!chunkGroupAuxiliary || chunk.auxiliaryFiles.size === 0)\n\t\t\t\t\t\t);\n\t\t\t\t\t})\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tobject.entrypoints = factory.create(\n\t\t\t\t`${type}.entrypoints`,\n\t\t\t\tarray,\n\t\t\t\tcontext\n\t\t\t);\n\t\t},\n\t\tchunkGroups: (object, compilation, context, options, factory) => {\n\t\t\tconst { type } = context;\n\t\t\tconst array = Array.from(\n\t\t\t\tcompilation.namedChunkGroups,\n\t\t\t\t([key, value]) => ({\n\t\t\t\t\tname: key,\n\t\t\t\t\tchunkGroup: value\n\t\t\t\t})\n\t\t\t);\n\t\t\tobject.namedChunkGroups = factory.create(\n\t\t\t\t`${type}.namedChunkGroups`,\n\t\t\t\tarray,\n\t\t\t\tcontext\n\t\t\t);\n\t\t},\n\t\terrors: (object, compilation, context, options, factory) => {\n\t\t\tconst { type, cachedGetErrors } = context;\n\t\t\tobject.errors = factory.create(\n\t\t\t\t`${type}.errors`,\n\t\t\t\tcachedGetErrors(compilation),\n\t\t\t\tcontext\n\t\t\t);\n\t\t},\n\t\terrorsCount: (object, compilation, { cachedGetErrors }) => {\n\t\t\tobject.errorsCount = countWithChildren(compilation, c =>\n\t\t\t\tcachedGetErrors(c)\n\t\t\t);\n\t\t},\n\t\twarnings: (object, compilation, context, options, factory) => {\n\t\t\tconst { type, cachedGetWarnings } = context;\n\t\t\tobject.warnings = factory.create(\n\t\t\t\t`${type}.warnings`,\n\t\t\t\tcachedGetWarnings(compilation),\n\t\t\t\tcontext\n\t\t\t);\n\t\t},\n\t\twarningsCount: (\n\t\t\tobject,\n\t\t\tcompilation,\n\t\t\tcontext,\n\t\t\t{ warningsFilter },\n\t\t\tfactory\n\t\t) => {\n\t\t\tconst { type, cachedGetWarnings } = context;\n\t\t\tobject.warningsCount = countWithChildren(compilation, (c, childType) => {\n\t\t\t\tif (!warningsFilter && warningsFilter.length === 0)\n\t\t\t\t\treturn cachedGetWarnings(c);\n\t\t\t\treturn factory\n\t\t\t\t\t.create(`${type}${childType}.warnings`, cachedGetWarnings(c), context)\n\t\t\t\t\t.filter(warning => {\n\t\t\t\t\t\tconst warningString = Object.keys(warning)\n\t\t\t\t\t\t\t.map(key => `${warning[key]}`)\n\t\t\t\t\t\t\t.join(\"\\n\");\n\t\t\t\t\t\treturn !warningsFilter.some(filter =>\n\t\t\t\t\t\t\tfilter(warning, warningString)\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t});\n\t\t},\n\t\terrorDetails: (\n\t\t\tobject,\n\t\t\tcompilation,\n\t\t\t{ cachedGetErrors, cachedGetWarnings },\n\t\t\t{ errorDetails, errors, warnings }\n\t\t) => {\n\t\t\tif (errorDetails === \"auto\") {\n\t\t\t\tif (warnings) {\n\t\t\t\t\tconst warnings = cachedGetWarnings(compilation);\n\t\t\t\t\tobject.filteredWarningDetailsCount = warnings\n\t\t\t\t\t\t.map(e => typeof e !== \"string\" && e.details)\n\t\t\t\t\t\t.filter(Boolean).length;\n\t\t\t\t}\n\t\t\t\tif (errors) {\n\t\t\t\t\tconst errors = cachedGetErrors(compilation);\n\t\t\t\t\tif (errors.length >= 3) {\n\t\t\t\t\t\tobject.filteredErrorDetailsCount = errors\n\t\t\t\t\t\t\t.map(e => typeof e !== \"string\" && e.details)\n\t\t\t\t\t\t\t.filter(Boolean).length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tchildren: (object, compilation, context, options, factory) => {\n\t\t\tconst { type } = context;\n\t\t\tobject.children = factory.create(\n\t\t\t\t`${type}.children`,\n\t\t\t\tcompilation.children,\n\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\t},\n\tasset: {\n\t\t_: (object, asset, context, options, factory) => {\n\t\t\tconst { compilation } = context;\n\t\t\tobject.type = asset.type;\n\t\t\tobject.name = asset.name;\n\t\t\tobject.size = asset.source.size();\n\t\t\tobject.emitted = compilation.emittedAssets.has(asset.name);\n\t\t\tobject.comparedForEmit = compilation.comparedForEmitAssets.has(\n\t\t\t\tasset.name\n\t\t\t);\n\t\t\tconst cached = !object.emitted && !object.comparedForEmit;\n\t\t\tobject.cached = cached;\n\t\t\tobject.info = asset.info;\n\t\t\tif (!cached || options.cachedAssets) {\n\t\t\t\tObject.assign(\n\t\t\t\t\tobject,\n\t\t\t\t\tfactory.create(`${context.type}$visible`, asset, context)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t},\n\tasset$visible: {\n\t\t_: (\n\t\t\tobject,\n\t\t\tasset,\n\t\t\t{ compilation, compilationFileToChunks, compilationAuxiliaryFileToChunks }\n\t\t) => {\n\t\t\tconst chunks = compilationFileToChunks.get(asset.name) || [];\n\t\t\tconst auxiliaryChunks =\n\t\t\t\tcompilationAuxiliaryFileToChunks.get(asset.name) || [];\n\t\t\tobject.chunkNames = uniqueOrderedArray(\n\t\t\t\tchunks,\n\t\t\t\tc => (c.name ? [c.name] : []),\n\t\t\t\tcompareIds\n\t\t\t);\n\t\t\tobject.chunkIdHints = uniqueOrderedArray(\n\t\t\t\tchunks,\n\t\t\t\tc => Array.from(c.idNameHints),\n\t\t\t\tcompareIds\n\t\t\t);\n\t\t\tobject.auxiliaryChunkNames = uniqueOrderedArray(\n\t\t\t\tauxiliaryChunks,\n\t\t\t\tc => (c.name ? [c.name] : []),\n\t\t\t\tcompareIds\n\t\t\t);\n\t\t\tobject.auxiliaryChunkIdHints = uniqueOrderedArray(\n\t\t\t\tauxiliaryChunks,\n\t\t\t\tc => Array.from(c.idNameHints),\n\t\t\t\tcompareIds\n\t\t\t);\n\t\t\tobject.filteredRelated = asset.related ? asset.related.length : undefined;\n\t\t},\n\t\trelatedAssets: (object, asset, context, options, factory) => {\n\t\t\tconst { type } = context;\n\t\t\tobject.related = factory.create(\n\t\t\t\t`${type.slice(0, -8)}.related`,\n\t\t\t\tasset.related,\n\t\t\t\tcontext\n\t\t\t);\n\t\t\tobject.filteredRelated = asset.related\n\t\t\t\t? asset.related.length - object.related.length\n\t\t\t\t: undefined;\n\t\t},\n\t\tids: (\n\t\t\tobject,\n\t\t\tasset,\n\t\t\t{ compilationFileToChunks, compilationAuxiliaryFileToChunks }\n\t\t) => {\n\t\t\tconst chunks = compilationFileToChunks.get(asset.name) || [];\n\t\t\tconst auxiliaryChunks =\n\t\t\t\tcompilationAuxiliaryFileToChunks.get(asset.name) || [];\n\t\t\tobject.chunks = uniqueOrderedArray(chunks, c => c.ids, compareIds);\n\t\t\tobject.auxiliaryChunks = uniqueOrderedArray(\n\t\t\t\tauxiliaryChunks,\n\t\t\t\tc => c.ids,\n\t\t\t\tcompareIds\n\t\t\t);\n\t\t},\n\t\tperformance: (object, asset) => {\n\t\t\tobject.isOverSizeLimit = SizeLimitsPlugin.isOverSizeLimit(asset.source);\n\t\t}\n\t},\n\tchunkGroup: {\n\t\t_: (\n\t\t\tobject,\n\t\t\t{ name, chunkGroup },\n\t\t\t{ compilation, compilation: { moduleGraph, chunkGraph } },\n\t\t\t{ ids, chunkGroupAuxiliary, chunkGroupChildren, chunkGroupMaxAssets }\n\t\t) => {\n\t\t\tconst children =\n\t\t\t\tchunkGroupChildren &&\n\t\t\t\tchunkGroup.getChildrenByOrders(moduleGraph, chunkGraph);\n\t\t\t/**\n\t\t\t * @param {string} name Name\n\t\t\t * @returns {{ name: string, size: number }} Asset object\n\t\t\t */\n\t\t\tconst toAsset = name => {\n\t\t\t\tconst asset = compilation.getAsset(name);\n\t\t\t\treturn {\n\t\t\t\t\tname,\n\t\t\t\t\tsize: asset ? asset.info.size : -1\n\t\t\t\t};\n\t\t\t};\n\t\t\t/** @type {(total: number, asset: { size: number }) => number} */\n\t\t\tconst sizeReducer = (total, { size }) => total + size;\n\t\t\tconst assets = uniqueArray(chunkGroup.chunks, c => c.files).map(toAsset);\n\t\t\tconst auxiliaryAssets = uniqueOrderedArray(\n\t\t\t\tchunkGroup.chunks,\n\t\t\t\tc => c.auxiliaryFiles,\n\t\t\t\tcompareIds\n\t\t\t).map(toAsset);\n\t\t\tconst assetsSize = assets.reduce(sizeReducer, 0);\n\t\t\tconst auxiliaryAssetsSize = auxiliaryAssets.reduce(sizeReducer, 0);\n\t\t\t/** @type {KnownStatsChunkGroup} */\n\t\t\tconst statsChunkGroup = {\n\t\t\t\tname,\n\t\t\t\tchunks: ids ? chunkGroup.chunks.map(c => c.id) : undefined,\n\t\t\t\tassets: assets.length <= chunkGroupMaxAssets ? assets : undefined,\n\t\t\t\tfilteredAssets:\n\t\t\t\t\tassets.length <= chunkGroupMaxAssets ? 0 : assets.length,\n\t\t\t\tassetsSize,\n\t\t\t\tauxiliaryAssets:\n\t\t\t\t\tchunkGroupAuxiliary && auxiliaryAssets.length <= chunkGroupMaxAssets\n\t\t\t\t\t\t? auxiliaryAssets\n\t\t\t\t\t\t: undefined,\n\t\t\t\tfilteredAuxiliaryAssets:\n\t\t\t\t\tchunkGroupAuxiliary && auxiliaryAssets.length <= chunkGroupMaxAssets\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: auxiliaryAssets.length,\n\t\t\t\tauxiliaryAssetsSize,\n\t\t\t\tchildren: children\n\t\t\t\t\t? mapObject(children, groups =>\n\t\t\t\t\t\t\tgroups.map(group => {\n\t\t\t\t\t\t\t\tconst assets = uniqueArray(group.chunks, c => c.files).map(\n\t\t\t\t\t\t\t\t\ttoAsset\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tconst auxiliaryAssets = uniqueOrderedArray(\n\t\t\t\t\t\t\t\t\tgroup.chunks,\n\t\t\t\t\t\t\t\t\tc => c.auxiliaryFiles,\n\t\t\t\t\t\t\t\t\tcompareIds\n\t\t\t\t\t\t\t\t).map(toAsset);\n\n\t\t\t\t\t\t\t\t/** @type {KnownStatsChunkGroup} */\n\t\t\t\t\t\t\t\tconst childStatsChunkGroup = {\n\t\t\t\t\t\t\t\t\tname: group.name,\n\t\t\t\t\t\t\t\t\tchunks: ids ? group.chunks.map(c => c.id) : undefined,\n\t\t\t\t\t\t\t\t\tassets:\n\t\t\t\t\t\t\t\t\t\tassets.length <= chunkGroupMaxAssets ? assets : undefined,\n\t\t\t\t\t\t\t\t\tfilteredAssets:\n\t\t\t\t\t\t\t\t\t\tassets.length <= chunkGroupMaxAssets ? 0 : assets.length,\n\t\t\t\t\t\t\t\t\tauxiliaryAssets:\n\t\t\t\t\t\t\t\t\t\tchunkGroupAuxiliary &&\n\t\t\t\t\t\t\t\t\t\tauxiliaryAssets.length <= chunkGroupMaxAssets\n\t\t\t\t\t\t\t\t\t\t\t? auxiliaryAssets\n\t\t\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t\t\t\tfilteredAuxiliaryAssets:\n\t\t\t\t\t\t\t\t\t\tchunkGroupAuxiliary &&\n\t\t\t\t\t\t\t\t\t\tauxiliaryAssets.length <= chunkGroupMaxAssets\n\t\t\t\t\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t\t\t\t\t: auxiliaryAssets.length\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\treturn childStatsChunkGroup;\n\t\t\t\t\t\t\t})\n\t\t\t\t\t  )\n\t\t\t\t\t: undefined,\n\t\t\t\tchildAssets: children\n\t\t\t\t\t? mapObject(children, groups => {\n\t\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\t\tconst set = new Set();\n\t\t\t\t\t\t\tfor (const group of groups) {\n\t\t\t\t\t\t\t\tfor (const chunk of group.chunks) {\n\t\t\t\t\t\t\t\t\tfor (const asset of chunk.files) {\n\t\t\t\t\t\t\t\t\t\tset.add(asset);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn Array.from(set);\n\t\t\t\t\t  })\n\t\t\t\t\t: undefined\n\t\t\t};\n\t\t\tObject.assign(object, statsChunkGroup);\n\t\t},\n\t\tperformance: (object, { chunkGroup }) => {\n\t\t\tobject.isOverSizeLimit = SizeLimitsPlugin.isOverSizeLimit(chunkGroup);\n\t\t}\n\t},\n\tmodule: {\n\t\t_: (object, module, context, options, factory) => {\n\t\t\tconst { compilation, type } = context;\n\t\t\tconst built = compilation.builtModules.has(module);\n\t\t\tconst codeGenerated = compilation.codeGeneratedModules.has(module);\n\t\t\tconst buildTimeExecuted =\n\t\t\t\tcompilation.buildTimeExecutedModules.has(module);\n\t\t\t/** @type {{[x: string]: number}} */\n\t\t\tconst sizes = {};\n\t\t\tfor (const sourceType of module.getSourceTypes()) {\n\t\t\t\tsizes[sourceType] = module.size(sourceType);\n\t\t\t}\n\t\t\t/** @type {KnownStatsModule} */\n\t\t\tconst statsModule = {\n\t\t\t\ttype: \"module\",\n\t\t\t\tmoduleType: module.type,\n\t\t\t\tlayer: module.layer,\n\t\t\t\tsize: module.size(),\n\t\t\t\tsizes,\n\t\t\t\tbuilt,\n\t\t\t\tcodeGenerated,\n\t\t\t\tbuildTimeExecuted,\n\t\t\t\tcached: !built && !codeGenerated\n\t\t\t};\n\t\t\tObject.assign(object, statsModule);\n\n\t\t\tif (built || codeGenerated || options.cachedModules) {\n\t\t\t\tObject.assign(\n\t\t\t\t\tobject,\n\t\t\t\t\tfactory.create(`${type}$visible`, module, context)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t},\n\tmodule$visible: {\n\t\t_: (object, module, context, { requestShortener }, factory) => {\n\t\t\tconst { compilation, type, rootModules } = context;\n\t\t\tconst { moduleGraph } = compilation;\n\t\t\t/** @type {Module[]} */\n\t\t\tconst path = [];\n\t\t\tconst issuer = moduleGraph.getIssuer(module);\n\t\t\tlet current = issuer;\n\t\t\twhile (current) {\n\t\t\t\tpath.push(current);\n\t\t\t\tcurrent = moduleGraph.getIssuer(current);\n\t\t\t}\n\t\t\tpath.reverse();\n\t\t\tconst profile = moduleGraph.getProfile(module);\n\t\t\tconst errors = module.getErrors();\n\t\t\tconst errorsCount = errors !== undefined ? countIterable(errors) : 0;\n\t\t\tconst warnings = module.getWarnings();\n\t\t\tconst warningsCount =\n\t\t\t\twarnings !== undefined ? countIterable(warnings) : 0;\n\t\t\t/** @type {{[x: string]: number}} */\n\t\t\tconst sizes = {};\n\t\t\tfor (const sourceType of module.getSourceTypes()) {\n\t\t\t\tsizes[sourceType] = module.size(sourceType);\n\t\t\t}\n\t\t\t/** @type {KnownStatsModule} */\n\t\t\tconst statsModule = {\n\t\t\t\tidentifier: module.identifier(),\n\t\t\t\tname: module.readableIdentifier(requestShortener),\n\t\t\t\tnameForCondition: module.nameForCondition(),\n\t\t\t\tindex: moduleGraph.getPreOrderIndex(module),\n\t\t\t\tpreOrderIndex: moduleGraph.getPreOrderIndex(module),\n\t\t\t\tindex2: moduleGraph.getPostOrderIndex(module),\n\t\t\t\tpostOrderIndex: moduleGraph.getPostOrderIndex(module),\n\t\t\t\tcacheable: module.buildInfo.cacheable,\n\t\t\t\toptional: module.isOptional(moduleGraph),\n\t\t\t\torphan:\n\t\t\t\t\t!type.endsWith(\"module.modules[].module$visible\") &&\n\t\t\t\t\tcompilation.chunkGraph.getNumberOfModuleChunks(module) === 0,\n\t\t\t\tdependent: rootModules ? !rootModules.has(module) : undefined,\n\t\t\t\tissuer: issuer && issuer.identifier(),\n\t\t\t\tissuerName: issuer && issuer.readableIdentifier(requestShortener),\n\t\t\t\tissuerPath:\n\t\t\t\t\tissuer &&\n\t\t\t\t\tfactory.create(`${type.slice(0, -8)}.issuerPath`, path, context),\n\t\t\t\tfailed: errorsCount > 0,\n\t\t\t\terrors: errorsCount,\n\t\t\t\twarnings: warningsCount\n\t\t\t};\n\t\t\tObject.assign(object, statsModule);\n\t\t\tif (profile) {\n\t\t\t\tobject.profile = factory.create(\n\t\t\t\t\t`${type.slice(0, -8)}.profile`,\n\t\t\t\t\tprofile,\n\t\t\t\t\tcontext\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t\tids: (object, module, { compilation: { chunkGraph, moduleGraph } }) => {\n\t\t\tobject.id = chunkGraph.getModuleId(module);\n\t\t\tconst issuer = moduleGraph.getIssuer(module);\n\t\t\tobject.issuerId = issuer && chunkGraph.getModuleId(issuer);\n\t\t\tobject.chunks = Array.from(\n\t\t\t\tchunkGraph.getOrderedModuleChunksIterable(module, compareChunksById),\n\t\t\t\tchunk => chunk.id\n\t\t\t);\n\t\t},\n\t\tmoduleAssets: (object, module) => {\n\t\t\tobject.assets = module.buildInfo.assets\n\t\t\t\t? Object.keys(module.buildInfo.assets)\n\t\t\t\t: [];\n\t\t},\n\t\treasons: (object, module, context, options, factory) => {\n\t\t\tconst {\n\t\t\t\ttype,\n\t\t\t\tcompilation: { moduleGraph }\n\t\t\t} = context;\n\t\t\tconst groupsReasons = factory.create(\n\t\t\t\t`${type.slice(0, -8)}.reasons`,\n\t\t\t\tArray.from(moduleGraph.getIncomingConnections(module)),\n\t\t\t\tcontext\n\t\t\t);\n\t\t\tconst limited = spaceLimited(groupsReasons, options.reasonsSpace);\n\t\t\tobject.reasons = limited.children;\n\t\t\tobject.filteredReasons = limited.filteredChildren;\n\t\t},\n\t\tusedExports: (\n\t\t\tobject,\n\t\t\tmodule,\n\t\t\t{ runtime, compilation: { moduleGraph } }\n\t\t) => {\n\t\t\tconst usedExports = moduleGraph.getUsedExports(module, runtime);\n\t\t\tif (usedExports === null) {\n\t\t\t\tobject.usedExports = null;\n\t\t\t} else if (typeof usedExports === \"boolean\") {\n\t\t\t\tobject.usedExports = usedExports;\n\t\t\t} else {\n\t\t\t\tobject.usedExports = Array.from(usedExports);\n\t\t\t}\n\t\t},\n\t\tprovidedExports: (object, module, { compilation: { moduleGraph } }) => {\n\t\t\tconst providedExports = moduleGraph.getProvidedExports(module);\n\t\t\tobject.providedExports = Array.isArray(providedExports)\n\t\t\t\t? providedExports\n\t\t\t\t: null;\n\t\t},\n\t\toptimizationBailout: (\n\t\t\tobject,\n\t\t\tmodule,\n\t\t\t{ compilation: { moduleGraph } },\n\t\t\t{ requestShortener }\n\t\t) => {\n\t\t\tobject.optimizationBailout = moduleGraph\n\t\t\t\t.getOptimizationBailout(module)\n\t\t\t\t.map(item => {\n\t\t\t\t\tif (typeof item === \"function\") return item(requestShortener);\n\t\t\t\t\treturn item;\n\t\t\t\t});\n\t\t},\n\t\tdepth: (object, module, { compilation: { moduleGraph } }) => {\n\t\t\tobject.depth = moduleGraph.getDepth(module);\n\t\t},\n\t\tnestedModules: (object, module, context, options, factory) => {\n\t\t\tconst { type } = context;\n\t\t\tconst innerModules = /** @type {Module & { modules?: Module[] }} */ (\n\t\t\t\tmodule\n\t\t\t).modules;\n\t\t\tif (Array.isArray(innerModules)) {\n\t\t\t\tconst groupedModules = factory.create(\n\t\t\t\t\t`${type.slice(0, -8)}.modules`,\n\t\t\t\t\tinnerModules,\n\t\t\t\t\tcontext\n\t\t\t\t);\n\t\t\t\tconst limited = spaceLimited(\n\t\t\t\t\tgroupedModules,\n\t\t\t\t\toptions.nestedModulesSpace\n\t\t\t\t);\n\t\t\t\tobject.modules = limited.children;\n\t\t\t\tobject.filteredModules = limited.filteredChildren;\n\t\t\t}\n\t\t},\n\t\tsource: (object, module) => {\n\t\t\tconst originalSource = module.originalSource();\n\t\t\tif (originalSource) {\n\t\t\t\tobject.source = originalSource.source();\n\t\t\t}\n\t\t}\n\t},\n\tprofile: {\n\t\t_: (object, profile) => {\n\t\t\t/** @type {KnownStatsProfile} */\n\t\t\tconst statsProfile = {\n\t\t\t\ttotal:\n\t\t\t\t\tprofile.factory +\n\t\t\t\t\tprofile.restoring +\n\t\t\t\t\tprofile.integration +\n\t\t\t\t\tprofile.building +\n\t\t\t\t\tprofile.storing,\n\t\t\t\tresolving: profile.factory,\n\t\t\t\trestoring: profile.restoring,\n\t\t\t\tbuilding: profile.building,\n\t\t\t\tintegration: profile.integration,\n\t\t\t\tstoring: profile.storing,\n\t\t\t\tadditionalResolving: profile.additionalFactories,\n\t\t\t\tadditionalIntegration: profile.additionalIntegration,\n\t\t\t\t// TODO remove this in webpack 6\n\t\t\t\tfactory: profile.factory,\n\t\t\t\t// TODO remove this in webpack 6\n\t\t\t\tdependencies: profile.additionalFactories\n\t\t\t};\n\t\t\tObject.assign(object, statsProfile);\n\t\t}\n\t},\n\tmoduleIssuer: {\n\t\t_: (object, module, context, { requestShortener }, factory) => {\n\t\t\tconst { compilation, type } = context;\n\t\t\tconst { moduleGraph } = compilation;\n\t\t\tconst profile = moduleGraph.getProfile(module);\n\t\t\t/** @type {KnownStatsModuleIssuer} */\n\t\t\tconst statsModuleIssuer = {\n\t\t\t\tidentifier: module.identifier(),\n\t\t\t\tname: module.readableIdentifier(requestShortener)\n\t\t\t};\n\t\t\tObject.assign(object, statsModuleIssuer);\n\t\t\tif (profile) {\n\t\t\t\tobject.profile = factory.create(`${type}.profile`, profile, context);\n\t\t\t}\n\t\t},\n\t\tids: (object, module, { compilation: { chunkGraph } }) => {\n\t\t\tobject.id = chunkGraph.getModuleId(module);\n\t\t}\n\t},\n\tmoduleReason: {\n\t\t_: (object, reason, { runtime }, { requestShortener }) => {\n\t\t\tconst dep = reason.dependency;\n\t\t\tconst moduleDep =\n\t\t\t\tdep && dep instanceof ModuleDependency ? dep : undefined;\n\t\t\t/** @type {KnownStatsModuleReason} */\n\t\t\tconst statsModuleReason = {\n\t\t\t\tmoduleIdentifier: reason.originModule\n\t\t\t\t\t? reason.originModule.identifier()\n\t\t\t\t\t: null,\n\t\t\t\tmodule: reason.originModule\n\t\t\t\t\t? reason.originModule.readableIdentifier(requestShortener)\n\t\t\t\t\t: null,\n\t\t\t\tmoduleName: reason.originModule\n\t\t\t\t\t? reason.originModule.readableIdentifier(requestShortener)\n\t\t\t\t\t: null,\n\t\t\t\tresolvedModuleIdentifier: reason.resolvedOriginModule\n\t\t\t\t\t? reason.resolvedOriginModule.identifier()\n\t\t\t\t\t: null,\n\t\t\t\tresolvedModule: reason.resolvedOriginModule\n\t\t\t\t\t? reason.resolvedOriginModule.readableIdentifier(requestShortener)\n\t\t\t\t\t: null,\n\t\t\t\ttype: reason.dependency ? reason.dependency.type : null,\n\t\t\t\tactive: reason.isActive(runtime),\n\t\t\t\texplanation: reason.explanation,\n\t\t\t\tuserRequest: (moduleDep && moduleDep.userRequest) || null\n\t\t\t};\n\t\t\tObject.assign(object, statsModuleReason);\n\t\t\tif (reason.dependency) {\n\t\t\t\tconst locInfo = formatLocation(reason.dependency.loc);\n\t\t\t\tif (locInfo) {\n\t\t\t\t\tobject.loc = locInfo;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tids: (object, reason, { compilation: { chunkGraph } }) => {\n\t\t\tobject.moduleId = reason.originModule\n\t\t\t\t? chunkGraph.getModuleId(reason.originModule)\n\t\t\t\t: null;\n\t\t\tobject.resolvedModuleId = reason.resolvedOriginModule\n\t\t\t\t? chunkGraph.getModuleId(reason.resolvedOriginModule)\n\t\t\t\t: null;\n\t\t}\n\t},\n\tchunk: {\n\t\t_: (object, chunk, { makePathsRelative, compilation: { chunkGraph } }) => {\n\t\t\tconst childIdByOrder = chunk.getChildIdsByOrders(chunkGraph);\n\n\t\t\t/** @type {KnownStatsChunk} */\n\t\t\tconst statsChunk = {\n\t\t\t\trendered: chunk.rendered,\n\t\t\t\tinitial: chunk.canBeInitial(),\n\t\t\t\tentry: chunk.hasRuntime(),\n\t\t\t\trecorded: AggressiveSplittingPlugin.wasChunkRecorded(chunk),\n\t\t\t\treason: chunk.chunkReason,\n\t\t\t\tsize: chunkGraph.getChunkModulesSize(chunk),\n\t\t\t\tsizes: chunkGraph.getChunkModulesSizes(chunk),\n\t\t\t\tnames: chunk.name ? [chunk.name] : [],\n\t\t\t\tidHints: Array.from(chunk.idNameHints),\n\t\t\t\truntime:\n\t\t\t\t\tchunk.runtime === undefined\n\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t: typeof chunk.runtime === \"string\"\n\t\t\t\t\t\t? [makePathsRelative(chunk.runtime)]\n\t\t\t\t\t\t: Array.from(chunk.runtime.sort(), makePathsRelative),\n\t\t\t\tfiles: Array.from(chunk.files),\n\t\t\t\tauxiliaryFiles: Array.from(chunk.auxiliaryFiles).sort(compareIds),\n\t\t\t\thash: chunk.renderedHash,\n\t\t\t\tchildrenByOrder: childIdByOrder\n\t\t\t};\n\t\t\tObject.assign(object, statsChunk);\n\t\t},\n\t\tids: (object, chunk) => {\n\t\t\tobject.id = chunk.id;\n\t\t},\n\t\tchunkRelations: (object, chunk, { compilation: { chunkGraph } }) => {\n\t\t\t/** @type {Set<string|number>} */\n\t\t\tconst parents = new Set();\n\t\t\t/** @type {Set<string|number>} */\n\t\t\tconst children = new Set();\n\t\t\t/** @type {Set<string|number>} */\n\t\t\tconst siblings = new Set();\n\n\t\t\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\t\t\tfor (const parentGroup of chunkGroup.parentsIterable) {\n\t\t\t\t\tfor (const chunk of parentGroup.chunks) {\n\t\t\t\t\t\tparents.add(chunk.id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const childGroup of chunkGroup.childrenIterable) {\n\t\t\t\t\tfor (const chunk of childGroup.chunks) {\n\t\t\t\t\t\tchildren.add(chunk.id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const sibling of chunkGroup.chunks) {\n\t\t\t\t\tif (sibling !== chunk) siblings.add(sibling.id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tobject.siblings = Array.from(siblings).sort(compareIds);\n\t\t\tobject.parents = Array.from(parents).sort(compareIds);\n\t\t\tobject.children = Array.from(children).sort(compareIds);\n\t\t},\n\t\tchunkModules: (object, chunk, context, options, factory) => {\n\t\t\tconst {\n\t\t\t\ttype,\n\t\t\t\tcompilation: { chunkGraph }\n\t\t\t} = context;\n\t\t\tconst array = chunkGraph.getChunkModules(chunk);\n\t\t\tconst groupedModules = factory.create(`${type}.modules`, array, {\n\t\t\t\t...context,\n\t\t\t\truntime: chunk.runtime,\n\t\t\t\trootModules: new Set(chunkGraph.getChunkRootModules(chunk))\n\t\t\t});\n\t\t\tconst limited = spaceLimited(groupedModules, options.chunkModulesSpace);\n\t\t\tobject.modules = limited.children;\n\t\t\tobject.filteredModules = limited.filteredChildren;\n\t\t},\n\t\tchunkOrigins: (object, chunk, context, options, factory) => {\n\t\t\tconst {\n\t\t\t\ttype,\n\t\t\t\tcompilation: { chunkGraph }\n\t\t\t} = context;\n\t\t\t/** @type {Set<string>} */\n\t\t\tconst originsKeySet = new Set();\n\t\t\tconst origins = [];\n\t\t\tfor (const g of chunk.groupsIterable) {\n\t\t\t\torigins.push(...g.origins);\n\t\t\t}\n\t\t\tconst array = origins.filter(origin => {\n\t\t\t\tconst key = [\n\t\t\t\t\torigin.module ? chunkGraph.getModuleId(origin.module) : undefined,\n\t\t\t\t\tformatLocation(origin.loc),\n\t\t\t\t\torigin.request\n\t\t\t\t].join();\n\t\t\t\tif (originsKeySet.has(key)) return false;\n\t\t\t\toriginsKeySet.add(key);\n\t\t\t\treturn true;\n\t\t\t});\n\t\t\tobject.origins = factory.create(`${type}.origins`, array, context);\n\t\t}\n\t},\n\tchunkOrigin: {\n\t\t_: (object, origin, context, { requestShortener }) => {\n\t\t\t/** @type {KnownStatsChunkOrigin} */\n\t\t\tconst statsChunkOrigin = {\n\t\t\t\tmodule: origin.module ? origin.module.identifier() : \"\",\n\t\t\t\tmoduleIdentifier: origin.module ? origin.module.identifier() : \"\",\n\t\t\t\tmoduleName: origin.module\n\t\t\t\t\t? origin.module.readableIdentifier(requestShortener)\n\t\t\t\t\t: \"\",\n\t\t\t\tloc: formatLocation(origin.loc),\n\t\t\t\trequest: origin.request\n\t\t\t};\n\t\t\tObject.assign(object, statsChunkOrigin);\n\t\t},\n\t\tids: (object, origin, { compilation: { chunkGraph } }) => {\n\t\t\tobject.moduleId = origin.module\n\t\t\t\t? chunkGraph.getModuleId(origin.module)\n\t\t\t\t: undefined;\n\t\t}\n\t},\n\terror: EXTRACT_ERROR,\n\twarning: EXTRACT_ERROR,\n\tmoduleTraceItem: {\n\t\t_: (object, { origin, module }, context, { requestShortener }, factory) => {\n\t\t\tconst {\n\t\t\t\ttype,\n\t\t\t\tcompilation: { moduleGraph }\n\t\t\t} = context;\n\t\t\tobject.originIdentifier = origin.identifier();\n\t\t\tobject.originName = origin.readableIdentifier(requestShortener);\n\t\t\tobject.moduleIdentifier = module.identifier();\n\t\t\tobject.moduleName = module.readableIdentifier(requestShortener);\n\t\t\tconst dependencies = Array.from(\n\t\t\t\tmoduleGraph.getIncomingConnections(module)\n\t\t\t)\n\t\t\t\t.filter(c => c.resolvedOriginModule === origin && c.dependency)\n\t\t\t\t.map(c => c.dependency);\n\t\t\tobject.dependencies = factory.create(\n\t\t\t\t`${type}.dependencies`,\n\t\t\t\tArray.from(new Set(dependencies)),\n\t\t\t\tcontext\n\t\t\t);\n\t\t},\n\t\tids: (object, { origin, module }, { compilation: { chunkGraph } }) => {\n\t\t\tobject.originId = chunkGraph.getModuleId(origin);\n\t\t\tobject.moduleId = chunkGraph.getModuleId(module);\n\t\t}\n\t},\n\tmoduleTraceDependency: {\n\t\t_: (object, dependency) => {\n\t\t\tobject.loc = formatLocation(dependency.loc);\n\t\t}\n\t}\n};\n\n/** @type {Record<string, Record<string, (thing: any, context: StatsFactoryContext, options: NormalizedStatsOptions) => boolean | undefined>>} */\nconst FILTER = {\n\t\"module.reasons\": {\n\t\t\"!orphanModules\": (reason, { compilation: { chunkGraph } }) => {\n\t\t\tif (\n\t\t\t\treason.originModule &&\n\t\t\t\tchunkGraph.getNumberOfModuleChunks(reason.originModule) === 0\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/** @type {Record<string, Record<string, (thing: Object, context: StatsFactoryContext, options: NormalizedStatsOptions) => boolean | undefined>>} */\nconst FILTER_RESULTS = {\n\t\"compilation.warnings\": {\n\t\twarningsFilter: util.deprecate(\n\t\t\t(warning, context, { warningsFilter }) => {\n\t\t\t\tconst warningString = Object.keys(warning)\n\t\t\t\t\t.map(key => `${warning[key]}`)\n\t\t\t\t\t.join(\"\\n\");\n\t\t\t\treturn !warningsFilter.some(filter => filter(warning, warningString));\n\t\t\t},\n\t\t\t\"config.stats.warningsFilter is deprecated in favor of config.ignoreWarnings\",\n\t\t\t\"DEP_WEBPACK_STATS_WARNINGS_FILTER\"\n\t\t)\n\t}\n};\n\n/** @type {Record<string, (comparators: Function[], context: StatsFactoryContext) => void>} */\nconst MODULES_SORTER = {\n\t_: (comparators, { compilation: { moduleGraph } }) => {\n\t\tcomparators.push(\n\t\t\tcompareSelect(\n\t\t\t\t/**\n\t\t\t\t * @param {Module} m module\n\t\t\t\t * @returns {number} depth\n\t\t\t\t */\n\t\t\t\tm => moduleGraph.getDepth(m),\n\t\t\t\tcompareNumbers\n\t\t\t),\n\t\t\tcompareSelect(\n\t\t\t\t/**\n\t\t\t\t * @param {Module} m module\n\t\t\t\t * @returns {number} index\n\t\t\t\t */\n\t\t\t\tm => moduleGraph.getPreOrderIndex(m),\n\t\t\t\tcompareNumbers\n\t\t\t),\n\t\t\tcompareSelect(\n\t\t\t\t/**\n\t\t\t\t * @param {Module} m module\n\t\t\t\t * @returns {string} identifier\n\t\t\t\t */\n\t\t\t\tm => m.identifier(),\n\t\t\t\tcompareIds\n\t\t\t)\n\t\t);\n\t}\n};\n\n/** @type {Record<string, Record<string, (comparators: Function[], context: StatsFactoryContext) => void>>} */\nconst SORTERS = {\n\t\"compilation.chunks\": {\n\t\t_: comparators => {\n\t\t\tcomparators.push(compareSelect(c => c.id, compareIds));\n\t\t}\n\t},\n\t\"compilation.modules\": MODULES_SORTER,\n\t\"chunk.rootModules\": MODULES_SORTER,\n\t\"chunk.modules\": MODULES_SORTER,\n\t\"module.modules\": MODULES_SORTER,\n\t\"module.reasons\": {\n\t\t_: (comparators, { compilation: { chunkGraph } }) => {\n\t\t\tcomparators.push(\n\t\t\t\tcompareSelect(x => x.originModule, compareModulesByIdentifier)\n\t\t\t);\n\t\t\tcomparators.push(\n\t\t\t\tcompareSelect(x => x.resolvedOriginModule, compareModulesByIdentifier)\n\t\t\t);\n\t\t\tcomparators.push(\n\t\t\t\tcompareSelect(\n\t\t\t\t\tx => x.dependency,\n\t\t\t\t\tconcatComparators(\n\t\t\t\t\t\tcompareSelect(\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {Dependency} x dependency\n\t\t\t\t\t\t\t * @returns {DependencyLocation} location\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tx => x.loc,\n\t\t\t\t\t\t\tcompareLocations\n\t\t\t\t\t\t),\n\t\t\t\t\t\tcompareSelect(x => x.type, compareIds)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t},\n\t\"chunk.origins\": {\n\t\t_: (comparators, { compilation: { chunkGraph } }) => {\n\t\t\tcomparators.push(\n\t\t\t\tcompareSelect(\n\t\t\t\t\torigin =>\n\t\t\t\t\t\torigin.module ? chunkGraph.getModuleId(origin.module) : undefined,\n\t\t\t\t\tcompareIds\n\t\t\t\t),\n\t\t\t\tcompareSelect(origin => formatLocation(origin.loc), compareIds),\n\t\t\t\tcompareSelect(origin => origin.request, compareIds)\n\t\t\t);\n\t\t}\n\t}\n};\n\nconst getItemSize = item => {\n\t// Each item takes 1 line\n\t// + the size of the children\n\t// + 1 extra line when it has children and filteredChildren\n\treturn !item.children\n\t\t? 1\n\t\t: item.filteredChildren\n\t\t? 2 + getTotalSize(item.children)\n\t\t: 1 + getTotalSize(item.children);\n};\n\nconst getTotalSize = children => {\n\tlet size = 0;\n\tfor (const child of children) {\n\t\tsize += getItemSize(child);\n\t}\n\treturn size;\n};\n\nconst getTotalItems = children => {\n\tlet count = 0;\n\tfor (const child of children) {\n\t\tif (!child.children && !child.filteredChildren) {\n\t\t\tcount++;\n\t\t} else {\n\t\t\tif (child.children) count += getTotalItems(child.children);\n\t\t\tif (child.filteredChildren) count += child.filteredChildren;\n\t\t}\n\t}\n\treturn count;\n};\n\nconst collapse = children => {\n\t// After collapse each child must take exactly one line\n\tconst newChildren = [];\n\tfor (const child of children) {\n\t\tif (child.children) {\n\t\t\tlet filteredChildren = child.filteredChildren || 0;\n\t\t\tfilteredChildren += getTotalItems(child.children);\n\t\t\tnewChildren.push({\n\t\t\t\t...child,\n\t\t\t\tchildren: undefined,\n\t\t\t\tfilteredChildren\n\t\t\t});\n\t\t} else {\n\t\t\tnewChildren.push(child);\n\t\t}\n\t}\n\treturn newChildren;\n};\n\nconst spaceLimited = (\n\titemsAndGroups,\n\tmax,\n\tfilteredChildrenLineReserved = false\n) => {\n\tif (max < 1) {\n\t\treturn {\n\t\t\tchildren: undefined,\n\t\t\tfilteredChildren: getTotalItems(itemsAndGroups)\n\t\t};\n\t}\n\t/** @type {any[] | undefined} */\n\tlet children = undefined;\n\t/** @type {number | undefined} */\n\tlet filteredChildren = undefined;\n\t// This are the groups, which take 1+ lines each\n\tconst groups = [];\n\t// The sizes of the groups are stored in groupSizes\n\tconst groupSizes = [];\n\t// This are the items, which take 1 line each\n\tconst items = [];\n\t// The total of group sizes\n\tlet groupsSize = 0;\n\n\tfor (const itemOrGroup of itemsAndGroups) {\n\t\t// is item\n\t\tif (!itemOrGroup.children && !itemOrGroup.filteredChildren) {\n\t\t\titems.push(itemOrGroup);\n\t\t} else {\n\t\t\tgroups.push(itemOrGroup);\n\t\t\tconst size = getItemSize(itemOrGroup);\n\t\t\tgroupSizes.push(size);\n\t\t\tgroupsSize += size;\n\t\t}\n\t}\n\n\tif (groupsSize + items.length <= max) {\n\t\t// The total size in the current state fits into the max\n\t\t// keep all\n\t\tchildren = groups.length > 0 ? groups.concat(items) : items;\n\t} else if (groups.length === 0) {\n\t\t// slice items to max\n\t\t// inner space marks that lines for filteredChildren already reserved\n\t\tconst limit = max - (filteredChildrenLineReserved ? 0 : 1);\n\t\tfilteredChildren = items.length - limit;\n\t\titems.length = limit;\n\t\tchildren = items;\n\t} else {\n\t\t// limit is the size when all groups are collapsed\n\t\tconst limit =\n\t\t\tgroups.length +\n\t\t\t(filteredChildrenLineReserved || items.length === 0 ? 0 : 1);\n\t\tif (limit < max) {\n\t\t\t// calculate how much we are over the size limit\n\t\t\t// this allows to approach the limit faster\n\t\t\tlet oversize;\n\t\t\t// If each group would take 1 line the total would be below the maximum\n\t\t\t// collapse some groups, keep items\n\t\t\twhile (\n\t\t\t\t(oversize =\n\t\t\t\t\tgroupsSize +\n\t\t\t\t\titems.length +\n\t\t\t\t\t(filteredChildren && !filteredChildrenLineReserved ? 1 : 0) -\n\t\t\t\t\tmax) > 0\n\t\t\t) {\n\t\t\t\t// Find the maximum group and process only this one\n\t\t\t\tconst maxGroupSize = Math.max(...groupSizes);\n\t\t\t\tif (maxGroupSize < items.length) {\n\t\t\t\t\tfilteredChildren = items.length;\n\t\t\t\t\titems.length = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < groups.length; i++) {\n\t\t\t\t\tif (groupSizes[i] === maxGroupSize) {\n\t\t\t\t\t\tconst group = groups[i];\n\t\t\t\t\t\t// run this algorithm recursively and limit the size of the children to\n\t\t\t\t\t\t// current size - oversize / number of groups\n\t\t\t\t\t\t// So it should always end up being smaller\n\t\t\t\t\t\tconst headerSize = group.filteredChildren ? 2 : 1;\n\t\t\t\t\t\tconst limited = spaceLimited(\n\t\t\t\t\t\t\tgroup.children,\n\t\t\t\t\t\t\tmaxGroupSize -\n\t\t\t\t\t\t\t\t// we should use ceil to always feet in max\n\t\t\t\t\t\t\t\tMath.ceil(oversize / groups.length) -\n\t\t\t\t\t\t\t\t// we substitute size of group head\n\t\t\t\t\t\t\t\theaderSize,\n\t\t\t\t\t\t\theaderSize === 2\n\t\t\t\t\t\t);\n\t\t\t\t\t\tgroups[i] = {\n\t\t\t\t\t\t\t...group,\n\t\t\t\t\t\t\tchildren: limited.children,\n\t\t\t\t\t\t\tfilteredChildren: limited.filteredChildren\n\t\t\t\t\t\t\t\t? (group.filteredChildren || 0) + limited.filteredChildren\n\t\t\t\t\t\t\t\t: group.filteredChildren\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst newSize = getItemSize(groups[i]);\n\t\t\t\t\t\tgroupsSize -= maxGroupSize - newSize;\n\t\t\t\t\t\tgroupSizes[i] = newSize;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tchildren = groups.concat(items);\n\t\t} else if (limit === max) {\n\t\t\t// If we have only enough space to show one line per group and one line for the filtered items\n\t\t\t// collapse all groups and items\n\t\t\tchildren = collapse(groups);\n\t\t\tfilteredChildren = items.length;\n\t\t} else {\n\t\t\t// If we have no space\n\t\t\t// collapse complete group\n\t\t\tfilteredChildren = getTotalItems(itemsAndGroups);\n\t\t}\n\t}\n\n\treturn {\n\t\tchildren,\n\t\tfilteredChildren\n\t};\n};\n\nconst assetGroup = (children, assets) => {\n\tlet size = 0;\n\tfor (const asset of children) {\n\t\tsize += asset.size;\n\t}\n\treturn {\n\t\tsize\n\t};\n};\n\nconst moduleGroup = (children, modules) => {\n\tlet size = 0;\n\tconst sizes = {};\n\tfor (const module of children) {\n\t\tsize += module.size;\n\t\tfor (const key of Object.keys(module.sizes)) {\n\t\t\tsizes[key] = (sizes[key] || 0) + module.sizes[key];\n\t\t}\n\t}\n\treturn {\n\t\tsize,\n\t\tsizes\n\t};\n};\n\nconst reasonGroup = (children, reasons) => {\n\tlet active = false;\n\tfor (const reason of children) {\n\t\tactive = active || reason.active;\n\t}\n\treturn {\n\t\tactive\n\t};\n};\n\nconst GROUP_EXTENSION_REGEXP = /(\\.[^.]+?)(?:\\?|(?: \\+ \\d+ modules?)?$)/;\nconst GROUP_PATH_REGEXP = /(.+)[/\\\\][^/\\\\]+?(?:\\?|(?: \\+ \\d+ modules?)?$)/;\n\n/** @type {Record<string, (groupConfigs: GroupConfig[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>} */\nconst ASSETS_GROUPERS = {\n\t_: (groupConfigs, context, options) => {\n\t\tconst groupByFlag = (name, exclude) => {\n\t\t\tgroupConfigs.push({\n\t\t\t\tgetKeys: asset => {\n\t\t\t\t\treturn asset[name] ? [\"1\"] : undefined;\n\t\t\t\t},\n\t\t\t\tgetOptions: () => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tgroupChildren: !exclude,\n\t\t\t\t\t\tforce: exclude\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tcreateGroup: (key, children, assets) => {\n\t\t\t\t\treturn exclude\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\ttype: \"assets by status\",\n\t\t\t\t\t\t\t\t[name]: !!key,\n\t\t\t\t\t\t\t\tfilteredChildren: assets.length,\n\t\t\t\t\t\t\t\t...assetGroup(children, assets)\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\ttype: \"assets by status\",\n\t\t\t\t\t\t\t\t[name]: !!key,\n\t\t\t\t\t\t\t\tchildren,\n\t\t\t\t\t\t\t\t...assetGroup(children, assets)\n\t\t\t\t\t\t  };\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\tconst {\n\t\t\tgroupAssetsByEmitStatus,\n\t\t\tgroupAssetsByPath,\n\t\t\tgroupAssetsByExtension\n\t\t} = options;\n\t\tif (groupAssetsByEmitStatus) {\n\t\t\tgroupByFlag(\"emitted\");\n\t\t\tgroupByFlag(\"comparedForEmit\");\n\t\t\tgroupByFlag(\"isOverSizeLimit\");\n\t\t}\n\t\tif (groupAssetsByEmitStatus || !options.cachedAssets) {\n\t\t\tgroupByFlag(\"cached\", !options.cachedAssets);\n\t\t}\n\t\tif (groupAssetsByPath || groupAssetsByExtension) {\n\t\t\tgroupConfigs.push({\n\t\t\t\tgetKeys: asset => {\n\t\t\t\t\tconst extensionMatch =\n\t\t\t\t\t\tgroupAssetsByExtension && GROUP_EXTENSION_REGEXP.exec(asset.name);\n\t\t\t\t\tconst extension = extensionMatch ? extensionMatch[1] : \"\";\n\t\t\t\t\tconst pathMatch =\n\t\t\t\t\t\tgroupAssetsByPath && GROUP_PATH_REGEXP.exec(asset.name);\n\t\t\t\t\tconst path = pathMatch ? pathMatch[1].split(/[/\\\\]/) : [];\n\t\t\t\t\tconst keys = [];\n\t\t\t\t\tif (groupAssetsByPath) {\n\t\t\t\t\t\tkeys.push(\".\");\n\t\t\t\t\t\tif (extension)\n\t\t\t\t\t\t\tkeys.push(\n\t\t\t\t\t\t\t\tpath.length\n\t\t\t\t\t\t\t\t\t? `${path.join(\"/\")}/*${extension}`\n\t\t\t\t\t\t\t\t\t: `*${extension}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\twhile (path.length > 0) {\n\t\t\t\t\t\t\tkeys.push(path.join(\"/\") + \"/\");\n\t\t\t\t\t\t\tpath.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (extension) keys.push(`*${extension}`);\n\t\t\t\t\t}\n\t\t\t\t\treturn keys;\n\t\t\t\t},\n\t\t\t\tcreateGroup: (key, children, assets) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: groupAssetsByPath ? \"assets by path\" : \"assets by extension\",\n\t\t\t\t\t\tname: key,\n\t\t\t\t\t\tchildren,\n\t\t\t\t\t\t...assetGroup(children, assets)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\tgroupAssetsByInfo: (groupConfigs, context, options) => {\n\t\tconst groupByAssetInfoFlag = name => {\n\t\t\tgroupConfigs.push({\n\t\t\t\tgetKeys: asset => {\n\t\t\t\t\treturn asset.info && asset.info[name] ? [\"1\"] : undefined;\n\t\t\t\t},\n\t\t\t\tcreateGroup: (key, children, assets) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"assets by info\",\n\t\t\t\t\t\tinfo: {\n\t\t\t\t\t\t\t[name]: !!key\n\t\t\t\t\t\t},\n\t\t\t\t\t\tchildren,\n\t\t\t\t\t\t...assetGroup(children, assets)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\tgroupByAssetInfoFlag(\"immutable\");\n\t\tgroupByAssetInfoFlag(\"development\");\n\t\tgroupByAssetInfoFlag(\"hotModuleReplacement\");\n\t},\n\tgroupAssetsByChunk: (groupConfigs, context, options) => {\n\t\tconst groupByNames = name => {\n\t\t\tgroupConfigs.push({\n\t\t\t\tgetKeys: asset => {\n\t\t\t\t\treturn asset[name];\n\t\t\t\t},\n\t\t\t\tcreateGroup: (key, children, assets) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"assets by chunk\",\n\t\t\t\t\t\t[name]: [key],\n\t\t\t\t\t\tchildren,\n\t\t\t\t\t\t...assetGroup(children, assets)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\tgroupByNames(\"chunkNames\");\n\t\tgroupByNames(\"auxiliaryChunkNames\");\n\t\tgroupByNames(\"chunkIdHints\");\n\t\tgroupByNames(\"auxiliaryChunkIdHints\");\n\t},\n\texcludeAssets: (groupConfigs, context, { excludeAssets }) => {\n\t\tgroupConfigs.push({\n\t\t\tgetKeys: asset => {\n\t\t\t\tconst ident = asset.name;\n\t\t\t\tconst excluded = excludeAssets.some(fn => fn(ident, asset));\n\t\t\t\tif (excluded) return [\"excluded\"];\n\t\t\t},\n\t\t\tgetOptions: () => ({\n\t\t\t\tgroupChildren: false,\n\t\t\t\tforce: true\n\t\t\t}),\n\t\t\tcreateGroup: (key, children, assets) => ({\n\t\t\t\ttype: \"hidden assets\",\n\t\t\t\tfilteredChildren: assets.length,\n\t\t\t\t...assetGroup(children, assets)\n\t\t\t})\n\t\t});\n\t}\n};\n\n/** @type {function(\"module\" | \"chunk\" | \"root-of-chunk\" | \"nested\"): Record<string, (groupConfigs: GroupConfig[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>} */\nconst MODULES_GROUPERS = type => ({\n\t_: (groupConfigs, context, options) => {\n\t\tconst groupByFlag = (name, type, exclude) => {\n\t\t\tgroupConfigs.push({\n\t\t\t\tgetKeys: module => {\n\t\t\t\t\treturn module[name] ? [\"1\"] : undefined;\n\t\t\t\t},\n\t\t\t\tgetOptions: () => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tgroupChildren: !exclude,\n\t\t\t\t\t\tforce: exclude\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tcreateGroup: (key, children, modules) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\t[name]: !!key,\n\t\t\t\t\t\t...(exclude ? { filteredChildren: modules.length } : { children }),\n\t\t\t\t\t\t...moduleGroup(children, modules)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\tconst {\n\t\t\tgroupModulesByCacheStatus,\n\t\t\tgroupModulesByLayer,\n\t\t\tgroupModulesByAttributes,\n\t\t\tgroupModulesByType,\n\t\t\tgroupModulesByPath,\n\t\t\tgroupModulesByExtension\n\t\t} = options;\n\t\tif (groupModulesByAttributes) {\n\t\t\tgroupByFlag(\"errors\", \"modules with errors\");\n\t\t\tgroupByFlag(\"warnings\", \"modules with warnings\");\n\t\t\tgroupByFlag(\"assets\", \"modules with assets\");\n\t\t\tgroupByFlag(\"optional\", \"optional modules\");\n\t\t}\n\t\tif (groupModulesByCacheStatus) {\n\t\t\tgroupByFlag(\"cacheable\", \"cacheable modules\");\n\t\t\tgroupByFlag(\"built\", \"built modules\");\n\t\t\tgroupByFlag(\"codeGenerated\", \"code generated modules\");\n\t\t}\n\t\tif (groupModulesByCacheStatus || !options.cachedModules) {\n\t\t\tgroupByFlag(\"cached\", \"cached modules\", !options.cachedModules);\n\t\t}\n\t\tif (groupModulesByAttributes || !options.orphanModules) {\n\t\t\tgroupByFlag(\"orphan\", \"orphan modules\", !options.orphanModules);\n\t\t}\n\t\tif (groupModulesByAttributes || !options.dependentModules) {\n\t\t\tgroupByFlag(\"dependent\", \"dependent modules\", !options.dependentModules);\n\t\t}\n\t\tif (groupModulesByType || !options.runtimeModules) {\n\t\t\tgroupConfigs.push({\n\t\t\t\tgetKeys: module => {\n\t\t\t\t\tif (!module.moduleType) return;\n\t\t\t\t\tif (groupModulesByType) {\n\t\t\t\t\t\treturn [module.moduleType.split(\"/\", 1)[0]];\n\t\t\t\t\t} else if (module.moduleType === \"runtime\") {\n\t\t\t\t\t\treturn [\"runtime\"];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tgetOptions: key => {\n\t\t\t\t\tconst exclude = key === \"runtime\" && !options.runtimeModules;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tgroupChildren: !exclude,\n\t\t\t\t\t\tforce: exclude\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tcreateGroup: (key, children, modules) => {\n\t\t\t\t\tconst exclude = key === \"runtime\" && !options.runtimeModules;\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: `${key} modules`,\n\t\t\t\t\t\tmoduleType: key,\n\t\t\t\t\t\t...(exclude ? { filteredChildren: modules.length } : { children }),\n\t\t\t\t\t\t...moduleGroup(children, modules)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (groupModulesByLayer) {\n\t\t\tgroupConfigs.push({\n\t\t\t\tgetKeys: module => {\n\t\t\t\t\treturn [module.layer];\n\t\t\t\t},\n\t\t\t\tcreateGroup: (key, children, modules) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"modules by layer\",\n\t\t\t\t\t\tlayer: key,\n\t\t\t\t\t\tchildren,\n\t\t\t\t\t\t...moduleGroup(children, modules)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (groupModulesByPath || groupModulesByExtension) {\n\t\t\tgroupConfigs.push({\n\t\t\t\tgetKeys: module => {\n\t\t\t\t\tif (!module.name) return;\n\t\t\t\t\tconst resource = parseResource(module.name.split(\"!\").pop()).path;\n\t\t\t\t\tconst dataUrl = /^data:[^,;]+/.exec(resource);\n\t\t\t\t\tif (dataUrl) return [dataUrl[0]];\n\t\t\t\t\tconst extensionMatch =\n\t\t\t\t\t\tgroupModulesByExtension && GROUP_EXTENSION_REGEXP.exec(resource);\n\t\t\t\t\tconst extension = extensionMatch ? extensionMatch[1] : \"\";\n\t\t\t\t\tconst pathMatch =\n\t\t\t\t\t\tgroupModulesByPath && GROUP_PATH_REGEXP.exec(resource);\n\t\t\t\t\tconst path = pathMatch ? pathMatch[1].split(/[/\\\\]/) : [];\n\t\t\t\t\tconst keys = [];\n\t\t\t\t\tif (groupModulesByPath) {\n\t\t\t\t\t\tif (extension)\n\t\t\t\t\t\t\tkeys.push(\n\t\t\t\t\t\t\t\tpath.length\n\t\t\t\t\t\t\t\t\t? `${path.join(\"/\")}/*${extension}`\n\t\t\t\t\t\t\t\t\t: `*${extension}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\twhile (path.length > 0) {\n\t\t\t\t\t\t\tkeys.push(path.join(\"/\") + \"/\");\n\t\t\t\t\t\t\tpath.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (extension) keys.push(`*${extension}`);\n\t\t\t\t\t}\n\t\t\t\t\treturn keys;\n\t\t\t\t},\n\t\t\t\tcreateGroup: (key, children, modules) => {\n\t\t\t\t\tconst isDataUrl = key.startsWith(\"data:\");\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: isDataUrl\n\t\t\t\t\t\t\t? \"modules by mime type\"\n\t\t\t\t\t\t\t: groupModulesByPath\n\t\t\t\t\t\t\t? \"modules by path\"\n\t\t\t\t\t\t\t: \"modules by extension\",\n\t\t\t\t\t\tname: isDataUrl ? key.slice(/* 'data:'.length */ 5) : key,\n\t\t\t\t\t\tchildren,\n\t\t\t\t\t\t...moduleGroup(children, modules)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\texcludeModules: (groupConfigs, context, { excludeModules }) => {\n\t\tgroupConfigs.push({\n\t\t\tgetKeys: module => {\n\t\t\t\tconst name = module.name;\n\t\t\t\tif (name) {\n\t\t\t\t\tconst excluded = excludeModules.some(fn => fn(name, module, type));\n\t\t\t\t\tif (excluded) return [\"1\"];\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetOptions: () => ({\n\t\t\t\tgroupChildren: false,\n\t\t\t\tforce: true\n\t\t\t}),\n\t\t\tcreateGroup: (key, children, modules) => ({\n\t\t\t\ttype: \"hidden modules\",\n\t\t\t\tfilteredChildren: children.length,\n\t\t\t\t...moduleGroup(children, modules)\n\t\t\t})\n\t\t});\n\t}\n});\n\n/** @type {Record<string, Record<string, (groupConfigs: GroupConfig[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>>} */\nconst RESULT_GROUPERS = {\n\t\"compilation.assets\": ASSETS_GROUPERS,\n\t\"asset.related\": ASSETS_GROUPERS,\n\t\"compilation.modules\": MODULES_GROUPERS(\"module\"),\n\t\"chunk.modules\": MODULES_GROUPERS(\"chunk\"),\n\t\"chunk.rootModules\": MODULES_GROUPERS(\"root-of-chunk\"),\n\t\"module.modules\": MODULES_GROUPERS(\"nested\"),\n\t\"module.reasons\": {\n\t\tgroupReasonsByOrigin: groupConfigs => {\n\t\t\tgroupConfigs.push({\n\t\t\t\tgetKeys: reason => {\n\t\t\t\t\treturn [reason.module];\n\t\t\t\t},\n\t\t\t\tcreateGroup: (key, children, reasons) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"from origin\",\n\t\t\t\t\t\tmodule: key,\n\t\t\t\t\t\tchildren,\n\t\t\t\t\t\t...reasonGroup(children, reasons)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n};\n\n// remove a prefixed \"!\" that can be specified to reverse sort order\nconst normalizeFieldKey = field => {\n\tif (field[0] === \"!\") {\n\t\treturn field.substr(1);\n\t}\n\treturn field;\n};\n\n// if a field is prefixed by a \"!\" reverse sort order\nconst sortOrderRegular = field => {\n\tif (field[0] === \"!\") {\n\t\treturn false;\n\t}\n\treturn true;\n};\n\n/**\n * @param {string} field field name\n * @returns {function(Object, Object): number} comparators\n */\nconst sortByField = field => {\n\tif (!field) {\n\t\t/**\n\t\t * @param {any} a first\n\t\t * @param {any} b second\n\t\t * @returns {-1|0|1} zero\n\t\t */\n\t\tconst noSort = (a, b) => 0;\n\t\treturn noSort;\n\t}\n\n\tconst fieldKey = normalizeFieldKey(field);\n\n\tlet sortFn = compareSelect(m => m[fieldKey], compareIds);\n\n\t// if a field is prefixed with a \"!\" the sort is reversed!\n\tconst sortIsRegular = sortOrderRegular(field);\n\n\tif (!sortIsRegular) {\n\t\tconst oldSortFn = sortFn;\n\t\tsortFn = (a, b) => oldSortFn(b, a);\n\t}\n\n\treturn sortFn;\n};\n\nconst ASSET_SORTERS = {\n\t/** @type {(comparators: Function[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void} */\n\tassetsSort: (comparators, context, { assetsSort }) => {\n\t\tcomparators.push(sortByField(assetsSort));\n\t},\n\t_: comparators => {\n\t\tcomparators.push(compareSelect(a => a.name, compareIds));\n\t}\n};\n\n/** @type {Record<string, Record<string, (comparators: Function[], context: StatsFactoryContext, options: NormalizedStatsOptions) => void>>} */\nconst RESULT_SORTERS = {\n\t\"compilation.chunks\": {\n\t\tchunksSort: (comparators, context, { chunksSort }) => {\n\t\t\tcomparators.push(sortByField(chunksSort));\n\t\t}\n\t},\n\t\"compilation.modules\": {\n\t\tmodulesSort: (comparators, context, { modulesSort }) => {\n\t\t\tcomparators.push(sortByField(modulesSort));\n\t\t}\n\t},\n\t\"chunk.modules\": {\n\t\tchunkModulesSort: (comparators, context, { chunkModulesSort }) => {\n\t\t\tcomparators.push(sortByField(chunkModulesSort));\n\t\t}\n\t},\n\t\"module.modules\": {\n\t\tnestedModulesSort: (comparators, context, { nestedModulesSort }) => {\n\t\t\tcomparators.push(sortByField(nestedModulesSort));\n\t\t}\n\t},\n\t\"compilation.assets\": ASSET_SORTERS,\n\t\"asset.related\": ASSET_SORTERS\n};\n\n/**\n * @param {Record<string, Record<string, Function>>} config the config see above\n * @param {NormalizedStatsOptions} options stats options\n * @param {function(string, Function): void} fn handler function called for every active line in config\n * @returns {void}\n */\nconst iterateConfig = (config, options, fn) => {\n\tfor (const hookFor of Object.keys(config)) {\n\t\tconst subConfig = config[hookFor];\n\t\tfor (const option of Object.keys(subConfig)) {\n\t\t\tif (option !== \"_\") {\n\t\t\t\tif (option.startsWith(\"!\")) {\n\t\t\t\t\tif (options[option.slice(1)]) continue;\n\t\t\t\t} else {\n\t\t\t\t\tconst value = options[option];\n\t\t\t\t\tif (\n\t\t\t\t\t\tvalue === false ||\n\t\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t\t(Array.isArray(value) && value.length === 0)\n\t\t\t\t\t)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfn(hookFor, subConfig[option]);\n\t\t}\n\t}\n};\n\n/** @type {Record<string, string>} */\nconst ITEM_NAMES = {\n\t\"compilation.children[]\": \"compilation\",\n\t\"compilation.modules[]\": \"module\",\n\t\"compilation.entrypoints[]\": \"chunkGroup\",\n\t\"compilation.namedChunkGroups[]\": \"chunkGroup\",\n\t\"compilation.errors[]\": \"error\",\n\t\"compilation.warnings[]\": \"warning\",\n\t\"chunk.modules[]\": \"module\",\n\t\"chunk.rootModules[]\": \"module\",\n\t\"chunk.origins[]\": \"chunkOrigin\",\n\t\"compilation.chunks[]\": \"chunk\",\n\t\"compilation.assets[]\": \"asset\",\n\t\"asset.related[]\": \"asset\",\n\t\"module.issuerPath[]\": \"moduleIssuer\",\n\t\"module.reasons[]\": \"moduleReason\",\n\t\"module.modules[]\": \"module\",\n\t\"module.children[]\": \"module\",\n\t\"moduleTrace[]\": \"moduleTraceItem\",\n\t\"moduleTraceItem.dependencies[]\": \"moduleTraceDependency\"\n};\n\n/**\n * @param {Object[]} items items to be merged\n * @returns {Object} an object\n */\nconst mergeToObject = items => {\n\tconst obj = Object.create(null);\n\tfor (const item of items) {\n\t\tobj[item.name] = item;\n\t}\n\treturn obj;\n};\n\n/** @type {Record<string, (items: Object[]) => any>} */\nconst MERGER = {\n\t\"compilation.entrypoints\": mergeToObject,\n\t\"compilation.namedChunkGroups\": mergeToObject\n};\n\nclass DefaultStatsFactoryPlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"DefaultStatsFactoryPlugin\", compilation => {\n\t\t\tcompilation.hooks.statsFactory.tap(\n\t\t\t\t\"DefaultStatsFactoryPlugin\",\n\t\t\t\t(stats, options, context) => {\n\t\t\t\t\titerateConfig(SIMPLE_EXTRACTORS, options, (hookFor, fn) => {\n\t\t\t\t\t\tstats.hooks.extract\n\t\t\t\t\t\t\t.for(hookFor)\n\t\t\t\t\t\t\t.tap(\"DefaultStatsFactoryPlugin\", (obj, data, ctx) =>\n\t\t\t\t\t\t\t\tfn(obj, data, ctx, options, stats)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\titerateConfig(FILTER, options, (hookFor, fn) => {\n\t\t\t\t\t\tstats.hooks.filter\n\t\t\t\t\t\t\t.for(hookFor)\n\t\t\t\t\t\t\t.tap(\"DefaultStatsFactoryPlugin\", (item, ctx, idx, i) =>\n\t\t\t\t\t\t\t\tfn(item, ctx, options, idx, i)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\titerateConfig(FILTER_RESULTS, options, (hookFor, fn) => {\n\t\t\t\t\t\tstats.hooks.filterResults\n\t\t\t\t\t\t\t.for(hookFor)\n\t\t\t\t\t\t\t.tap(\"DefaultStatsFactoryPlugin\", (item, ctx, idx, i) =>\n\t\t\t\t\t\t\t\tfn(item, ctx, options, idx, i)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\titerateConfig(SORTERS, options, (hookFor, fn) => {\n\t\t\t\t\t\tstats.hooks.sort\n\t\t\t\t\t\t\t.for(hookFor)\n\t\t\t\t\t\t\t.tap(\"DefaultStatsFactoryPlugin\", (comparators, ctx) =>\n\t\t\t\t\t\t\t\tfn(comparators, ctx, options)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\titerateConfig(RESULT_SORTERS, options, (hookFor, fn) => {\n\t\t\t\t\t\tstats.hooks.sortResults\n\t\t\t\t\t\t\t.for(hookFor)\n\t\t\t\t\t\t\t.tap(\"DefaultStatsFactoryPlugin\", (comparators, ctx) =>\n\t\t\t\t\t\t\t\tfn(comparators, ctx, options)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\titerateConfig(RESULT_GROUPERS, options, (hookFor, fn) => {\n\t\t\t\t\t\tstats.hooks.groupResults\n\t\t\t\t\t\t\t.for(hookFor)\n\t\t\t\t\t\t\t.tap(\"DefaultStatsFactoryPlugin\", (groupConfigs, ctx) =>\n\t\t\t\t\t\t\t\tfn(groupConfigs, ctx, options)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\tfor (const key of Object.keys(ITEM_NAMES)) {\n\t\t\t\t\t\tconst itemName = ITEM_NAMES[key];\n\t\t\t\t\t\tstats.hooks.getItemName\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\"DefaultStatsFactoryPlugin\", () => itemName);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const key of Object.keys(MERGER)) {\n\t\t\t\t\t\tconst merger = MERGER[key];\n\t\t\t\t\t\tstats.hooks.merge.for(key).tap(\"DefaultStatsFactoryPlugin\", merger);\n\t\t\t\t\t}\n\t\t\t\t\tif (options.children) {\n\t\t\t\t\t\tif (Array.isArray(options.children)) {\n\t\t\t\t\t\t\tstats.hooks.getItemFactory\n\t\t\t\t\t\t\t\t.for(\"compilation.children[].compilation\")\n\t\t\t\t\t\t\t\t.tap(\"DefaultStatsFactoryPlugin\", (comp, { _index: idx }) => {\n\t\t\t\t\t\t\t\t\tif (idx < options.children.length) {\n\t\t\t\t\t\t\t\t\t\treturn compilation.createStatsFactory(\n\t\t\t\t\t\t\t\t\t\t\tcompilation.createStatsOptions(\n\t\t\t\t\t\t\t\t\t\t\t\toptions.children[idx],\n\t\t\t\t\t\t\t\t\t\t\t\tcontext\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else if (options.children !== true) {\n\t\t\t\t\t\t\tconst childFactory = compilation.createStatsFactory(\n\t\t\t\t\t\t\t\tcompilation.createStatsOptions(options.children, context)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tstats.hooks.getItemFactory\n\t\t\t\t\t\t\t\t.for(\"compilation.children[].compilation\")\n\t\t\t\t\t\t\t\t.tap(\"DefaultStatsFactoryPlugin\", () => {\n\t\t\t\t\t\t\t\t\treturn childFactory;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = DefaultStatsFactoryPlugin;\n"]},"metadata":{},"sourceType":"script"}