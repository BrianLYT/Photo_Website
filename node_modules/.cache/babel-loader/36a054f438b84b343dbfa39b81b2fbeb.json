{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  RawSource\n} = require(\"webpack-sources\");\n\nconst Generator = require(\"../Generator\");\n\nconst WebAssemblyUtils = require(\"./WebAssemblyUtils\");\n\nconst t = require(\"@webassemblyjs/ast\");\n\nconst {\n  moduleContextFromModuleAST\n} = require(\"@webassemblyjs/ast\");\n\nconst {\n  editWithAST,\n  addWithAST\n} = require(\"@webassemblyjs/wasm-edit\");\n\nconst {\n  decode\n} = require(\"@webassemblyjs/wasm-parser\");\n\nconst WebAssemblyExportImportedDependency = require(\"../dependencies/WebAssemblyExportImportedDependency\");\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../DependencyTemplates\")} DependencyTemplates */\n\n/** @typedef {import(\"../Generator\").GenerateContext} GenerateContext */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @typedef {import(\"./WebAssemblyUtils\").UsedWasmDependency} UsedWasmDependency */\n\n/**\n * @typedef {(ArrayBuffer) => ArrayBuffer} ArrayBufferTransform\n */\n\n/**\n * @template T\n * @param {Function[]} fns transforms\n * @returns {Function} composed transform\n */\n\n\nconst compose = function () {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return fns.reduce((prevFn, nextFn) => {\n    return value => nextFn(prevFn(value));\n  }, value => value);\n};\n/**\n * Removes the start instruction\n *\n * @param {Object} state unused state\n * @returns {ArrayBufferTransform} transform\n */\n\n\nconst removeStartFunc = state => bin => {\n  return editWithAST(state.ast, bin, {\n    Start(path) {\n      path.remove();\n    }\n\n  });\n};\n/**\n * Get imported globals\n *\n * @param {Object} ast Module's AST\n * @returns {Array<t.ModuleImport>} - nodes\n */\n\n\nconst getImportedGlobals = ast => {\n  const importedGlobals = [];\n  t.traverse(ast, {\n    ModuleImport(_ref) {\n      let {\n        node\n      } = _ref;\n\n      if (t.isGlobalType(node.descr)) {\n        importedGlobals.push(node);\n      }\n    }\n\n  });\n  return importedGlobals;\n};\n/**\n * Get the count for imported func\n *\n * @param {Object} ast Module's AST\n * @returns {Number} - count\n */\n\n\nconst getCountImportedFunc = ast => {\n  let count = 0;\n  t.traverse(ast, {\n    ModuleImport(_ref2) {\n      let {\n        node\n      } = _ref2;\n\n      if (t.isFuncImportDescr(node.descr)) {\n        count++;\n      }\n    }\n\n  });\n  return count;\n};\n/**\n * Get next type index\n *\n * @param {Object} ast Module's AST\n * @returns {t.Index} - index\n */\n\n\nconst getNextTypeIndex = ast => {\n  const typeSectionMetadata = t.getSectionMetadata(ast, \"type\");\n\n  if (typeSectionMetadata === undefined) {\n    return t.indexLiteral(0);\n  }\n\n  return t.indexLiteral(typeSectionMetadata.vectorOfSize.value);\n};\n/**\n * Get next func index\n *\n * The Func section metadata provide informations for implemented funcs\n * in order to have the correct index we shift the index by number of external\n * functions.\n *\n * @param {Object} ast Module's AST\n * @param {Number} countImportedFunc number of imported funcs\n * @returns {t.Index} - index\n */\n\n\nconst getNextFuncIndex = (ast, countImportedFunc) => {\n  const funcSectionMetadata = t.getSectionMetadata(ast, \"func\");\n\n  if (funcSectionMetadata === undefined) {\n    return t.indexLiteral(0 + countImportedFunc);\n  }\n\n  const vectorOfSize = funcSectionMetadata.vectorOfSize.value;\n  return t.indexLiteral(vectorOfSize + countImportedFunc);\n};\n/**\n * Creates an init instruction for a global type\n * @param {t.GlobalType} globalType the global type\n * @returns {t.Instruction} init expression\n */\n\n\nconst createDefaultInitForGlobal = globalType => {\n  if (globalType.valtype[0] === \"i\") {\n    // create NumberLiteral global initializer\n    return t.objectInstruction(\"const\", globalType.valtype, [t.numberLiteralFromRaw(66)]);\n  } else if (globalType.valtype[0] === \"f\") {\n    // create FloatLiteral global initializer\n    return t.objectInstruction(\"const\", globalType.valtype, [t.floatLiteral(66, false, false, \"66\")]);\n  } else {\n    throw new Error(\"unknown type: \" + globalType.valtype);\n  }\n};\n/**\n * Rewrite the import globals:\n * - removes the ModuleImport instruction\n * - injects at the same offset a mutable global of the same type\n *\n * Since the imported globals are before the other global declarations, our\n * indices will be preserved.\n *\n * Note that globals will become mutable.\n *\n * @param {Object} state unused state\n * @returns {ArrayBufferTransform} transform\n */\n\n\nconst rewriteImportedGlobals = state => bin => {\n  const additionalInitCode = state.additionalInitCode;\n  const newGlobals = [];\n  bin = editWithAST(state.ast, bin, {\n    ModuleImport(path) {\n      if (t.isGlobalType(path.node.descr)) {\n        const globalType = path.node.descr;\n        globalType.mutability = \"var\";\n        const init = [createDefaultInitForGlobal(globalType), t.instruction(\"end\")];\n        newGlobals.push(t.global(globalType, init));\n        path.remove();\n      }\n    },\n\n    // in order to preserve non-imported global's order we need to re-inject\n    // those as well\n    Global(path) {\n      const {\n        node\n      } = path;\n      const [init] = node.init;\n\n      if (init.id === \"get_global\") {\n        node.globalType.mutability = \"var\";\n        const initialGlobalIdx = init.args[0];\n        node.init = [createDefaultInitForGlobal(node.globalType), t.instruction(\"end\")];\n        additionalInitCode.push(\n        /**\n         * get_global in global initializer only works for imported globals.\n         * They have the same indices as the init params, so use the\n         * same index.\n         */\n        t.instruction(\"get_local\", [initialGlobalIdx]), t.instruction(\"set_global\", [t.indexLiteral(newGlobals.length)]));\n      }\n\n      newGlobals.push(node);\n      path.remove();\n    }\n\n  }); // Add global declaration instructions\n\n  return addWithAST(state.ast, bin, newGlobals);\n};\n/**\n * Rewrite the export names\n * @param {Object} state state\n * @param {Object} state.ast Module's ast\n * @param {Module} state.module Module\n * @param {ModuleGraph} state.moduleGraph module graph\n * @param {Set<string>} state.externalExports Module\n * @param {RuntimeSpec} state.runtime runtime\n * @returns {ArrayBufferTransform} transform\n */\n\n\nconst rewriteExportNames = _ref3 => {\n  let {\n    ast,\n    moduleGraph,\n    module,\n    externalExports,\n    runtime\n  } = _ref3;\n  return bin => {\n    return editWithAST(ast, bin, {\n      ModuleExport(path) {\n        const isExternal = externalExports.has(path.node.name);\n\n        if (isExternal) {\n          path.remove();\n          return;\n        }\n\n        const usedName = moduleGraph.getExportsInfo(module).getUsedName(path.node.name, runtime);\n\n        if (!usedName) {\n          path.remove();\n          return;\n        }\n\n        path.node.name = usedName;\n      }\n\n    });\n  };\n};\n/**\n * Mangle import names and modules\n * @param {Object} state state\n * @param {Object} state.ast Module's ast\n * @param {Map<string, UsedWasmDependency>} state.usedDependencyMap mappings to mangle names\n * @returns {ArrayBufferTransform} transform\n */\n\n\nconst rewriteImports = _ref4 => {\n  let {\n    ast,\n    usedDependencyMap\n  } = _ref4;\n  return bin => {\n    return editWithAST(ast, bin, {\n      ModuleImport(path) {\n        const result = usedDependencyMap.get(path.node.module + \":\" + path.node.name);\n\n        if (result !== undefined) {\n          path.node.module = result.module;\n          path.node.name = result.name;\n        }\n      }\n\n    });\n  };\n};\n/**\n * Add an init function.\n *\n * The init function fills the globals given input arguments.\n *\n * @param {Object} state transformation state\n * @param {Object} state.ast Module's ast\n * @param {t.Identifier} state.initFuncId identifier of the init function\n * @param {t.Index} state.startAtFuncOffset index of the start function\n * @param {t.ModuleImport[]} state.importedGlobals list of imported globals\n * @param {t.Instruction[]} state.additionalInitCode list of addition instructions for the init function\n * @param {t.Index} state.nextFuncIndex index of the next function\n * @param {t.Index} state.nextTypeIndex index of the next type\n * @returns {ArrayBufferTransform} transform\n */\n\n\nconst addInitFunction = _ref5 => {\n  let {\n    ast,\n    initFuncId,\n    startAtFuncOffset,\n    importedGlobals,\n    additionalInitCode,\n    nextFuncIndex,\n    nextTypeIndex\n  } = _ref5;\n  return bin => {\n    const funcParams = importedGlobals.map(importedGlobal => {\n      // used for debugging\n      const id = t.identifier(`${importedGlobal.module}.${importedGlobal.name}`);\n      return t.funcParam(importedGlobal.descr.valtype, id);\n    });\n    const funcBody = [];\n    importedGlobals.forEach((importedGlobal, index) => {\n      const args = [t.indexLiteral(index)];\n      const body = [t.instruction(\"get_local\", args), t.instruction(\"set_global\", args)];\n      funcBody.push(...body);\n    });\n\n    if (typeof startAtFuncOffset === \"number\") {\n      funcBody.push(t.callInstruction(t.numberLiteralFromRaw(startAtFuncOffset)));\n    }\n\n    for (const instr of additionalInitCode) {\n      funcBody.push(instr);\n    }\n\n    funcBody.push(t.instruction(\"end\"));\n    const funcResults = []; // Code section\n\n    const funcSignature = t.signature(funcParams, funcResults);\n    const func = t.func(initFuncId, funcSignature, funcBody); // Type section\n\n    const functype = t.typeInstruction(undefined, funcSignature); // Func section\n\n    const funcindex = t.indexInFuncSection(nextTypeIndex); // Export section\n\n    const moduleExport = t.moduleExport(initFuncId.value, t.moduleExportDescr(\"Func\", nextFuncIndex));\n    return addWithAST(ast, bin, [func, moduleExport, funcindex, functype]);\n  };\n};\n/**\n * Extract mangle mappings from module\n * @param {ModuleGraph} moduleGraph module graph\n * @param {Module} module current module\n * @param {boolean} mangle mangle imports\n * @returns {Map<string, UsedWasmDependency>} mappings to mangled names\n */\n\n\nconst getUsedDependencyMap = (moduleGraph, module, mangle) => {\n  /** @type {Map<string, UsedWasmDependency>} */\n  const map = new Map();\n\n  for (const usedDep of WebAssemblyUtils.getUsedDependencies(moduleGraph, module, mangle)) {\n    const dep = usedDep.dependency;\n    const request = dep.request;\n    const exportName = dep.name;\n    map.set(request + \":\" + exportName, usedDep);\n  }\n\n  return map;\n};\n\nconst TYPES = new Set([\"webassembly\"]);\n\nclass WebAssemblyGenerator extends Generator {\n  constructor(options) {\n    super();\n    this.options = options;\n  }\n  /**\n   * @param {NormalModule} module fresh module\n   * @returns {Set<string>} available types (do not mutate)\n   */\n\n\n  getTypes(module) {\n    return TYPES;\n  }\n  /**\n   * @param {NormalModule} module the module\n   * @param {string=} type source type\n   * @returns {number} estimate size of the module\n   */\n\n\n  getSize(module, type) {\n    const originalSource = module.originalSource();\n\n    if (!originalSource) {\n      return 0;\n    }\n\n    return originalSource.size();\n  }\n  /**\n   * @param {NormalModule} module module for which the code should be generated\n   * @param {GenerateContext} generateContext context for generate\n   * @returns {Source} generated code\n   */\n\n\n  generate(module, _ref6) {\n    let {\n      moduleGraph,\n      runtime\n    } = _ref6;\n    const bin = module.originalSource().source();\n    const initFuncId = t.identifier(\"\"); // parse it\n\n    const ast = decode(bin, {\n      ignoreDataSection: true,\n      ignoreCodeSection: true,\n      ignoreCustomNameSection: true\n    });\n    const moduleContext = moduleContextFromModuleAST(ast.body[0]);\n    const importedGlobals = getImportedGlobals(ast);\n    const countImportedFunc = getCountImportedFunc(ast);\n    const startAtFuncOffset = moduleContext.getStart();\n    const nextFuncIndex = getNextFuncIndex(ast, countImportedFunc);\n    const nextTypeIndex = getNextTypeIndex(ast);\n    const usedDependencyMap = getUsedDependencyMap(moduleGraph, module, this.options.mangleImports);\n    const externalExports = new Set(module.dependencies.filter(d => d instanceof WebAssemblyExportImportedDependency).map(d => {\n      const wasmDep =\n      /** @type {WebAssemblyExportImportedDependency} */\n      d;\n      return wasmDep.exportName;\n    }));\n    /** @type {t.Instruction[]} */\n\n    const additionalInitCode = [];\n    const transform = compose(rewriteExportNames({\n      ast,\n      moduleGraph,\n      module,\n      externalExports,\n      runtime\n    }), removeStartFunc({\n      ast\n    }), rewriteImportedGlobals({\n      ast,\n      additionalInitCode\n    }), rewriteImports({\n      ast,\n      usedDependencyMap\n    }), addInitFunction({\n      ast,\n      initFuncId,\n      importedGlobals,\n      additionalInitCode,\n      startAtFuncOffset,\n      nextFuncIndex,\n      nextTypeIndex\n    }));\n    const newBin = transform(bin);\n    const newBuf = Buffer.from(newBin);\n    return new RawSource(newBuf);\n  }\n\n}\n\nmodule.exports = WebAssemblyGenerator;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/wasm-sync/WebAssemblyGenerator.js"],"names":["RawSource","require","Generator","WebAssemblyUtils","t","moduleContextFromModuleAST","editWithAST","addWithAST","decode","WebAssemblyExportImportedDependency","compose","fns","reduce","prevFn","nextFn","value","removeStartFunc","state","bin","ast","Start","path","remove","getImportedGlobals","importedGlobals","traverse","ModuleImport","node","isGlobalType","descr","push","getCountImportedFunc","count","isFuncImportDescr","getNextTypeIndex","typeSectionMetadata","getSectionMetadata","undefined","indexLiteral","vectorOfSize","getNextFuncIndex","countImportedFunc","funcSectionMetadata","createDefaultInitForGlobal","globalType","valtype","objectInstruction","numberLiteralFromRaw","floatLiteral","Error","rewriteImportedGlobals","additionalInitCode","newGlobals","mutability","init","instruction","global","Global","id","initialGlobalIdx","args","length","rewriteExportNames","moduleGraph","module","externalExports","runtime","ModuleExport","isExternal","has","name","usedName","getExportsInfo","getUsedName","rewriteImports","usedDependencyMap","result","get","addInitFunction","initFuncId","startAtFuncOffset","nextFuncIndex","nextTypeIndex","funcParams","map","importedGlobal","identifier","funcParam","funcBody","forEach","index","body","callInstruction","instr","funcResults","funcSignature","signature","func","functype","typeInstruction","funcindex","indexInFuncSection","moduleExport","moduleExportDescr","getUsedDependencyMap","mangle","Map","usedDep","getUsedDependencies","dep","dependency","request","exportName","set","TYPES","Set","WebAssemblyGenerator","constructor","options","getTypes","getSize","type","originalSource","size","generate","source","ignoreDataSection","ignoreCodeSection","ignoreCustomNameSection","moduleContext","getStart","mangleImports","dependencies","filter","d","wasmDep","transform","newBin","newBuf","Buffer","from","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { RawSource } = require(\"webpack-sources\");\nconst Generator = require(\"../Generator\");\nconst WebAssemblyUtils = require(\"./WebAssemblyUtils\");\n\nconst t = require(\"@webassemblyjs/ast\");\nconst { moduleContextFromModuleAST } = require(\"@webassemblyjs/ast\");\nconst { editWithAST, addWithAST } = require(\"@webassemblyjs/wasm-edit\");\nconst { decode } = require(\"@webassemblyjs/wasm-parser\");\n\nconst WebAssemblyExportImportedDependency = require(\"../dependencies/WebAssemblyExportImportedDependency\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../DependencyTemplates\")} DependencyTemplates */\n/** @typedef {import(\"../Generator\").GenerateContext} GenerateContext */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n/** @typedef {import(\"./WebAssemblyUtils\").UsedWasmDependency} UsedWasmDependency */\n\n/**\n * @typedef {(ArrayBuffer) => ArrayBuffer} ArrayBufferTransform\n */\n\n/**\n * @template T\n * @param {Function[]} fns transforms\n * @returns {Function} composed transform\n */\nconst compose = (...fns) => {\n\treturn fns.reduce(\n\t\t(prevFn, nextFn) => {\n\t\t\treturn value => nextFn(prevFn(value));\n\t\t},\n\t\tvalue => value\n\t);\n};\n\n/**\n * Removes the start instruction\n *\n * @param {Object} state unused state\n * @returns {ArrayBufferTransform} transform\n */\nconst removeStartFunc = state => bin => {\n\treturn editWithAST(state.ast, bin, {\n\t\tStart(path) {\n\t\t\tpath.remove();\n\t\t}\n\t});\n};\n\n/**\n * Get imported globals\n *\n * @param {Object} ast Module's AST\n * @returns {Array<t.ModuleImport>} - nodes\n */\nconst getImportedGlobals = ast => {\n\tconst importedGlobals = [];\n\n\tt.traverse(ast, {\n\t\tModuleImport({ node }) {\n\t\t\tif (t.isGlobalType(node.descr)) {\n\t\t\t\timportedGlobals.push(node);\n\t\t\t}\n\t\t}\n\t});\n\n\treturn importedGlobals;\n};\n\n/**\n * Get the count for imported func\n *\n * @param {Object} ast Module's AST\n * @returns {Number} - count\n */\nconst getCountImportedFunc = ast => {\n\tlet count = 0;\n\n\tt.traverse(ast, {\n\t\tModuleImport({ node }) {\n\t\t\tif (t.isFuncImportDescr(node.descr)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn count;\n};\n\n/**\n * Get next type index\n *\n * @param {Object} ast Module's AST\n * @returns {t.Index} - index\n */\nconst getNextTypeIndex = ast => {\n\tconst typeSectionMetadata = t.getSectionMetadata(ast, \"type\");\n\n\tif (typeSectionMetadata === undefined) {\n\t\treturn t.indexLiteral(0);\n\t}\n\n\treturn t.indexLiteral(typeSectionMetadata.vectorOfSize.value);\n};\n\n/**\n * Get next func index\n *\n * The Func section metadata provide informations for implemented funcs\n * in order to have the correct index we shift the index by number of external\n * functions.\n *\n * @param {Object} ast Module's AST\n * @param {Number} countImportedFunc number of imported funcs\n * @returns {t.Index} - index\n */\nconst getNextFuncIndex = (ast, countImportedFunc) => {\n\tconst funcSectionMetadata = t.getSectionMetadata(ast, \"func\");\n\n\tif (funcSectionMetadata === undefined) {\n\t\treturn t.indexLiteral(0 + countImportedFunc);\n\t}\n\n\tconst vectorOfSize = funcSectionMetadata.vectorOfSize.value;\n\n\treturn t.indexLiteral(vectorOfSize + countImportedFunc);\n};\n\n/**\n * Creates an init instruction for a global type\n * @param {t.GlobalType} globalType the global type\n * @returns {t.Instruction} init expression\n */\nconst createDefaultInitForGlobal = globalType => {\n\tif (globalType.valtype[0] === \"i\") {\n\t\t// create NumberLiteral global initializer\n\t\treturn t.objectInstruction(\"const\", globalType.valtype, [\n\t\t\tt.numberLiteralFromRaw(66)\n\t\t]);\n\t} else if (globalType.valtype[0] === \"f\") {\n\t\t// create FloatLiteral global initializer\n\t\treturn t.objectInstruction(\"const\", globalType.valtype, [\n\t\t\tt.floatLiteral(66, false, false, \"66\")\n\t\t]);\n\t} else {\n\t\tthrow new Error(\"unknown type: \" + globalType.valtype);\n\t}\n};\n\n/**\n * Rewrite the import globals:\n * - removes the ModuleImport instruction\n * - injects at the same offset a mutable global of the same type\n *\n * Since the imported globals are before the other global declarations, our\n * indices will be preserved.\n *\n * Note that globals will become mutable.\n *\n * @param {Object} state unused state\n * @returns {ArrayBufferTransform} transform\n */\nconst rewriteImportedGlobals = state => bin => {\n\tconst additionalInitCode = state.additionalInitCode;\n\tconst newGlobals = [];\n\n\tbin = editWithAST(state.ast, bin, {\n\t\tModuleImport(path) {\n\t\t\tif (t.isGlobalType(path.node.descr)) {\n\t\t\t\tconst globalType = path.node.descr;\n\n\t\t\t\tglobalType.mutability = \"var\";\n\n\t\t\t\tconst init = [\n\t\t\t\t\tcreateDefaultInitForGlobal(globalType),\n\t\t\t\t\tt.instruction(\"end\")\n\t\t\t\t];\n\n\t\t\t\tnewGlobals.push(t.global(globalType, init));\n\n\t\t\t\tpath.remove();\n\t\t\t}\n\t\t},\n\n\t\t// in order to preserve non-imported global's order we need to re-inject\n\t\t// those as well\n\t\tGlobal(path) {\n\t\t\tconst { node } = path;\n\t\t\tconst [init] = node.init;\n\n\t\t\tif (init.id === \"get_global\") {\n\t\t\t\tnode.globalType.mutability = \"var\";\n\n\t\t\t\tconst initialGlobalIdx = init.args[0];\n\n\t\t\t\tnode.init = [\n\t\t\t\t\tcreateDefaultInitForGlobal(node.globalType),\n\t\t\t\t\tt.instruction(\"end\")\n\t\t\t\t];\n\n\t\t\t\tadditionalInitCode.push(\n\t\t\t\t\t/**\n\t\t\t\t\t * get_global in global initializer only works for imported globals.\n\t\t\t\t\t * They have the same indices as the init params, so use the\n\t\t\t\t\t * same index.\n\t\t\t\t\t */\n\t\t\t\t\tt.instruction(\"get_local\", [initialGlobalIdx]),\n\t\t\t\t\tt.instruction(\"set_global\", [t.indexLiteral(newGlobals.length)])\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tnewGlobals.push(node);\n\n\t\t\tpath.remove();\n\t\t}\n\t});\n\n\t// Add global declaration instructions\n\treturn addWithAST(state.ast, bin, newGlobals);\n};\n\n/**\n * Rewrite the export names\n * @param {Object} state state\n * @param {Object} state.ast Module's ast\n * @param {Module} state.module Module\n * @param {ModuleGraph} state.moduleGraph module graph\n * @param {Set<string>} state.externalExports Module\n * @param {RuntimeSpec} state.runtime runtime\n * @returns {ArrayBufferTransform} transform\n */\nconst rewriteExportNames =\n\t({ ast, moduleGraph, module, externalExports, runtime }) =>\n\tbin => {\n\t\treturn editWithAST(ast, bin, {\n\t\t\tModuleExport(path) {\n\t\t\t\tconst isExternal = externalExports.has(path.node.name);\n\t\t\t\tif (isExternal) {\n\t\t\t\t\tpath.remove();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst usedName = moduleGraph\n\t\t\t\t\t.getExportsInfo(module)\n\t\t\t\t\t.getUsedName(path.node.name, runtime);\n\t\t\t\tif (!usedName) {\n\t\t\t\t\tpath.remove();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpath.node.name = usedName;\n\t\t\t}\n\t\t});\n\t};\n\n/**\n * Mangle import names and modules\n * @param {Object} state state\n * @param {Object} state.ast Module's ast\n * @param {Map<string, UsedWasmDependency>} state.usedDependencyMap mappings to mangle names\n * @returns {ArrayBufferTransform} transform\n */\nconst rewriteImports =\n\t({ ast, usedDependencyMap }) =>\n\tbin => {\n\t\treturn editWithAST(ast, bin, {\n\t\t\tModuleImport(path) {\n\t\t\t\tconst result = usedDependencyMap.get(\n\t\t\t\t\tpath.node.module + \":\" + path.node.name\n\t\t\t\t);\n\n\t\t\t\tif (result !== undefined) {\n\t\t\t\t\tpath.node.module = result.module;\n\t\t\t\t\tpath.node.name = result.name;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n/**\n * Add an init function.\n *\n * The init function fills the globals given input arguments.\n *\n * @param {Object} state transformation state\n * @param {Object} state.ast Module's ast\n * @param {t.Identifier} state.initFuncId identifier of the init function\n * @param {t.Index} state.startAtFuncOffset index of the start function\n * @param {t.ModuleImport[]} state.importedGlobals list of imported globals\n * @param {t.Instruction[]} state.additionalInitCode list of addition instructions for the init function\n * @param {t.Index} state.nextFuncIndex index of the next function\n * @param {t.Index} state.nextTypeIndex index of the next type\n * @returns {ArrayBufferTransform} transform\n */\nconst addInitFunction =\n\t({\n\t\tast,\n\t\tinitFuncId,\n\t\tstartAtFuncOffset,\n\t\timportedGlobals,\n\t\tadditionalInitCode,\n\t\tnextFuncIndex,\n\t\tnextTypeIndex\n\t}) =>\n\tbin => {\n\t\tconst funcParams = importedGlobals.map(importedGlobal => {\n\t\t\t// used for debugging\n\t\t\tconst id = t.identifier(\n\t\t\t\t`${importedGlobal.module}.${importedGlobal.name}`\n\t\t\t);\n\n\t\t\treturn t.funcParam(importedGlobal.descr.valtype, id);\n\t\t});\n\n\t\tconst funcBody = [];\n\t\timportedGlobals.forEach((importedGlobal, index) => {\n\t\t\tconst args = [t.indexLiteral(index)];\n\t\t\tconst body = [\n\t\t\t\tt.instruction(\"get_local\", args),\n\t\t\t\tt.instruction(\"set_global\", args)\n\t\t\t];\n\n\t\t\tfuncBody.push(...body);\n\t\t});\n\n\t\tif (typeof startAtFuncOffset === \"number\") {\n\t\t\tfuncBody.push(\n\t\t\t\tt.callInstruction(t.numberLiteralFromRaw(startAtFuncOffset))\n\t\t\t);\n\t\t}\n\n\t\tfor (const instr of additionalInitCode) {\n\t\t\tfuncBody.push(instr);\n\t\t}\n\n\t\tfuncBody.push(t.instruction(\"end\"));\n\n\t\tconst funcResults = [];\n\n\t\t// Code section\n\t\tconst funcSignature = t.signature(funcParams, funcResults);\n\t\tconst func = t.func(initFuncId, funcSignature, funcBody);\n\n\t\t// Type section\n\t\tconst functype = t.typeInstruction(undefined, funcSignature);\n\n\t\t// Func section\n\t\tconst funcindex = t.indexInFuncSection(nextTypeIndex);\n\n\t\t// Export section\n\t\tconst moduleExport = t.moduleExport(\n\t\t\tinitFuncId.value,\n\t\t\tt.moduleExportDescr(\"Func\", nextFuncIndex)\n\t\t);\n\n\t\treturn addWithAST(ast, bin, [func, moduleExport, funcindex, functype]);\n\t};\n\n/**\n * Extract mangle mappings from module\n * @param {ModuleGraph} moduleGraph module graph\n * @param {Module} module current module\n * @param {boolean} mangle mangle imports\n * @returns {Map<string, UsedWasmDependency>} mappings to mangled names\n */\nconst getUsedDependencyMap = (moduleGraph, module, mangle) => {\n\t/** @type {Map<string, UsedWasmDependency>} */\n\tconst map = new Map();\n\tfor (const usedDep of WebAssemblyUtils.getUsedDependencies(\n\t\tmoduleGraph,\n\t\tmodule,\n\t\tmangle\n\t)) {\n\t\tconst dep = usedDep.dependency;\n\t\tconst request = dep.request;\n\t\tconst exportName = dep.name;\n\t\tmap.set(request + \":\" + exportName, usedDep);\n\t}\n\treturn map;\n};\n\nconst TYPES = new Set([\"webassembly\"]);\n\nclass WebAssemblyGenerator extends Generator {\n\tconstructor(options) {\n\t\tsuper();\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * @param {NormalModule} module fresh module\n\t * @returns {Set<string>} available types (do not mutate)\n\t */\n\tgetTypes(module) {\n\t\treturn TYPES;\n\t}\n\n\t/**\n\t * @param {NormalModule} module the module\n\t * @param {string=} type source type\n\t * @returns {number} estimate size of the module\n\t */\n\tgetSize(module, type) {\n\t\tconst originalSource = module.originalSource();\n\t\tif (!originalSource) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn originalSource.size();\n\t}\n\n\t/**\n\t * @param {NormalModule} module module for which the code should be generated\n\t * @param {GenerateContext} generateContext context for generate\n\t * @returns {Source} generated code\n\t */\n\tgenerate(module, { moduleGraph, runtime }) {\n\t\tconst bin = module.originalSource().source();\n\n\t\tconst initFuncId = t.identifier(\"\");\n\n\t\t// parse it\n\t\tconst ast = decode(bin, {\n\t\t\tignoreDataSection: true,\n\t\t\tignoreCodeSection: true,\n\t\t\tignoreCustomNameSection: true\n\t\t});\n\n\t\tconst moduleContext = moduleContextFromModuleAST(ast.body[0]);\n\n\t\tconst importedGlobals = getImportedGlobals(ast);\n\t\tconst countImportedFunc = getCountImportedFunc(ast);\n\t\tconst startAtFuncOffset = moduleContext.getStart();\n\t\tconst nextFuncIndex = getNextFuncIndex(ast, countImportedFunc);\n\t\tconst nextTypeIndex = getNextTypeIndex(ast);\n\n\t\tconst usedDependencyMap = getUsedDependencyMap(\n\t\t\tmoduleGraph,\n\t\t\tmodule,\n\t\t\tthis.options.mangleImports\n\t\t);\n\t\tconst externalExports = new Set(\n\t\t\tmodule.dependencies\n\t\t\t\t.filter(d => d instanceof WebAssemblyExportImportedDependency)\n\t\t\t\t.map(d => {\n\t\t\t\t\tconst wasmDep = /** @type {WebAssemblyExportImportedDependency} */ (\n\t\t\t\t\t\td\n\t\t\t\t\t);\n\t\t\t\t\treturn wasmDep.exportName;\n\t\t\t\t})\n\t\t);\n\n\t\t/** @type {t.Instruction[]} */\n\t\tconst additionalInitCode = [];\n\n\t\tconst transform = compose(\n\t\t\trewriteExportNames({\n\t\t\t\tast,\n\t\t\t\tmoduleGraph,\n\t\t\t\tmodule,\n\t\t\t\texternalExports,\n\t\t\t\truntime\n\t\t\t}),\n\n\t\t\tremoveStartFunc({ ast }),\n\n\t\t\trewriteImportedGlobals({ ast, additionalInitCode }),\n\n\t\t\trewriteImports({\n\t\t\t\tast,\n\t\t\t\tusedDependencyMap\n\t\t\t}),\n\n\t\t\taddInitFunction({\n\t\t\t\tast,\n\t\t\t\tinitFuncId,\n\t\t\t\timportedGlobals,\n\t\t\t\tadditionalInitCode,\n\t\t\t\tstartAtFuncOffset,\n\t\t\t\tnextFuncIndex,\n\t\t\t\tnextTypeIndex\n\t\t\t})\n\t\t);\n\n\t\tconst newBin = transform(bin);\n\n\t\tconst newBuf = Buffer.from(newBin);\n\n\t\treturn new RawSource(newBuf);\n\t}\n}\n\nmodule.exports = WebAssemblyGenerator;\n"]},"metadata":{},"sourceType":"script"}