{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst glob2regexp = require(\"glob-to-regexp\");\n\nconst {\n  STAGE_DEFAULT\n} = require(\"../OptimizationStages\");\n\nconst HarmonyExportImportedSpecifierDependency = require(\"../dependencies/HarmonyExportImportedSpecifierDependency\");\n\nconst HarmonyImportSpecifierDependency = require(\"../dependencies/HarmonyImportSpecifierDependency\");\n\nconst formatLocation = require(\"../formatLocation\");\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Dependency\")} Dependency */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n\n/**\n * @typedef {Object} ExportInModule\n * @property {Module} module the module\n * @property {string} exportName the name of the export\n * @property {boolean} checked if the export is conditional\n */\n\n/**\n * @typedef {Object} ReexportInfo\n * @property {Map<string, ExportInModule[]>} static\n * @property {Map<Module, Set<string>>} dynamic\n */\n\n/** @type {WeakMap<any, Map<string, RegExp>>} */\n\n\nconst globToRegexpCache = new WeakMap();\n/**\n * @param {string} glob the pattern\n * @param {Map<string, RegExp>} cache the glob to RegExp cache\n * @returns {RegExp} a regular expression\n */\n\nconst globToRegexp = (glob, cache) => {\n  const cacheEntry = cache.get(glob);\n  if (cacheEntry !== undefined) return cacheEntry;\n\n  if (!glob.includes(\"/\")) {\n    glob = `**/${glob}`;\n  }\n\n  const baseRegexp = glob2regexp(glob, {\n    globstar: true,\n    extended: true\n  });\n  const regexpSource = baseRegexp.source;\n  const regexp = new RegExp(\"^(\\\\./)?\" + regexpSource.slice(1));\n  cache.set(glob, regexp);\n  return regexp;\n};\n\nclass SideEffectsFlagPlugin {\n  /**\n   * @param {boolean} analyseSource analyse source code for side effects\n   */\n  constructor() {\n    let analyseSource = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this._analyseSource = analyseSource;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    let cache = globToRegexpCache.get(compiler.root);\n\n    if (cache === undefined) {\n      cache = new Map();\n      globToRegexpCache.set(compiler.root, cache);\n    }\n\n    compiler.hooks.compilation.tap(\"SideEffectsFlagPlugin\", (compilation, _ref) => {\n      let {\n        normalModuleFactory\n      } = _ref;\n      const moduleGraph = compilation.moduleGraph;\n      normalModuleFactory.hooks.module.tap(\"SideEffectsFlagPlugin\", (module, data) => {\n        const resolveData = data.resourceResolveData;\n\n        if (resolveData && resolveData.descriptionFileData && resolveData.relativePath) {\n          const sideEffects = resolveData.descriptionFileData.sideEffects;\n\n          if (sideEffects !== undefined) {\n            if (module.factoryMeta === undefined) {\n              module.factoryMeta = {};\n            }\n\n            const hasSideEffects = SideEffectsFlagPlugin.moduleHasSideEffects(resolveData.relativePath, sideEffects, cache);\n            module.factoryMeta.sideEffectFree = !hasSideEffects;\n          }\n        }\n\n        return module;\n      });\n      normalModuleFactory.hooks.module.tap(\"SideEffectsFlagPlugin\", (module, data) => {\n        if (typeof data.settings.sideEffects === \"boolean\") {\n          if (module.factoryMeta === undefined) {\n            module.factoryMeta = {};\n          }\n\n          module.factoryMeta.sideEffectFree = !data.settings.sideEffects;\n        }\n\n        return module;\n      });\n\n      if (this._analyseSource) {\n        /**\n         * @param {JavascriptParser} parser the parser\n         * @returns {void}\n         */\n        const parserHandler = parser => {\n          let sideEffectsStatement;\n          parser.hooks.program.tap(\"SideEffectsFlagPlugin\", () => {\n            sideEffectsStatement = undefined;\n          });\n          parser.hooks.statement.tap({\n            name: \"SideEffectsFlagPlugin\",\n            stage: -100\n          }, statement => {\n            if (sideEffectsStatement) return;\n            if (parser.scope.topLevelScope !== true) return;\n\n            switch (statement.type) {\n              case \"ExpressionStatement\":\n                if (!parser.isPure(statement.expression, statement.range[0])) {\n                  sideEffectsStatement = statement;\n                }\n\n                break;\n\n              case \"IfStatement\":\n              case \"WhileStatement\":\n              case \"DoWhileStatement\":\n                if (!parser.isPure(statement.test, statement.range[0])) {\n                  sideEffectsStatement = statement;\n                } // statement hook will be called for child statements too\n\n\n                break;\n\n              case \"ForStatement\":\n                if (!parser.isPure(statement.init, statement.range[0]) || !parser.isPure(statement.test, statement.init ? statement.init.range[1] : statement.range[0]) || !parser.isPure(statement.update, statement.test ? statement.test.range[1] : statement.init ? statement.init.range[1] : statement.range[0])) {\n                  sideEffectsStatement = statement;\n                } // statement hook will be called for child statements too\n\n\n                break;\n\n              case \"SwitchStatement\":\n                if (!parser.isPure(statement.discriminant, statement.range[0])) {\n                  sideEffectsStatement = statement;\n                } // statement hook will be called for child statements too\n\n\n                break;\n\n              case \"VariableDeclaration\":\n              case \"ClassDeclaration\":\n              case \"FunctionDeclaration\":\n                if (!parser.isPure(statement, statement.range[0])) {\n                  sideEffectsStatement = statement;\n                }\n\n                break;\n\n              case \"ExportNamedDeclaration\":\n              case \"ExportDefaultDeclaration\":\n                if (!parser.isPure(statement.declaration, statement.range[0])) {\n                  sideEffectsStatement = statement;\n                }\n\n                break;\n\n              case \"LabeledStatement\":\n              case \"BlockStatement\":\n                // statement hook will be called for child statements too\n                break;\n\n              case \"EmptyStatement\":\n                break;\n\n              case \"ExportAllDeclaration\":\n              case \"ImportDeclaration\":\n                // imports will be handled by the dependencies\n                break;\n\n              default:\n                sideEffectsStatement = statement;\n                break;\n            }\n          });\n          parser.hooks.finish.tap(\"SideEffectsFlagPlugin\", () => {\n            if (sideEffectsStatement === undefined) {\n              parser.state.module.buildMeta.sideEffectFree = true;\n            } else {\n              const {\n                loc,\n                type\n              } = sideEffectsStatement;\n              moduleGraph.getOptimizationBailout(parser.state.module).push(() => `Statement (${type}) with side effects in source code at ${formatLocation(loc)}`);\n            }\n          });\n        };\n\n        for (const key of [\"javascript/auto\", \"javascript/esm\", \"javascript/dynamic\"]) {\n          normalModuleFactory.hooks.parser.for(key).tap(\"SideEffectsFlagPlugin\", parserHandler);\n        }\n      }\n\n      compilation.hooks.optimizeDependencies.tap({\n        name: \"SideEffectsFlagPlugin\",\n        stage: STAGE_DEFAULT\n      }, modules => {\n        const logger = compilation.getLogger(\"webpack.SideEffectsFlagPlugin\");\n        logger.time(\"update dependencies\");\n\n        for (const module of modules) {\n          if (module.getSideEffectsConnectionState(moduleGraph) === false) {\n            const exportsInfo = moduleGraph.getExportsInfo(module);\n\n            for (const connection of moduleGraph.getIncomingConnections(module)) {\n              const dep = connection.dependency;\n              let isReexport;\n\n              if ((isReexport = dep instanceof HarmonyExportImportedSpecifierDependency) || dep instanceof HarmonyImportSpecifierDependency && !dep.namespaceObjectAsContext) {\n                // TODO improve for export *\n                if (isReexport && dep.name) {\n                  const exportInfo = moduleGraph.getExportInfo(connection.originModule, dep.name);\n                  exportInfo.moveTarget(moduleGraph, _ref2 => {\n                    let {\n                      module\n                    } = _ref2;\n                    return module.getSideEffectsConnectionState(moduleGraph) === false;\n                  }, _ref3 => {\n                    let {\n                      module: newModule,\n                      export: exportName\n                    } = _ref3;\n                    moduleGraph.updateModule(dep, newModule);\n                    moduleGraph.addExplanation(dep, \"(skipped side-effect-free modules)\");\n                    const ids = dep.getIds(moduleGraph);\n                    dep.setIds(moduleGraph, exportName ? [...exportName, ...ids.slice(1)] : ids.slice(1));\n                    return moduleGraph.getConnection(dep);\n                  });\n                  continue;\n                } // TODO improve for nested imports\n\n\n                const ids = dep.getIds(moduleGraph);\n\n                if (ids.length > 0) {\n                  const exportInfo = exportsInfo.getExportInfo(ids[0]);\n                  const target = exportInfo.getTarget(moduleGraph, _ref4 => {\n                    let {\n                      module\n                    } = _ref4;\n                    return module.getSideEffectsConnectionState(moduleGraph) === false;\n                  });\n                  if (!target) continue;\n                  moduleGraph.updateModule(dep, target.module);\n                  moduleGraph.addExplanation(dep, \"(skipped side-effect-free modules)\");\n                  dep.setIds(moduleGraph, target.export ? [...target.export, ...ids.slice(1)] : ids.slice(1));\n                }\n              }\n            }\n          }\n        }\n\n        logger.timeEnd(\"update dependencies\");\n      });\n    });\n  }\n\n  static moduleHasSideEffects(moduleName, flagValue, cache) {\n    switch (typeof flagValue) {\n      case \"undefined\":\n        return true;\n\n      case \"boolean\":\n        return flagValue;\n\n      case \"string\":\n        return globToRegexp(flagValue, cache).test(moduleName);\n\n      case \"object\":\n        return flagValue.some(glob => SideEffectsFlagPlugin.moduleHasSideEffects(moduleName, glob, cache));\n    }\n  }\n\n}\n\nmodule.exports = SideEffectsFlagPlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/optimize/SideEffectsFlagPlugin.js"],"names":["glob2regexp","require","STAGE_DEFAULT","HarmonyExportImportedSpecifierDependency","HarmonyImportSpecifierDependency","formatLocation","globToRegexpCache","WeakMap","globToRegexp","glob","cache","cacheEntry","get","undefined","includes","baseRegexp","globstar","extended","regexpSource","source","regexp","RegExp","slice","set","SideEffectsFlagPlugin","constructor","analyseSource","_analyseSource","apply","compiler","root","Map","hooks","compilation","tap","normalModuleFactory","moduleGraph","module","data","resolveData","resourceResolveData","descriptionFileData","relativePath","sideEffects","factoryMeta","hasSideEffects","moduleHasSideEffects","sideEffectFree","settings","parserHandler","parser","sideEffectsStatement","program","statement","name","stage","scope","topLevelScope","type","isPure","expression","range","test","init","update","discriminant","declaration","finish","state","buildMeta","loc","getOptimizationBailout","push","key","for","optimizeDependencies","modules","logger","getLogger","time","getSideEffectsConnectionState","exportsInfo","getExportsInfo","connection","getIncomingConnections","dep","dependency","isReexport","namespaceObjectAsContext","exportInfo","getExportInfo","originModule","moveTarget","newModule","export","exportName","updateModule","addExplanation","ids","getIds","setIds","getConnection","length","target","getTarget","timeEnd","moduleName","flagValue","some","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst glob2regexp = require(\"glob-to-regexp\");\nconst { STAGE_DEFAULT } = require(\"../OptimizationStages\");\nconst HarmonyExportImportedSpecifierDependency = require(\"../dependencies/HarmonyExportImportedSpecifierDependency\");\nconst HarmonyImportSpecifierDependency = require(\"../dependencies/HarmonyImportSpecifierDependency\");\nconst formatLocation = require(\"../formatLocation\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n\n/**\n * @typedef {Object} ExportInModule\n * @property {Module} module the module\n * @property {string} exportName the name of the export\n * @property {boolean} checked if the export is conditional\n */\n\n/**\n * @typedef {Object} ReexportInfo\n * @property {Map<string, ExportInModule[]>} static\n * @property {Map<Module, Set<string>>} dynamic\n */\n\n/** @type {WeakMap<any, Map<string, RegExp>>} */\nconst globToRegexpCache = new WeakMap();\n\n/**\n * @param {string} glob the pattern\n * @param {Map<string, RegExp>} cache the glob to RegExp cache\n * @returns {RegExp} a regular expression\n */\nconst globToRegexp = (glob, cache) => {\n\tconst cacheEntry = cache.get(glob);\n\tif (cacheEntry !== undefined) return cacheEntry;\n\tif (!glob.includes(\"/\")) {\n\t\tglob = `**/${glob}`;\n\t}\n\tconst baseRegexp = glob2regexp(glob, { globstar: true, extended: true });\n\tconst regexpSource = baseRegexp.source;\n\tconst regexp = new RegExp(\"^(\\\\./)?\" + regexpSource.slice(1));\n\tcache.set(glob, regexp);\n\treturn regexp;\n};\n\nclass SideEffectsFlagPlugin {\n\t/**\n\t * @param {boolean} analyseSource analyse source code for side effects\n\t */\n\tconstructor(analyseSource = true) {\n\t\tthis._analyseSource = analyseSource;\n\t}\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tlet cache = globToRegexpCache.get(compiler.root);\n\t\tif (cache === undefined) {\n\t\t\tcache = new Map();\n\t\t\tglobToRegexpCache.set(compiler.root, cache);\n\t\t}\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"SideEffectsFlagPlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\t\tnormalModuleFactory.hooks.module.tap(\n\t\t\t\t\t\"SideEffectsFlagPlugin\",\n\t\t\t\t\t(module, data) => {\n\t\t\t\t\t\tconst resolveData = data.resourceResolveData;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tresolveData &&\n\t\t\t\t\t\t\tresolveData.descriptionFileData &&\n\t\t\t\t\t\t\tresolveData.relativePath\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst sideEffects = resolveData.descriptionFileData.sideEffects;\n\t\t\t\t\t\t\tif (sideEffects !== undefined) {\n\t\t\t\t\t\t\t\tif (module.factoryMeta === undefined) {\n\t\t\t\t\t\t\t\t\tmodule.factoryMeta = {};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst hasSideEffects =\n\t\t\t\t\t\t\t\t\tSideEffectsFlagPlugin.moduleHasSideEffects(\n\t\t\t\t\t\t\t\t\t\tresolveData.relativePath,\n\t\t\t\t\t\t\t\t\t\tsideEffects,\n\t\t\t\t\t\t\t\t\t\tcache\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tmodule.factoryMeta.sideEffectFree = !hasSideEffects;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn module;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tnormalModuleFactory.hooks.module.tap(\n\t\t\t\t\t\"SideEffectsFlagPlugin\",\n\t\t\t\t\t(module, data) => {\n\t\t\t\t\t\tif (typeof data.settings.sideEffects === \"boolean\") {\n\t\t\t\t\t\t\tif (module.factoryMeta === undefined) {\n\t\t\t\t\t\t\t\tmodule.factoryMeta = {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmodule.factoryMeta.sideEffectFree = !data.settings.sideEffects;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn module;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tif (this._analyseSource) {\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {JavascriptParser} parser the parser\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst parserHandler = parser => {\n\t\t\t\t\t\tlet sideEffectsStatement;\n\t\t\t\t\t\tparser.hooks.program.tap(\"SideEffectsFlagPlugin\", () => {\n\t\t\t\t\t\t\tsideEffectsStatement = undefined;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.statement.tap(\n\t\t\t\t\t\t\t{ name: \"SideEffectsFlagPlugin\", stage: -100 },\n\t\t\t\t\t\t\tstatement => {\n\t\t\t\t\t\t\t\tif (sideEffectsStatement) return;\n\t\t\t\t\t\t\t\tif (parser.scope.topLevelScope !== true) return;\n\t\t\t\t\t\t\t\tswitch (statement.type) {\n\t\t\t\t\t\t\t\t\tcase \"ExpressionStatement\":\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!parser.isPure(statement.expression, statement.range[0])\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tsideEffectsStatement = statement;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"IfStatement\":\n\t\t\t\t\t\t\t\t\tcase \"WhileStatement\":\n\t\t\t\t\t\t\t\t\tcase \"DoWhileStatement\":\n\t\t\t\t\t\t\t\t\t\tif (!parser.isPure(statement.test, statement.range[0])) {\n\t\t\t\t\t\t\t\t\t\t\tsideEffectsStatement = statement;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// statement hook will be called for child statements too\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"ForStatement\":\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!parser.isPure(statement.init, statement.range[0]) ||\n\t\t\t\t\t\t\t\t\t\t\t!parser.isPure(\n\t\t\t\t\t\t\t\t\t\t\t\tstatement.test,\n\t\t\t\t\t\t\t\t\t\t\t\tstatement.init\n\t\t\t\t\t\t\t\t\t\t\t\t\t? statement.init.range[1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t: statement.range[0]\n\t\t\t\t\t\t\t\t\t\t\t) ||\n\t\t\t\t\t\t\t\t\t\t\t!parser.isPure(\n\t\t\t\t\t\t\t\t\t\t\t\tstatement.update,\n\t\t\t\t\t\t\t\t\t\t\t\tstatement.test\n\t\t\t\t\t\t\t\t\t\t\t\t\t? statement.test.range[1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t: statement.init\n\t\t\t\t\t\t\t\t\t\t\t\t\t? statement.init.range[1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t: statement.range[0]\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tsideEffectsStatement = statement;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// statement hook will be called for child statements too\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"SwitchStatement\":\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!parser.isPure(statement.discriminant, statement.range[0])\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tsideEffectsStatement = statement;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// statement hook will be called for child statements too\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"VariableDeclaration\":\n\t\t\t\t\t\t\t\t\tcase \"ClassDeclaration\":\n\t\t\t\t\t\t\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\t\t\t\t\t\t\tif (!parser.isPure(statement, statement.range[0])) {\n\t\t\t\t\t\t\t\t\t\t\tsideEffectsStatement = statement;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\t\t\t\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!parser.isPure(statement.declaration, statement.range[0])\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tsideEffectsStatement = statement;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"LabeledStatement\":\n\t\t\t\t\t\t\t\t\tcase \"BlockStatement\":\n\t\t\t\t\t\t\t\t\t\t// statement hook will be called for child statements too\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"EmptyStatement\":\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"ExportAllDeclaration\":\n\t\t\t\t\t\t\t\t\tcase \"ImportDeclaration\":\n\t\t\t\t\t\t\t\t\t\t// imports will be handled by the dependencies\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tsideEffectsStatement = statement;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t\tparser.hooks.finish.tap(\"SideEffectsFlagPlugin\", () => {\n\t\t\t\t\t\t\tif (sideEffectsStatement === undefined) {\n\t\t\t\t\t\t\t\tparser.state.module.buildMeta.sideEffectFree = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst { loc, type } = sideEffectsStatement;\n\t\t\t\t\t\t\t\tmoduleGraph\n\t\t\t\t\t\t\t\t\t.getOptimizationBailout(parser.state.module)\n\t\t\t\t\t\t\t\t\t.push(\n\t\t\t\t\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\t\t\t\t\t`Statement (${type}) with side effects in source code at ${formatLocation(\n\t\t\t\t\t\t\t\t\t\t\t\tloc\n\t\t\t\t\t\t\t\t\t\t\t)}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\t\t\t\t\tfor (const key of [\n\t\t\t\t\t\t\"javascript/auto\",\n\t\t\t\t\t\t\"javascript/esm\",\n\t\t\t\t\t\t\"javascript/dynamic\"\n\t\t\t\t\t]) {\n\t\t\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\"SideEffectsFlagPlugin\", parserHandler);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcompilation.hooks.optimizeDependencies.tap(\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"SideEffectsFlagPlugin\",\n\t\t\t\t\t\tstage: STAGE_DEFAULT\n\t\t\t\t\t},\n\t\t\t\t\tmodules => {\n\t\t\t\t\t\tconst logger = compilation.getLogger(\n\t\t\t\t\t\t\t\"webpack.SideEffectsFlagPlugin\"\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tlogger.time(\"update dependencies\");\n\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\tif (module.getSideEffectsConnectionState(moduleGraph) === false) {\n\t\t\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\t\t\tfor (const connection of moduleGraph.getIncomingConnections(\n\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\t\t\tconst dep = connection.dependency;\n\t\t\t\t\t\t\t\t\tlet isReexport;\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t(isReexport =\n\t\t\t\t\t\t\t\t\t\t\tdep instanceof\n\t\t\t\t\t\t\t\t\t\t\tHarmonyExportImportedSpecifierDependency) ||\n\t\t\t\t\t\t\t\t\t\t(dep instanceof HarmonyImportSpecifierDependency &&\n\t\t\t\t\t\t\t\t\t\t\t!dep.namespaceObjectAsContext)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t// TODO improve for export *\n\t\t\t\t\t\t\t\t\t\tif (isReexport && dep.name) {\n\t\t\t\t\t\t\t\t\t\t\tconst exportInfo = moduleGraph.getExportInfo(\n\t\t\t\t\t\t\t\t\t\t\t\tconnection.originModule,\n\t\t\t\t\t\t\t\t\t\t\t\tdep.name\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\texportInfo.moveTarget(\n\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\t\t\t\t\t\t\t({ module }) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\tmodule.getSideEffectsConnectionState(moduleGraph) ===\n\t\t\t\t\t\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\t\t\t\t({ module: newModule, export: exportName }) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph.updateModule(dep, newModule);\n\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph.addExplanation(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdep,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"(skipped side-effect-free modules)\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst ids = dep.getIds(moduleGraph);\n\t\t\t\t\t\t\t\t\t\t\t\t\tdep.setIds(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\texportName\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? [...exportName, ...ids.slice(1)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: ids.slice(1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn moduleGraph.getConnection(dep);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// TODO improve for nested imports\n\t\t\t\t\t\t\t\t\t\tconst ids = dep.getIds(moduleGraph);\n\t\t\t\t\t\t\t\t\t\tif (ids.length > 0) {\n\t\t\t\t\t\t\t\t\t\t\tconst exportInfo = exportsInfo.getExportInfo(ids[0]);\n\t\t\t\t\t\t\t\t\t\t\tconst target = exportInfo.getTarget(\n\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\t\t\t\t\t\t\t({ module }) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\tmodule.getSideEffectsConnectionState(moduleGraph) ===\n\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tif (!target) continue;\n\n\t\t\t\t\t\t\t\t\t\t\tmoduleGraph.updateModule(dep, target.module);\n\t\t\t\t\t\t\t\t\t\t\tmoduleGraph.addExplanation(\n\t\t\t\t\t\t\t\t\t\t\t\tdep,\n\t\t\t\t\t\t\t\t\t\t\t\t\"(skipped side-effect-free modules)\"\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tdep.setIds(\n\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\t\t\t\t\t\t\ttarget.export\n\t\t\t\t\t\t\t\t\t\t\t\t\t? [...target.export, ...ids.slice(1)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t: ids.slice(1)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlogger.timeEnd(\"update dependencies\");\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\tstatic moduleHasSideEffects(moduleName, flagValue, cache) {\n\t\tswitch (typeof flagValue) {\n\t\t\tcase \"undefined\":\n\t\t\t\treturn true;\n\t\t\tcase \"boolean\":\n\t\t\t\treturn flagValue;\n\t\t\tcase \"string\":\n\t\t\t\treturn globToRegexp(flagValue, cache).test(moduleName);\n\t\t\tcase \"object\":\n\t\t\t\treturn flagValue.some(glob =>\n\t\t\t\t\tSideEffectsFlagPlugin.moduleHasSideEffects(moduleName, glob, cache)\n\t\t\t\t);\n\t\t}\n\t}\n}\nmodule.exports = SideEffectsFlagPlugin;\n"]},"metadata":{},"sourceType":"script"}