{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Dependency = require(\"./Dependency\");\n\nconst {\n  UsageState\n} = require(\"./ExportsInfo\");\n\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\n\nconst {\n  STAGE_DEFAULT\n} = require(\"./OptimizationStages\");\n\nconst ArrayQueue = require(\"./util/ArrayQueue\");\n\nconst TupleQueue = require(\"./util/TupleQueue\");\n\nconst {\n  getEntryRuntime,\n  mergeRuntimeOwned\n} = require(\"./util/runtime\");\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n\n/** @typedef {import(\"./Dependency\").ReferencedExport} ReferencedExport */\n\n/** @typedef {import(\"./ExportsInfo\")} ExportsInfo */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n\nconst {\n  NO_EXPORTS_REFERENCED,\n  EXPORTS_OBJECT_REFERENCED\n} = Dependency;\n\nclass FlagDependencyUsagePlugin {\n  /**\n   * @param {boolean} global do a global analysis instead of per runtime\n   */\n  constructor(global) {\n    this.global = global;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"FlagDependencyUsagePlugin\", compilation => {\n      const moduleGraph = compilation.moduleGraph;\n      compilation.hooks.optimizeDependencies.tap({\n        name: \"FlagDependencyUsagePlugin\",\n        stage: STAGE_DEFAULT\n      }, modules => {\n        if (compilation.moduleMemCaches) {\n          throw new Error(\"optimization.usedExports can't be used with cacheUnaffected as export usage is a global effect\");\n        }\n\n        const logger = compilation.getLogger(\"webpack.FlagDependencyUsagePlugin\");\n        /** @type {Map<ExportsInfo, Module>} */\n\n        const exportInfoToModuleMap = new Map();\n        /** @type {TupleQueue<[Module, RuntimeSpec]>} */\n\n        const queue = new TupleQueue();\n        /**\n         * @param {Module} module module to process\n         * @param {(string[] | ReferencedExport)[]} usedExports list of used exports\n         * @param {RuntimeSpec} runtime part of which runtime\n         * @param {boolean} forceSideEffects always apply side effects\n         * @returns {void}\n         */\n\n        const processReferencedModule = (module, usedExports, runtime, forceSideEffects) => {\n          const exportsInfo = moduleGraph.getExportsInfo(module);\n\n          if (usedExports.length > 0) {\n            if (!module.buildMeta || !module.buildMeta.exportsType) {\n              if (exportsInfo.setUsedWithoutInfo(runtime)) {\n                queue.enqueue(module, runtime);\n              }\n\n              return;\n            }\n\n            for (const usedExportInfo of usedExports) {\n              let usedExport;\n              let canMangle = true;\n\n              if (Array.isArray(usedExportInfo)) {\n                usedExport = usedExportInfo;\n              } else {\n                usedExport = usedExportInfo.name;\n                canMangle = usedExportInfo.canMangle !== false;\n              }\n\n              if (usedExport.length === 0) {\n                if (exportsInfo.setUsedInUnknownWay(runtime)) {\n                  queue.enqueue(module, runtime);\n                }\n              } else {\n                let currentExportsInfo = exportsInfo;\n\n                for (let i = 0; i < usedExport.length; i++) {\n                  const exportInfo = currentExportsInfo.getExportInfo(usedExport[i]);\n\n                  if (canMangle === false) {\n                    exportInfo.canMangleUse = false;\n                  }\n\n                  const lastOne = i === usedExport.length - 1;\n\n                  if (!lastOne) {\n                    const nestedInfo = exportInfo.getNestedExportsInfo();\n\n                    if (nestedInfo) {\n                      if (exportInfo.setUsedConditionally(used => used === UsageState.Unused, UsageState.OnlyPropertiesUsed, runtime)) {\n                        const currentModule = currentExportsInfo === exportsInfo ? module : exportInfoToModuleMap.get(currentExportsInfo);\n\n                        if (currentModule) {\n                          queue.enqueue(currentModule, runtime);\n                        }\n                      }\n\n                      currentExportsInfo = nestedInfo;\n                      continue;\n                    }\n                  }\n\n                  if (exportInfo.setUsedConditionally(v => v !== UsageState.Used, UsageState.Used, runtime)) {\n                    const currentModule = currentExportsInfo === exportsInfo ? module : exportInfoToModuleMap.get(currentExportsInfo);\n\n                    if (currentModule) {\n                      queue.enqueue(currentModule, runtime);\n                    }\n                  }\n\n                  break;\n                }\n              }\n            }\n          } else {\n            // for a module without side effects we stop tracking usage here when no export is used\n            // This module won't be evaluated in this case\n            // TODO webpack 6 remove this check\n            if (!forceSideEffects && module.factoryMeta !== undefined && module.factoryMeta.sideEffectFree) {\n              return;\n            }\n\n            if (exportsInfo.setUsedForSideEffectsOnly(runtime)) {\n              queue.enqueue(module, runtime);\n            }\n          }\n        };\n        /**\n         * @param {DependenciesBlock} module the module\n         * @param {RuntimeSpec} runtime part of which runtime\n         * @param {boolean} forceSideEffects always apply side effects\n         * @returns {void}\n         */\n\n\n        const processModule = (module, runtime, forceSideEffects) => {\n          /** @type {Map<Module, (string[] | ReferencedExport)[] | Map<string, string[] | ReferencedExport>>} */\n          const map = new Map();\n          /** @type {ArrayQueue<DependenciesBlock>} */\n\n          const queue = new ArrayQueue();\n          queue.enqueue(module);\n\n          for (;;) {\n            const block = queue.dequeue();\n            if (block === undefined) break;\n\n            for (const b of block.blocks) {\n              if (!this.global && b.groupOptions && b.groupOptions.entryOptions) {\n                processModule(b, b.groupOptions.entryOptions.runtime || undefined, true);\n              } else {\n                queue.enqueue(b);\n              }\n            }\n\n            for (const dep of block.dependencies) {\n              const connection = moduleGraph.getConnection(dep);\n\n              if (!connection || !connection.module) {\n                continue;\n              }\n\n              const activeState = connection.getActiveState(runtime);\n              if (activeState === false) continue;\n              const {\n                module\n              } = connection;\n\n              if (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\n                processModule(module, runtime, false);\n                continue;\n              }\n\n              const oldReferencedExports = map.get(module);\n\n              if (oldReferencedExports === EXPORTS_OBJECT_REFERENCED) {\n                continue;\n              }\n\n              const referencedExports = compilation.getDependencyReferencedExports(dep, runtime);\n\n              if (oldReferencedExports === undefined || oldReferencedExports === NO_EXPORTS_REFERENCED || referencedExports === EXPORTS_OBJECT_REFERENCED) {\n                map.set(module, referencedExports);\n              } else if (oldReferencedExports !== undefined && referencedExports === NO_EXPORTS_REFERENCED) {\n                continue;\n              } else {\n                let exportsMap;\n\n                if (Array.isArray(oldReferencedExports)) {\n                  exportsMap = new Map();\n\n                  for (const item of oldReferencedExports) {\n                    if (Array.isArray(item)) {\n                      exportsMap.set(item.join(\"\\n\"), item);\n                    } else {\n                      exportsMap.set(item.name.join(\"\\n\"), item);\n                    }\n                  }\n\n                  map.set(module, exportsMap);\n                } else {\n                  exportsMap = oldReferencedExports;\n                }\n\n                for (const item of referencedExports) {\n                  if (Array.isArray(item)) {\n                    const key = item.join(\"\\n\");\n                    const oldItem = exportsMap.get(key);\n\n                    if (oldItem === undefined) {\n                      exportsMap.set(key, item);\n                    } // if oldItem is already an array we have to do nothing\n                    // if oldItem is an ReferencedExport object, we don't have to do anything\n                    // as canMangle defaults to true for arrays\n\n                  } else {\n                    const key = item.name.join(\"\\n\");\n                    const oldItem = exportsMap.get(key);\n\n                    if (oldItem === undefined || Array.isArray(oldItem)) {\n                      exportsMap.set(key, item);\n                    } else {\n                      exportsMap.set(key, {\n                        name: item.name,\n                        canMangle: item.canMangle && oldItem.canMangle\n                      });\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          for (const [module, referencedExports] of map) {\n            if (Array.isArray(referencedExports)) {\n              processReferencedModule(module, referencedExports, runtime, forceSideEffects);\n            } else {\n              processReferencedModule(module, Array.from(referencedExports.values()), runtime, forceSideEffects);\n            }\n          }\n        };\n\n        logger.time(\"initialize exports usage\");\n\n        for (const module of modules) {\n          const exportsInfo = moduleGraph.getExportsInfo(module);\n          exportInfoToModuleMap.set(exportsInfo, module);\n          exportsInfo.setHasUseInfo();\n        }\n\n        logger.timeEnd(\"initialize exports usage\");\n        logger.time(\"trace exports usage in graph\");\n        /**\n         * @param {Dependency} dep dependency\n         * @param {RuntimeSpec} runtime runtime\n         */\n\n        const processEntryDependency = (dep, runtime) => {\n          const module = moduleGraph.getModule(dep);\n\n          if (module) {\n            processReferencedModule(module, NO_EXPORTS_REFERENCED, runtime, true);\n          }\n        };\n        /** @type {RuntimeSpec} */\n\n\n        let globalRuntime = undefined;\n\n        for (const [entryName, {\n          dependencies: deps,\n          includeDependencies: includeDeps,\n          options\n        }] of compilation.entries) {\n          const runtime = this.global ? undefined : getEntryRuntime(compilation, entryName, options);\n\n          for (const dep of deps) {\n            processEntryDependency(dep, runtime);\n          }\n\n          for (const dep of includeDeps) {\n            processEntryDependency(dep, runtime);\n          }\n\n          globalRuntime = mergeRuntimeOwned(globalRuntime, runtime);\n        }\n\n        for (const dep of compilation.globalEntry.dependencies) {\n          processEntryDependency(dep, globalRuntime);\n        }\n\n        for (const dep of compilation.globalEntry.includeDependencies) {\n          processEntryDependency(dep, globalRuntime);\n        }\n\n        while (queue.length) {\n          const [module, runtime] = queue.dequeue();\n          processModule(module, runtime, false);\n        }\n\n        logger.timeEnd(\"trace exports usage in graph\");\n      });\n    });\n  }\n\n}\n\nmodule.exports = FlagDependencyUsagePlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/FlagDependencyUsagePlugin.js"],"names":["Dependency","require","UsageState","ModuleGraphConnection","STAGE_DEFAULT","ArrayQueue","TupleQueue","getEntryRuntime","mergeRuntimeOwned","NO_EXPORTS_REFERENCED","EXPORTS_OBJECT_REFERENCED","FlagDependencyUsagePlugin","constructor","global","apply","compiler","hooks","compilation","tap","moduleGraph","optimizeDependencies","name","stage","modules","moduleMemCaches","Error","logger","getLogger","exportInfoToModuleMap","Map","queue","processReferencedModule","module","usedExports","runtime","forceSideEffects","exportsInfo","getExportsInfo","length","buildMeta","exportsType","setUsedWithoutInfo","enqueue","usedExportInfo","usedExport","canMangle","Array","isArray","setUsedInUnknownWay","currentExportsInfo","i","exportInfo","getExportInfo","canMangleUse","lastOne","nestedInfo","getNestedExportsInfo","setUsedConditionally","used","Unused","OnlyPropertiesUsed","currentModule","get","v","Used","factoryMeta","undefined","sideEffectFree","setUsedForSideEffectsOnly","processModule","map","block","dequeue","b","blocks","groupOptions","entryOptions","dep","dependencies","connection","getConnection","activeState","getActiveState","TRANSITIVE_ONLY","oldReferencedExports","referencedExports","getDependencyReferencedExports","set","exportsMap","item","join","key","oldItem","from","values","time","setHasUseInfo","timeEnd","processEntryDependency","getModule","globalRuntime","entryName","deps","includeDependencies","includeDeps","options","entries","globalEntry","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Dependency = require(\"./Dependency\");\nconst { UsageState } = require(\"./ExportsInfo\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst { STAGE_DEFAULT } = require(\"./OptimizationStages\");\nconst ArrayQueue = require(\"./util/ArrayQueue\");\nconst TupleQueue = require(\"./util/TupleQueue\");\nconst { getEntryRuntime, mergeRuntimeOwned } = require(\"./util/runtime\");\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\").ReferencedExport} ReferencedExport */\n/** @typedef {import(\"./ExportsInfo\")} ExportsInfo */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\nconst { NO_EXPORTS_REFERENCED, EXPORTS_OBJECT_REFERENCED } = Dependency;\n\nclass FlagDependencyUsagePlugin {\n\t/**\n\t * @param {boolean} global do a global analysis instead of per runtime\n\t */\n\tconstructor(global) {\n\t\tthis.global = global;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"FlagDependencyUsagePlugin\", compilation => {\n\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\tcompilation.hooks.optimizeDependencies.tap(\n\t\t\t\t{\n\t\t\t\t\tname: \"FlagDependencyUsagePlugin\",\n\t\t\t\t\tstage: STAGE_DEFAULT\n\t\t\t\t},\n\t\t\t\tmodules => {\n\t\t\t\t\tif (compilation.moduleMemCaches) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\"optimization.usedExports can't be used with cacheUnaffected as export usage is a global effect\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst logger = compilation.getLogger(\n\t\t\t\t\t\t\"webpack.FlagDependencyUsagePlugin\"\n\t\t\t\t\t);\n\t\t\t\t\t/** @type {Map<ExportsInfo, Module>} */\n\t\t\t\t\tconst exportInfoToModuleMap = new Map();\n\n\t\t\t\t\t/** @type {TupleQueue<[Module, RuntimeSpec]>} */\n\t\t\t\t\tconst queue = new TupleQueue();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Module} module module to process\n\t\t\t\t\t * @param {(string[] | ReferencedExport)[]} usedExports list of used exports\n\t\t\t\t\t * @param {RuntimeSpec} runtime part of which runtime\n\t\t\t\t\t * @param {boolean} forceSideEffects always apply side effects\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst processReferencedModule = (\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tusedExports,\n\t\t\t\t\t\truntime,\n\t\t\t\t\t\tforceSideEffects\n\t\t\t\t\t) => {\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\tif (usedExports.length > 0) {\n\t\t\t\t\t\t\tif (!module.buildMeta || !module.buildMeta.exportsType) {\n\t\t\t\t\t\t\t\tif (exportsInfo.setUsedWithoutInfo(runtime)) {\n\t\t\t\t\t\t\t\t\tqueue.enqueue(module, runtime);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const usedExportInfo of usedExports) {\n\t\t\t\t\t\t\t\tlet usedExport;\n\t\t\t\t\t\t\t\tlet canMangle = true;\n\t\t\t\t\t\t\t\tif (Array.isArray(usedExportInfo)) {\n\t\t\t\t\t\t\t\t\tusedExport = usedExportInfo;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tusedExport = usedExportInfo.name;\n\t\t\t\t\t\t\t\t\tcanMangle = usedExportInfo.canMangle !== false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (usedExport.length === 0) {\n\t\t\t\t\t\t\t\t\tif (exportsInfo.setUsedInUnknownWay(runtime)) {\n\t\t\t\t\t\t\t\t\t\tqueue.enqueue(module, runtime);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlet currentExportsInfo = exportsInfo;\n\t\t\t\t\t\t\t\t\tfor (let i = 0; i < usedExport.length; i++) {\n\t\t\t\t\t\t\t\t\t\tconst exportInfo = currentExportsInfo.getExportInfo(\n\t\t\t\t\t\t\t\t\t\t\tusedExport[i]\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tif (canMangle === false) {\n\t\t\t\t\t\t\t\t\t\t\texportInfo.canMangleUse = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst lastOne = i === usedExport.length - 1;\n\t\t\t\t\t\t\t\t\t\tif (!lastOne) {\n\t\t\t\t\t\t\t\t\t\t\tconst nestedInfo = exportInfo.getNestedExportsInfo();\n\t\t\t\t\t\t\t\t\t\t\tif (nestedInfo) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.setUsedConditionally(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tused => used === UsageState.Unused,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUsageState.OnlyPropertiesUsed,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst currentModule =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentExportsInfo === exportsInfo\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? module\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: exportInfoToModuleMap.get(currentExportsInfo);\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (currentModule) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tqueue.enqueue(currentModule, runtime);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentExportsInfo = nestedInfo;\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\texportInfo.setUsedConditionally(\n\t\t\t\t\t\t\t\t\t\t\t\tv => v !== UsageState.Used,\n\t\t\t\t\t\t\t\t\t\t\t\tUsageState.Used,\n\t\t\t\t\t\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tconst currentModule =\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentExportsInfo === exportsInfo\n\t\t\t\t\t\t\t\t\t\t\t\t\t? module\n\t\t\t\t\t\t\t\t\t\t\t\t\t: exportInfoToModuleMap.get(currentExportsInfo);\n\t\t\t\t\t\t\t\t\t\t\tif (currentModule) {\n\t\t\t\t\t\t\t\t\t\t\t\tqueue.enqueue(currentModule, runtime);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// for a module without side effects we stop tracking usage here when no export is used\n\t\t\t\t\t\t\t// This module won't be evaluated in this case\n\t\t\t\t\t\t\t// TODO webpack 6 remove this check\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!forceSideEffects &&\n\t\t\t\t\t\t\t\tmodule.factoryMeta !== undefined &&\n\t\t\t\t\t\t\t\tmodule.factoryMeta.sideEffectFree\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (exportsInfo.setUsedForSideEffectsOnly(runtime)) {\n\t\t\t\t\t\t\t\tqueue.enqueue(module, runtime);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {DependenciesBlock} module the module\n\t\t\t\t\t * @param {RuntimeSpec} runtime part of which runtime\n\t\t\t\t\t * @param {boolean} forceSideEffects always apply side effects\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst processModule = (module, runtime, forceSideEffects) => {\n\t\t\t\t\t\t/** @type {Map<Module, (string[] | ReferencedExport)[] | Map<string, string[] | ReferencedExport>>} */\n\t\t\t\t\t\tconst map = new Map();\n\n\t\t\t\t\t\t/** @type {ArrayQueue<DependenciesBlock>} */\n\t\t\t\t\t\tconst queue = new ArrayQueue();\n\t\t\t\t\t\tqueue.enqueue(module);\n\t\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\t\tconst block = queue.dequeue();\n\t\t\t\t\t\t\tif (block === undefined) break;\n\t\t\t\t\t\t\tfor (const b of block.blocks) {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t!this.global &&\n\t\t\t\t\t\t\t\t\tb.groupOptions &&\n\t\t\t\t\t\t\t\t\tb.groupOptions.entryOptions\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tprocessModule(\n\t\t\t\t\t\t\t\t\t\tb,\n\t\t\t\t\t\t\t\t\t\tb.groupOptions.entryOptions.runtime || undefined,\n\t\t\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tqueue.enqueue(b);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const dep of block.dependencies) {\n\t\t\t\t\t\t\t\tconst connection = moduleGraph.getConnection(dep);\n\t\t\t\t\t\t\t\tif (!connection || !connection.module) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst activeState = connection.getActiveState(runtime);\n\t\t\t\t\t\t\t\tif (activeState === false) continue;\n\t\t\t\t\t\t\t\tconst { module } = connection;\n\t\t\t\t\t\t\t\tif (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\n\t\t\t\t\t\t\t\t\tprocessModule(module, runtime, false);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst oldReferencedExports = map.get(module);\n\t\t\t\t\t\t\t\tif (oldReferencedExports === EXPORTS_OBJECT_REFERENCED) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst referencedExports =\n\t\t\t\t\t\t\t\t\tcompilation.getDependencyReferencedExports(dep, runtime);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\toldReferencedExports === undefined ||\n\t\t\t\t\t\t\t\t\toldReferencedExports === NO_EXPORTS_REFERENCED ||\n\t\t\t\t\t\t\t\t\treferencedExports === EXPORTS_OBJECT_REFERENCED\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tmap.set(module, referencedExports);\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\toldReferencedExports !== undefined &&\n\t\t\t\t\t\t\t\t\treferencedExports === NO_EXPORTS_REFERENCED\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlet exportsMap;\n\t\t\t\t\t\t\t\t\tif (Array.isArray(oldReferencedExports)) {\n\t\t\t\t\t\t\t\t\t\texportsMap = new Map();\n\t\t\t\t\t\t\t\t\t\tfor (const item of oldReferencedExports) {\n\t\t\t\t\t\t\t\t\t\t\tif (Array.isArray(item)) {\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(item.join(\"\\n\"), item);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(item.name.join(\"\\n\"), item);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tmap.set(module, exportsMap);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\texportsMap = oldReferencedExports;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor (const item of referencedExports) {\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(item)) {\n\t\t\t\t\t\t\t\t\t\t\tconst key = item.join(\"\\n\");\n\t\t\t\t\t\t\t\t\t\t\tconst oldItem = exportsMap.get(key);\n\t\t\t\t\t\t\t\t\t\t\tif (oldItem === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(key, item);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// if oldItem is already an array we have to do nothing\n\t\t\t\t\t\t\t\t\t\t\t// if oldItem is an ReferencedExport object, we don't have to do anything\n\t\t\t\t\t\t\t\t\t\t\t// as canMangle defaults to true for arrays\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tconst key = item.name.join(\"\\n\");\n\t\t\t\t\t\t\t\t\t\t\tconst oldItem = exportsMap.get(key);\n\t\t\t\t\t\t\t\t\t\t\tif (oldItem === undefined || Array.isArray(oldItem)) {\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(key, item);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(key, {\n\t\t\t\t\t\t\t\t\t\t\t\t\tname: item.name,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcanMangle: item.canMangle && oldItem.canMangle\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (const [module, referencedExports] of map) {\n\t\t\t\t\t\t\tif (Array.isArray(referencedExports)) {\n\t\t\t\t\t\t\t\tprocessReferencedModule(\n\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\treferencedExports,\n\t\t\t\t\t\t\t\t\truntime,\n\t\t\t\t\t\t\t\t\tforceSideEffects\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprocessReferencedModule(\n\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\tArray.from(referencedExports.values()),\n\t\t\t\t\t\t\t\t\truntime,\n\t\t\t\t\t\t\t\t\tforceSideEffects\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tlogger.time(\"initialize exports usage\");\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\texportInfoToModuleMap.set(exportsInfo, module);\n\t\t\t\t\t\texportsInfo.setHasUseInfo();\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"initialize exports usage\");\n\n\t\t\t\t\tlogger.time(\"trace exports usage in graph\");\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Dependency} dep dependency\n\t\t\t\t\t * @param {RuntimeSpec} runtime runtime\n\t\t\t\t\t */\n\t\t\t\t\tconst processEntryDependency = (dep, runtime) => {\n\t\t\t\t\t\tconst module = moduleGraph.getModule(dep);\n\t\t\t\t\t\tif (module) {\n\t\t\t\t\t\t\tprocessReferencedModule(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\tNO_EXPORTS_REFERENCED,\n\t\t\t\t\t\t\t\truntime,\n\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t/** @type {RuntimeSpec} */\n\t\t\t\t\tlet globalRuntime = undefined;\n\t\t\t\t\tfor (const [\n\t\t\t\t\t\tentryName,\n\t\t\t\t\t\t{ dependencies: deps, includeDependencies: includeDeps, options }\n\t\t\t\t\t] of compilation.entries) {\n\t\t\t\t\t\tconst runtime = this.global\n\t\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t\t: getEntryRuntime(compilation, entryName, options);\n\t\t\t\t\t\tfor (const dep of deps) {\n\t\t\t\t\t\t\tprocessEntryDependency(dep, runtime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const dep of includeDeps) {\n\t\t\t\t\t\t\tprocessEntryDependency(dep, runtime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tglobalRuntime = mergeRuntimeOwned(globalRuntime, runtime);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const dep of compilation.globalEntry.dependencies) {\n\t\t\t\t\t\tprocessEntryDependency(dep, globalRuntime);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const dep of compilation.globalEntry.includeDependencies) {\n\t\t\t\t\t\tprocessEntryDependency(dep, globalRuntime);\n\t\t\t\t\t}\n\n\t\t\t\t\twhile (queue.length) {\n\t\t\t\t\t\tconst [module, runtime] = queue.dequeue();\n\t\t\t\t\t\tprocessModule(module, runtime, false);\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"trace exports usage in graph\");\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = FlagDependencyUsagePlugin;\n"]},"metadata":{},"sourceType":"script"}