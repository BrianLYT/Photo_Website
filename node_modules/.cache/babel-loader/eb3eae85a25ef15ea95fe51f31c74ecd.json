{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Sergey Melyukov @smelukov\n*/\n\"use strict\";\n\nconst mimeTypes = require(\"mime-types\");\n\nconst path = require(\"path\");\n\nconst {\n  RawSource\n} = require(\"webpack-sources\");\n\nconst Generator = require(\"../Generator\");\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\n\nconst createHash = require(\"../util/createHash\");\n\nconst {\n  makePathsRelative\n} = require(\"../util/identifier\");\n\nconst nonNumericOnlyHash = require(\"../util/nonNumericOnlyHash\");\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").AssetGeneratorOptions} AssetGeneratorOptions */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").AssetModuleOutputPath} AssetModuleOutputPath */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").RawPublicPath} RawPublicPath */\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Generator\").GenerateContext} GenerateContext */\n\n/** @typedef {import(\"../Generator\").UpdateHashContext} UpdateHashContext */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n\n/** @typedef {import(\"../util/Hash\")} Hash */\n\n\nconst mergeMaybeArrays = (a, b) => {\n  const set = new Set();\n  if (Array.isArray(a)) for (const item of a) set.add(item);else set.add(a);\n  if (Array.isArray(b)) for (const item of b) set.add(item);else set.add(b);\n  return Array.from(set);\n};\n\nconst mergeAssetInfo = (a, b) => {\n  const result = { ...a,\n    ...b\n  };\n\n  for (const key of Object.keys(a)) {\n    if (key in b) {\n      if (a[key] === b[key]) continue;\n\n      switch (key) {\n        case \"fullhash\":\n        case \"chunkhash\":\n        case \"modulehash\":\n        case \"contenthash\":\n          result[key] = mergeMaybeArrays(a[key], b[key]);\n          break;\n\n        case \"immutable\":\n        case \"development\":\n        case \"hotModuleReplacement\":\n        case \"javascriptModule\":\n          result[key] = a[key] || b[key];\n          break;\n\n        case \"related\":\n          result[key] = mergeRelatedInfo(a[key], b[key]);\n          break;\n\n        default:\n          throw new Error(`Can't handle conflicting asset info for ${key}`);\n      }\n    }\n  }\n\n  return result;\n};\n\nconst mergeRelatedInfo = (a, b) => {\n  const result = { ...a,\n    ...b\n  };\n\n  for (const key of Object.keys(a)) {\n    if (key in b) {\n      if (a[key] === b[key]) continue;\n      result[key] = mergeMaybeArrays(a[key], b[key]);\n    }\n  }\n\n  return result;\n};\n\nconst encodeDataUri = (encoding, source) => {\n  let encodedContent;\n\n  switch (encoding) {\n    case \"base64\":\n      {\n        encodedContent = source.buffer().toString(\"base64\");\n        break;\n      }\n\n    case false:\n      {\n        const content = source.source();\n\n        if (typeof content !== \"string\") {\n          encodedContent = content.toString(\"utf-8\");\n        }\n\n        encodedContent = encodeURIComponent(encodedContent).replace(/[!'()*]/g, character => \"%\" + character.codePointAt(0).toString(16));\n        break;\n      }\n\n    default:\n      throw new Error(`Unsupported encoding '${encoding}'`);\n  }\n\n  return encodedContent;\n};\n\nconst decodeDataUriContent = (encoding, content) => {\n  const isBase64 = encoding === \"base64\";\n  return isBase64 ? Buffer.from(content, \"base64\") : Buffer.from(decodeURIComponent(content), \"ascii\");\n};\n\nconst JS_TYPES = new Set([\"javascript\"]);\nconst JS_AND_ASSET_TYPES = new Set([\"javascript\", \"asset\"]);\nconst DEFAULT_ENCODING = \"base64\";\n\nclass AssetGenerator extends Generator {\n  /**\n   * @param {AssetGeneratorOptions[\"dataUrl\"]=} dataUrlOptions the options for the data url\n   * @param {string=} filename override for output.assetModuleFilename\n   * @param {RawPublicPath=} publicPath override for output.assetModulePublicPath\n   * @param {AssetModuleOutputPath=} outputPath the output path for the emitted file which is not included in the runtime import\n   * @param {boolean=} emit generate output asset\n   */\n  constructor(dataUrlOptions, filename, publicPath, outputPath, emit) {\n    super();\n    this.dataUrlOptions = dataUrlOptions;\n    this.filename = filename;\n    this.publicPath = publicPath;\n    this.outputPath = outputPath;\n    this.emit = emit;\n  }\n  /**\n   * @param {NormalModule} module module\n   * @param {RuntimeTemplate} runtimeTemplate runtime template\n   * @returns {string} source file name\n   */\n\n\n  getSourceFileName(module, runtimeTemplate) {\n    return makePathsRelative(runtimeTemplate.compilation.compiler.context, module.matchResource || module.resource, runtimeTemplate.compilation.compiler.root).replace(/^\\.\\//, \"\");\n  }\n  /**\n   * @param {NormalModule} module module\n   * @returns {string} mime type\n   */\n\n\n  getMimeType(module) {\n    if (typeof this.dataUrlOptions === \"function\") {\n      throw new Error(\"This method must not be called when dataUrlOptions is a function\");\n    }\n\n    let mimeType = this.dataUrlOptions.mimetype;\n\n    if (mimeType === undefined) {\n      const ext = path.extname(module.nameForCondition());\n\n      if (module.resourceResolveData && module.resourceResolveData.mimetype !== undefined) {\n        mimeType = module.resourceResolveData.mimetype + module.resourceResolveData.parameters;\n      } else if (ext) {\n        mimeType = mimeTypes.lookup(ext);\n\n        if (typeof mimeType !== \"string\") {\n          throw new Error(\"DataUrl can't be generated automatically, \" + `because there is no mimetype for \"${ext}\" in mimetype database. ` + 'Either pass a mimetype via \"generator.mimetype\" or ' + 'use type: \"asset/resource\" to create a resource file instead of a DataUrl');\n        }\n      }\n    }\n\n    if (typeof mimeType !== \"string\") {\n      throw new Error(\"DataUrl can't be generated automatically. \" + 'Either pass a mimetype via \"generator.mimetype\" or ' + 'use type: \"asset/resource\" to create a resource file instead of a DataUrl');\n    }\n\n    return mimeType;\n  }\n  /**\n   * @param {NormalModule} module module for which the code should be generated\n   * @param {GenerateContext} generateContext context for generate\n   * @returns {Source} generated code\n   */\n\n\n  generate(module, _ref) {\n    let {\n      runtime,\n      chunkGraph,\n      runtimeTemplate,\n      runtimeRequirements,\n      type,\n      getData\n    } = _ref;\n\n    switch (type) {\n      case \"asset\":\n        return module.originalSource();\n\n      default:\n        {\n          runtimeRequirements.add(RuntimeGlobals.module);\n          const originalSource = module.originalSource();\n\n          if (module.buildInfo.dataUrl) {\n            let encodedSource;\n\n            if (typeof this.dataUrlOptions === \"function\") {\n              encodedSource = this.dataUrlOptions.call(null, originalSource.source(), {\n                filename: module.matchResource || module.resource,\n                module\n              });\n            } else {\n              /** @type {string | false | undefined} */\n              let encoding = this.dataUrlOptions.encoding;\n\n              if (encoding === undefined) {\n                if (module.resourceResolveData && module.resourceResolveData.encoding !== undefined) {\n                  encoding = module.resourceResolveData.encoding;\n                }\n              }\n\n              if (encoding === undefined) {\n                encoding = DEFAULT_ENCODING;\n              }\n\n              const mimeType = this.getMimeType(module);\n              let encodedContent;\n\n              if (module.resourceResolveData && module.resourceResolveData.encoding === encoding && decodeDataUriContent(module.resourceResolveData.encoding, module.resourceResolveData.encodedContent).equals(originalSource.buffer())) {\n                encodedContent = module.resourceResolveData.encodedContent;\n              } else {\n                encodedContent = encodeDataUri(encoding, originalSource);\n              }\n\n              encodedSource = `data:${mimeType}${encoding ? `;${encoding}` : \"\"},${encodedContent}`;\n            }\n\n            const data = getData();\n            data.set(\"url\", Buffer.from(encodedSource));\n            return new RawSource(`${RuntimeGlobals.module}.exports = ${JSON.stringify(encodedSource)};`);\n          } else {\n            const assetModuleFilename = this.filename || runtimeTemplate.outputOptions.assetModuleFilename;\n            const hash = createHash(runtimeTemplate.outputOptions.hashFunction);\n\n            if (runtimeTemplate.outputOptions.hashSalt) {\n              hash.update(runtimeTemplate.outputOptions.hashSalt);\n            }\n\n            hash.update(originalSource.buffer());\n            const fullHash =\n            /** @type {string} */\n            hash.digest(runtimeTemplate.outputOptions.hashDigest);\n            const contentHash = nonNumericOnlyHash(fullHash, runtimeTemplate.outputOptions.hashDigestLength);\n            module.buildInfo.fullContentHash = fullHash;\n            const sourceFilename = this.getSourceFileName(module, runtimeTemplate);\n            let {\n              path: filename,\n              info: assetInfo\n            } = runtimeTemplate.compilation.getAssetPathWithInfo(assetModuleFilename, {\n              module,\n              runtime,\n              filename: sourceFilename,\n              chunkGraph,\n              contentHash\n            });\n            let assetPath;\n\n            if (this.publicPath !== undefined) {\n              const {\n                path,\n                info\n              } = runtimeTemplate.compilation.getAssetPathWithInfo(this.publicPath, {\n                module,\n                runtime,\n                filename: sourceFilename,\n                chunkGraph,\n                contentHash\n              });\n              assetInfo = mergeAssetInfo(assetInfo, info);\n              assetPath = JSON.stringify(path + filename);\n            } else {\n              runtimeRequirements.add(RuntimeGlobals.publicPath); // add __webpack_require__.p\n\n              assetPath = runtimeTemplate.concatenation({\n                expr: RuntimeGlobals.publicPath\n              }, filename);\n            }\n\n            assetInfo = {\n              sourceFilename,\n              ...assetInfo\n            };\n\n            if (this.outputPath) {\n              const {\n                path: outputPath,\n                info\n              } = runtimeTemplate.compilation.getAssetPathWithInfo(this.outputPath, {\n                module,\n                runtime,\n                filename: sourceFilename,\n                chunkGraph,\n                contentHash\n              });\n              assetInfo = mergeAssetInfo(assetInfo, info);\n              filename = path.posix.join(outputPath, filename);\n            }\n\n            module.buildInfo.filename = filename;\n            module.buildInfo.assetInfo = assetInfo;\n\n            if (getData) {\n              // Due to code generation caching module.buildInfo.XXX can't used to store such information\n              // It need to be stored in the code generation results instead, where it's cached too\n              // TODO webpack 6 For back-compat reasons we also store in on module.buildInfo\n              const data = getData();\n              data.set(\"fullContentHash\", fullHash);\n              data.set(\"filename\", filename);\n              data.set(\"assetInfo\", assetInfo);\n            }\n\n            return new RawSource(`${RuntimeGlobals.module}.exports = ${assetPath};`);\n          }\n        }\n    }\n  }\n  /**\n   * @param {NormalModule} module fresh module\n   * @returns {Set<string>} available types (do not mutate)\n   */\n\n\n  getTypes(module) {\n    if (module.buildInfo && module.buildInfo.dataUrl || this.emit === false) {\n      return JS_TYPES;\n    } else {\n      return JS_AND_ASSET_TYPES;\n    }\n  }\n  /**\n   * @param {NormalModule} module the module\n   * @param {string=} type source type\n   * @returns {number} estimate size of the module\n   */\n\n\n  getSize(module, type) {\n    switch (type) {\n      case \"asset\":\n        {\n          const originalSource = module.originalSource();\n\n          if (!originalSource) {\n            return 0;\n          }\n\n          return originalSource.size();\n        }\n\n      default:\n        if (module.buildInfo && module.buildInfo.dataUrl) {\n          const originalSource = module.originalSource();\n\n          if (!originalSource) {\n            return 0;\n          } // roughly for data url\n          // Example: m.exports=\"data:image/png;base64,ag82/f+2==\"\n          // 4/3 = base64 encoding\n          // 34 = ~ data url header + footer + rounding\n\n\n          return originalSource.size() * 1.34 + 36;\n        } else {\n          // it's only estimated so this number is probably fine\n          // Example: m.exports=r.p+\"0123456789012345678901.ext\"\n          return 42;\n        }\n\n    }\n  }\n  /**\n   * @param {Hash} hash hash that will be modified\n   * @param {UpdateHashContext} updateHashContext context for updating hash\n   */\n\n\n  updateHash(hash, _ref2) {\n    let {\n      module,\n      runtime,\n      runtimeTemplate,\n      chunkGraph\n    } = _ref2;\n\n    if (module.buildInfo.dataUrl) {\n      hash.update(\"data-url\"); // this.dataUrlOptions as function should be pure and only depend on input source and filename\n      // therefore it doesn't need to be hashed\n\n      if (typeof this.dataUrlOptions === \"function\") {\n        const ident =\n        /** @type {{ ident?: string }} */\n        this.dataUrlOptions.ident;\n        if (ident) hash.update(ident);\n      } else {\n        if (this.dataUrlOptions.encoding && this.dataUrlOptions.encoding !== DEFAULT_ENCODING) {\n          hash.update(this.dataUrlOptions.encoding);\n        }\n\n        if (this.dataUrlOptions.mimetype) hash.update(this.dataUrlOptions.mimetype); // computed mimetype depends only on module filename which is already part of the hash\n      }\n    } else {\n      hash.update(\"resource\");\n      const pathData = {\n        module,\n        runtime,\n        filename: this.getSourceFileName(module, runtimeTemplate),\n        chunkGraph,\n        contentHash: runtimeTemplate.contentHashReplacement\n      };\n\n      if (typeof this.publicPath === \"function\") {\n        hash.update(\"path\");\n        const assetInfo = {};\n        hash.update(this.publicPath(pathData, assetInfo));\n        hash.update(JSON.stringify(assetInfo));\n      } else if (this.publicPath) {\n        hash.update(\"path\");\n        hash.update(this.publicPath);\n      } else {\n        hash.update(\"no-path\");\n      }\n\n      const assetModuleFilename = this.filename || runtimeTemplate.outputOptions.assetModuleFilename;\n      const {\n        path: filename,\n        info\n      } = runtimeTemplate.compilation.getAssetPathWithInfo(assetModuleFilename, pathData);\n      hash.update(filename);\n      hash.update(JSON.stringify(info));\n    }\n  }\n\n}\n\nmodule.exports = AssetGenerator;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/asset/AssetGenerator.js"],"names":["mimeTypes","require","path","RawSource","Generator","RuntimeGlobals","createHash","makePathsRelative","nonNumericOnlyHash","mergeMaybeArrays","a","b","set","Set","Array","isArray","item","add","from","mergeAssetInfo","result","key","Object","keys","mergeRelatedInfo","Error","encodeDataUri","encoding","source","encodedContent","buffer","toString","content","encodeURIComponent","replace","character","codePointAt","decodeDataUriContent","isBase64","Buffer","decodeURIComponent","JS_TYPES","JS_AND_ASSET_TYPES","DEFAULT_ENCODING","AssetGenerator","constructor","dataUrlOptions","filename","publicPath","outputPath","emit","getSourceFileName","module","runtimeTemplate","compilation","compiler","context","matchResource","resource","root","getMimeType","mimeType","mimetype","undefined","ext","extname","nameForCondition","resourceResolveData","parameters","lookup","generate","runtime","chunkGraph","runtimeRequirements","type","getData","originalSource","buildInfo","dataUrl","encodedSource","call","equals","data","JSON","stringify","assetModuleFilename","outputOptions","hash","hashFunction","hashSalt","update","fullHash","digest","hashDigest","contentHash","hashDigestLength","fullContentHash","sourceFilename","info","assetInfo","getAssetPathWithInfo","assetPath","concatenation","expr","posix","join","getTypes","getSize","size","updateHash","ident","pathData","contentHashReplacement","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Sergey Melyukov @smelukov\n*/\n\n\"use strict\";\n\nconst mimeTypes = require(\"mime-types\");\nconst path = require(\"path\");\nconst { RawSource } = require(\"webpack-sources\");\nconst Generator = require(\"../Generator\");\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst createHash = require(\"../util/createHash\");\nconst { makePathsRelative } = require(\"../util/identifier\");\nconst nonNumericOnlyHash = require(\"../util/nonNumericOnlyHash\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../../declarations/WebpackOptions\").AssetGeneratorOptions} AssetGeneratorOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").AssetModuleOutputPath} AssetModuleOutputPath */\n/** @typedef {import(\"../../declarations/WebpackOptions\").RawPublicPath} RawPublicPath */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Generator\").GenerateContext} GenerateContext */\n/** @typedef {import(\"../Generator\").UpdateHashContext} UpdateHashContext */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"../util/Hash\")} Hash */\n\nconst mergeMaybeArrays = (a, b) => {\n\tconst set = new Set();\n\tif (Array.isArray(a)) for (const item of a) set.add(item);\n\telse set.add(a);\n\tif (Array.isArray(b)) for (const item of b) set.add(item);\n\telse set.add(b);\n\treturn Array.from(set);\n};\n\nconst mergeAssetInfo = (a, b) => {\n\tconst result = { ...a, ...b };\n\tfor (const key of Object.keys(a)) {\n\t\tif (key in b) {\n\t\t\tif (a[key] === b[key]) continue;\n\t\t\tswitch (key) {\n\t\t\t\tcase \"fullhash\":\n\t\t\t\tcase \"chunkhash\":\n\t\t\t\tcase \"modulehash\":\n\t\t\t\tcase \"contenthash\":\n\t\t\t\t\tresult[key] = mergeMaybeArrays(a[key], b[key]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"immutable\":\n\t\t\t\tcase \"development\":\n\t\t\t\tcase \"hotModuleReplacement\":\n\t\t\t\tcase \"javascriptModule\":\n\t\t\t\t\tresult[key] = a[key] || b[key];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"related\":\n\t\t\t\t\tresult[key] = mergeRelatedInfo(a[key], b[key]);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Can't handle conflicting asset info for ${key}`);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n};\n\nconst mergeRelatedInfo = (a, b) => {\n\tconst result = { ...a, ...b };\n\tfor (const key of Object.keys(a)) {\n\t\tif (key in b) {\n\t\t\tif (a[key] === b[key]) continue;\n\t\t\tresult[key] = mergeMaybeArrays(a[key], b[key]);\n\t\t}\n\t}\n\treturn result;\n};\n\nconst encodeDataUri = (encoding, source) => {\n\tlet encodedContent;\n\n\tswitch (encoding) {\n\t\tcase \"base64\": {\n\t\t\tencodedContent = source.buffer().toString(\"base64\");\n\t\t\tbreak;\n\t\t}\n\t\tcase false: {\n\t\t\tconst content = source.source();\n\n\t\t\tif (typeof content !== \"string\") {\n\t\t\t\tencodedContent = content.toString(\"utf-8\");\n\t\t\t}\n\n\t\t\tencodedContent = encodeURIComponent(encodedContent).replace(\n\t\t\t\t/[!'()*]/g,\n\t\t\t\tcharacter => \"%\" + character.codePointAt(0).toString(16)\n\t\t\t);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported encoding '${encoding}'`);\n\t}\n\n\treturn encodedContent;\n};\n\nconst decodeDataUriContent = (encoding, content) => {\n\tconst isBase64 = encoding === \"base64\";\n\treturn isBase64\n\t\t? Buffer.from(content, \"base64\")\n\t\t: Buffer.from(decodeURIComponent(content), \"ascii\");\n};\n\nconst JS_TYPES = new Set([\"javascript\"]);\nconst JS_AND_ASSET_TYPES = new Set([\"javascript\", \"asset\"]);\nconst DEFAULT_ENCODING = \"base64\";\n\nclass AssetGenerator extends Generator {\n\t/**\n\t * @param {AssetGeneratorOptions[\"dataUrl\"]=} dataUrlOptions the options for the data url\n\t * @param {string=} filename override for output.assetModuleFilename\n\t * @param {RawPublicPath=} publicPath override for output.assetModulePublicPath\n\t * @param {AssetModuleOutputPath=} outputPath the output path for the emitted file which is not included in the runtime import\n\t * @param {boolean=} emit generate output asset\n\t */\n\tconstructor(dataUrlOptions, filename, publicPath, outputPath, emit) {\n\t\tsuper();\n\t\tthis.dataUrlOptions = dataUrlOptions;\n\t\tthis.filename = filename;\n\t\tthis.publicPath = publicPath;\n\t\tthis.outputPath = outputPath;\n\t\tthis.emit = emit;\n\t}\n\n\t/**\n\t * @param {NormalModule} module module\n\t * @param {RuntimeTemplate} runtimeTemplate runtime template\n\t * @returns {string} source file name\n\t */\n\tgetSourceFileName(module, runtimeTemplate) {\n\t\treturn makePathsRelative(\n\t\t\truntimeTemplate.compilation.compiler.context,\n\t\t\tmodule.matchResource || module.resource,\n\t\t\truntimeTemplate.compilation.compiler.root\n\t\t).replace(/^\\.\\//, \"\");\n\t}\n\n\t/**\n\t * @param {NormalModule} module module\n\t * @returns {string} mime type\n\t */\n\tgetMimeType(module) {\n\t\tif (typeof this.dataUrlOptions === \"function\") {\n\t\t\tthrow new Error(\n\t\t\t\t\"This method must not be called when dataUrlOptions is a function\"\n\t\t\t);\n\t\t}\n\n\t\tlet mimeType = this.dataUrlOptions.mimetype;\n\t\tif (mimeType === undefined) {\n\t\t\tconst ext = path.extname(module.nameForCondition());\n\t\t\tif (\n\t\t\t\tmodule.resourceResolveData &&\n\t\t\t\tmodule.resourceResolveData.mimetype !== undefined\n\t\t\t) {\n\t\t\t\tmimeType =\n\t\t\t\t\tmodule.resourceResolveData.mimetype +\n\t\t\t\t\tmodule.resourceResolveData.parameters;\n\t\t\t} else if (ext) {\n\t\t\t\tmimeType = mimeTypes.lookup(ext);\n\n\t\t\t\tif (typeof mimeType !== \"string\") {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\"DataUrl can't be generated automatically, \" +\n\t\t\t\t\t\t\t`because there is no mimetype for \"${ext}\" in mimetype database. ` +\n\t\t\t\t\t\t\t'Either pass a mimetype via \"generator.mimetype\" or ' +\n\t\t\t\t\t\t\t'use type: \"asset/resource\" to create a resource file instead of a DataUrl'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (typeof mimeType !== \"string\") {\n\t\t\tthrow new Error(\n\t\t\t\t\"DataUrl can't be generated automatically. \" +\n\t\t\t\t\t'Either pass a mimetype via \"generator.mimetype\" or ' +\n\t\t\t\t\t'use type: \"asset/resource\" to create a resource file instead of a DataUrl'\n\t\t\t);\n\t\t}\n\n\t\treturn mimeType;\n\t}\n\n\t/**\n\t * @param {NormalModule} module module for which the code should be generated\n\t * @param {GenerateContext} generateContext context for generate\n\t * @returns {Source} generated code\n\t */\n\tgenerate(\n\t\tmodule,\n\t\t{ runtime, chunkGraph, runtimeTemplate, runtimeRequirements, type, getData }\n\t) {\n\t\tswitch (type) {\n\t\t\tcase \"asset\":\n\t\t\t\treturn module.originalSource();\n\t\t\tdefault: {\n\t\t\t\truntimeRequirements.add(RuntimeGlobals.module);\n\n\t\t\t\tconst originalSource = module.originalSource();\n\t\t\t\tif (module.buildInfo.dataUrl) {\n\t\t\t\t\tlet encodedSource;\n\t\t\t\t\tif (typeof this.dataUrlOptions === \"function\") {\n\t\t\t\t\t\tencodedSource = this.dataUrlOptions.call(\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\toriginalSource.source(),\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfilename: module.matchResource || module.resource,\n\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/** @type {string | false | undefined} */\n\t\t\t\t\t\tlet encoding = this.dataUrlOptions.encoding;\n\t\t\t\t\t\tif (encoding === undefined) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tmodule.resourceResolveData &&\n\t\t\t\t\t\t\t\tmodule.resourceResolveData.encoding !== undefined\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tencoding = module.resourceResolveData.encoding;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (encoding === undefined) {\n\t\t\t\t\t\t\tencoding = DEFAULT_ENCODING;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst mimeType = this.getMimeType(module);\n\n\t\t\t\t\t\tlet encodedContent;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tmodule.resourceResolveData &&\n\t\t\t\t\t\t\tmodule.resourceResolveData.encoding === encoding &&\n\t\t\t\t\t\t\tdecodeDataUriContent(\n\t\t\t\t\t\t\t\tmodule.resourceResolveData.encoding,\n\t\t\t\t\t\t\t\tmodule.resourceResolveData.encodedContent\n\t\t\t\t\t\t\t).equals(originalSource.buffer())\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tencodedContent = module.resourceResolveData.encodedContent;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tencodedContent = encodeDataUri(encoding, originalSource);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tencodedSource = `data:${mimeType}${\n\t\t\t\t\t\t\tencoding ? `;${encoding}` : \"\"\n\t\t\t\t\t\t},${encodedContent}`;\n\t\t\t\t\t}\n\t\t\t\t\tconst data = getData();\n\t\t\t\t\tdata.set(\"url\", Buffer.from(encodedSource));\n\t\t\t\t\treturn new RawSource(\n\t\t\t\t\t\t`${RuntimeGlobals.module}.exports = ${JSON.stringify(\n\t\t\t\t\t\t\tencodedSource\n\t\t\t\t\t\t)};`\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tconst assetModuleFilename =\n\t\t\t\t\t\tthis.filename || runtimeTemplate.outputOptions.assetModuleFilename;\n\t\t\t\t\tconst hash = createHash(runtimeTemplate.outputOptions.hashFunction);\n\t\t\t\t\tif (runtimeTemplate.outputOptions.hashSalt) {\n\t\t\t\t\t\thash.update(runtimeTemplate.outputOptions.hashSalt);\n\t\t\t\t\t}\n\t\t\t\t\thash.update(originalSource.buffer());\n\t\t\t\t\tconst fullHash = /** @type {string} */ (\n\t\t\t\t\t\thash.digest(runtimeTemplate.outputOptions.hashDigest)\n\t\t\t\t\t);\n\t\t\t\t\tconst contentHash = nonNumericOnlyHash(\n\t\t\t\t\t\tfullHash,\n\t\t\t\t\t\truntimeTemplate.outputOptions.hashDigestLength\n\t\t\t\t\t);\n\t\t\t\t\tmodule.buildInfo.fullContentHash = fullHash;\n\t\t\t\t\tconst sourceFilename = this.getSourceFileName(\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\truntimeTemplate\n\t\t\t\t\t);\n\t\t\t\t\tlet { path: filename, info: assetInfo } =\n\t\t\t\t\t\truntimeTemplate.compilation.getAssetPathWithInfo(\n\t\t\t\t\t\t\tassetModuleFilename,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\truntime,\n\t\t\t\t\t\t\t\tfilename: sourceFilename,\n\t\t\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\t\t\tcontentHash\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\tlet assetPath;\n\t\t\t\t\tif (this.publicPath !== undefined) {\n\t\t\t\t\t\tconst { path, info } =\n\t\t\t\t\t\t\truntimeTemplate.compilation.getAssetPathWithInfo(\n\t\t\t\t\t\t\t\tthis.publicPath,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\truntime,\n\t\t\t\t\t\t\t\t\tfilename: sourceFilename,\n\t\t\t\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\t\t\t\tcontentHash\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tassetInfo = mergeAssetInfo(assetInfo, info);\n\t\t\t\t\t\tassetPath = JSON.stringify(path + filename);\n\t\t\t\t\t} else {\n\t\t\t\t\t\truntimeRequirements.add(RuntimeGlobals.publicPath); // add __webpack_require__.p\n\t\t\t\t\t\tassetPath = runtimeTemplate.concatenation(\n\t\t\t\t\t\t\t{ expr: RuntimeGlobals.publicPath },\n\t\t\t\t\t\t\tfilename\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tassetInfo = {\n\t\t\t\t\t\tsourceFilename,\n\t\t\t\t\t\t...assetInfo\n\t\t\t\t\t};\n\t\t\t\t\tif (this.outputPath) {\n\t\t\t\t\t\tconst { path: outputPath, info } =\n\t\t\t\t\t\t\truntimeTemplate.compilation.getAssetPathWithInfo(\n\t\t\t\t\t\t\t\tthis.outputPath,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\truntime,\n\t\t\t\t\t\t\t\t\tfilename: sourceFilename,\n\t\t\t\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\t\t\t\tcontentHash\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tassetInfo = mergeAssetInfo(assetInfo, info);\n\t\t\t\t\t\tfilename = path.posix.join(outputPath, filename);\n\t\t\t\t\t}\n\t\t\t\t\tmodule.buildInfo.filename = filename;\n\t\t\t\t\tmodule.buildInfo.assetInfo = assetInfo;\n\t\t\t\t\tif (getData) {\n\t\t\t\t\t\t// Due to code generation caching module.buildInfo.XXX can't used to store such information\n\t\t\t\t\t\t// It need to be stored in the code generation results instead, where it's cached too\n\t\t\t\t\t\t// TODO webpack 6 For back-compat reasons we also store in on module.buildInfo\n\t\t\t\t\t\tconst data = getData();\n\t\t\t\t\t\tdata.set(\"fullContentHash\", fullHash);\n\t\t\t\t\t\tdata.set(\"filename\", filename);\n\t\t\t\t\t\tdata.set(\"assetInfo\", assetInfo);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn new RawSource(\n\t\t\t\t\t\t`${RuntimeGlobals.module}.exports = ${assetPath};`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {NormalModule} module fresh module\n\t * @returns {Set<string>} available types (do not mutate)\n\t */\n\tgetTypes(module) {\n\t\tif ((module.buildInfo && module.buildInfo.dataUrl) || this.emit === false) {\n\t\t\treturn JS_TYPES;\n\t\t} else {\n\t\t\treturn JS_AND_ASSET_TYPES;\n\t\t}\n\t}\n\n\t/**\n\t * @param {NormalModule} module the module\n\t * @param {string=} type source type\n\t * @returns {number} estimate size of the module\n\t */\n\tgetSize(module, type) {\n\t\tswitch (type) {\n\t\t\tcase \"asset\": {\n\t\t\t\tconst originalSource = module.originalSource();\n\n\t\t\t\tif (!originalSource) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn originalSource.size();\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tif (module.buildInfo && module.buildInfo.dataUrl) {\n\t\t\t\t\tconst originalSource = module.originalSource();\n\n\t\t\t\t\tif (!originalSource) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t// roughly for data url\n\t\t\t\t\t// Example: m.exports=\"data:image/png;base64,ag82/f+2==\"\n\t\t\t\t\t// 4/3 = base64 encoding\n\t\t\t\t\t// 34 = ~ data url header + footer + rounding\n\t\t\t\t\treturn originalSource.size() * 1.34 + 36;\n\t\t\t\t} else {\n\t\t\t\t\t// it's only estimated so this number is probably fine\n\t\t\t\t\t// Example: m.exports=r.p+\"0123456789012345678901.ext\"\n\t\t\t\t\treturn 42;\n\t\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Hash} hash hash that will be modified\n\t * @param {UpdateHashContext} updateHashContext context for updating hash\n\t */\n\tupdateHash(hash, { module, runtime, runtimeTemplate, chunkGraph }) {\n\t\tif (module.buildInfo.dataUrl) {\n\t\t\thash.update(\"data-url\");\n\t\t\t// this.dataUrlOptions as function should be pure and only depend on input source and filename\n\t\t\t// therefore it doesn't need to be hashed\n\t\t\tif (typeof this.dataUrlOptions === \"function\") {\n\t\t\t\tconst ident = /** @type {{ ident?: string }} */ (this.dataUrlOptions)\n\t\t\t\t\t.ident;\n\t\t\t\tif (ident) hash.update(ident);\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tthis.dataUrlOptions.encoding &&\n\t\t\t\t\tthis.dataUrlOptions.encoding !== DEFAULT_ENCODING\n\t\t\t\t) {\n\t\t\t\t\thash.update(this.dataUrlOptions.encoding);\n\t\t\t\t}\n\t\t\t\tif (this.dataUrlOptions.mimetype)\n\t\t\t\t\thash.update(this.dataUrlOptions.mimetype);\n\t\t\t\t// computed mimetype depends only on module filename which is already part of the hash\n\t\t\t}\n\t\t} else {\n\t\t\thash.update(\"resource\");\n\n\t\t\tconst pathData = {\n\t\t\t\tmodule,\n\t\t\t\truntime,\n\t\t\t\tfilename: this.getSourceFileName(module, runtimeTemplate),\n\t\t\t\tchunkGraph,\n\t\t\t\tcontentHash: runtimeTemplate.contentHashReplacement\n\t\t\t};\n\n\t\t\tif (typeof this.publicPath === \"function\") {\n\t\t\t\thash.update(\"path\");\n\t\t\t\tconst assetInfo = {};\n\t\t\t\thash.update(this.publicPath(pathData, assetInfo));\n\t\t\t\thash.update(JSON.stringify(assetInfo));\n\t\t\t} else if (this.publicPath) {\n\t\t\t\thash.update(\"path\");\n\t\t\t\thash.update(this.publicPath);\n\t\t\t} else {\n\t\t\t\thash.update(\"no-path\");\n\t\t\t}\n\n\t\t\tconst assetModuleFilename =\n\t\t\t\tthis.filename || runtimeTemplate.outputOptions.assetModuleFilename;\n\t\t\tconst { path: filename, info } =\n\t\t\t\truntimeTemplate.compilation.getAssetPathWithInfo(\n\t\t\t\t\tassetModuleFilename,\n\t\t\t\t\tpathData\n\t\t\t\t);\n\t\t\thash.update(filename);\n\t\t\thash.update(JSON.stringify(info));\n\t\t}\n\t}\n}\n\nmodule.exports = AssetGenerator;\n"]},"metadata":{},"sourceType":"script"}