{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst FileSystemInfo = require(\"../FileSystemInfo\");\n\nconst ProgressPlugin = require(\"../ProgressPlugin\");\n\nconst {\n  formatSize\n} = require(\"../SizeFormatHelpers\");\n\nconst SerializerMiddleware = require(\"../serialization/SerializerMiddleware\");\n\nconst LazySet = require(\"../util/LazySet\");\n\nconst makeSerializable = require(\"../util/makeSerializable\");\n\nconst memoize = require(\"../util/memoize\");\n\nconst {\n  createFileSerializer,\n  NOT_SERIALIZABLE\n} = require(\"../util/serialization\");\n/** @typedef {import(\"../../declarations/WebpackOptions\").SnapshotOptions} SnapshotOptions */\n\n/** @typedef {import(\"../Cache\").Etag} Etag */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\n\n/** @typedef {import(\"../logging/Logger\").Logger} Logger */\n\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\n\nclass PackContainer {\n  /**\n   * @param {Object} data stored data\n   * @param {string} version version identifier\n   * @param {Snapshot} buildSnapshot snapshot of all build dependencies\n   * @param {Set<string>} buildDependencies list of all unresolved build dependencies captured\n   * @param {Map<string, string | false>} resolveResults result of the resolved build dependencies\n   * @param {Snapshot} resolveBuildDependenciesSnapshot snapshot of the dependencies of the build dependencies resolving\n   */\n  constructor(data, version, buildSnapshot, buildDependencies, resolveResults, resolveBuildDependenciesSnapshot) {\n    this.data = data;\n    this.version = version;\n    this.buildSnapshot = buildSnapshot;\n    this.buildDependencies = buildDependencies;\n    this.resolveResults = resolveResults;\n    this.resolveBuildDependenciesSnapshot = resolveBuildDependenciesSnapshot;\n  }\n\n  serialize(_ref) {\n    let {\n      write,\n      writeLazy\n    } = _ref;\n    write(this.version);\n    write(this.buildSnapshot);\n    write(this.buildDependencies);\n    write(this.resolveResults);\n    write(this.resolveBuildDependenciesSnapshot);\n    writeLazy(this.data);\n  }\n\n  deserialize(_ref2) {\n    let {\n      read\n    } = _ref2;\n    this.version = read();\n    this.buildSnapshot = read();\n    this.buildDependencies = read();\n    this.resolveResults = read();\n    this.resolveBuildDependenciesSnapshot = read();\n    this.data = read();\n  }\n\n}\n\nmakeSerializable(PackContainer, \"webpack/lib/cache/PackFileCacheStrategy\", \"PackContainer\");\nconst MIN_CONTENT_SIZE = 1024 * 1024; // 1 MB\n\nconst CONTENT_COUNT_TO_MERGE = 10;\nconst MIN_ITEMS_IN_FRESH_PACK = 100;\nconst MAX_ITEMS_IN_FRESH_PACK = 50000;\nconst MAX_TIME_IN_FRESH_PACK = 1 * 60 * 1000; // 1 min\n\nclass PackItemInfo {\n  /**\n   * @param {string} identifier identifier of item\n   * @param {string | null} etag etag of item\n   * @param {any} value fresh value of item\n   */\n  constructor(identifier, etag, value) {\n    this.identifier = identifier;\n    this.etag = etag;\n    this.location = -1;\n    this.lastAccess = Date.now();\n    this.freshValue = value;\n  }\n\n}\n\nclass Pack {\n  constructor(logger, maxAge) {\n    /** @type {Map<string, PackItemInfo>} */\n    this.itemInfo = new Map();\n    /** @type {string[]} */\n\n    this.requests = [];\n    this.requestsTimeout = undefined;\n    /** @type {Map<string, PackItemInfo>} */\n\n    this.freshContent = new Map();\n    /** @type {(undefined | PackContent)[]} */\n\n    this.content = [];\n    this.invalid = false;\n    this.logger = logger;\n    this.maxAge = maxAge;\n  }\n\n  _addRequest(identifier) {\n    this.requests.push(identifier);\n\n    if (this.requestsTimeout === undefined) {\n      this.requestsTimeout = setTimeout(() => {\n        this.requests.push(undefined);\n        this.requestsTimeout = undefined;\n      }, MAX_TIME_IN_FRESH_PACK);\n      if (this.requestsTimeout.unref) this.requestsTimeout.unref();\n    }\n  }\n\n  stopCapturingRequests() {\n    if (this.requestsTimeout !== undefined) {\n      clearTimeout(this.requestsTimeout);\n      this.requestsTimeout = undefined;\n    }\n  }\n  /**\n   * @param {string} identifier unique name for the resource\n   * @param {string | null} etag etag of the resource\n   * @returns {any} cached content\n   */\n\n\n  get(identifier, etag) {\n    const info = this.itemInfo.get(identifier);\n\n    this._addRequest(identifier);\n\n    if (info === undefined) {\n      return undefined;\n    }\n\n    if (info.etag !== etag) return null;\n    info.lastAccess = Date.now();\n    const loc = info.location;\n\n    if (loc === -1) {\n      return info.freshValue;\n    } else {\n      if (!this.content[loc]) {\n        return undefined;\n      }\n\n      return this.content[loc].get(identifier);\n    }\n  }\n  /**\n   * @param {string} identifier unique name for the resource\n   * @param {string | null} etag etag of the resource\n   * @param {any} data cached content\n   * @returns {void}\n   */\n\n\n  set(identifier, etag, data) {\n    if (!this.invalid) {\n      this.invalid = true;\n      this.logger.log(`Pack got invalid because of write to: ${identifier}`);\n    }\n\n    const info = this.itemInfo.get(identifier);\n\n    if (info === undefined) {\n      const newInfo = new PackItemInfo(identifier, etag, data);\n      this.itemInfo.set(identifier, newInfo);\n\n      this._addRequest(identifier);\n\n      this.freshContent.set(identifier, newInfo);\n    } else {\n      const loc = info.location;\n\n      if (loc >= 0) {\n        this._addRequest(identifier);\n\n        this.freshContent.set(identifier, info);\n        const content = this.content[loc];\n        content.delete(identifier);\n\n        if (content.items.size === 0) {\n          this.content[loc] = undefined;\n          this.logger.debug(\"Pack %d got empty and is removed\", loc);\n        }\n      }\n\n      info.freshValue = data;\n      info.lastAccess = Date.now();\n      info.etag = etag;\n      info.location = -1;\n    }\n  }\n\n  getContentStats() {\n    let count = 0;\n    let size = 0;\n\n    for (const content of this.content) {\n      if (content !== undefined) {\n        count++;\n        const s = content.getSize();\n\n        if (s > 0) {\n          size += s;\n        }\n      }\n    }\n\n    return {\n      count,\n      size\n    };\n  }\n  /**\n   * @returns {number} new location of data entries\n   */\n\n\n  _findLocation() {\n    let i;\n\n    for (i = 0; i < this.content.length && this.content[i] !== undefined; i++);\n\n    return i;\n  }\n\n  _gcAndUpdateLocation(items, usedItems, newLoc) {\n    let count = 0;\n    let lastGC;\n    const now = Date.now();\n\n    for (const identifier of items) {\n      const info = this.itemInfo.get(identifier);\n\n      if (now - info.lastAccess > this.maxAge) {\n        this.itemInfo.delete(identifier);\n        items.delete(identifier);\n        usedItems.delete(identifier);\n        count++;\n        lastGC = identifier;\n      } else {\n        info.location = newLoc;\n      }\n    }\n\n    if (count > 0) {\n      this.logger.log(\"Garbage Collected %d old items at pack %d (%d items remaining) e. g. %s\", count, newLoc, items.size, lastGC);\n    }\n  }\n\n  _persistFreshContent() {\n    const itemsCount = this.freshContent.size;\n\n    if (itemsCount > 0) {\n      const packCount = Math.ceil(itemsCount / MAX_ITEMS_IN_FRESH_PACK);\n      const itemsPerPack = Math.ceil(itemsCount / packCount);\n      const packs = [];\n      let i = 0;\n      let ignoreNextTimeTick = false;\n\n      const createNextPack = () => {\n        const loc = this._findLocation();\n\n        this.content[loc] = null; // reserve\n\n        const pack = {\n          /** @type {Set<string>} */\n          items: new Set(),\n\n          /** @type {Map<string, any>} */\n          map: new Map(),\n          loc\n        };\n        packs.push(pack);\n        return pack;\n      };\n\n      let pack = createNextPack();\n      if (this.requestsTimeout !== undefined) clearTimeout(this.requestsTimeout);\n\n      for (const identifier of this.requests) {\n        if (identifier === undefined) {\n          if (ignoreNextTimeTick) {\n            ignoreNextTimeTick = false;\n          } else if (pack.items.size >= MIN_ITEMS_IN_FRESH_PACK) {\n            i = 0;\n            pack = createNextPack();\n          }\n\n          continue;\n        }\n\n        const info = this.freshContent.get(identifier);\n        if (info === undefined) continue;\n        pack.items.add(identifier);\n        pack.map.set(identifier, info.freshValue);\n        info.location = pack.loc;\n        info.freshValue = undefined;\n        this.freshContent.delete(identifier);\n\n        if (++i > itemsPerPack) {\n          i = 0;\n          pack = createNextPack();\n          ignoreNextTimeTick = true;\n        }\n      }\n\n      this.requests.length = 0;\n\n      for (const pack of packs) {\n        this.content[pack.loc] = new PackContent(pack.items, new Set(pack.items), new PackContentItems(pack.map));\n      }\n\n      this.logger.log(`${itemsCount} fresh items in cache put into pack ${packs.length > 1 ? packs.map(pack => `${pack.loc} (${pack.items.size} items)`).join(\", \") : packs[0].loc}`);\n    }\n  }\n  /**\n   * Merges small content files to a single content file\n   */\n\n\n  _optimizeSmallContent() {\n    // 1. Find all small content files\n    // Treat unused content files separately to avoid\n    // a merge-split cycle\n\n    /** @type {number[]} */\n    const smallUsedContents = [];\n    /** @type {number} */\n\n    let smallUsedContentSize = 0;\n    /** @type {number[]} */\n\n    const smallUnusedContents = [];\n    /** @type {number} */\n\n    let smallUnusedContentSize = 0;\n\n    for (let i = 0; i < this.content.length; i++) {\n      const content = this.content[i];\n      if (content === undefined) continue;\n      if (content.outdated) continue;\n      const size = content.getSize();\n      if (size < 0 || size > MIN_CONTENT_SIZE) continue;\n\n      if (content.used.size > 0) {\n        smallUsedContents.push(i);\n        smallUsedContentSize += size;\n      } else {\n        smallUnusedContents.push(i);\n        smallUnusedContentSize += size;\n      }\n    } // 2. Check if minimum number is reached\n\n\n    let mergedIndices;\n\n    if (smallUsedContents.length >= CONTENT_COUNT_TO_MERGE || smallUsedContentSize > MIN_CONTENT_SIZE) {\n      mergedIndices = smallUsedContents;\n    } else if (smallUnusedContents.length >= CONTENT_COUNT_TO_MERGE || smallUnusedContentSize > MIN_CONTENT_SIZE) {\n      mergedIndices = smallUnusedContents;\n    } else return;\n\n    const mergedContent = []; // 3. Remove old content entries\n\n    for (const i of mergedIndices) {\n      mergedContent.push(this.content[i]);\n      this.content[i] = undefined;\n    } // 4. Determine merged items\n\n    /** @type {Set<string>} */\n\n\n    const mergedItems = new Set();\n    /** @type {Set<string>} */\n\n    const mergedUsedItems = new Set();\n    /** @type {(function(Map<string, any>): Promise)[]} */\n\n    const addToMergedMap = [];\n\n    for (const content of mergedContent) {\n      for (const identifier of content.items) {\n        mergedItems.add(identifier);\n      }\n\n      for (const identifier of content.used) {\n        mergedUsedItems.add(identifier);\n      }\n\n      addToMergedMap.push(async map => {\n        // unpack existing content\n        // after that values are accessible in .content\n        await content.unpack(\"it should be merged with other small pack contents\");\n\n        for (const [identifier, value] of content.content) {\n          map.set(identifier, value);\n        }\n      });\n    } // 5. GC and update location of merged items\n\n\n    const newLoc = this._findLocation();\n\n    this._gcAndUpdateLocation(mergedItems, mergedUsedItems, newLoc); // 6. If not empty, store content somewhere\n\n\n    if (mergedItems.size > 0) {\n      this.content[newLoc] = new PackContent(mergedItems, mergedUsedItems, memoize(async () => {\n        /** @type {Map<string, any>} */\n        const map = new Map();\n        await Promise.all(addToMergedMap.map(fn => fn(map)));\n        return new PackContentItems(map);\n      }));\n      this.logger.log(\"Merged %d small files with %d cache items into pack %d\", mergedContent.length, mergedItems.size, newLoc);\n    }\n  }\n  /**\n   * Split large content files with used and unused items\n   * into two parts to separate used from unused items\n   */\n\n\n  _optimizeUnusedContent() {\n    // 1. Find a large content file with used and unused items\n    for (let i = 0; i < this.content.length; i++) {\n      const content = this.content[i];\n      if (content === undefined) continue;\n      const size = content.getSize();\n      if (size < MIN_CONTENT_SIZE) continue;\n      const used = content.used.size;\n      const total = content.items.size;\n\n      if (used > 0 && used < total) {\n        // 2. Remove this content\n        this.content[i] = undefined; // 3. Determine items for the used content file\n\n        const usedItems = new Set(content.used);\n\n        const newLoc = this._findLocation();\n\n        this._gcAndUpdateLocation(usedItems, usedItems, newLoc); // 4. Create content file for used items\n\n\n        if (usedItems.size > 0) {\n          this.content[newLoc] = new PackContent(usedItems, new Set(usedItems), async () => {\n            await content.unpack(\"it should be splitted into used and unused items\");\n            const map = new Map();\n\n            for (const identifier of usedItems) {\n              map.set(identifier, content.content.get(identifier));\n            }\n\n            return new PackContentItems(map);\n          });\n        } // 5. Determine items for the unused content file\n\n\n        const unusedItems = new Set(content.items);\n        const usedOfUnusedItems = new Set();\n\n        for (const identifier of usedItems) {\n          unusedItems.delete(identifier);\n        }\n\n        const newUnusedLoc = this._findLocation();\n\n        this._gcAndUpdateLocation(unusedItems, usedOfUnusedItems, newUnusedLoc); // 6. Create content file for unused items\n\n\n        if (unusedItems.size > 0) {\n          this.content[newUnusedLoc] = new PackContent(unusedItems, usedOfUnusedItems, async () => {\n            await content.unpack(\"it should be splitted into used and unused items\");\n            const map = new Map();\n\n            for (const identifier of unusedItems) {\n              map.set(identifier, content.content.get(identifier));\n            }\n\n            return new PackContentItems(map);\n          });\n        }\n\n        this.logger.log(\"Split pack %d into pack %d with %d used items and pack %d with %d unused items\", i, newLoc, usedItems.size, newUnusedLoc, unusedItems.size); // optimizing only one of them is good enough and\n        // reduces the amount of serialization needed\n\n        return;\n      }\n    }\n  }\n  /**\n   * Find the content with the oldest item and run GC on that.\n   * Only runs for one content to avoid large invalidation.\n   */\n\n\n  _gcOldestContent() {\n    /** @type {PackItemInfo} */\n    let oldest = undefined;\n\n    for (const info of this.itemInfo.values()) {\n      if (oldest === undefined || info.lastAccess < oldest.lastAccess) {\n        oldest = info;\n      }\n    }\n\n    if (Date.now() - oldest.lastAccess > this.maxAge) {\n      const loc = oldest.location;\n      if (loc < 0) return;\n      const content = this.content[loc];\n      const items = new Set(content.items);\n      const usedItems = new Set(content.used);\n\n      this._gcAndUpdateLocation(items, usedItems, loc);\n\n      this.content[loc] = items.size > 0 ? new PackContent(items, usedItems, async () => {\n        await content.unpack(\"it contains old items that should be garbage collected\");\n        const map = new Map();\n\n        for (const identifier of items) {\n          map.set(identifier, content.content.get(identifier));\n        }\n\n        return new PackContentItems(map);\n      }) : undefined;\n    }\n  }\n\n  serialize(_ref3) {\n    let {\n      write,\n      writeSeparate\n    } = _ref3;\n\n    this._persistFreshContent();\n\n    this._optimizeSmallContent();\n\n    this._optimizeUnusedContent();\n\n    this._gcOldestContent();\n\n    for (const identifier of this.itemInfo.keys()) {\n      write(identifier);\n    }\n\n    write(null); // null as marker of the end of keys\n\n    for (const info of this.itemInfo.values()) {\n      write(info.etag);\n    }\n\n    for (const info of this.itemInfo.values()) {\n      write(info.lastAccess);\n    }\n\n    for (let i = 0; i < this.content.length; i++) {\n      const content = this.content[i];\n\n      if (content !== undefined) {\n        write(content.items);\n        content.writeLazy(lazy => writeSeparate(lazy, {\n          name: `${i}`\n        }));\n      } else {\n        write(undefined); // undefined marks an empty content slot\n      }\n    }\n\n    write(null); // null as marker of the end of items\n  }\n\n  deserialize(_ref4) {\n    let {\n      read,\n      logger\n    } = _ref4;\n    this.logger = logger;\n    {\n      const items = [];\n      let item = read();\n\n      while (item !== null) {\n        items.push(item);\n        item = read();\n      }\n\n      this.itemInfo.clear();\n      const infoItems = items.map(identifier => {\n        const info = new PackItemInfo(identifier, undefined, undefined);\n        this.itemInfo.set(identifier, info);\n        return info;\n      });\n\n      for (const info of infoItems) {\n        info.etag = read();\n      }\n\n      for (const info of infoItems) {\n        info.lastAccess = read();\n      }\n    }\n    this.content.length = 0;\n    let items = read();\n\n    while (items !== null) {\n      if (items === undefined) {\n        this.content.push(items);\n      } else {\n        const idx = this.content.length;\n        const lazy = read();\n        this.content.push(new PackContent(items, new Set(), lazy, logger, `${this.content.length}`));\n\n        for (const identifier of items) {\n          this.itemInfo.get(identifier).location = idx;\n        }\n      }\n\n      items = read();\n    }\n  }\n\n}\n\nmakeSerializable(Pack, \"webpack/lib/cache/PackFileCacheStrategy\", \"Pack\");\n\nclass PackContentItems {\n  /**\n   * @param {Map<string, any>} map items\n   */\n  constructor(map) {\n    this.map = map;\n  }\n\n  serialize(_ref5) {\n    let {\n      write,\n      snapshot,\n      rollback,\n      logger,\n      profile\n    } = _ref5;\n\n    if (profile) {\n      write(false);\n\n      for (const [key, value] of this.map) {\n        const s = snapshot();\n\n        try {\n          write(key);\n          const start = process.hrtime();\n          write(value);\n          const durationHr = process.hrtime(start);\n          const duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\n\n          if (duration > 1) {\n            if (duration > 500) logger.error(`Serialization of '${key}': ${duration} ms`);else if (duration > 50) logger.warn(`Serialization of '${key}': ${duration} ms`);else if (duration > 10) logger.info(`Serialization of '${key}': ${duration} ms`);else if (duration > 5) logger.log(`Serialization of '${key}': ${duration} ms`);else logger.debug(`Serialization of '${key}': ${duration} ms`);\n          }\n        } catch (e) {\n          rollback(s);\n          if (e === NOT_SERIALIZABLE) continue;\n          logger.warn(`Skipped not serializable cache item '${key}': ${e.message}`);\n          logger.debug(e.stack);\n        }\n      }\n\n      write(null);\n      return;\n    } // Try to serialize all at once\n\n\n    const s = snapshot();\n\n    try {\n      write(true);\n      write(this.map);\n    } catch (e) {\n      rollback(s); // Try to serialize each item on it's own\n\n      write(false);\n\n      for (const [key, value] of this.map) {\n        const s = snapshot();\n\n        try {\n          write(key);\n          write(value);\n        } catch (e) {\n          rollback(s);\n          if (e === NOT_SERIALIZABLE) continue;\n          logger.warn(`Skipped not serializable cache item '${key}': ${e.message}`);\n          logger.debug(e.stack);\n        }\n      }\n\n      write(null);\n    }\n  }\n\n  deserialize(_ref6) {\n    let {\n      read,\n      logger,\n      profile\n    } = _ref6;\n\n    if (read()) {\n      this.map = read();\n    } else if (profile) {\n      const map = new Map();\n      let key = read();\n\n      while (key !== null) {\n        const start = process.hrtime();\n        const value = read();\n        const durationHr = process.hrtime(start);\n        const duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\n\n        if (duration > 1) {\n          if (duration > 100) logger.error(`Deserialization of '${key}': ${duration} ms`);else if (duration > 20) logger.warn(`Deserialization of '${key}': ${duration} ms`);else if (duration > 5) logger.info(`Deserialization of '${key}': ${duration} ms`);else if (duration > 2) logger.log(`Deserialization of '${key}': ${duration} ms`);else logger.debug(`Deserialization of '${key}': ${duration} ms`);\n        }\n\n        map.set(key, value);\n        key = read();\n      }\n\n      this.map = map;\n    } else {\n      const map = new Map();\n      let key = read();\n\n      while (key !== null) {\n        map.set(key, read());\n        key = read();\n      }\n\n      this.map = map;\n    }\n  }\n\n}\n\nmakeSerializable(PackContentItems, \"webpack/lib/cache/PackFileCacheStrategy\", \"PackContentItems\");\n\nclass PackContent {\n  /*\n  \tThis class can be in these states:\n  \t   |   this.lazy    | this.content | this.outdated | state\n  \tA1 |   undefined    |     Map      |     false     | fresh content\n  \tA2 |   undefined    |     Map      |     true      | (will not happen)\n  \tB1 | lazy () => {}  |  undefined   |     false     | not deserialized\n  \tB2 | lazy () => {}  |  undefined   |     true      | not deserialized, but some items has been removed\n  \tC1 | lazy* () => {} |     Map      |     false     | deserialized\n  \tC2 | lazy* () => {} |     Map      |     true      | deserialized, and some items has been removed\n  \t\tthis.used is a subset of this.items.\n  \tthis.items is a subset of this.content.keys() resp. this.lazy().map.keys()\n  \tWhen this.outdated === false, this.items === this.content.keys() resp. this.lazy().map.keys()\n  \tWhen this.outdated === true, this.items should be used to recreated this.lazy/this.content.\n  \tWhen this.lazy and this.content is set, they contain the same data.\n  \tthis.get must only be called with a valid item from this.items.\n  \tIn state C this.lazy is unMemoized\n  */\n\n  /**\n   * @param {Set<string>} items keys\n   * @param {Set<string>} usedItems used keys\n   * @param {PackContentItems | function(): Promise<PackContentItems>} dataOrFn sync or async content\n   * @param {Logger=} logger logger for logging\n   * @param {string=} lazyName name of dataOrFn for logging\n   */\n  constructor(items, usedItems, dataOrFn, logger, lazyName) {\n    this.items = items;\n    /** @type {function(): Promise<PackContentItems> | PackContentItems} */\n\n    this.lazy = typeof dataOrFn === \"function\" ? dataOrFn : undefined;\n    /** @type {Map<string, any>} */\n\n    this.content = typeof dataOrFn === \"function\" ? undefined : dataOrFn.map;\n    this.outdated = false;\n    this.used = usedItems;\n    this.logger = logger;\n    this.lazyName = lazyName;\n  }\n\n  get(identifier) {\n    this.used.add(identifier);\n\n    if (this.content) {\n      return this.content.get(identifier);\n    } // We are in state B\n\n\n    const {\n      lazyName\n    } = this;\n    let timeMessage;\n\n    if (lazyName) {\n      // only log once\n      this.lazyName = undefined;\n      timeMessage = `restore cache content ${lazyName} (${formatSize(this.getSize())})`;\n      this.logger.log(`starting to restore cache content ${lazyName} (${formatSize(this.getSize())}) because of request to: ${identifier}`);\n      this.logger.time(timeMessage);\n    }\n\n    const value = this.lazy();\n\n    if (\"then\" in value) {\n      return value.then(data => {\n        const map = data.map;\n\n        if (timeMessage) {\n          this.logger.timeEnd(timeMessage);\n        } // Move to state C\n\n\n        this.content = map;\n        this.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n        return map.get(identifier);\n      });\n    } else {\n      const map = value.map;\n\n      if (timeMessage) {\n        this.logger.timeEnd(timeMessage);\n      } // Move to state C\n\n\n      this.content = map;\n      this.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n      return map.get(identifier);\n    }\n  }\n  /**\n   * @param {string} reason explanation why unpack is necessary\n   * @returns {void | Promise} maybe a promise if lazy\n   */\n\n\n  unpack(reason) {\n    if (this.content) return; // Move from state B to C\n\n    if (this.lazy) {\n      const {\n        lazyName\n      } = this;\n      let timeMessage;\n\n      if (lazyName) {\n        // only log once\n        this.lazyName = undefined;\n        timeMessage = `unpack cache content ${lazyName} (${formatSize(this.getSize())})`;\n        this.logger.log(`starting to unpack cache content ${lazyName} (${formatSize(this.getSize())}) because ${reason}`);\n        this.logger.time(timeMessage);\n      }\n\n      const value = this.lazy();\n\n      if (\"then\" in value) {\n        return value.then(data => {\n          if (timeMessage) {\n            this.logger.timeEnd(timeMessage);\n          }\n\n          this.content = data.map;\n        });\n      } else {\n        if (timeMessage) {\n          this.logger.timeEnd(timeMessage);\n        }\n\n        this.content = value.map;\n      }\n    }\n  }\n  /**\n   * @returns {number} size of the content or -1 if not known\n   */\n\n\n  getSize() {\n    if (!this.lazy) return -1;\n    const options =\n    /** @type {any} */\n    this.lazy.options;\n    if (!options) return -1;\n    const size = options.size;\n    if (typeof size !== \"number\") return -1;\n    return size;\n  }\n\n  delete(identifier) {\n    this.items.delete(identifier);\n    this.used.delete(identifier);\n    this.outdated = true;\n  }\n  /**\n   * @template T\n   * @param {function(any): function(): Promise<PackContentItems> | PackContentItems} write write function\n   * @returns {void}\n   */\n\n\n  writeLazy(write) {\n    if (!this.outdated && this.lazy) {\n      // State B1 or C1\n      // this.lazy is still the valid deserialized version\n      write(this.lazy);\n      return;\n    }\n\n    if (!this.outdated && this.content) {\n      // State A1\n      const map = new Map(this.content); // Move to state C1\n\n      this.lazy = SerializerMiddleware.unMemoizeLazy(write(() => new PackContentItems(map)));\n      return;\n    }\n\n    if (this.content) {\n      // State A2 or C2\n\n      /** @type {Map<string, any>} */\n      const map = new Map();\n\n      for (const item of this.items) {\n        map.set(item, this.content.get(item));\n      } // Move to state C1\n\n\n      this.outdated = false;\n      this.content = map;\n      this.lazy = SerializerMiddleware.unMemoizeLazy(write(() => new PackContentItems(map)));\n      return;\n    } // State B2\n\n\n    const {\n      lazyName\n    } = this;\n    let timeMessage;\n\n    if (lazyName) {\n      // only log once\n      this.lazyName = undefined;\n      timeMessage = `unpack cache content ${lazyName} (${formatSize(this.getSize())})`;\n      this.logger.log(`starting to unpack cache content ${lazyName} (${formatSize(this.getSize())}) because it's outdated and need to be serialized`);\n      this.logger.time(timeMessage);\n    }\n\n    const value = this.lazy();\n    this.outdated = false;\n\n    if (\"then\" in value) {\n      // Move to state B1\n      this.lazy = write(() => value.then(data => {\n        if (timeMessage) {\n          this.logger.timeEnd(timeMessage);\n        }\n\n        const oldMap = data.map;\n        /** @type {Map<string, any>} */\n\n        const map = new Map();\n\n        for (const item of this.items) {\n          map.set(item, oldMap.get(item));\n        } // Move to state C1 (or maybe C2)\n\n\n        this.content = map;\n        this.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n        return new PackContentItems(map);\n      }));\n    } else {\n      // Move to state C1\n      if (timeMessage) {\n        this.logger.timeEnd(timeMessage);\n      }\n\n      const oldMap = value.map;\n      /** @type {Map<string, any>} */\n\n      const map = new Map();\n\n      for (const item of this.items) {\n        map.set(item, oldMap.get(item));\n      }\n\n      this.content = map;\n      this.lazy = write(() => new PackContentItems(map));\n    }\n  }\n\n}\n\nconst allowCollectingMemory = buf => {\n  const wasted = buf.buffer.byteLength - buf.byteLength;\n\n  if (wasted > 8192 && (wasted > 1048576 || wasted > buf.byteLength)) {\n    return Buffer.from(buf);\n  }\n\n  return buf;\n};\n\nclass PackFileCacheStrategy {\n  /**\n   * @param {Object} options options\n   * @param {Compiler} options.compiler the compiler\n   * @param {IntermediateFileSystem} options.fs the filesystem\n   * @param {string} options.context the context directory\n   * @param {string} options.cacheLocation the location of the cache data\n   * @param {string} options.version version identifier\n   * @param {Logger} options.logger a logger\n   * @param {SnapshotOptions} options.snapshot options regarding snapshotting\n   * @param {number} options.maxAge max age of cache items\n   * @param {boolean} options.profile track and log detailed timing information for individual cache items\n   * @param {boolean} options.allowCollectingMemory allow to collect unused memory created during deserialization\n   * @param {false | \"gzip\" | \"brotli\"} options.compression compression used\n   */\n  constructor(_ref7) {\n    let {\n      compiler,\n      fs,\n      context,\n      cacheLocation,\n      version,\n      logger,\n      snapshot,\n      maxAge,\n      profile,\n      allowCollectingMemory,\n      compression\n    } = _ref7;\n    this.fileSerializer = createFileSerializer(fs, compiler.options.output.hashFunction);\n    this.fileSystemInfo = new FileSystemInfo(fs, {\n      managedPaths: snapshot.managedPaths,\n      immutablePaths: snapshot.immutablePaths,\n      logger: logger.getChildLogger(\"webpack.FileSystemInfo\"),\n      hashFunction: compiler.options.output.hashFunction\n    });\n    this.compiler = compiler;\n    this.context = context;\n    this.cacheLocation = cacheLocation;\n    this.version = version;\n    this.logger = logger;\n    this.maxAge = maxAge;\n    this.profile = profile;\n    this.allowCollectingMemory = allowCollectingMemory;\n    this.compression = compression;\n    this._extension = compression === \"brotli\" ? \".pack.br\" : compression === \"gzip\" ? \".pack.gz\" : \".pack\";\n    this.snapshot = snapshot;\n    /** @type {Set<string>} */\n\n    this.buildDependencies = new Set();\n    /** @type {LazySet<string>} */\n\n    this.newBuildDependencies = new LazySet();\n    /** @type {Snapshot} */\n\n    this.resolveBuildDependenciesSnapshot = undefined;\n    /** @type {Map<string, string | false>} */\n\n    this.resolveResults = undefined;\n    /** @type {Snapshot} */\n\n    this.buildSnapshot = undefined;\n    /** @type {Promise<Pack>} */\n\n    this.packPromise = this._openPack();\n    this.storePromise = Promise.resolve();\n  }\n\n  _getPack() {\n    if (this.packPromise === undefined) {\n      this.packPromise = this.storePromise.then(() => this._openPack());\n    }\n\n    return this.packPromise;\n  }\n  /**\n   * @returns {Promise<Pack>} the pack\n   */\n\n\n  _openPack() {\n    const {\n      logger,\n      profile,\n      cacheLocation,\n      version\n    } = this;\n    /** @type {Snapshot} */\n\n    let buildSnapshot;\n    /** @type {Set<string>} */\n\n    let buildDependencies;\n    /** @type {Set<string>} */\n\n    let newBuildDependencies;\n    /** @type {Snapshot} */\n\n    let resolveBuildDependenciesSnapshot;\n    /** @type {Map<string, string | false>} */\n\n    let resolveResults;\n    logger.time(\"restore cache container\");\n    return this.fileSerializer.deserialize(null, {\n      filename: `${cacheLocation}/index${this._extension}`,\n      extension: `${this._extension}`,\n      logger,\n      profile,\n      retainedBuffer: this.allowCollectingMemory ? allowCollectingMemory : undefined\n    }).catch(err => {\n      if (err.code !== \"ENOENT\") {\n        logger.warn(`Restoring pack failed from ${cacheLocation}${this._extension}: ${err}`);\n        logger.debug(err.stack);\n      } else {\n        logger.debug(`No pack exists at ${cacheLocation}${this._extension}: ${err}`);\n      }\n\n      return undefined;\n    }).then(packContainer => {\n      logger.timeEnd(\"restore cache container\");\n      if (!packContainer) return undefined;\n\n      if (!(packContainer instanceof PackContainer)) {\n        logger.warn(`Restored pack from ${cacheLocation}${this._extension}, but contained content is unexpected.`, packContainer);\n        return undefined;\n      }\n\n      if (packContainer.version !== version) {\n        logger.log(`Restored pack from ${cacheLocation}${this._extension}, but version doesn't match.`);\n        return undefined;\n      }\n\n      logger.time(\"check build dependencies\");\n      return Promise.all([new Promise((resolve, reject) => {\n        this.fileSystemInfo.checkSnapshotValid(packContainer.buildSnapshot, (err, valid) => {\n          if (err) {\n            logger.log(`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of build dependencies errored: ${err}.`);\n            logger.debug(err.stack);\n            return resolve(false);\n          }\n\n          if (!valid) {\n            logger.log(`Restored pack from ${cacheLocation}${this._extension}, but build dependencies have changed.`);\n            return resolve(false);\n          }\n\n          buildSnapshot = packContainer.buildSnapshot;\n          return resolve(true);\n        });\n      }), new Promise((resolve, reject) => {\n        this.fileSystemInfo.checkSnapshotValid(packContainer.resolveBuildDependenciesSnapshot, (err, valid) => {\n          if (err) {\n            logger.log(`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of resolving of build dependencies errored: ${err}.`);\n            logger.debug(err.stack);\n            return resolve(false);\n          }\n\n          if (valid) {\n            resolveBuildDependenciesSnapshot = packContainer.resolveBuildDependenciesSnapshot;\n            buildDependencies = packContainer.buildDependencies;\n            resolveResults = packContainer.resolveResults;\n            return resolve(true);\n          }\n\n          logger.log(\"resolving of build dependencies is invalid, will re-resolve build dependencies\");\n          this.fileSystemInfo.checkResolveResultsValid(packContainer.resolveResults, (err, valid) => {\n            if (err) {\n              logger.log(`Restored pack from ${cacheLocation}${this._extension}, but resolving of build dependencies errored: ${err}.`);\n              logger.debug(err.stack);\n              return resolve(false);\n            }\n\n            if (valid) {\n              newBuildDependencies = packContainer.buildDependencies;\n              resolveResults = packContainer.resolveResults;\n              return resolve(true);\n            }\n\n            logger.log(`Restored pack from ${cacheLocation}${this._extension}, but build dependencies resolve to different locations.`);\n            return resolve(false);\n          });\n        });\n      })]).catch(err => {\n        logger.timeEnd(\"check build dependencies\");\n        throw err;\n      }).then(_ref8 => {\n        let [buildSnapshotValid, resolveValid] = _ref8;\n        logger.timeEnd(\"check build dependencies\");\n\n        if (buildSnapshotValid && resolveValid) {\n          logger.time(\"restore cache content metadata\");\n          const d = packContainer.data();\n          logger.timeEnd(\"restore cache content metadata\");\n          return d;\n        }\n\n        return undefined;\n      });\n    }).then(pack => {\n      if (pack) {\n        pack.maxAge = this.maxAge;\n        this.buildSnapshot = buildSnapshot;\n        if (buildDependencies) this.buildDependencies = buildDependencies;\n        if (newBuildDependencies) this.newBuildDependencies.addAll(newBuildDependencies);\n        this.resolveResults = resolveResults;\n        this.resolveBuildDependenciesSnapshot = resolveBuildDependenciesSnapshot;\n        return pack;\n      }\n\n      return new Pack(logger, this.maxAge);\n    }).catch(err => {\n      this.logger.warn(`Restoring pack from ${cacheLocation}${this._extension} failed: ${err}`);\n      this.logger.debug(err.stack);\n      return new Pack(logger, this.maxAge);\n    });\n  }\n  /**\n   * @param {string} identifier unique name for the resource\n   * @param {Etag | null} etag etag of the resource\n   * @param {any} data cached content\n   * @returns {Promise<void>} promise\n   */\n\n\n  store(identifier, etag, data) {\n    return this._getPack().then(pack => {\n      pack.set(identifier, etag === null ? null : etag.toString(), data);\n    });\n  }\n  /**\n   * @param {string} identifier unique name for the resource\n   * @param {Etag | null} etag etag of the resource\n   * @returns {Promise<any>} promise to the cached content\n   */\n\n\n  restore(identifier, etag) {\n    return this._getPack().then(pack => pack.get(identifier, etag === null ? null : etag.toString())).catch(err => {\n      if (err && err.code !== \"ENOENT\") {\n        this.logger.warn(`Restoring failed for ${identifier} from pack: ${err}`);\n        this.logger.debug(err.stack);\n      }\n    });\n  }\n\n  storeBuildDependencies(dependencies) {\n    this.newBuildDependencies.addAll(dependencies);\n  }\n\n  afterAllStored() {\n    const packPromise = this.packPromise;\n    if (packPromise === undefined) return Promise.resolve();\n    const reportProgress = ProgressPlugin.getReporter(this.compiler);\n    return this.storePromise = packPromise.then(pack => {\n      pack.stopCapturingRequests();\n      if (!pack.invalid) return;\n      this.packPromise = undefined;\n      this.logger.log(`Storing pack...`);\n      let promise;\n      const newBuildDependencies = new Set();\n\n      for (const dep of this.newBuildDependencies) {\n        if (!this.buildDependencies.has(dep)) {\n          newBuildDependencies.add(dep);\n        }\n      }\n\n      if (newBuildDependencies.size > 0 || !this.buildSnapshot) {\n        if (reportProgress) reportProgress(0.5, \"resolve build dependencies\");\n        this.logger.debug(`Capturing build dependencies... (${Array.from(newBuildDependencies).join(\", \")})`);\n        promise = new Promise((resolve, reject) => {\n          this.logger.time(\"resolve build dependencies\");\n          this.fileSystemInfo.resolveBuildDependencies(this.context, newBuildDependencies, (err, result) => {\n            this.logger.timeEnd(\"resolve build dependencies\");\n            if (err) return reject(err);\n            this.logger.time(\"snapshot build dependencies\");\n            const {\n              files,\n              directories,\n              missing,\n              resolveResults,\n              resolveDependencies\n            } = result;\n\n            if (this.resolveResults) {\n              for (const [key, value] of resolveResults) {\n                this.resolveResults.set(key, value);\n              }\n            } else {\n              this.resolveResults = resolveResults;\n            }\n\n            if (reportProgress) {\n              reportProgress(0.6, \"snapshot build dependencies\", \"resolving\");\n            }\n\n            this.fileSystemInfo.createSnapshot(undefined, resolveDependencies.files, resolveDependencies.directories, resolveDependencies.missing, this.snapshot.resolveBuildDependencies, (err, snapshot) => {\n              if (err) {\n                this.logger.timeEnd(\"snapshot build dependencies\");\n                return reject(err);\n              }\n\n              if (!snapshot) {\n                this.logger.timeEnd(\"snapshot build dependencies\");\n                return reject(new Error(\"Unable to snapshot resolve dependencies\"));\n              }\n\n              if (this.resolveBuildDependenciesSnapshot) {\n                this.resolveBuildDependenciesSnapshot = this.fileSystemInfo.mergeSnapshots(this.resolveBuildDependenciesSnapshot, snapshot);\n              } else {\n                this.resolveBuildDependenciesSnapshot = snapshot;\n              }\n\n              if (reportProgress) {\n                reportProgress(0.7, \"snapshot build dependencies\", \"modules\");\n              }\n\n              this.fileSystemInfo.createSnapshot(undefined, files, directories, missing, this.snapshot.buildDependencies, (err, snapshot) => {\n                this.logger.timeEnd(\"snapshot build dependencies\");\n                if (err) return reject(err);\n\n                if (!snapshot) {\n                  return reject(new Error(\"Unable to snapshot build dependencies\"));\n                }\n\n                this.logger.debug(\"Captured build dependencies\");\n\n                if (this.buildSnapshot) {\n                  this.buildSnapshot = this.fileSystemInfo.mergeSnapshots(this.buildSnapshot, snapshot);\n                } else {\n                  this.buildSnapshot = snapshot;\n                }\n\n                resolve();\n              });\n            });\n          });\n        });\n      } else {\n        promise = Promise.resolve();\n      }\n\n      return promise.then(() => {\n        if (reportProgress) reportProgress(0.8, \"serialize pack\");\n        this.logger.time(`store pack`);\n        const updatedBuildDependencies = new Set(this.buildDependencies);\n\n        for (const dep of newBuildDependencies) {\n          updatedBuildDependencies.add(dep);\n        }\n\n        const content = new PackContainer(pack, this.version, this.buildSnapshot, updatedBuildDependencies, this.resolveResults, this.resolveBuildDependenciesSnapshot);\n        return this.fileSerializer.serialize(content, {\n          filename: `${this.cacheLocation}/index${this._extension}`,\n          extension: `${this._extension}`,\n          logger: this.logger,\n          profile: this.profile\n        }).then(() => {\n          for (const dep of newBuildDependencies) {\n            this.buildDependencies.add(dep);\n          }\n\n          this.newBuildDependencies.clear();\n          this.logger.timeEnd(`store pack`);\n          const stats = pack.getContentStats();\n          this.logger.log(\"Stored pack (%d items, %d files, %d MiB)\", pack.itemInfo.size, stats.count, Math.round(stats.size / 1024 / 1024));\n        }).catch(err => {\n          this.logger.timeEnd(`store pack`);\n          this.logger.warn(`Caching failed for pack: ${err}`);\n          this.logger.debug(err.stack);\n        });\n      });\n    }).catch(err => {\n      this.logger.warn(`Caching failed for pack: ${err}`);\n      this.logger.debug(err.stack);\n    });\n  }\n\n  clear() {\n    this.fileSystemInfo.clear();\n    this.buildDependencies.clear();\n    this.newBuildDependencies.clear();\n    this.resolveBuildDependenciesSnapshot = undefined;\n    this.resolveResults = undefined;\n    this.buildSnapshot = undefined;\n    this.packPromise = undefined;\n  }\n\n}\n\nmodule.exports = PackFileCacheStrategy;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/cache/PackFileCacheStrategy.js"],"names":["FileSystemInfo","require","ProgressPlugin","formatSize","SerializerMiddleware","LazySet","makeSerializable","memoize","createFileSerializer","NOT_SERIALIZABLE","PackContainer","constructor","data","version","buildSnapshot","buildDependencies","resolveResults","resolveBuildDependenciesSnapshot","serialize","write","writeLazy","deserialize","read","MIN_CONTENT_SIZE","CONTENT_COUNT_TO_MERGE","MIN_ITEMS_IN_FRESH_PACK","MAX_ITEMS_IN_FRESH_PACK","MAX_TIME_IN_FRESH_PACK","PackItemInfo","identifier","etag","value","location","lastAccess","Date","now","freshValue","Pack","logger","maxAge","itemInfo","Map","requests","requestsTimeout","undefined","freshContent","content","invalid","_addRequest","push","setTimeout","unref","stopCapturingRequests","clearTimeout","get","info","loc","set","log","newInfo","delete","items","size","debug","getContentStats","count","s","getSize","_findLocation","i","length","_gcAndUpdateLocation","usedItems","newLoc","lastGC","_persistFreshContent","itemsCount","packCount","Math","ceil","itemsPerPack","packs","ignoreNextTimeTick","createNextPack","pack","Set","map","add","PackContent","PackContentItems","join","_optimizeSmallContent","smallUsedContents","smallUsedContentSize","smallUnusedContents","smallUnusedContentSize","outdated","used","mergedIndices","mergedContent","mergedItems","mergedUsedItems","addToMergedMap","unpack","Promise","all","fn","_optimizeUnusedContent","total","unusedItems","usedOfUnusedItems","newUnusedLoc","_gcOldestContent","oldest","values","writeSeparate","keys","lazy","name","item","clear","infoItems","idx","snapshot","rollback","profile","key","start","process","hrtime","durationHr","duration","error","warn","e","message","stack","dataOrFn","lazyName","timeMessage","time","then","timeEnd","unMemoizeLazy","reason","options","oldMap","allowCollectingMemory","buf","wasted","buffer","byteLength","Buffer","from","PackFileCacheStrategy","compiler","fs","context","cacheLocation","compression","fileSerializer","output","hashFunction","fileSystemInfo","managedPaths","immutablePaths","getChildLogger","_extension","newBuildDependencies","packPromise","_openPack","storePromise","resolve","_getPack","filename","extension","retainedBuffer","catch","err","code","packContainer","reject","checkSnapshotValid","valid","checkResolveResultsValid","buildSnapshotValid","resolveValid","d","addAll","store","toString","restore","storeBuildDependencies","dependencies","afterAllStored","reportProgress","getReporter","promise","dep","has","Array","resolveBuildDependencies","result","files","directories","missing","resolveDependencies","createSnapshot","Error","mergeSnapshots","updatedBuildDependencies","stats","round","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst FileSystemInfo = require(\"../FileSystemInfo\");\nconst ProgressPlugin = require(\"../ProgressPlugin\");\nconst { formatSize } = require(\"../SizeFormatHelpers\");\nconst SerializerMiddleware = require(\"../serialization/SerializerMiddleware\");\nconst LazySet = require(\"../util/LazySet\");\nconst makeSerializable = require(\"../util/makeSerializable\");\nconst memoize = require(\"../util/memoize\");\nconst {\n\tcreateFileSerializer,\n\tNOT_SERIALIZABLE\n} = require(\"../util/serialization\");\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").SnapshotOptions} SnapshotOptions */\n/** @typedef {import(\"../Cache\").Etag} Etag */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\n/** @typedef {import(\"../logging/Logger\").Logger} Logger */\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\nclass PackContainer {\n\t/**\n\t * @param {Object} data stored data\n\t * @param {string} version version identifier\n\t * @param {Snapshot} buildSnapshot snapshot of all build dependencies\n\t * @param {Set<string>} buildDependencies list of all unresolved build dependencies captured\n\t * @param {Map<string, string | false>} resolveResults result of the resolved build dependencies\n\t * @param {Snapshot} resolveBuildDependenciesSnapshot snapshot of the dependencies of the build dependencies resolving\n\t */\n\tconstructor(\n\t\tdata,\n\t\tversion,\n\t\tbuildSnapshot,\n\t\tbuildDependencies,\n\t\tresolveResults,\n\t\tresolveBuildDependenciesSnapshot\n\t) {\n\t\tthis.data = data;\n\t\tthis.version = version;\n\t\tthis.buildSnapshot = buildSnapshot;\n\t\tthis.buildDependencies = buildDependencies;\n\t\tthis.resolveResults = resolveResults;\n\t\tthis.resolveBuildDependenciesSnapshot = resolveBuildDependenciesSnapshot;\n\t}\n\n\tserialize({ write, writeLazy }) {\n\t\twrite(this.version);\n\t\twrite(this.buildSnapshot);\n\t\twrite(this.buildDependencies);\n\t\twrite(this.resolveResults);\n\t\twrite(this.resolveBuildDependenciesSnapshot);\n\t\twriteLazy(this.data);\n\t}\n\n\tdeserialize({ read }) {\n\t\tthis.version = read();\n\t\tthis.buildSnapshot = read();\n\t\tthis.buildDependencies = read();\n\t\tthis.resolveResults = read();\n\t\tthis.resolveBuildDependenciesSnapshot = read();\n\t\tthis.data = read();\n\t}\n}\n\nmakeSerializable(\n\tPackContainer,\n\t\"webpack/lib/cache/PackFileCacheStrategy\",\n\t\"PackContainer\"\n);\n\nconst MIN_CONTENT_SIZE = 1024 * 1024; // 1 MB\nconst CONTENT_COUNT_TO_MERGE = 10;\nconst MIN_ITEMS_IN_FRESH_PACK = 100;\nconst MAX_ITEMS_IN_FRESH_PACK = 50000;\nconst MAX_TIME_IN_FRESH_PACK = 1 * 60 * 1000; // 1 min\n\nclass PackItemInfo {\n\t/**\n\t * @param {string} identifier identifier of item\n\t * @param {string | null} etag etag of item\n\t * @param {any} value fresh value of item\n\t */\n\tconstructor(identifier, etag, value) {\n\t\tthis.identifier = identifier;\n\t\tthis.etag = etag;\n\t\tthis.location = -1;\n\t\tthis.lastAccess = Date.now();\n\t\tthis.freshValue = value;\n\t}\n}\n\nclass Pack {\n\tconstructor(logger, maxAge) {\n\t\t/** @type {Map<string, PackItemInfo>} */\n\t\tthis.itemInfo = new Map();\n\t\t/** @type {string[]} */\n\t\tthis.requests = [];\n\t\tthis.requestsTimeout = undefined;\n\t\t/** @type {Map<string, PackItemInfo>} */\n\t\tthis.freshContent = new Map();\n\t\t/** @type {(undefined | PackContent)[]} */\n\t\tthis.content = [];\n\t\tthis.invalid = false;\n\t\tthis.logger = logger;\n\t\tthis.maxAge = maxAge;\n\t}\n\n\t_addRequest(identifier) {\n\t\tthis.requests.push(identifier);\n\t\tif (this.requestsTimeout === undefined) {\n\t\t\tthis.requestsTimeout = setTimeout(() => {\n\t\t\t\tthis.requests.push(undefined);\n\t\t\t\tthis.requestsTimeout = undefined;\n\t\t\t}, MAX_TIME_IN_FRESH_PACK);\n\t\t\tif (this.requestsTimeout.unref) this.requestsTimeout.unref();\n\t\t}\n\t}\n\n\tstopCapturingRequests() {\n\t\tif (this.requestsTimeout !== undefined) {\n\t\t\tclearTimeout(this.requestsTimeout);\n\t\t\tthis.requestsTimeout = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} identifier unique name for the resource\n\t * @param {string | null} etag etag of the resource\n\t * @returns {any} cached content\n\t */\n\tget(identifier, etag) {\n\t\tconst info = this.itemInfo.get(identifier);\n\t\tthis._addRequest(identifier);\n\t\tif (info === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (info.etag !== etag) return null;\n\t\tinfo.lastAccess = Date.now();\n\t\tconst loc = info.location;\n\t\tif (loc === -1) {\n\t\t\treturn info.freshValue;\n\t\t} else {\n\t\t\tif (!this.content[loc]) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\treturn this.content[loc].get(identifier);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} identifier unique name for the resource\n\t * @param {string | null} etag etag of the resource\n\t * @param {any} data cached content\n\t * @returns {void}\n\t */\n\tset(identifier, etag, data) {\n\t\tif (!this.invalid) {\n\t\t\tthis.invalid = true;\n\t\t\tthis.logger.log(`Pack got invalid because of write to: ${identifier}`);\n\t\t}\n\t\tconst info = this.itemInfo.get(identifier);\n\t\tif (info === undefined) {\n\t\t\tconst newInfo = new PackItemInfo(identifier, etag, data);\n\t\t\tthis.itemInfo.set(identifier, newInfo);\n\t\t\tthis._addRequest(identifier);\n\t\t\tthis.freshContent.set(identifier, newInfo);\n\t\t} else {\n\t\t\tconst loc = info.location;\n\t\t\tif (loc >= 0) {\n\t\t\t\tthis._addRequest(identifier);\n\t\t\t\tthis.freshContent.set(identifier, info);\n\t\t\t\tconst content = this.content[loc];\n\t\t\t\tcontent.delete(identifier);\n\t\t\t\tif (content.items.size === 0) {\n\t\t\t\t\tthis.content[loc] = undefined;\n\t\t\t\t\tthis.logger.debug(\"Pack %d got empty and is removed\", loc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tinfo.freshValue = data;\n\t\t\tinfo.lastAccess = Date.now();\n\t\t\tinfo.etag = etag;\n\t\t\tinfo.location = -1;\n\t\t}\n\t}\n\n\tgetContentStats() {\n\t\tlet count = 0;\n\t\tlet size = 0;\n\t\tfor (const content of this.content) {\n\t\t\tif (content !== undefined) {\n\t\t\t\tcount++;\n\t\t\t\tconst s = content.getSize();\n\t\t\t\tif (s > 0) {\n\t\t\t\t\tsize += s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { count, size };\n\t}\n\n\t/**\n\t * @returns {number} new location of data entries\n\t */\n\t_findLocation() {\n\t\tlet i;\n\t\tfor (i = 0; i < this.content.length && this.content[i] !== undefined; i++);\n\t\treturn i;\n\t}\n\n\t_gcAndUpdateLocation(items, usedItems, newLoc) {\n\t\tlet count = 0;\n\t\tlet lastGC;\n\t\tconst now = Date.now();\n\t\tfor (const identifier of items) {\n\t\t\tconst info = this.itemInfo.get(identifier);\n\t\t\tif (now - info.lastAccess > this.maxAge) {\n\t\t\t\tthis.itemInfo.delete(identifier);\n\t\t\t\titems.delete(identifier);\n\t\t\t\tusedItems.delete(identifier);\n\t\t\t\tcount++;\n\t\t\t\tlastGC = identifier;\n\t\t\t} else {\n\t\t\t\tinfo.location = newLoc;\n\t\t\t}\n\t\t}\n\t\tif (count > 0) {\n\t\t\tthis.logger.log(\n\t\t\t\t\"Garbage Collected %d old items at pack %d (%d items remaining) e. g. %s\",\n\t\t\t\tcount,\n\t\t\t\tnewLoc,\n\t\t\t\titems.size,\n\t\t\t\tlastGC\n\t\t\t);\n\t\t}\n\t}\n\n\t_persistFreshContent() {\n\t\tconst itemsCount = this.freshContent.size;\n\t\tif (itemsCount > 0) {\n\t\t\tconst packCount = Math.ceil(itemsCount / MAX_ITEMS_IN_FRESH_PACK);\n\t\t\tconst itemsPerPack = Math.ceil(itemsCount / packCount);\n\t\t\tconst packs = [];\n\t\t\tlet i = 0;\n\t\t\tlet ignoreNextTimeTick = false;\n\t\t\tconst createNextPack = () => {\n\t\t\t\tconst loc = this._findLocation();\n\t\t\t\tthis.content[loc] = null; // reserve\n\t\t\t\tconst pack = {\n\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\titems: new Set(),\n\t\t\t\t\t/** @type {Map<string, any>} */\n\t\t\t\t\tmap: new Map(),\n\t\t\t\t\tloc\n\t\t\t\t};\n\t\t\t\tpacks.push(pack);\n\t\t\t\treturn pack;\n\t\t\t};\n\t\t\tlet pack = createNextPack();\n\t\t\tif (this.requestsTimeout !== undefined)\n\t\t\t\tclearTimeout(this.requestsTimeout);\n\t\t\tfor (const identifier of this.requests) {\n\t\t\t\tif (identifier === undefined) {\n\t\t\t\t\tif (ignoreNextTimeTick) {\n\t\t\t\t\t\tignoreNextTimeTick = false;\n\t\t\t\t\t} else if (pack.items.size >= MIN_ITEMS_IN_FRESH_PACK) {\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\tpack = createNextPack();\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst info = this.freshContent.get(identifier);\n\t\t\t\tif (info === undefined) continue;\n\t\t\t\tpack.items.add(identifier);\n\t\t\t\tpack.map.set(identifier, info.freshValue);\n\t\t\t\tinfo.location = pack.loc;\n\t\t\t\tinfo.freshValue = undefined;\n\t\t\t\tthis.freshContent.delete(identifier);\n\t\t\t\tif (++i > itemsPerPack) {\n\t\t\t\t\ti = 0;\n\t\t\t\t\tpack = createNextPack();\n\t\t\t\t\tignoreNextTimeTick = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.requests.length = 0;\n\t\t\tfor (const pack of packs) {\n\t\t\t\tthis.content[pack.loc] = new PackContent(\n\t\t\t\t\tpack.items,\n\t\t\t\t\tnew Set(pack.items),\n\t\t\t\t\tnew PackContentItems(pack.map)\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis.logger.log(\n\t\t\t\t`${itemsCount} fresh items in cache put into pack ${\n\t\t\t\t\tpacks.length > 1\n\t\t\t\t\t\t? packs\n\t\t\t\t\t\t\t\t.map(pack => `${pack.loc} (${pack.items.size} items)`)\n\t\t\t\t\t\t\t\t.join(\", \")\n\t\t\t\t\t\t: packs[0].loc\n\t\t\t\t}`\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Merges small content files to a single content file\n\t */\n\t_optimizeSmallContent() {\n\t\t// 1. Find all small content files\n\t\t// Treat unused content files separately to avoid\n\t\t// a merge-split cycle\n\t\t/** @type {number[]} */\n\t\tconst smallUsedContents = [];\n\t\t/** @type {number} */\n\t\tlet smallUsedContentSize = 0;\n\t\t/** @type {number[]} */\n\t\tconst smallUnusedContents = [];\n\t\t/** @type {number} */\n\t\tlet smallUnusedContentSize = 0;\n\t\tfor (let i = 0; i < this.content.length; i++) {\n\t\t\tconst content = this.content[i];\n\t\t\tif (content === undefined) continue;\n\t\t\tif (content.outdated) continue;\n\t\t\tconst size = content.getSize();\n\t\t\tif (size < 0 || size > MIN_CONTENT_SIZE) continue;\n\t\t\tif (content.used.size > 0) {\n\t\t\t\tsmallUsedContents.push(i);\n\t\t\t\tsmallUsedContentSize += size;\n\t\t\t} else {\n\t\t\t\tsmallUnusedContents.push(i);\n\t\t\t\tsmallUnusedContentSize += size;\n\t\t\t}\n\t\t}\n\n\t\t// 2. Check if minimum number is reached\n\t\tlet mergedIndices;\n\t\tif (\n\t\t\tsmallUsedContents.length >= CONTENT_COUNT_TO_MERGE ||\n\t\t\tsmallUsedContentSize > MIN_CONTENT_SIZE\n\t\t) {\n\t\t\tmergedIndices = smallUsedContents;\n\t\t} else if (\n\t\t\tsmallUnusedContents.length >= CONTENT_COUNT_TO_MERGE ||\n\t\t\tsmallUnusedContentSize > MIN_CONTENT_SIZE\n\t\t) {\n\t\t\tmergedIndices = smallUnusedContents;\n\t\t} else return;\n\n\t\tconst mergedContent = [];\n\n\t\t// 3. Remove old content entries\n\t\tfor (const i of mergedIndices) {\n\t\t\tmergedContent.push(this.content[i]);\n\t\t\tthis.content[i] = undefined;\n\t\t}\n\n\t\t// 4. Determine merged items\n\t\t/** @type {Set<string>} */\n\t\tconst mergedItems = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst mergedUsedItems = new Set();\n\t\t/** @type {(function(Map<string, any>): Promise)[]} */\n\t\tconst addToMergedMap = [];\n\t\tfor (const content of mergedContent) {\n\t\t\tfor (const identifier of content.items) {\n\t\t\t\tmergedItems.add(identifier);\n\t\t\t}\n\t\t\tfor (const identifier of content.used) {\n\t\t\t\tmergedUsedItems.add(identifier);\n\t\t\t}\n\t\t\taddToMergedMap.push(async map => {\n\t\t\t\t// unpack existing content\n\t\t\t\t// after that values are accessible in .content\n\t\t\t\tawait content.unpack(\n\t\t\t\t\t\"it should be merged with other small pack contents\"\n\t\t\t\t);\n\t\t\t\tfor (const [identifier, value] of content.content) {\n\t\t\t\t\tmap.set(identifier, value);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// 5. GC and update location of merged items\n\t\tconst newLoc = this._findLocation();\n\t\tthis._gcAndUpdateLocation(mergedItems, mergedUsedItems, newLoc);\n\n\t\t// 6. If not empty, store content somewhere\n\t\tif (mergedItems.size > 0) {\n\t\t\tthis.content[newLoc] = new PackContent(\n\t\t\t\tmergedItems,\n\t\t\t\tmergedUsedItems,\n\t\t\t\tmemoize(async () => {\n\t\t\t\t\t/** @type {Map<string, any>} */\n\t\t\t\t\tconst map = new Map();\n\t\t\t\t\tawait Promise.all(addToMergedMap.map(fn => fn(map)));\n\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.logger.log(\n\t\t\t\t\"Merged %d small files with %d cache items into pack %d\",\n\t\t\t\tmergedContent.length,\n\t\t\t\tmergedItems.size,\n\t\t\t\tnewLoc\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Split large content files with used and unused items\n\t * into two parts to separate used from unused items\n\t */\n\t_optimizeUnusedContent() {\n\t\t// 1. Find a large content file with used and unused items\n\t\tfor (let i = 0; i < this.content.length; i++) {\n\t\t\tconst content = this.content[i];\n\t\t\tif (content === undefined) continue;\n\t\t\tconst size = content.getSize();\n\t\t\tif (size < MIN_CONTENT_SIZE) continue;\n\t\t\tconst used = content.used.size;\n\t\t\tconst total = content.items.size;\n\t\t\tif (used > 0 && used < total) {\n\t\t\t\t// 2. Remove this content\n\t\t\t\tthis.content[i] = undefined;\n\n\t\t\t\t// 3. Determine items for the used content file\n\t\t\t\tconst usedItems = new Set(content.used);\n\t\t\t\tconst newLoc = this._findLocation();\n\t\t\t\tthis._gcAndUpdateLocation(usedItems, usedItems, newLoc);\n\n\t\t\t\t// 4. Create content file for used items\n\t\t\t\tif (usedItems.size > 0) {\n\t\t\t\t\tthis.content[newLoc] = new PackContent(\n\t\t\t\t\t\tusedItems,\n\t\t\t\t\t\tnew Set(usedItems),\n\t\t\t\t\t\tasync () => {\n\t\t\t\t\t\t\tawait content.unpack(\n\t\t\t\t\t\t\t\t\"it should be splitted into used and unused items\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst map = new Map();\n\t\t\t\t\t\t\tfor (const identifier of usedItems) {\n\t\t\t\t\t\t\t\tmap.set(identifier, content.content.get(identifier));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// 5. Determine items for the unused content file\n\t\t\t\tconst unusedItems = new Set(content.items);\n\t\t\t\tconst usedOfUnusedItems = new Set();\n\t\t\t\tfor (const identifier of usedItems) {\n\t\t\t\t\tunusedItems.delete(identifier);\n\t\t\t\t}\n\t\t\t\tconst newUnusedLoc = this._findLocation();\n\t\t\t\tthis._gcAndUpdateLocation(unusedItems, usedOfUnusedItems, newUnusedLoc);\n\n\t\t\t\t// 6. Create content file for unused items\n\t\t\t\tif (unusedItems.size > 0) {\n\t\t\t\t\tthis.content[newUnusedLoc] = new PackContent(\n\t\t\t\t\t\tunusedItems,\n\t\t\t\t\t\tusedOfUnusedItems,\n\t\t\t\t\t\tasync () => {\n\t\t\t\t\t\t\tawait content.unpack(\n\t\t\t\t\t\t\t\t\"it should be splitted into used and unused items\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst map = new Map();\n\t\t\t\t\t\t\tfor (const identifier of unusedItems) {\n\t\t\t\t\t\t\t\tmap.set(identifier, content.content.get(identifier));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthis.logger.log(\n\t\t\t\t\t\"Split pack %d into pack %d with %d used items and pack %d with %d unused items\",\n\t\t\t\t\ti,\n\t\t\t\t\tnewLoc,\n\t\t\t\t\tusedItems.size,\n\t\t\t\t\tnewUnusedLoc,\n\t\t\t\t\tunusedItems.size\n\t\t\t\t);\n\n\t\t\t\t// optimizing only one of them is good enough and\n\t\t\t\t// reduces the amount of serialization needed\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Find the content with the oldest item and run GC on that.\n\t * Only runs for one content to avoid large invalidation.\n\t */\n\t_gcOldestContent() {\n\t\t/** @type {PackItemInfo} */\n\t\tlet oldest = undefined;\n\t\tfor (const info of this.itemInfo.values()) {\n\t\t\tif (oldest === undefined || info.lastAccess < oldest.lastAccess) {\n\t\t\t\toldest = info;\n\t\t\t}\n\t\t}\n\t\tif (Date.now() - oldest.lastAccess > this.maxAge) {\n\t\t\tconst loc = oldest.location;\n\t\t\tif (loc < 0) return;\n\t\t\tconst content = this.content[loc];\n\t\t\tconst items = new Set(content.items);\n\t\t\tconst usedItems = new Set(content.used);\n\t\t\tthis._gcAndUpdateLocation(items, usedItems, loc);\n\n\t\t\tthis.content[loc] =\n\t\t\t\titems.size > 0\n\t\t\t\t\t? new PackContent(items, usedItems, async () => {\n\t\t\t\t\t\t\tawait content.unpack(\n\t\t\t\t\t\t\t\t\"it contains old items that should be garbage collected\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst map = new Map();\n\t\t\t\t\t\t\tfor (const identifier of items) {\n\t\t\t\t\t\t\t\tmap.set(identifier, content.content.get(identifier));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t\t  })\n\t\t\t\t\t: undefined;\n\t\t}\n\t}\n\n\tserialize({ write, writeSeparate }) {\n\t\tthis._persistFreshContent();\n\t\tthis._optimizeSmallContent();\n\t\tthis._optimizeUnusedContent();\n\t\tthis._gcOldestContent();\n\t\tfor (const identifier of this.itemInfo.keys()) {\n\t\t\twrite(identifier);\n\t\t}\n\t\twrite(null); // null as marker of the end of keys\n\t\tfor (const info of this.itemInfo.values()) {\n\t\t\twrite(info.etag);\n\t\t}\n\t\tfor (const info of this.itemInfo.values()) {\n\t\t\twrite(info.lastAccess);\n\t\t}\n\t\tfor (let i = 0; i < this.content.length; i++) {\n\t\t\tconst content = this.content[i];\n\t\t\tif (content !== undefined) {\n\t\t\t\twrite(content.items);\n\t\t\t\tcontent.writeLazy(lazy => writeSeparate(lazy, { name: `${i}` }));\n\t\t\t} else {\n\t\t\t\twrite(undefined); // undefined marks an empty content slot\n\t\t\t}\n\t\t}\n\t\twrite(null); // null as marker of the end of items\n\t}\n\n\tdeserialize({ read, logger }) {\n\t\tthis.logger = logger;\n\t\t{\n\t\t\tconst items = [];\n\t\t\tlet item = read();\n\t\t\twhile (item !== null) {\n\t\t\t\titems.push(item);\n\t\t\t\titem = read();\n\t\t\t}\n\t\t\tthis.itemInfo.clear();\n\t\t\tconst infoItems = items.map(identifier => {\n\t\t\t\tconst info = new PackItemInfo(identifier, undefined, undefined);\n\t\t\t\tthis.itemInfo.set(identifier, info);\n\t\t\t\treturn info;\n\t\t\t});\n\t\t\tfor (const info of infoItems) {\n\t\t\t\tinfo.etag = read();\n\t\t\t}\n\t\t\tfor (const info of infoItems) {\n\t\t\t\tinfo.lastAccess = read();\n\t\t\t}\n\t\t}\n\t\tthis.content.length = 0;\n\t\tlet items = read();\n\t\twhile (items !== null) {\n\t\t\tif (items === undefined) {\n\t\t\t\tthis.content.push(items);\n\t\t\t} else {\n\t\t\t\tconst idx = this.content.length;\n\t\t\t\tconst lazy = read();\n\t\t\t\tthis.content.push(\n\t\t\t\t\tnew PackContent(\n\t\t\t\t\t\titems,\n\t\t\t\t\t\tnew Set(),\n\t\t\t\t\t\tlazy,\n\t\t\t\t\t\tlogger,\n\t\t\t\t\t\t`${this.content.length}`\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\tfor (const identifier of items) {\n\t\t\t\t\tthis.itemInfo.get(identifier).location = idx;\n\t\t\t\t}\n\t\t\t}\n\t\t\titems = read();\n\t\t}\n\t}\n}\n\nmakeSerializable(Pack, \"webpack/lib/cache/PackFileCacheStrategy\", \"Pack\");\n\nclass PackContentItems {\n\t/**\n\t * @param {Map<string, any>} map items\n\t */\n\tconstructor(map) {\n\t\tthis.map = map;\n\t}\n\n\tserialize({ write, snapshot, rollback, logger, profile }) {\n\t\tif (profile) {\n\t\t\twrite(false);\n\t\t\tfor (const [key, value] of this.map) {\n\t\t\t\tconst s = snapshot();\n\t\t\t\ttry {\n\t\t\t\t\twrite(key);\n\t\t\t\t\tconst start = process.hrtime();\n\t\t\t\t\twrite(value);\n\t\t\t\t\tconst durationHr = process.hrtime(start);\n\t\t\t\t\tconst duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\n\t\t\t\t\tif (duration > 1) {\n\t\t\t\t\t\tif (duration > 500)\n\t\t\t\t\t\t\tlogger.error(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t\telse if (duration > 50)\n\t\t\t\t\t\t\tlogger.warn(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t\telse if (duration > 10)\n\t\t\t\t\t\t\tlogger.info(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t\telse if (duration > 5)\n\t\t\t\t\t\t\tlogger.log(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t\telse logger.debug(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\trollback(s);\n\t\t\t\t\tif (e === NOT_SERIALIZABLE) continue;\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`Skipped not serializable cache item '${key}': ${e.message}`\n\t\t\t\t\t);\n\t\t\t\t\tlogger.debug(e.stack);\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite(null);\n\t\t\treturn;\n\t\t}\n\t\t// Try to serialize all at once\n\t\tconst s = snapshot();\n\t\ttry {\n\t\t\twrite(true);\n\t\t\twrite(this.map);\n\t\t} catch (e) {\n\t\t\trollback(s);\n\n\t\t\t// Try to serialize each item on it's own\n\t\t\twrite(false);\n\t\t\tfor (const [key, value] of this.map) {\n\t\t\t\tconst s = snapshot();\n\t\t\t\ttry {\n\t\t\t\t\twrite(key);\n\t\t\t\t\twrite(value);\n\t\t\t\t} catch (e) {\n\t\t\t\t\trollback(s);\n\t\t\t\t\tif (e === NOT_SERIALIZABLE) continue;\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`Skipped not serializable cache item '${key}': ${e.message}`\n\t\t\t\t\t);\n\t\t\t\t\tlogger.debug(e.stack);\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite(null);\n\t\t}\n\t}\n\n\tdeserialize({ read, logger, profile }) {\n\t\tif (read()) {\n\t\t\tthis.map = read();\n\t\t} else if (profile) {\n\t\t\tconst map = new Map();\n\t\t\tlet key = read();\n\t\t\twhile (key !== null) {\n\t\t\t\tconst start = process.hrtime();\n\t\t\t\tconst value = read();\n\t\t\t\tconst durationHr = process.hrtime(start);\n\t\t\t\tconst duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\n\t\t\t\tif (duration > 1) {\n\t\t\t\t\tif (duration > 100)\n\t\t\t\t\t\tlogger.error(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t\telse if (duration > 20)\n\t\t\t\t\t\tlogger.warn(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t\telse if (duration > 5)\n\t\t\t\t\t\tlogger.info(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t\telse if (duration > 2)\n\t\t\t\t\t\tlogger.log(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t\telse logger.debug(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t}\n\t\t\t\tmap.set(key, value);\n\t\t\t\tkey = read();\n\t\t\t}\n\t\t\tthis.map = map;\n\t\t} else {\n\t\t\tconst map = new Map();\n\t\t\tlet key = read();\n\t\t\twhile (key !== null) {\n\t\t\t\tmap.set(key, read());\n\t\t\t\tkey = read();\n\t\t\t}\n\t\t\tthis.map = map;\n\t\t}\n\t}\n}\n\nmakeSerializable(\n\tPackContentItems,\n\t\"webpack/lib/cache/PackFileCacheStrategy\",\n\t\"PackContentItems\"\n);\n\nclass PackContent {\n\t/*\n\t\tThis class can be in these states:\n\t\t   |   this.lazy    | this.content | this.outdated | state\n\t\tA1 |   undefined    |     Map      |     false     | fresh content\n\t\tA2 |   undefined    |     Map      |     true      | (will not happen)\n\t\tB1 | lazy () => {}  |  undefined   |     false     | not deserialized\n\t\tB2 | lazy () => {}  |  undefined   |     true      | not deserialized, but some items has been removed\n\t\tC1 | lazy* () => {} |     Map      |     false     | deserialized\n\t\tC2 | lazy* () => {} |     Map      |     true      | deserialized, and some items has been removed\n\n\t\tthis.used is a subset of this.items.\n\t\tthis.items is a subset of this.content.keys() resp. this.lazy().map.keys()\n\t\tWhen this.outdated === false, this.items === this.content.keys() resp. this.lazy().map.keys()\n\t\tWhen this.outdated === true, this.items should be used to recreated this.lazy/this.content.\n\t\tWhen this.lazy and this.content is set, they contain the same data.\n\t\tthis.get must only be called with a valid item from this.items.\n\t\tIn state C this.lazy is unMemoized\n\t*/\n\n\t/**\n\t * @param {Set<string>} items keys\n\t * @param {Set<string>} usedItems used keys\n\t * @param {PackContentItems | function(): Promise<PackContentItems>} dataOrFn sync or async content\n\t * @param {Logger=} logger logger for logging\n\t * @param {string=} lazyName name of dataOrFn for logging\n\t */\n\tconstructor(items, usedItems, dataOrFn, logger, lazyName) {\n\t\tthis.items = items;\n\t\t/** @type {function(): Promise<PackContentItems> | PackContentItems} */\n\t\tthis.lazy = typeof dataOrFn === \"function\" ? dataOrFn : undefined;\n\t\t/** @type {Map<string, any>} */\n\t\tthis.content = typeof dataOrFn === \"function\" ? undefined : dataOrFn.map;\n\t\tthis.outdated = false;\n\t\tthis.used = usedItems;\n\t\tthis.logger = logger;\n\t\tthis.lazyName = lazyName;\n\t}\n\n\tget(identifier) {\n\t\tthis.used.add(identifier);\n\t\tif (this.content) {\n\t\t\treturn this.content.get(identifier);\n\t\t}\n\n\t\t// We are in state B\n\t\tconst { lazyName } = this;\n\t\tlet timeMessage;\n\t\tif (lazyName) {\n\t\t\t// only log once\n\t\t\tthis.lazyName = undefined;\n\t\t\ttimeMessage = `restore cache content ${lazyName} (${formatSize(\n\t\t\t\tthis.getSize()\n\t\t\t)})`;\n\t\t\tthis.logger.log(\n\t\t\t\t`starting to restore cache content ${lazyName} (${formatSize(\n\t\t\t\t\tthis.getSize()\n\t\t\t\t)}) because of request to: ${identifier}`\n\t\t\t);\n\t\t\tthis.logger.time(timeMessage);\n\t\t}\n\t\tconst value = this.lazy();\n\t\tif (\"then\" in value) {\n\t\t\treturn value.then(data => {\n\t\t\t\tconst map = data.map;\n\t\t\t\tif (timeMessage) {\n\t\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t\t}\n\t\t\t\t// Move to state C\n\t\t\t\tthis.content = map;\n\t\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n\t\t\t\treturn map.get(identifier);\n\t\t\t});\n\t\t} else {\n\t\t\tconst map = value.map;\n\t\t\tif (timeMessage) {\n\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t}\n\t\t\t// Move to state C\n\t\t\tthis.content = map;\n\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n\t\t\treturn map.get(identifier);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} reason explanation why unpack is necessary\n\t * @returns {void | Promise} maybe a promise if lazy\n\t */\n\tunpack(reason) {\n\t\tif (this.content) return;\n\n\t\t// Move from state B to C\n\t\tif (this.lazy) {\n\t\t\tconst { lazyName } = this;\n\t\t\tlet timeMessage;\n\t\t\tif (lazyName) {\n\t\t\t\t// only log once\n\t\t\t\tthis.lazyName = undefined;\n\t\t\t\ttimeMessage = `unpack cache content ${lazyName} (${formatSize(\n\t\t\t\t\tthis.getSize()\n\t\t\t\t)})`;\n\t\t\t\tthis.logger.log(\n\t\t\t\t\t`starting to unpack cache content ${lazyName} (${formatSize(\n\t\t\t\t\t\tthis.getSize()\n\t\t\t\t\t)}) because ${reason}`\n\t\t\t\t);\n\t\t\t\tthis.logger.time(timeMessage);\n\t\t\t}\n\t\t\tconst value = this.lazy();\n\t\t\tif (\"then\" in value) {\n\t\t\t\treturn value.then(data => {\n\t\t\t\t\tif (timeMessage) {\n\t\t\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t\t\t}\n\t\t\t\t\tthis.content = data.map;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (timeMessage) {\n\t\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t\t}\n\t\t\t\tthis.content = value.map;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @returns {number} size of the content or -1 if not known\n\t */\n\tgetSize() {\n\t\tif (!this.lazy) return -1;\n\t\tconst options = /** @type {any} */ (this.lazy).options;\n\t\tif (!options) return -1;\n\t\tconst size = options.size;\n\t\tif (typeof size !== \"number\") return -1;\n\t\treturn size;\n\t}\n\n\tdelete(identifier) {\n\t\tthis.items.delete(identifier);\n\t\tthis.used.delete(identifier);\n\t\tthis.outdated = true;\n\t}\n\n\t/**\n\t * @template T\n\t * @param {function(any): function(): Promise<PackContentItems> | PackContentItems} write write function\n\t * @returns {void}\n\t */\n\twriteLazy(write) {\n\t\tif (!this.outdated && this.lazy) {\n\t\t\t// State B1 or C1\n\t\t\t// this.lazy is still the valid deserialized version\n\t\t\twrite(this.lazy);\n\t\t\treturn;\n\t\t}\n\t\tif (!this.outdated && this.content) {\n\t\t\t// State A1\n\t\t\tconst map = new Map(this.content);\n\t\t\t// Move to state C1\n\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(\n\t\t\t\twrite(() => new PackContentItems(map))\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\tif (this.content) {\n\t\t\t// State A2 or C2\n\t\t\t/** @type {Map<string, any>} */\n\t\t\tconst map = new Map();\n\t\t\tfor (const item of this.items) {\n\t\t\t\tmap.set(item, this.content.get(item));\n\t\t\t}\n\t\t\t// Move to state C1\n\t\t\tthis.outdated = false;\n\t\t\tthis.content = map;\n\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(\n\t\t\t\twrite(() => new PackContentItems(map))\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\t// State B2\n\t\tconst { lazyName } = this;\n\t\tlet timeMessage;\n\t\tif (lazyName) {\n\t\t\t// only log once\n\t\t\tthis.lazyName = undefined;\n\t\t\ttimeMessage = `unpack cache content ${lazyName} (${formatSize(\n\t\t\t\tthis.getSize()\n\t\t\t)})`;\n\t\t\tthis.logger.log(\n\t\t\t\t`starting to unpack cache content ${lazyName} (${formatSize(\n\t\t\t\t\tthis.getSize()\n\t\t\t\t)}) because it's outdated and need to be serialized`\n\t\t\t);\n\t\t\tthis.logger.time(timeMessage);\n\t\t}\n\t\tconst value = this.lazy();\n\t\tthis.outdated = false;\n\t\tif (\"then\" in value) {\n\t\t\t// Move to state B1\n\t\t\tthis.lazy = write(() =>\n\t\t\t\tvalue.then(data => {\n\t\t\t\t\tif (timeMessage) {\n\t\t\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t\t\t}\n\t\t\t\t\tconst oldMap = data.map;\n\t\t\t\t\t/** @type {Map<string, any>} */\n\t\t\t\t\tconst map = new Map();\n\t\t\t\t\tfor (const item of this.items) {\n\t\t\t\t\t\tmap.set(item, oldMap.get(item));\n\t\t\t\t\t}\n\t\t\t\t\t// Move to state C1 (or maybe C2)\n\t\t\t\t\tthis.content = map;\n\t\t\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n\n\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t})\n\t\t\t);\n\t\t} else {\n\t\t\t// Move to state C1\n\t\t\tif (timeMessage) {\n\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t}\n\t\t\tconst oldMap = value.map;\n\t\t\t/** @type {Map<string, any>} */\n\t\t\tconst map = new Map();\n\t\t\tfor (const item of this.items) {\n\t\t\t\tmap.set(item, oldMap.get(item));\n\t\t\t}\n\t\t\tthis.content = map;\n\t\t\tthis.lazy = write(() => new PackContentItems(map));\n\t\t}\n\t}\n}\n\nconst allowCollectingMemory = buf => {\n\tconst wasted = buf.buffer.byteLength - buf.byteLength;\n\tif (wasted > 8192 && (wasted > 1048576 || wasted > buf.byteLength)) {\n\t\treturn Buffer.from(buf);\n\t}\n\treturn buf;\n};\n\nclass PackFileCacheStrategy {\n\t/**\n\t * @param {Object} options options\n\t * @param {Compiler} options.compiler the compiler\n\t * @param {IntermediateFileSystem} options.fs the filesystem\n\t * @param {string} options.context the context directory\n\t * @param {string} options.cacheLocation the location of the cache data\n\t * @param {string} options.version version identifier\n\t * @param {Logger} options.logger a logger\n\t * @param {SnapshotOptions} options.snapshot options regarding snapshotting\n\t * @param {number} options.maxAge max age of cache items\n\t * @param {boolean} options.profile track and log detailed timing information for individual cache items\n\t * @param {boolean} options.allowCollectingMemory allow to collect unused memory created during deserialization\n\t * @param {false | \"gzip\" | \"brotli\"} options.compression compression used\n\t */\n\tconstructor({\n\t\tcompiler,\n\t\tfs,\n\t\tcontext,\n\t\tcacheLocation,\n\t\tversion,\n\t\tlogger,\n\t\tsnapshot,\n\t\tmaxAge,\n\t\tprofile,\n\t\tallowCollectingMemory,\n\t\tcompression\n\t}) {\n\t\tthis.fileSerializer = createFileSerializer(\n\t\t\tfs,\n\t\t\tcompiler.options.output.hashFunction\n\t\t);\n\t\tthis.fileSystemInfo = new FileSystemInfo(fs, {\n\t\t\tmanagedPaths: snapshot.managedPaths,\n\t\t\timmutablePaths: snapshot.immutablePaths,\n\t\t\tlogger: logger.getChildLogger(\"webpack.FileSystemInfo\"),\n\t\t\thashFunction: compiler.options.output.hashFunction\n\t\t});\n\t\tthis.compiler = compiler;\n\t\tthis.context = context;\n\t\tthis.cacheLocation = cacheLocation;\n\t\tthis.version = version;\n\t\tthis.logger = logger;\n\t\tthis.maxAge = maxAge;\n\t\tthis.profile = profile;\n\t\tthis.allowCollectingMemory = allowCollectingMemory;\n\t\tthis.compression = compression;\n\t\tthis._extension =\n\t\t\tcompression === \"brotli\"\n\t\t\t\t? \".pack.br\"\n\t\t\t\t: compression === \"gzip\"\n\t\t\t\t? \".pack.gz\"\n\t\t\t\t: \".pack\";\n\t\tthis.snapshot = snapshot;\n\t\t/** @type {Set<string>} */\n\t\tthis.buildDependencies = new Set();\n\t\t/** @type {LazySet<string>} */\n\t\tthis.newBuildDependencies = new LazySet();\n\t\t/** @type {Snapshot} */\n\t\tthis.resolveBuildDependenciesSnapshot = undefined;\n\t\t/** @type {Map<string, string | false>} */\n\t\tthis.resolveResults = undefined;\n\t\t/** @type {Snapshot} */\n\t\tthis.buildSnapshot = undefined;\n\t\t/** @type {Promise<Pack>} */\n\t\tthis.packPromise = this._openPack();\n\t\tthis.storePromise = Promise.resolve();\n\t}\n\n\t_getPack() {\n\t\tif (this.packPromise === undefined) {\n\t\t\tthis.packPromise = this.storePromise.then(() => this._openPack());\n\t\t}\n\t\treturn this.packPromise;\n\t}\n\n\t/**\n\t * @returns {Promise<Pack>} the pack\n\t */\n\t_openPack() {\n\t\tconst { logger, profile, cacheLocation, version } = this;\n\t\t/** @type {Snapshot} */\n\t\tlet buildSnapshot;\n\t\t/** @type {Set<string>} */\n\t\tlet buildDependencies;\n\t\t/** @type {Set<string>} */\n\t\tlet newBuildDependencies;\n\t\t/** @type {Snapshot} */\n\t\tlet resolveBuildDependenciesSnapshot;\n\t\t/** @type {Map<string, string | false>} */\n\t\tlet resolveResults;\n\t\tlogger.time(\"restore cache container\");\n\t\treturn this.fileSerializer\n\t\t\t.deserialize(null, {\n\t\t\t\tfilename: `${cacheLocation}/index${this._extension}`,\n\t\t\t\textension: `${this._extension}`,\n\t\t\t\tlogger,\n\t\t\t\tprofile,\n\t\t\t\tretainedBuffer: this.allowCollectingMemory\n\t\t\t\t\t? allowCollectingMemory\n\t\t\t\t\t: undefined\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tif (err.code !== \"ENOENT\") {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`Restoring pack failed from ${cacheLocation}${this._extension}: ${err}`\n\t\t\t\t\t);\n\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t`No pack exists at ${cacheLocation}${this._extension}: ${err}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t})\n\t\t\t.then(packContainer => {\n\t\t\t\tlogger.timeEnd(\"restore cache container\");\n\t\t\t\tif (!packContainer) return undefined;\n\t\t\t\tif (!(packContainer instanceof PackContainer)) {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but contained content is unexpected.`,\n\t\t\t\t\t\tpackContainer\n\t\t\t\t\t);\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tif (packContainer.version !== version) {\n\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but version doesn't match.`\n\t\t\t\t\t);\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tlogger.time(\"check build dependencies\");\n\t\t\t\treturn Promise.all([\n\t\t\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\t\t\tthis.fileSystemInfo.checkSnapshotValid(\n\t\t\t\t\t\t\tpackContainer.buildSnapshot,\n\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of build dependencies errored: ${err}.`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!valid) {\n\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but build dependencies have changed.`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbuildSnapshot = packContainer.buildSnapshot;\n\t\t\t\t\t\t\t\treturn resolve(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}),\n\t\t\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\t\t\tthis.fileSystemInfo.checkSnapshotValid(\n\t\t\t\t\t\t\tpackContainer.resolveBuildDependenciesSnapshot,\n\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of resolving of build dependencies errored: ${err}.`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\t\tresolveBuildDependenciesSnapshot =\n\t\t\t\t\t\t\t\t\t\tpackContainer.resolveBuildDependenciesSnapshot;\n\t\t\t\t\t\t\t\t\tbuildDependencies = packContainer.buildDependencies;\n\t\t\t\t\t\t\t\t\tresolveResults = packContainer.resolveResults;\n\t\t\t\t\t\t\t\t\treturn resolve(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\"resolving of build dependencies is invalid, will re-resolve build dependencies\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tthis.fileSystemInfo.checkResolveResultsValid(\n\t\t\t\t\t\t\t\t\tpackContainer.resolveResults,\n\t\t\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but resolving of build dependencies errored: ${err}.`\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\t\t\t\tnewBuildDependencies = packContainer.buildDependencies;\n\t\t\t\t\t\t\t\t\t\t\tresolveResults = packContainer.resolveResults;\n\t\t\t\t\t\t\t\t\t\t\treturn resolve(true);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but build dependencies resolve to different locations.`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t})\n\t\t\t\t])\n\t\t\t\t\t.catch(err => {\n\t\t\t\t\t\tlogger.timeEnd(\"check build dependencies\");\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t})\n\t\t\t\t\t.then(([buildSnapshotValid, resolveValid]) => {\n\t\t\t\t\t\tlogger.timeEnd(\"check build dependencies\");\n\t\t\t\t\t\tif (buildSnapshotValid && resolveValid) {\n\t\t\t\t\t\t\tlogger.time(\"restore cache content metadata\");\n\t\t\t\t\t\t\tconst d = packContainer.data();\n\t\t\t\t\t\t\tlogger.timeEnd(\"restore cache content metadata\");\n\t\t\t\t\t\t\treturn d;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t});\n\t\t\t})\n\t\t\t.then(pack => {\n\t\t\t\tif (pack) {\n\t\t\t\t\tpack.maxAge = this.maxAge;\n\t\t\t\t\tthis.buildSnapshot = buildSnapshot;\n\t\t\t\t\tif (buildDependencies) this.buildDependencies = buildDependencies;\n\t\t\t\t\tif (newBuildDependencies)\n\t\t\t\t\t\tthis.newBuildDependencies.addAll(newBuildDependencies);\n\t\t\t\t\tthis.resolveResults = resolveResults;\n\t\t\t\t\tthis.resolveBuildDependenciesSnapshot =\n\t\t\t\t\t\tresolveBuildDependenciesSnapshot;\n\t\t\t\t\treturn pack;\n\t\t\t\t}\n\t\t\t\treturn new Pack(logger, this.maxAge);\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tthis.logger.warn(\n\t\t\t\t\t`Restoring pack from ${cacheLocation}${this._extension} failed: ${err}`\n\t\t\t\t);\n\t\t\t\tthis.logger.debug(err.stack);\n\t\t\t\treturn new Pack(logger, this.maxAge);\n\t\t\t});\n\t}\n\n\t/**\n\t * @param {string} identifier unique name for the resource\n\t * @param {Etag | null} etag etag of the resource\n\t * @param {any} data cached content\n\t * @returns {Promise<void>} promise\n\t */\n\tstore(identifier, etag, data) {\n\t\treturn this._getPack().then(pack => {\n\t\t\tpack.set(identifier, etag === null ? null : etag.toString(), data);\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} identifier unique name for the resource\n\t * @param {Etag | null} etag etag of the resource\n\t * @returns {Promise<any>} promise to the cached content\n\t */\n\trestore(identifier, etag) {\n\t\treturn this._getPack()\n\t\t\t.then(pack =>\n\t\t\t\tpack.get(identifier, etag === null ? null : etag.toString())\n\t\t\t)\n\t\t\t.catch(err => {\n\t\t\t\tif (err && err.code !== \"ENOENT\") {\n\t\t\t\t\tthis.logger.warn(\n\t\t\t\t\t\t`Restoring failed for ${identifier} from pack: ${err}`\n\t\t\t\t\t);\n\t\t\t\t\tthis.logger.debug(err.stack);\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\tstoreBuildDependencies(dependencies) {\n\t\tthis.newBuildDependencies.addAll(dependencies);\n\t}\n\n\tafterAllStored() {\n\t\tconst packPromise = this.packPromise;\n\t\tif (packPromise === undefined) return Promise.resolve();\n\t\tconst reportProgress = ProgressPlugin.getReporter(this.compiler);\n\t\treturn (this.storePromise = packPromise\n\t\t\t.then(pack => {\n\t\t\t\tpack.stopCapturingRequests();\n\t\t\t\tif (!pack.invalid) return;\n\t\t\t\tthis.packPromise = undefined;\n\t\t\t\tthis.logger.log(`Storing pack...`);\n\t\t\t\tlet promise;\n\t\t\t\tconst newBuildDependencies = new Set();\n\t\t\t\tfor (const dep of this.newBuildDependencies) {\n\t\t\t\t\tif (!this.buildDependencies.has(dep)) {\n\t\t\t\t\t\tnewBuildDependencies.add(dep);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (newBuildDependencies.size > 0 || !this.buildSnapshot) {\n\t\t\t\t\tif (reportProgress) reportProgress(0.5, \"resolve build dependencies\");\n\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t`Capturing build dependencies... (${Array.from(\n\t\t\t\t\t\t\tnewBuildDependencies\n\t\t\t\t\t\t).join(\", \")})`\n\t\t\t\t\t);\n\t\t\t\t\tpromise = new Promise((resolve, reject) => {\n\t\t\t\t\t\tthis.logger.time(\"resolve build dependencies\");\n\t\t\t\t\t\tthis.fileSystemInfo.resolveBuildDependencies(\n\t\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\t\tnewBuildDependencies,\n\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"resolve build dependencies\");\n\t\t\t\t\t\t\t\tif (err) return reject(err);\n\n\t\t\t\t\t\t\t\tthis.logger.time(\"snapshot build dependencies\");\n\t\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\t\tfiles,\n\t\t\t\t\t\t\t\t\tdirectories,\n\t\t\t\t\t\t\t\t\tmissing,\n\t\t\t\t\t\t\t\t\tresolveResults,\n\t\t\t\t\t\t\t\t\tresolveDependencies\n\t\t\t\t\t\t\t\t} = result;\n\t\t\t\t\t\t\t\tif (this.resolveResults) {\n\t\t\t\t\t\t\t\t\tfor (const [key, value] of resolveResults) {\n\t\t\t\t\t\t\t\t\t\tthis.resolveResults.set(key, value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis.resolveResults = resolveResults;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (reportProgress) {\n\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t0.6,\n\t\t\t\t\t\t\t\t\t\t\"snapshot build dependencies\",\n\t\t\t\t\t\t\t\t\t\t\"resolving\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.fileSystemInfo.createSnapshot(\n\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\tresolveDependencies.files,\n\t\t\t\t\t\t\t\t\tresolveDependencies.directories,\n\t\t\t\t\t\t\t\t\tresolveDependencies.missing,\n\t\t\t\t\t\t\t\t\tthis.snapshot.resolveBuildDependencies,\n\t\t\t\t\t\t\t\t\t(err, snapshot) => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"snapshot build dependencies\");\n\t\t\t\t\t\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!snapshot) {\n\t\t\t\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"snapshot build dependencies\");\n\t\t\t\t\t\t\t\t\t\t\treturn reject(\n\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\"Unable to snapshot resolve dependencies\")\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (this.resolveBuildDependenciesSnapshot) {\n\t\t\t\t\t\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot =\n\t\t\t\t\t\t\t\t\t\t\t\tthis.fileSystemInfo.mergeSnapshots(\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot,\n\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot = snapshot;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (reportProgress) {\n\t\t\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t\t\t0.7,\n\t\t\t\t\t\t\t\t\t\t\t\t\"snapshot build dependencies\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"modules\"\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tthis.fileSystemInfo.createSnapshot(\n\t\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t\t\tfiles,\n\t\t\t\t\t\t\t\t\t\t\tdirectories,\n\t\t\t\t\t\t\t\t\t\t\tmissing,\n\t\t\t\t\t\t\t\t\t\t\tthis.snapshot.buildDependencies,\n\t\t\t\t\t\t\t\t\t\t\t(err, snapshot) => {\n\t\t\t\t\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"snapshot build dependencies\");\n\t\t\t\t\t\t\t\t\t\t\t\tif (err) return reject(err);\n\t\t\t\t\t\t\t\t\t\t\t\tif (!snapshot) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn reject(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\"Unable to snapshot build dependencies\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\"Captured build dependencies\");\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (this.buildSnapshot) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.buildSnapshot =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.fileSystemInfo.mergeSnapshots(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.buildSnapshot,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.buildSnapshot = snapshot;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tpromise = Promise.resolve();\n\t\t\t\t}\n\t\t\t\treturn promise.then(() => {\n\t\t\t\t\tif (reportProgress) reportProgress(0.8, \"serialize pack\");\n\t\t\t\t\tthis.logger.time(`store pack`);\n\t\t\t\t\tconst updatedBuildDependencies = new Set(this.buildDependencies);\n\t\t\t\t\tfor (const dep of newBuildDependencies) {\n\t\t\t\t\t\tupdatedBuildDependencies.add(dep);\n\t\t\t\t\t}\n\t\t\t\t\tconst content = new PackContainer(\n\t\t\t\t\t\tpack,\n\t\t\t\t\t\tthis.version,\n\t\t\t\t\t\tthis.buildSnapshot,\n\t\t\t\t\t\tupdatedBuildDependencies,\n\t\t\t\t\t\tthis.resolveResults,\n\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot\n\t\t\t\t\t);\n\t\t\t\t\treturn this.fileSerializer\n\t\t\t\t\t\t.serialize(content, {\n\t\t\t\t\t\t\tfilename: `${this.cacheLocation}/index${this._extension}`,\n\t\t\t\t\t\t\textension: `${this._extension}`,\n\t\t\t\t\t\t\tlogger: this.logger,\n\t\t\t\t\t\t\tprofile: this.profile\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t\tfor (const dep of newBuildDependencies) {\n\t\t\t\t\t\t\t\tthis.buildDependencies.add(dep);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.newBuildDependencies.clear();\n\t\t\t\t\t\t\tthis.logger.timeEnd(`store pack`);\n\t\t\t\t\t\t\tconst stats = pack.getContentStats();\n\t\t\t\t\t\t\tthis.logger.log(\n\t\t\t\t\t\t\t\t\"Stored pack (%d items, %d files, %d MiB)\",\n\t\t\t\t\t\t\t\tpack.itemInfo.size,\n\t\t\t\t\t\t\t\tstats.count,\n\t\t\t\t\t\t\t\tMath.round(stats.size / 1024 / 1024)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(err => {\n\t\t\t\t\t\t\tthis.logger.timeEnd(`store pack`);\n\t\t\t\t\t\t\tthis.logger.warn(`Caching failed for pack: ${err}`);\n\t\t\t\t\t\t\tthis.logger.debug(err.stack);\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tthis.logger.warn(`Caching failed for pack: ${err}`);\n\t\t\t\tthis.logger.debug(err.stack);\n\t\t\t}));\n\t}\n\n\tclear() {\n\t\tthis.fileSystemInfo.clear();\n\t\tthis.buildDependencies.clear();\n\t\tthis.newBuildDependencies.clear();\n\t\tthis.resolveBuildDependenciesSnapshot = undefined;\n\t\tthis.resolveResults = undefined;\n\t\tthis.buildSnapshot = undefined;\n\t\tthis.packPromise = undefined;\n\t}\n}\n\nmodule.exports = PackFileCacheStrategy;\n"]},"metadata":{},"sourceType":"script"}