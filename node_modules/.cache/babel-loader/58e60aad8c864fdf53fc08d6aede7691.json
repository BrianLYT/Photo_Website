{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\n\nconst AMDDefineDependency = require(\"./AMDDefineDependency\");\n\nconst AMDRequireArrayDependency = require(\"./AMDRequireArrayDependency\");\n\nconst AMDRequireContextDependency = require(\"./AMDRequireContextDependency\");\n\nconst AMDRequireItemDependency = require(\"./AMDRequireItemDependency\");\n\nconst ConstDependency = require(\"./ConstDependency\");\n\nconst ContextDependencyHelpers = require(\"./ContextDependencyHelpers\");\n\nconst DynamicExports = require(\"./DynamicExports\");\n\nconst LocalModuleDependency = require(\"./LocalModuleDependency\");\n\nconst {\n  addLocalModule,\n  getLocalModule\n} = require(\"./LocalModulesHelpers\");\n\nconst isBoundFunctionExpression = expr => {\n  if (expr.type !== \"CallExpression\") return false;\n  if (expr.callee.type !== \"MemberExpression\") return false;\n  if (expr.callee.computed) return false;\n  if (expr.callee.object.type !== \"FunctionExpression\") return false;\n  if (expr.callee.property.type !== \"Identifier\") return false;\n  if (expr.callee.property.name !== \"bind\") return false;\n  return true;\n};\n\nconst isUnboundFunctionExpression = expr => {\n  if (expr.type === \"FunctionExpression\") return true;\n  if (expr.type === \"ArrowFunctionExpression\") return true;\n  return false;\n};\n\nconst isCallable = expr => {\n  if (isUnboundFunctionExpression(expr)) return true;\n  if (isBoundFunctionExpression(expr)) return true;\n  return false;\n};\n\nclass AMDDefineDependencyParserPlugin {\n  constructor(options) {\n    this.options = options;\n  }\n\n  apply(parser) {\n    parser.hooks.call.for(\"define\").tap(\"AMDDefineDependencyParserPlugin\", this.processCallDefine.bind(this, parser));\n  }\n\n  processArray(parser, expr, param, identifiers, namedModule) {\n    if (param.isArray()) {\n      param.items.forEach((param, idx) => {\n        if (param.isString() && [\"require\", \"module\", \"exports\"].includes(param.string)) identifiers[idx] = param.string;\n        const result = this.processItem(parser, expr, param, namedModule);\n\n        if (result === undefined) {\n          this.processContext(parser, expr, param);\n        }\n      });\n      return true;\n    } else if (param.isConstArray()) {\n      const deps = [];\n      param.array.forEach((request, idx) => {\n        let dep;\n        let localModule;\n\n        if (request === \"require\") {\n          identifiers[idx] = request;\n          dep = \"__webpack_require__\";\n        } else if ([\"exports\", \"module\"].includes(request)) {\n          identifiers[idx] = request;\n          dep = request;\n        } else if (localModule = getLocalModule(parser.state, request)) {\n          localModule.flagUsed();\n          dep = new LocalModuleDependency(localModule, undefined, false);\n          dep.loc = expr.loc;\n          parser.state.module.addPresentationalDependency(dep);\n        } else {\n          dep = this.newRequireItemDependency(request);\n          dep.loc = expr.loc;\n          dep.optional = !!parser.scope.inTry;\n          parser.state.current.addDependency(dep);\n        }\n\n        deps.push(dep);\n      });\n      const dep = this.newRequireArrayDependency(deps, param.range);\n      dep.loc = expr.loc;\n      dep.optional = !!parser.scope.inTry;\n      parser.state.module.addPresentationalDependency(dep);\n      return true;\n    }\n  }\n\n  processItem(parser, expr, param, namedModule) {\n    if (param.isConditional()) {\n      param.options.forEach(param => {\n        const result = this.processItem(parser, expr, param);\n\n        if (result === undefined) {\n          this.processContext(parser, expr, param);\n        }\n      });\n      return true;\n    } else if (param.isString()) {\n      let dep, localModule;\n\n      if (param.string === \"require\") {\n        dep = new ConstDependency(\"__webpack_require__\", param.range, [RuntimeGlobals.require]);\n      } else if (param.string === \"exports\") {\n        dep = new ConstDependency(\"exports\", param.range, [RuntimeGlobals.exports]);\n      } else if (param.string === \"module\") {\n        dep = new ConstDependency(\"module\", param.range, [RuntimeGlobals.module]);\n      } else if (localModule = getLocalModule(parser.state, param.string, namedModule)) {\n        localModule.flagUsed();\n        dep = new LocalModuleDependency(localModule, param.range, false);\n      } else {\n        dep = this.newRequireItemDependency(param.string, param.range);\n        dep.optional = !!parser.scope.inTry;\n        parser.state.current.addDependency(dep);\n        return true;\n      }\n\n      dep.loc = expr.loc;\n      parser.state.module.addPresentationalDependency(dep);\n      return true;\n    }\n  }\n\n  processContext(parser, expr, param) {\n    const dep = ContextDependencyHelpers.create(AMDRequireContextDependency, param.range, param, expr, this.options, {\n      category: \"amd\"\n    }, parser);\n    if (!dep) return;\n    dep.loc = expr.loc;\n    dep.optional = !!parser.scope.inTry;\n    parser.state.current.addDependency(dep);\n    return true;\n  }\n\n  processCallDefine(parser, expr) {\n    let array, fn, obj, namedModule;\n\n    switch (expr.arguments.length) {\n      case 1:\n        if (isCallable(expr.arguments[0])) {\n          // define(f() {…})\n          fn = expr.arguments[0];\n        } else if (expr.arguments[0].type === \"ObjectExpression\") {\n          // define({…})\n          obj = expr.arguments[0];\n        } else {\n          // define(expr)\n          // unclear if function or object\n          obj = fn = expr.arguments[0];\n        }\n\n        break;\n\n      case 2:\n        if (expr.arguments[0].type === \"Literal\") {\n          namedModule = expr.arguments[0].value; // define(\"…\", …)\n\n          if (isCallable(expr.arguments[1])) {\n            // define(\"…\", f() {…})\n            fn = expr.arguments[1];\n          } else if (expr.arguments[1].type === \"ObjectExpression\") {\n            // define(\"…\", {…})\n            obj = expr.arguments[1];\n          } else {\n            // define(\"…\", expr)\n            // unclear if function or object\n            obj = fn = expr.arguments[1];\n          }\n        } else {\n          array = expr.arguments[0];\n\n          if (isCallable(expr.arguments[1])) {\n            // define([…], f() {})\n            fn = expr.arguments[1];\n          } else if (expr.arguments[1].type === \"ObjectExpression\") {\n            // define([…], {…})\n            obj = expr.arguments[1];\n          } else {\n            // define([…], expr)\n            // unclear if function or object\n            obj = fn = expr.arguments[1];\n          }\n        }\n\n        break;\n\n      case 3:\n        // define(\"…\", […], f() {…})\n        namedModule = expr.arguments[0].value;\n        array = expr.arguments[1];\n\n        if (isCallable(expr.arguments[2])) {\n          // define(\"…\", […], f() {})\n          fn = expr.arguments[2];\n        } else if (expr.arguments[2].type === \"ObjectExpression\") {\n          // define(\"…\", […], {…})\n          obj = expr.arguments[2];\n        } else {\n          // define(\"…\", […], expr)\n          // unclear if function or object\n          obj = fn = expr.arguments[2];\n        }\n\n        break;\n\n      default:\n        return;\n    }\n\n    DynamicExports.bailout(parser.state);\n    let fnParams = null;\n    let fnParamsOffset = 0;\n\n    if (fn) {\n      if (isUnboundFunctionExpression(fn)) {\n        fnParams = fn.params;\n      } else if (isBoundFunctionExpression(fn)) {\n        fnParams = fn.callee.object.params;\n        fnParamsOffset = fn.arguments.length - 1;\n\n        if (fnParamsOffset < 0) {\n          fnParamsOffset = 0;\n        }\n      }\n    }\n\n    let fnRenames = new Map();\n\n    if (array) {\n      const identifiers = {};\n      const param = parser.evaluateExpression(array);\n      const result = this.processArray(parser, expr, param, identifiers, namedModule);\n      if (!result) return;\n\n      if (fnParams) {\n        fnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => {\n          if (identifiers[idx]) {\n            fnRenames.set(param.name, parser.getVariableInfo(identifiers[idx]));\n            return false;\n          }\n\n          return true;\n        });\n      }\n    } else {\n      const identifiers = [\"require\", \"exports\", \"module\"];\n\n      if (fnParams) {\n        fnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => {\n          if (identifiers[idx]) {\n            fnRenames.set(param.name, parser.getVariableInfo(identifiers[idx]));\n            return false;\n          }\n\n          return true;\n        });\n      }\n    }\n\n    let inTry;\n\n    if (fn && isUnboundFunctionExpression(fn)) {\n      inTry = parser.scope.inTry;\n      parser.inScope(fnParams, () => {\n        for (const [name, varInfo] of fnRenames) {\n          parser.setVariable(name, varInfo);\n        }\n\n        parser.scope.inTry = inTry;\n\n        if (fn.body.type === \"BlockStatement\") {\n          parser.detectMode(fn.body.body);\n          const prev = parser.prevStatement;\n          parser.preWalkStatement(fn.body);\n          parser.prevStatement = prev;\n          parser.walkStatement(fn.body);\n        } else {\n          parser.walkExpression(fn.body);\n        }\n      });\n    } else if (fn && isBoundFunctionExpression(fn)) {\n      inTry = parser.scope.inTry;\n      parser.inScope(fn.callee.object.params.filter(i => ![\"require\", \"module\", \"exports\"].includes(i.name)), () => {\n        for (const [name, varInfo] of fnRenames) {\n          parser.setVariable(name, varInfo);\n        }\n\n        parser.scope.inTry = inTry;\n\n        if (fn.callee.object.body.type === \"BlockStatement\") {\n          parser.detectMode(fn.callee.object.body.body);\n          const prev = parser.prevStatement;\n          parser.preWalkStatement(fn.callee.object.body);\n          parser.prevStatement = prev;\n          parser.walkStatement(fn.callee.object.body);\n        } else {\n          parser.walkExpression(fn.callee.object.body);\n        }\n      });\n\n      if (fn.arguments) {\n        parser.walkExpressions(fn.arguments);\n      }\n    } else if (fn || obj) {\n      parser.walkExpression(fn || obj);\n    }\n\n    const dep = this.newDefineDependency(expr.range, array ? array.range : null, fn ? fn.range : null, obj ? obj.range : null, namedModule ? namedModule : null);\n    dep.loc = expr.loc;\n\n    if (namedModule) {\n      dep.localModule = addLocalModule(parser.state, namedModule);\n    }\n\n    parser.state.module.addPresentationalDependency(dep);\n    return true;\n  }\n\n  newDefineDependency(range, arrayRange, functionRange, objectRange, namedModule) {\n    return new AMDDefineDependency(range, arrayRange, functionRange, objectRange, namedModule);\n  }\n\n  newRequireArrayDependency(depsArray, range) {\n    return new AMDRequireArrayDependency(depsArray, range);\n  }\n\n  newRequireItemDependency(request, range) {\n    return new AMDRequireItemDependency(request, range);\n  }\n\n}\n\nmodule.exports = AMDDefineDependencyParserPlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/dependencies/AMDDefineDependencyParserPlugin.js"],"names":["RuntimeGlobals","require","AMDDefineDependency","AMDRequireArrayDependency","AMDRequireContextDependency","AMDRequireItemDependency","ConstDependency","ContextDependencyHelpers","DynamicExports","LocalModuleDependency","addLocalModule","getLocalModule","isBoundFunctionExpression","expr","type","callee","computed","object","property","name","isUnboundFunctionExpression","isCallable","AMDDefineDependencyParserPlugin","constructor","options","apply","parser","hooks","call","for","tap","processCallDefine","bind","processArray","param","identifiers","namedModule","isArray","items","forEach","idx","isString","includes","string","result","processItem","undefined","processContext","isConstArray","deps","array","request","dep","localModule","state","flagUsed","loc","module","addPresentationalDependency","newRequireItemDependency","optional","scope","inTry","current","addDependency","push","newRequireArrayDependency","range","isConditional","exports","create","category","fn","obj","arguments","length","value","bailout","fnParams","fnParamsOffset","params","fnRenames","Map","evaluateExpression","slice","filter","set","getVariableInfo","inScope","varInfo","setVariable","body","detectMode","prev","prevStatement","preWalkStatement","walkStatement","walkExpression","i","walkExpressions","newDefineDependency","arrayRange","functionRange","objectRange","depsArray"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst AMDDefineDependency = require(\"./AMDDefineDependency\");\nconst AMDRequireArrayDependency = require(\"./AMDRequireArrayDependency\");\nconst AMDRequireContextDependency = require(\"./AMDRequireContextDependency\");\nconst AMDRequireItemDependency = require(\"./AMDRequireItemDependency\");\nconst ConstDependency = require(\"./ConstDependency\");\nconst ContextDependencyHelpers = require(\"./ContextDependencyHelpers\");\nconst DynamicExports = require(\"./DynamicExports\");\nconst LocalModuleDependency = require(\"./LocalModuleDependency\");\nconst { addLocalModule, getLocalModule } = require(\"./LocalModulesHelpers\");\n\nconst isBoundFunctionExpression = expr => {\n\tif (expr.type !== \"CallExpression\") return false;\n\tif (expr.callee.type !== \"MemberExpression\") return false;\n\tif (expr.callee.computed) return false;\n\tif (expr.callee.object.type !== \"FunctionExpression\") return false;\n\tif (expr.callee.property.type !== \"Identifier\") return false;\n\tif (expr.callee.property.name !== \"bind\") return false;\n\treturn true;\n};\n\nconst isUnboundFunctionExpression = expr => {\n\tif (expr.type === \"FunctionExpression\") return true;\n\tif (expr.type === \"ArrowFunctionExpression\") return true;\n\treturn false;\n};\n\nconst isCallable = expr => {\n\tif (isUnboundFunctionExpression(expr)) return true;\n\tif (isBoundFunctionExpression(expr)) return true;\n\treturn false;\n};\n\nclass AMDDefineDependencyParserPlugin {\n\tconstructor(options) {\n\t\tthis.options = options;\n\t}\n\n\tapply(parser) {\n\t\tparser.hooks.call\n\t\t\t.for(\"define\")\n\t\t\t.tap(\n\t\t\t\t\"AMDDefineDependencyParserPlugin\",\n\t\t\t\tthis.processCallDefine.bind(this, parser)\n\t\t\t);\n\t}\n\n\tprocessArray(parser, expr, param, identifiers, namedModule) {\n\t\tif (param.isArray()) {\n\t\t\tparam.items.forEach((param, idx) => {\n\t\t\t\tif (\n\t\t\t\t\tparam.isString() &&\n\t\t\t\t\t[\"require\", \"module\", \"exports\"].includes(param.string)\n\t\t\t\t)\n\t\t\t\t\tidentifiers[idx] = param.string;\n\t\t\t\tconst result = this.processItem(parser, expr, param, namedModule);\n\t\t\t\tif (result === undefined) {\n\t\t\t\t\tthis.processContext(parser, expr, param);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn true;\n\t\t} else if (param.isConstArray()) {\n\t\t\tconst deps = [];\n\t\t\tparam.array.forEach((request, idx) => {\n\t\t\t\tlet dep;\n\t\t\t\tlet localModule;\n\t\t\t\tif (request === \"require\") {\n\t\t\t\t\tidentifiers[idx] = request;\n\t\t\t\t\tdep = \"__webpack_require__\";\n\t\t\t\t} else if ([\"exports\", \"module\"].includes(request)) {\n\t\t\t\t\tidentifiers[idx] = request;\n\t\t\t\t\tdep = request;\n\t\t\t\t} else if ((localModule = getLocalModule(parser.state, request))) {\n\t\t\t\t\tlocalModule.flagUsed();\n\t\t\t\t\tdep = new LocalModuleDependency(localModule, undefined, false);\n\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t} else {\n\t\t\t\t\tdep = this.newRequireItemDependency(request);\n\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\t}\n\t\t\t\tdeps.push(dep);\n\t\t\t});\n\t\t\tconst dep = this.newRequireArrayDependency(deps, param.range);\n\t\t\tdep.loc = expr.loc;\n\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\treturn true;\n\t\t}\n\t}\n\tprocessItem(parser, expr, param, namedModule) {\n\t\tif (param.isConditional()) {\n\t\t\tparam.options.forEach(param => {\n\t\t\t\tconst result = this.processItem(parser, expr, param);\n\t\t\t\tif (result === undefined) {\n\t\t\t\t\tthis.processContext(parser, expr, param);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn true;\n\t\t} else if (param.isString()) {\n\t\t\tlet dep, localModule;\n\t\t\tif (param.string === \"require\") {\n\t\t\t\tdep = new ConstDependency(\"__webpack_require__\", param.range, [\n\t\t\t\t\tRuntimeGlobals.require\n\t\t\t\t]);\n\t\t\t} else if (param.string === \"exports\") {\n\t\t\t\tdep = new ConstDependency(\"exports\", param.range, [\n\t\t\t\t\tRuntimeGlobals.exports\n\t\t\t\t]);\n\t\t\t} else if (param.string === \"module\") {\n\t\t\t\tdep = new ConstDependency(\"module\", param.range, [\n\t\t\t\t\tRuntimeGlobals.module\n\t\t\t\t]);\n\t\t\t} else if (\n\t\t\t\t(localModule = getLocalModule(parser.state, param.string, namedModule))\n\t\t\t) {\n\t\t\t\tlocalModule.flagUsed();\n\t\t\t\tdep = new LocalModuleDependency(localModule, param.range, false);\n\t\t\t} else {\n\t\t\t\tdep = this.newRequireItemDependency(param.string, param.range);\n\t\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tdep.loc = expr.loc;\n\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\treturn true;\n\t\t}\n\t}\n\tprocessContext(parser, expr, param) {\n\t\tconst dep = ContextDependencyHelpers.create(\n\t\t\tAMDRequireContextDependency,\n\t\t\tparam.range,\n\t\t\tparam,\n\t\t\texpr,\n\t\t\tthis.options,\n\t\t\t{\n\t\t\t\tcategory: \"amd\"\n\t\t\t},\n\t\t\tparser\n\t\t);\n\t\tif (!dep) return;\n\t\tdep.loc = expr.loc;\n\t\tdep.optional = !!parser.scope.inTry;\n\t\tparser.state.current.addDependency(dep);\n\t\treturn true;\n\t}\n\n\tprocessCallDefine(parser, expr) {\n\t\tlet array, fn, obj, namedModule;\n\t\tswitch (expr.arguments.length) {\n\t\t\tcase 1:\n\t\t\t\tif (isCallable(expr.arguments[0])) {\n\t\t\t\t\t// define(f() {…})\n\t\t\t\t\tfn = expr.arguments[0];\n\t\t\t\t} else if (expr.arguments[0].type === \"ObjectExpression\") {\n\t\t\t\t\t// define({…})\n\t\t\t\t\tobj = expr.arguments[0];\n\t\t\t\t} else {\n\t\t\t\t\t// define(expr)\n\t\t\t\t\t// unclear if function or object\n\t\t\t\t\tobj = fn = expr.arguments[0];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (expr.arguments[0].type === \"Literal\") {\n\t\t\t\t\tnamedModule = expr.arguments[0].value;\n\t\t\t\t\t// define(\"…\", …)\n\t\t\t\t\tif (isCallable(expr.arguments[1])) {\n\t\t\t\t\t\t// define(\"…\", f() {…})\n\t\t\t\t\t\tfn = expr.arguments[1];\n\t\t\t\t\t} else if (expr.arguments[1].type === \"ObjectExpression\") {\n\t\t\t\t\t\t// define(\"…\", {…})\n\t\t\t\t\t\tobj = expr.arguments[1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// define(\"…\", expr)\n\t\t\t\t\t\t// unclear if function or object\n\t\t\t\t\t\tobj = fn = expr.arguments[1];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tarray = expr.arguments[0];\n\t\t\t\t\tif (isCallable(expr.arguments[1])) {\n\t\t\t\t\t\t// define([…], f() {})\n\t\t\t\t\t\tfn = expr.arguments[1];\n\t\t\t\t\t} else if (expr.arguments[1].type === \"ObjectExpression\") {\n\t\t\t\t\t\t// define([…], {…})\n\t\t\t\t\t\tobj = expr.arguments[1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// define([…], expr)\n\t\t\t\t\t\t// unclear if function or object\n\t\t\t\t\t\tobj = fn = expr.arguments[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t// define(\"…\", […], f() {…})\n\t\t\t\tnamedModule = expr.arguments[0].value;\n\t\t\t\tarray = expr.arguments[1];\n\t\t\t\tif (isCallable(expr.arguments[2])) {\n\t\t\t\t\t// define(\"…\", […], f() {})\n\t\t\t\t\tfn = expr.arguments[2];\n\t\t\t\t} else if (expr.arguments[2].type === \"ObjectExpression\") {\n\t\t\t\t\t// define(\"…\", […], {…})\n\t\t\t\t\tobj = expr.arguments[2];\n\t\t\t\t} else {\n\t\t\t\t\t// define(\"…\", […], expr)\n\t\t\t\t\t// unclear if function or object\n\t\t\t\t\tobj = fn = expr.arguments[2];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\t\tDynamicExports.bailout(parser.state);\n\t\tlet fnParams = null;\n\t\tlet fnParamsOffset = 0;\n\t\tif (fn) {\n\t\t\tif (isUnboundFunctionExpression(fn)) {\n\t\t\t\tfnParams = fn.params;\n\t\t\t} else if (isBoundFunctionExpression(fn)) {\n\t\t\t\tfnParams = fn.callee.object.params;\n\t\t\t\tfnParamsOffset = fn.arguments.length - 1;\n\t\t\t\tif (fnParamsOffset < 0) {\n\t\t\t\t\tfnParamsOffset = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet fnRenames = new Map();\n\t\tif (array) {\n\t\t\tconst identifiers = {};\n\t\t\tconst param = parser.evaluateExpression(array);\n\t\t\tconst result = this.processArray(\n\t\t\t\tparser,\n\t\t\t\texpr,\n\t\t\t\tparam,\n\t\t\t\tidentifiers,\n\t\t\t\tnamedModule\n\t\t\t);\n\t\t\tif (!result) return;\n\t\t\tif (fnParams) {\n\t\t\t\tfnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => {\n\t\t\t\t\tif (identifiers[idx]) {\n\t\t\t\t\t\tfnRenames.set(param.name, parser.getVariableInfo(identifiers[idx]));\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tconst identifiers = [\"require\", \"exports\", \"module\"];\n\t\t\tif (fnParams) {\n\t\t\t\tfnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => {\n\t\t\t\t\tif (identifiers[idx]) {\n\t\t\t\t\t\tfnRenames.set(param.name, parser.getVariableInfo(identifiers[idx]));\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tlet inTry;\n\t\tif (fn && isUnboundFunctionExpression(fn)) {\n\t\t\tinTry = parser.scope.inTry;\n\t\t\tparser.inScope(fnParams, () => {\n\t\t\t\tfor (const [name, varInfo] of fnRenames) {\n\t\t\t\t\tparser.setVariable(name, varInfo);\n\t\t\t\t}\n\t\t\t\tparser.scope.inTry = inTry;\n\t\t\t\tif (fn.body.type === \"BlockStatement\") {\n\t\t\t\t\tparser.detectMode(fn.body.body);\n\t\t\t\t\tconst prev = parser.prevStatement;\n\t\t\t\t\tparser.preWalkStatement(fn.body);\n\t\t\t\t\tparser.prevStatement = prev;\n\t\t\t\t\tparser.walkStatement(fn.body);\n\t\t\t\t} else {\n\t\t\t\t\tparser.walkExpression(fn.body);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (fn && isBoundFunctionExpression(fn)) {\n\t\t\tinTry = parser.scope.inTry;\n\t\t\tparser.inScope(\n\t\t\t\tfn.callee.object.params.filter(\n\t\t\t\t\ti => ![\"require\", \"module\", \"exports\"].includes(i.name)\n\t\t\t\t),\n\t\t\t\t() => {\n\t\t\t\t\tfor (const [name, varInfo] of fnRenames) {\n\t\t\t\t\t\tparser.setVariable(name, varInfo);\n\t\t\t\t\t}\n\t\t\t\t\tparser.scope.inTry = inTry;\n\t\t\t\t\tif (fn.callee.object.body.type === \"BlockStatement\") {\n\t\t\t\t\t\tparser.detectMode(fn.callee.object.body.body);\n\t\t\t\t\t\tconst prev = parser.prevStatement;\n\t\t\t\t\t\tparser.preWalkStatement(fn.callee.object.body);\n\t\t\t\t\t\tparser.prevStatement = prev;\n\t\t\t\t\t\tparser.walkStatement(fn.callee.object.body);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparser.walkExpression(fn.callee.object.body);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\tif (fn.arguments) {\n\t\t\t\tparser.walkExpressions(fn.arguments);\n\t\t\t}\n\t\t} else if (fn || obj) {\n\t\t\tparser.walkExpression(fn || obj);\n\t\t}\n\n\t\tconst dep = this.newDefineDependency(\n\t\t\texpr.range,\n\t\t\tarray ? array.range : null,\n\t\t\tfn ? fn.range : null,\n\t\t\tobj ? obj.range : null,\n\t\t\tnamedModule ? namedModule : null\n\t\t);\n\t\tdep.loc = expr.loc;\n\t\tif (namedModule) {\n\t\t\tdep.localModule = addLocalModule(parser.state, namedModule);\n\t\t}\n\t\tparser.state.module.addPresentationalDependency(dep);\n\t\treturn true;\n\t}\n\n\tnewDefineDependency(\n\t\trange,\n\t\tarrayRange,\n\t\tfunctionRange,\n\t\tobjectRange,\n\t\tnamedModule\n\t) {\n\t\treturn new AMDDefineDependency(\n\t\t\trange,\n\t\t\tarrayRange,\n\t\t\tfunctionRange,\n\t\t\tobjectRange,\n\t\t\tnamedModule\n\t\t);\n\t}\n\tnewRequireArrayDependency(depsArray, range) {\n\t\treturn new AMDRequireArrayDependency(depsArray, range);\n\t}\n\tnewRequireItemDependency(request, range) {\n\t\treturn new AMDRequireItemDependency(request, range);\n\t}\n}\nmodule.exports = AMDDefineDependencyParserPlugin;\n"]},"metadata":{},"sourceType":"script"}