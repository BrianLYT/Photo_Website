{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  STAGE_BASIC\n} = require(\"../OptimizationStages\");\n\nconst {\n  runtimeEqual\n} = require(\"../util/runtime\");\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n\nclass MergeDuplicateChunksPlugin {\n  /**\n   * @param {Compiler} compiler the compiler\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"MergeDuplicateChunksPlugin\", compilation => {\n      compilation.hooks.optimizeChunks.tap({\n        name: \"MergeDuplicateChunksPlugin\",\n        stage: STAGE_BASIC\n      }, chunks => {\n        const {\n          chunkGraph,\n          moduleGraph\n        } = compilation; // remember already tested chunks for performance\n\n        const notDuplicates = new Set(); // for each chunk\n\n        for (const chunk of chunks) {\n          // track a Set of all chunk that could be duplicates\n          let possibleDuplicates;\n\n          for (const module of chunkGraph.getChunkModulesIterable(chunk)) {\n            if (possibleDuplicates === undefined) {\n              // when possibleDuplicates is not yet set,\n              // create a new Set from chunks of the current module\n              // including only chunks with the same number of modules\n              for (const dup of chunkGraph.getModuleChunksIterable(module)) {\n                if (dup !== chunk && chunkGraph.getNumberOfChunkModules(chunk) === chunkGraph.getNumberOfChunkModules(dup) && !notDuplicates.has(dup)) {\n                  // delay allocating the new Set until here, reduce memory pressure\n                  if (possibleDuplicates === undefined) {\n                    possibleDuplicates = new Set();\n                  }\n\n                  possibleDuplicates.add(dup);\n                }\n              } // when no chunk is possible we can break here\n\n\n              if (possibleDuplicates === undefined) break;\n            } else {\n              // validate existing possible duplicates\n              for (const dup of possibleDuplicates) {\n                // remove possible duplicate when module is not contained\n                if (!chunkGraph.isModuleInChunk(module, dup)) {\n                  possibleDuplicates.delete(dup);\n                }\n              } // when all chunks has been removed we can break here\n\n\n              if (possibleDuplicates.size === 0) break;\n            }\n          } // when we found duplicates\n\n\n          if (possibleDuplicates !== undefined && possibleDuplicates.size > 0) {\n            outer: for (const otherChunk of possibleDuplicates) {\n              if (otherChunk.hasRuntime() !== chunk.hasRuntime()) continue;\n              if (chunkGraph.getNumberOfEntryModules(chunk) > 0) continue;\n              if (chunkGraph.getNumberOfEntryModules(otherChunk) > 0) continue;\n\n              if (!runtimeEqual(chunk.runtime, otherChunk.runtime)) {\n                for (const module of chunkGraph.getChunkModulesIterable(chunk)) {\n                  const exportsInfo = moduleGraph.getExportsInfo(module);\n\n                  if (!exportsInfo.isEquallyUsed(chunk.runtime, otherChunk.runtime)) {\n                    continue outer;\n                  }\n                }\n              } // merge them\n\n\n              if (chunkGraph.canChunksBeIntegrated(chunk, otherChunk)) {\n                chunkGraph.integrateChunks(chunk, otherChunk);\n                compilation.chunks.delete(otherChunk);\n              }\n            }\n          } // don't check already processed chunks twice\n\n\n          notDuplicates.add(chunk);\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = MergeDuplicateChunksPlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/optimize/MergeDuplicateChunksPlugin.js"],"names":["STAGE_BASIC","require","runtimeEqual","MergeDuplicateChunksPlugin","apply","compiler","hooks","compilation","tap","optimizeChunks","name","stage","chunks","chunkGraph","moduleGraph","notDuplicates","Set","chunk","possibleDuplicates","module","getChunkModulesIterable","undefined","dup","getModuleChunksIterable","getNumberOfChunkModules","has","add","isModuleInChunk","delete","size","outer","otherChunk","hasRuntime","getNumberOfEntryModules","runtime","exportsInfo","getExportsInfo","isEquallyUsed","canChunksBeIntegrated","integrateChunks","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { STAGE_BASIC } = require(\"../OptimizationStages\");\nconst { runtimeEqual } = require(\"../util/runtime\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nclass MergeDuplicateChunksPlugin {\n\t/**\n\t * @param {Compiler} compiler the compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"MergeDuplicateChunksPlugin\",\n\t\t\tcompilation => {\n\t\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"MergeDuplicateChunksPlugin\",\n\t\t\t\t\t\tstage: STAGE_BASIC\n\t\t\t\t\t},\n\t\t\t\t\tchunks => {\n\t\t\t\t\t\tconst { chunkGraph, moduleGraph } = compilation;\n\n\t\t\t\t\t\t// remember already tested chunks for performance\n\t\t\t\t\t\tconst notDuplicates = new Set();\n\n\t\t\t\t\t\t// for each chunk\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\t// track a Set of all chunk that could be duplicates\n\t\t\t\t\t\t\tlet possibleDuplicates;\n\t\t\t\t\t\t\tfor (const module of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\t\t\t\t\t\tif (possibleDuplicates === undefined) {\n\t\t\t\t\t\t\t\t\t// when possibleDuplicates is not yet set,\n\t\t\t\t\t\t\t\t\t// create a new Set from chunks of the current module\n\t\t\t\t\t\t\t\t\t// including only chunks with the same number of modules\n\t\t\t\t\t\t\t\t\tfor (const dup of chunkGraph.getModuleChunksIterable(\n\t\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\tdup !== chunk &&\n\t\t\t\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(chunk) ===\n\t\t\t\t\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(dup) &&\n\t\t\t\t\t\t\t\t\t\t\t!notDuplicates.has(dup)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t// delay allocating the new Set until here, reduce memory pressure\n\t\t\t\t\t\t\t\t\t\t\tif (possibleDuplicates === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\tpossibleDuplicates = new Set();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tpossibleDuplicates.add(dup);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// when no chunk is possible we can break here\n\t\t\t\t\t\t\t\t\tif (possibleDuplicates === undefined) break;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// validate existing possible duplicates\n\t\t\t\t\t\t\t\t\tfor (const dup of possibleDuplicates) {\n\t\t\t\t\t\t\t\t\t\t// remove possible duplicate when module is not contained\n\t\t\t\t\t\t\t\t\t\tif (!chunkGraph.isModuleInChunk(module, dup)) {\n\t\t\t\t\t\t\t\t\t\t\tpossibleDuplicates.delete(dup);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// when all chunks has been removed we can break here\n\t\t\t\t\t\t\t\t\tif (possibleDuplicates.size === 0) break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// when we found duplicates\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tpossibleDuplicates !== undefined &&\n\t\t\t\t\t\t\t\tpossibleDuplicates.size > 0\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\touter: for (const otherChunk of possibleDuplicates) {\n\t\t\t\t\t\t\t\t\tif (otherChunk.hasRuntime() !== chunk.hasRuntime()) continue;\n\t\t\t\t\t\t\t\t\tif (chunkGraph.getNumberOfEntryModules(chunk) > 0) continue;\n\t\t\t\t\t\t\t\t\tif (chunkGraph.getNumberOfEntryModules(otherChunk) > 0)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tif (!runtimeEqual(chunk.runtime, otherChunk.runtime)) {\n\t\t\t\t\t\t\t\t\t\tfor (const module of chunkGraph.getChunkModulesIterable(\n\t\t\t\t\t\t\t\t\t\t\tchunk\n\t\t\t\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t!exportsInfo.isEquallyUsed(\n\t\t\t\t\t\t\t\t\t\t\t\t\tchunk.runtime,\n\t\t\t\t\t\t\t\t\t\t\t\t\totherChunk.runtime\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// merge them\n\t\t\t\t\t\t\t\t\tif (chunkGraph.canChunksBeIntegrated(chunk, otherChunk)) {\n\t\t\t\t\t\t\t\t\t\tchunkGraph.integrateChunks(chunk, otherChunk);\n\t\t\t\t\t\t\t\t\t\tcompilation.chunks.delete(otherChunk);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// don't check already processed chunks twice\n\t\t\t\t\t\t\tnotDuplicates.add(chunk);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = MergeDuplicateChunksPlugin;\n"]},"metadata":{},"sourceType":"script"}