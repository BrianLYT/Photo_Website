{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst NormalModule = require(\"../NormalModule\");\n/** @typedef {import(\"../Compiler\")} Compiler */\n// data URL scheme: \"data:text/javascript;charset=utf-8;base64,some-string\"\n// http://www.ietf.org/rfc/rfc2397.txt\n\n\nconst URIRegEx = /^data:([^;,]+)?((?:;[^;,]+)*?)(?:;(base64))?,(.*)$/i;\n\nconst decodeDataURI = uri => {\n  const match = URIRegEx.exec(uri);\n  if (!match) return null;\n  const isBase64 = match[3];\n  const body = match[4];\n  return isBase64 ? Buffer.from(body, \"base64\") : Buffer.from(decodeURIComponent(body), \"ascii\");\n};\n\nclass DataUriPlugin {\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"DataUriPlugin\", (compilation, _ref) => {\n      let {\n        normalModuleFactory\n      } = _ref;\n      normalModuleFactory.hooks.resolveForScheme.for(\"data\").tap(\"DataUriPlugin\", resourceData => {\n        const match = URIRegEx.exec(resourceData.resource);\n\n        if (match) {\n          resourceData.data.mimetype = match[1] || \"\";\n          resourceData.data.parameters = match[2] || \"\";\n          resourceData.data.encoding = match[3] || false;\n          resourceData.data.encodedContent = match[4] || \"\";\n        }\n      });\n      NormalModule.getCompilationHooks(compilation).readResourceForScheme.for(\"data\").tap(\"DataUriPlugin\", resource => decodeDataURI(resource));\n    });\n  }\n\n}\n\nmodule.exports = DataUriPlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/schemes/DataUriPlugin.js"],"names":["NormalModule","require","URIRegEx","decodeDataURI","uri","match","exec","isBase64","body","Buffer","from","decodeURIComponent","DataUriPlugin","apply","compiler","hooks","compilation","tap","normalModuleFactory","resolveForScheme","for","resourceData","resource","data","mimetype","parameters","encoding","encodedContent","getCompilationHooks","readResourceForScheme","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,YAAY,GAAGC,OAAO,CAAC,iBAAD,CAA5B;AAEA;AAEA;AACA;;;AACA,MAAMC,QAAQ,GAAG,qDAAjB;;AAEA,MAAMC,aAAa,GAAGC,GAAG,IAAI;AAC5B,QAAMC,KAAK,GAAGH,QAAQ,CAACI,IAAT,CAAcF,GAAd,CAAd;AACA,MAAI,CAACC,KAAL,EAAY,OAAO,IAAP;AAEZ,QAAME,QAAQ,GAAGF,KAAK,CAAC,CAAD,CAAtB;AACA,QAAMG,IAAI,GAAGH,KAAK,CAAC,CAAD,CAAlB;AACA,SAAOE,QAAQ,GACZE,MAAM,CAACC,IAAP,CAAYF,IAAZ,EAAkB,QAAlB,CADY,GAEZC,MAAM,CAACC,IAAP,CAAYC,kBAAkB,CAACH,IAAD,CAA9B,EAAsC,OAAtC,CAFH;AAGA,CATD;;AAWA,MAAMI,aAAN,CAAoB;AACnB;AACD;AACA;AACA;AACA;AACCC,EAAAA,KAAK,CAACC,QAAD,EAAW;AACfA,IAAAA,QAAQ,CAACC,KAAT,CAAeC,WAAf,CAA2BC,GAA3B,CACC,eADD,EAEC,CAACD,WAAD,WAA0C;AAAA,UAA5B;AAAEE,QAAAA;AAAF,OAA4B;AACzCA,MAAAA,mBAAmB,CAACH,KAApB,CAA0BI,gBAA1B,CACEC,GADF,CACM,MADN,EAEEH,GAFF,CAEM,eAFN,EAEuBI,YAAY,IAAI;AACrC,cAAMhB,KAAK,GAAGH,QAAQ,CAACI,IAAT,CAAce,YAAY,CAACC,QAA3B,CAAd;;AACA,YAAIjB,KAAJ,EAAW;AACVgB,UAAAA,YAAY,CAACE,IAAb,CAAkBC,QAAlB,GAA6BnB,KAAK,CAAC,CAAD,CAAL,IAAY,EAAzC;AACAgB,UAAAA,YAAY,CAACE,IAAb,CAAkBE,UAAlB,GAA+BpB,KAAK,CAAC,CAAD,CAAL,IAAY,EAA3C;AACAgB,UAAAA,YAAY,CAACE,IAAb,CAAkBG,QAAlB,GAA6BrB,KAAK,CAAC,CAAD,CAAL,IAAY,KAAzC;AACAgB,UAAAA,YAAY,CAACE,IAAb,CAAkBI,cAAlB,GAAmCtB,KAAK,CAAC,CAAD,CAAL,IAAY,EAA/C;AACA;AACD,OAVF;AAWAL,MAAAA,YAAY,CAAC4B,mBAAb,CAAiCZ,WAAjC,EACEa,qBADF,CACwBT,GADxB,CAC4B,MAD5B,EAEEH,GAFF,CAEM,eAFN,EAEuBK,QAAQ,IAAInB,aAAa,CAACmB,QAAD,CAFhD;AAGA,KAjBF;AAmBA;;AA1BkB;;AA6BpBQ,MAAM,CAACC,OAAP,GAAiBnB,aAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst NormalModule = require(\"../NormalModule\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n// data URL scheme: \"data:text/javascript;charset=utf-8;base64,some-string\"\n// http://www.ietf.org/rfc/rfc2397.txt\nconst URIRegEx = /^data:([^;,]+)?((?:;[^;,]+)*?)(?:;(base64))?,(.*)$/i;\n\nconst decodeDataURI = uri => {\n\tconst match = URIRegEx.exec(uri);\n\tif (!match) return null;\n\n\tconst isBase64 = match[3];\n\tconst body = match[4];\n\treturn isBase64\n\t\t? Buffer.from(body, \"base64\")\n\t\t: Buffer.from(decodeURIComponent(body), \"ascii\");\n};\n\nclass DataUriPlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"DataUriPlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tnormalModuleFactory.hooks.resolveForScheme\n\t\t\t\t\t.for(\"data\")\n\t\t\t\t\t.tap(\"DataUriPlugin\", resourceData => {\n\t\t\t\t\t\tconst match = URIRegEx.exec(resourceData.resource);\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\tresourceData.data.mimetype = match[1] || \"\";\n\t\t\t\t\t\t\tresourceData.data.parameters = match[2] || \"\";\n\t\t\t\t\t\t\tresourceData.data.encoding = match[3] || false;\n\t\t\t\t\t\t\tresourceData.data.encodedContent = match[4] || \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\tNormalModule.getCompilationHooks(compilation)\n\t\t\t\t\t.readResourceForScheme.for(\"data\")\n\t\t\t\t\t.tap(\"DataUriPlugin\", resource => decodeDataURI(resource));\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = DataUriPlugin;\n"]},"metadata":{},"sourceType":"script"}