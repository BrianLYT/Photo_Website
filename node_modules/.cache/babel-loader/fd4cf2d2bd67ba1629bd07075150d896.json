{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Source = require(\"./Source\");\n\nconst streamChunksOfSourceMap = require(\"./helpers/streamChunksOfSourceMap\");\n\nconst streamChunksOfRawSource = require(\"./helpers/streamChunksOfRawSource\");\n\nconst streamAndGetSourceAndMap = require(\"./helpers/streamAndGetSourceAndMap\");\n\nconst mapToBufferedMap = map => {\n  if (typeof map !== \"object\" || !map) return map;\n  const bufferedMap = Object.assign({}, map);\n\n  if (map.mappings) {\n    bufferedMap.mappings = Buffer.from(map.mappings, \"utf-8\");\n  }\n\n  if (map.sourcesContent) {\n    bufferedMap.sourcesContent = map.sourcesContent.map(str => str && Buffer.from(str, \"utf-8\"));\n  }\n\n  return bufferedMap;\n};\n\nconst bufferedMapToMap = bufferedMap => {\n  if (typeof bufferedMap !== \"object\" || !bufferedMap) return bufferedMap;\n  const map = Object.assign({}, bufferedMap);\n\n  if (bufferedMap.mappings) {\n    map.mappings = bufferedMap.mappings.toString(\"utf-8\");\n  }\n\n  if (bufferedMap.sourcesContent) {\n    map.sourcesContent = bufferedMap.sourcesContent.map(buffer => buffer && buffer.toString(\"utf-8\"));\n  }\n\n  return map;\n};\n\nclass CachedSource extends Source {\n  constructor(source, cachedData) {\n    super();\n    this._source = source;\n    this._cachedSourceType = cachedData ? cachedData.source : undefined;\n    this._cachedSource = undefined;\n    this._cachedBuffer = cachedData ? cachedData.buffer : undefined;\n    this._cachedSize = cachedData ? cachedData.size : undefined;\n    this._cachedMaps = cachedData ? cachedData.maps : new Map();\n    this._cachedHashUpdate = cachedData ? cachedData.hash : undefined;\n  }\n\n  getCachedData() {\n    const bufferedMaps = new Map();\n\n    for (const pair of this._cachedMaps) {\n      let cacheEntry = pair[1];\n\n      if (cacheEntry.bufferedMap === undefined) {\n        cacheEntry.bufferedMap = mapToBufferedMap(this._getMapFromCacheEntry(cacheEntry));\n      }\n\n      bufferedMaps.set(pair[0], {\n        map: undefined,\n        bufferedMap: cacheEntry.bufferedMap\n      });\n    } // We don't want to cache strings\n    // So if we have a caches sources\n    // create a buffer from it and only store\n    // if it was a Buffer or string\n\n\n    if (this._cachedSource) {\n      this.buffer();\n    }\n\n    return {\n      buffer: this._cachedBuffer,\n      source: this._cachedSourceType !== undefined ? this._cachedSourceType : typeof this._cachedSource === \"string\" ? true : Buffer.isBuffer(this._cachedSource) ? false : undefined,\n      size: this._cachedSize,\n      maps: bufferedMaps,\n      hash: this._cachedHashUpdate\n    };\n  }\n\n  originalLazy() {\n    return this._source;\n  }\n\n  original() {\n    if (typeof this._source === \"function\") this._source = this._source();\n    return this._source;\n  }\n\n  source() {\n    const source = this._getCachedSource();\n\n    if (source !== undefined) return source;\n    return this._cachedSource = this.original().source();\n  }\n\n  _getMapFromCacheEntry(cacheEntry) {\n    if (cacheEntry.map !== undefined) {\n      return cacheEntry.map;\n    } else if (cacheEntry.bufferedMap !== undefined) {\n      return cacheEntry.map = bufferedMapToMap(cacheEntry.bufferedMap);\n    }\n  }\n\n  _getCachedSource() {\n    if (this._cachedSource !== undefined) return this._cachedSource;\n\n    if (this._cachedBuffer && this._cachedSourceType !== undefined) {\n      return this._cachedSource = this._cachedSourceType ? this._cachedBuffer.toString(\"utf-8\") : this._cachedBuffer;\n    }\n  }\n\n  buffer() {\n    if (this._cachedBuffer !== undefined) return this._cachedBuffer;\n\n    if (this._cachedSource !== undefined) {\n      if (Buffer.isBuffer(this._cachedSource)) {\n        return this._cachedBuffer = this._cachedSource;\n      }\n\n      return this._cachedBuffer = Buffer.from(this._cachedSource, \"utf-8\");\n    }\n\n    if (typeof this.original().buffer === \"function\") {\n      return this._cachedBuffer = this.original().buffer();\n    }\n\n    const bufferOrString = this.source();\n\n    if (Buffer.isBuffer(bufferOrString)) {\n      return this._cachedBuffer = bufferOrString;\n    }\n\n    return this._cachedBuffer = Buffer.from(bufferOrString, \"utf-8\");\n  }\n\n  size() {\n    if (this._cachedSize !== undefined) return this._cachedSize;\n\n    if (this._cachedBuffer !== undefined) {\n      return this._cachedSize = this._cachedBuffer.length;\n    }\n\n    const source = this._getCachedSource();\n\n    if (source !== undefined) {\n      return this._cachedSize = Buffer.byteLength(source);\n    }\n\n    return this._cachedSize = this.original().size();\n  }\n\n  sourceAndMap(options) {\n    const key = options ? JSON.stringify(options) : \"{}\";\n\n    const cacheEntry = this._cachedMaps.get(key); // Look for a cached map\n\n\n    if (cacheEntry !== undefined) {\n      // We have a cached map in some representation\n      const map = this._getMapFromCacheEntry(cacheEntry); // Either get the cached source or compute it\n\n\n      return {\n        source: this.source(),\n        map\n      };\n    } // Look for a cached source\n\n\n    let source = this._getCachedSource(); // Compute the map\n\n\n    let map;\n\n    if (source !== undefined) {\n      map = this.original().map(options);\n    } else {\n      // Compute the source and map together.\n      const sourceAndMap = this.original().sourceAndMap(options);\n      source = sourceAndMap.source;\n      map = sourceAndMap.map;\n      this._cachedSource = source;\n    }\n\n    this._cachedMaps.set(key, {\n      map,\n      bufferedMap: undefined\n    });\n\n    return {\n      source,\n      map\n    };\n  }\n\n  streamChunks(options, onChunk, onSource, onName) {\n    const key = options ? JSON.stringify(options) : \"{}\";\n\n    if (this._cachedMaps.has(key) && (this._cachedBuffer !== undefined || this._cachedSource !== undefined)) {\n      const {\n        source,\n        map\n      } = this.sourceAndMap(options);\n\n      if (map) {\n        return streamChunksOfSourceMap(source, map, onChunk, onSource, onName, !!(options && options.finalSource), true);\n      } else {\n        return streamChunksOfRawSource(source, onChunk, onSource, onName, !!(options && options.finalSource));\n      }\n    }\n\n    const {\n      result,\n      source,\n      map\n    } = streamAndGetSourceAndMap(this.original(), options, onChunk, onSource, onName);\n    this._cachedSource = source;\n\n    this._cachedMaps.set(key, {\n      map,\n      bufferedMap: undefined\n    });\n\n    return result;\n  }\n\n  map(options) {\n    const key = options ? JSON.stringify(options) : \"{}\";\n\n    const cacheEntry = this._cachedMaps.get(key);\n\n    if (cacheEntry !== undefined) {\n      return this._getMapFromCacheEntry(cacheEntry);\n    }\n\n    const map = this.original().map(options);\n\n    this._cachedMaps.set(key, {\n      map,\n      bufferedMap: undefined\n    });\n\n    return map;\n  }\n\n  updateHash(hash) {\n    if (this._cachedHashUpdate !== undefined) {\n      for (const item of this._cachedHashUpdate) hash.update(item);\n\n      return;\n    }\n\n    const update = [];\n    let currentString = undefined;\n    const tracker = {\n      update: item => {\n        if (typeof item === \"string\" && item.length < 10240) {\n          if (currentString === undefined) {\n            currentString = item;\n          } else {\n            currentString += item;\n\n            if (currentString.length > 102400) {\n              update.push(Buffer.from(currentString));\n              currentString = undefined;\n            }\n          }\n        } else {\n          if (currentString !== undefined) {\n            update.push(Buffer.from(currentString));\n            currentString = undefined;\n          }\n\n          update.push(item);\n        }\n      }\n    };\n    this.original().updateHash(tracker);\n\n    if (currentString !== undefined) {\n      update.push(Buffer.from(currentString));\n    }\n\n    for (const item of update) hash.update(item);\n\n    this._cachedHashUpdate = update;\n  }\n\n}\n\nmodule.exports = CachedSource;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack-sources/lib/CachedSource.js"],"names":["Source","require","streamChunksOfSourceMap","streamChunksOfRawSource","streamAndGetSourceAndMap","mapToBufferedMap","map","bufferedMap","Object","assign","mappings","Buffer","from","sourcesContent","str","bufferedMapToMap","toString","buffer","CachedSource","constructor","source","cachedData","_source","_cachedSourceType","undefined","_cachedSource","_cachedBuffer","_cachedSize","size","_cachedMaps","maps","Map","_cachedHashUpdate","hash","getCachedData","bufferedMaps","pair","cacheEntry","_getMapFromCacheEntry","set","isBuffer","originalLazy","original","_getCachedSource","bufferOrString","length","byteLength","sourceAndMap","options","key","JSON","stringify","get","streamChunks","onChunk","onSource","onName","has","finalSource","result","updateHash","item","update","currentString","tracker","push","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Source = require(\"./Source\");\nconst streamChunksOfSourceMap = require(\"./helpers/streamChunksOfSourceMap\");\nconst streamChunksOfRawSource = require(\"./helpers/streamChunksOfRawSource\");\nconst streamAndGetSourceAndMap = require(\"./helpers/streamAndGetSourceAndMap\");\n\nconst mapToBufferedMap = map => {\n\tif (typeof map !== \"object\" || !map) return map;\n\tconst bufferedMap = Object.assign({}, map);\n\tif (map.mappings) {\n\t\tbufferedMap.mappings = Buffer.from(map.mappings, \"utf-8\");\n\t}\n\tif (map.sourcesContent) {\n\t\tbufferedMap.sourcesContent = map.sourcesContent.map(\n\t\t\tstr => str && Buffer.from(str, \"utf-8\")\n\t\t);\n\t}\n\treturn bufferedMap;\n};\n\nconst bufferedMapToMap = bufferedMap => {\n\tif (typeof bufferedMap !== \"object\" || !bufferedMap) return bufferedMap;\n\tconst map = Object.assign({}, bufferedMap);\n\tif (bufferedMap.mappings) {\n\t\tmap.mappings = bufferedMap.mappings.toString(\"utf-8\");\n\t}\n\tif (bufferedMap.sourcesContent) {\n\t\tmap.sourcesContent = bufferedMap.sourcesContent.map(\n\t\t\tbuffer => buffer && buffer.toString(\"utf-8\")\n\t\t);\n\t}\n\treturn map;\n};\n\nclass CachedSource extends Source {\n\tconstructor(source, cachedData) {\n\t\tsuper();\n\t\tthis._source = source;\n\t\tthis._cachedSourceType = cachedData ? cachedData.source : undefined;\n\t\tthis._cachedSource = undefined;\n\t\tthis._cachedBuffer = cachedData ? cachedData.buffer : undefined;\n\t\tthis._cachedSize = cachedData ? cachedData.size : undefined;\n\t\tthis._cachedMaps = cachedData ? cachedData.maps : new Map();\n\t\tthis._cachedHashUpdate = cachedData ? cachedData.hash : undefined;\n\t}\n\n\tgetCachedData() {\n\t\tconst bufferedMaps = new Map();\n\t\tfor (const pair of this._cachedMaps) {\n\t\t\tlet cacheEntry = pair[1];\n\t\t\tif (cacheEntry.bufferedMap === undefined) {\n\t\t\t\tcacheEntry.bufferedMap = mapToBufferedMap(\n\t\t\t\t\tthis._getMapFromCacheEntry(cacheEntry)\n\t\t\t\t);\n\t\t\t}\n\t\t\tbufferedMaps.set(pair[0], {\n\t\t\t\tmap: undefined,\n\t\t\t\tbufferedMap: cacheEntry.bufferedMap\n\t\t\t});\n\t\t}\n\t\t// We don't want to cache strings\n\t\t// So if we have a caches sources\n\t\t// create a buffer from it and only store\n\t\t// if it was a Buffer or string\n\t\tif (this._cachedSource) {\n\t\t\tthis.buffer();\n\t\t}\n\t\treturn {\n\t\t\tbuffer: this._cachedBuffer,\n\t\t\tsource:\n\t\t\t\tthis._cachedSourceType !== undefined\n\t\t\t\t\t? this._cachedSourceType\n\t\t\t\t\t: typeof this._cachedSource === \"string\"\n\t\t\t\t\t? true\n\t\t\t\t\t: Buffer.isBuffer(this._cachedSource)\n\t\t\t\t\t? false\n\t\t\t\t\t: undefined,\n\t\t\tsize: this._cachedSize,\n\t\t\tmaps: bufferedMaps,\n\t\t\thash: this._cachedHashUpdate\n\t\t};\n\t}\n\n\toriginalLazy() {\n\t\treturn this._source;\n\t}\n\n\toriginal() {\n\t\tif (typeof this._source === \"function\") this._source = this._source();\n\t\treturn this._source;\n\t}\n\n\tsource() {\n\t\tconst source = this._getCachedSource();\n\t\tif (source !== undefined) return source;\n\t\treturn (this._cachedSource = this.original().source());\n\t}\n\n\t_getMapFromCacheEntry(cacheEntry) {\n\t\tif (cacheEntry.map !== undefined) {\n\t\t\treturn cacheEntry.map;\n\t\t} else if (cacheEntry.bufferedMap !== undefined) {\n\t\t\treturn (cacheEntry.map = bufferedMapToMap(cacheEntry.bufferedMap));\n\t\t}\n\t}\n\n\t_getCachedSource() {\n\t\tif (this._cachedSource !== undefined) return this._cachedSource;\n\t\tif (this._cachedBuffer && this._cachedSourceType !== undefined) {\n\t\t\treturn (this._cachedSource = this._cachedSourceType\n\t\t\t\t? this._cachedBuffer.toString(\"utf-8\")\n\t\t\t\t: this._cachedBuffer);\n\t\t}\n\t}\n\n\tbuffer() {\n\t\tif (this._cachedBuffer !== undefined) return this._cachedBuffer;\n\t\tif (this._cachedSource !== undefined) {\n\t\t\tif (Buffer.isBuffer(this._cachedSource)) {\n\t\t\t\treturn (this._cachedBuffer = this._cachedSource);\n\t\t\t}\n\t\t\treturn (this._cachedBuffer = Buffer.from(this._cachedSource, \"utf-8\"));\n\t\t}\n\t\tif (typeof this.original().buffer === \"function\") {\n\t\t\treturn (this._cachedBuffer = this.original().buffer());\n\t\t}\n\t\tconst bufferOrString = this.source();\n\t\tif (Buffer.isBuffer(bufferOrString)) {\n\t\t\treturn (this._cachedBuffer = bufferOrString);\n\t\t}\n\t\treturn (this._cachedBuffer = Buffer.from(bufferOrString, \"utf-8\"));\n\t}\n\n\tsize() {\n\t\tif (this._cachedSize !== undefined) return this._cachedSize;\n\t\tif (this._cachedBuffer !== undefined) {\n\t\t\treturn (this._cachedSize = this._cachedBuffer.length);\n\t\t}\n\t\tconst source = this._getCachedSource();\n\t\tif (source !== undefined) {\n\t\t\treturn (this._cachedSize = Buffer.byteLength(source));\n\t\t}\n\t\treturn (this._cachedSize = this.original().size());\n\t}\n\n\tsourceAndMap(options) {\n\t\tconst key = options ? JSON.stringify(options) : \"{}\";\n\t\tconst cacheEntry = this._cachedMaps.get(key);\n\t\t// Look for a cached map\n\t\tif (cacheEntry !== undefined) {\n\t\t\t// We have a cached map in some representation\n\t\t\tconst map = this._getMapFromCacheEntry(cacheEntry);\n\t\t\t// Either get the cached source or compute it\n\t\t\treturn { source: this.source(), map };\n\t\t}\n\t\t// Look for a cached source\n\t\tlet source = this._getCachedSource();\n\t\t// Compute the map\n\t\tlet map;\n\t\tif (source !== undefined) {\n\t\t\tmap = this.original().map(options);\n\t\t} else {\n\t\t\t// Compute the source and map together.\n\t\t\tconst sourceAndMap = this.original().sourceAndMap(options);\n\t\t\tsource = sourceAndMap.source;\n\t\t\tmap = sourceAndMap.map;\n\t\t\tthis._cachedSource = source;\n\t\t}\n\t\tthis._cachedMaps.set(key, {\n\t\t\tmap,\n\t\t\tbufferedMap: undefined\n\t\t});\n\t\treturn { source, map };\n\t}\n\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tconst key = options ? JSON.stringify(options) : \"{}\";\n\t\tif (\n\t\t\tthis._cachedMaps.has(key) &&\n\t\t\t(this._cachedBuffer !== undefined || this._cachedSource !== undefined)\n\t\t) {\n\t\t\tconst { source, map } = this.sourceAndMap(options);\n\t\t\tif (map) {\n\t\t\t\treturn streamChunksOfSourceMap(\n\t\t\t\t\tsource,\n\t\t\t\t\tmap,\n\t\t\t\t\tonChunk,\n\t\t\t\t\tonSource,\n\t\t\t\t\tonName,\n\t\t\t\t\t!!(options && options.finalSource),\n\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\treturn streamChunksOfRawSource(\n\t\t\t\t\tsource,\n\t\t\t\t\tonChunk,\n\t\t\t\t\tonSource,\n\t\t\t\t\tonName,\n\t\t\t\t\t!!(options && options.finalSource)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tconst { result, source, map } = streamAndGetSourceAndMap(\n\t\t\tthis.original(),\n\t\t\toptions,\n\t\t\tonChunk,\n\t\t\tonSource,\n\t\t\tonName\n\t\t);\n\t\tthis._cachedSource = source;\n\t\tthis._cachedMaps.set(key, {\n\t\t\tmap,\n\t\t\tbufferedMap: undefined\n\t\t});\n\t\treturn result;\n\t}\n\n\tmap(options) {\n\t\tconst key = options ? JSON.stringify(options) : \"{}\";\n\t\tconst cacheEntry = this._cachedMaps.get(key);\n\t\tif (cacheEntry !== undefined) {\n\t\t\treturn this._getMapFromCacheEntry(cacheEntry);\n\t\t}\n\t\tconst map = this.original().map(options);\n\t\tthis._cachedMaps.set(key, {\n\t\t\tmap,\n\t\t\tbufferedMap: undefined\n\t\t});\n\t\treturn map;\n\t}\n\n\tupdateHash(hash) {\n\t\tif (this._cachedHashUpdate !== undefined) {\n\t\t\tfor (const item of this._cachedHashUpdate) hash.update(item);\n\t\t\treturn;\n\t\t}\n\t\tconst update = [];\n\t\tlet currentString = undefined;\n\t\tconst tracker = {\n\t\t\tupdate: item => {\n\t\t\t\tif (typeof item === \"string\" && item.length < 10240) {\n\t\t\t\t\tif (currentString === undefined) {\n\t\t\t\t\t\tcurrentString = item;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentString += item;\n\t\t\t\t\t\tif (currentString.length > 102400) {\n\t\t\t\t\t\t\tupdate.push(Buffer.from(currentString));\n\t\t\t\t\t\t\tcurrentString = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (currentString !== undefined) {\n\t\t\t\t\t\tupdate.push(Buffer.from(currentString));\n\t\t\t\t\t\tcurrentString = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tupdate.push(item);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthis.original().updateHash(tracker);\n\t\tif (currentString !== undefined) {\n\t\t\tupdate.push(Buffer.from(currentString));\n\t\t}\n\t\tfor (const item of update) hash.update(item);\n\t\tthis._cachedHashUpdate = update;\n\t}\n}\n\nmodule.exports = CachedSource;\n"]},"metadata":{},"sourceType":"script"}