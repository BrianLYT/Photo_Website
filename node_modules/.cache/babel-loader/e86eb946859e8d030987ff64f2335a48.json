{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  STAGE_BASIC\n} = require(\"../OptimizationStages\");\n\nconst Queue = require(\"../util/Queue\");\n\nconst {\n  intersect\n} = require(\"../util/SetHelpers\");\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n\nclass RemoveParentModulesPlugin {\n  /**\n   * @param {Compiler} compiler the compiler\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"RemoveParentModulesPlugin\", compilation => {\n      const handler = (chunks, chunkGroups) => {\n        const chunkGraph = compilation.chunkGraph;\n        const queue = new Queue();\n        const availableModulesMap = new WeakMap();\n\n        for (const chunkGroup of compilation.entrypoints.values()) {\n          // initialize available modules for chunks without parents\n          availableModulesMap.set(chunkGroup, new Set());\n\n          for (const child of chunkGroup.childrenIterable) {\n            queue.enqueue(child);\n          }\n        }\n\n        for (const chunkGroup of compilation.asyncEntrypoints) {\n          // initialize available modules for chunks without parents\n          availableModulesMap.set(chunkGroup, new Set());\n\n          for (const child of chunkGroup.childrenIterable) {\n            queue.enqueue(child);\n          }\n        }\n\n        while (queue.length > 0) {\n          const chunkGroup = queue.dequeue();\n          let availableModules = availableModulesMap.get(chunkGroup);\n          let changed = false;\n\n          for (const parent of chunkGroup.parentsIterable) {\n            const availableModulesInParent = availableModulesMap.get(parent);\n\n            if (availableModulesInParent !== undefined) {\n              // If we know the available modules in parent: process these\n              if (availableModules === undefined) {\n                // if we have not own info yet: create new entry\n                availableModules = new Set(availableModulesInParent);\n\n                for (const chunk of parent.chunks) {\n                  for (const m of chunkGraph.getChunkModulesIterable(chunk)) {\n                    availableModules.add(m);\n                  }\n                }\n\n                availableModulesMap.set(chunkGroup, availableModules);\n                changed = true;\n              } else {\n                for (const m of availableModules) {\n                  if (!chunkGraph.isModuleInChunkGroup(m, parent) && !availableModulesInParent.has(m)) {\n                    availableModules.delete(m);\n                    changed = true;\n                  }\n                }\n              }\n            }\n          }\n\n          if (changed) {\n            // if something changed: enqueue our children\n            for (const child of chunkGroup.childrenIterable) {\n              queue.enqueue(child);\n            }\n          }\n        } // now we have available modules for every chunk\n\n\n        for (const chunk of chunks) {\n          const availableModulesSets = Array.from(chunk.groupsIterable, chunkGroup => availableModulesMap.get(chunkGroup));\n          if (availableModulesSets.some(s => s === undefined)) continue; // No info about this chunk group\n\n          const availableModules = availableModulesSets.length === 1 ? availableModulesSets[0] : intersect(availableModulesSets);\n          const numberOfModules = chunkGraph.getNumberOfChunkModules(chunk);\n          const toRemove = new Set();\n\n          if (numberOfModules < availableModules.size) {\n            for (const m of chunkGraph.getChunkModulesIterable(chunk)) {\n              if (availableModules.has(m)) {\n                toRemove.add(m);\n              }\n            }\n          } else {\n            for (const m of availableModules) {\n              if (chunkGraph.isModuleInChunk(m, chunk)) {\n                toRemove.add(m);\n              }\n            }\n          }\n\n          for (const module of toRemove) {\n            chunkGraph.disconnectChunkAndModule(chunk, module);\n          }\n        }\n      };\n\n      compilation.hooks.optimizeChunks.tap({\n        name: \"RemoveParentModulesPlugin\",\n        stage: STAGE_BASIC\n      }, handler);\n    });\n  }\n\n}\n\nmodule.exports = RemoveParentModulesPlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/optimize/RemoveParentModulesPlugin.js"],"names":["STAGE_BASIC","require","Queue","intersect","RemoveParentModulesPlugin","apply","compiler","hooks","compilation","tap","handler","chunks","chunkGroups","chunkGraph","queue","availableModulesMap","WeakMap","chunkGroup","entrypoints","values","set","Set","child","childrenIterable","enqueue","asyncEntrypoints","length","dequeue","availableModules","get","changed","parent","parentsIterable","availableModulesInParent","undefined","chunk","m","getChunkModulesIterable","add","isModuleInChunkGroup","has","delete","availableModulesSets","Array","from","groupsIterable","some","s","numberOfModules","getNumberOfChunkModules","toRemove","size","isModuleInChunk","module","disconnectChunkAndModule","optimizeChunks","name","stage","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { STAGE_BASIC } = require(\"../OptimizationStages\");\nconst Queue = require(\"../util/Queue\");\nconst { intersect } = require(\"../util/SetHelpers\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nclass RemoveParentModulesPlugin {\n\t/**\n\t * @param {Compiler} compiler the compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"RemoveParentModulesPlugin\", compilation => {\n\t\t\tconst handler = (chunks, chunkGroups) => {\n\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\tconst queue = new Queue();\n\t\t\t\tconst availableModulesMap = new WeakMap();\n\n\t\t\t\tfor (const chunkGroup of compilation.entrypoints.values()) {\n\t\t\t\t\t// initialize available modules for chunks without parents\n\t\t\t\t\tavailableModulesMap.set(chunkGroup, new Set());\n\t\t\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\t\t\tqueue.enqueue(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const chunkGroup of compilation.asyncEntrypoints) {\n\t\t\t\t\t// initialize available modules for chunks without parents\n\t\t\t\t\tavailableModulesMap.set(chunkGroup, new Set());\n\t\t\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\t\t\tqueue.enqueue(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\tconst chunkGroup = queue.dequeue();\n\t\t\t\t\tlet availableModules = availableModulesMap.get(chunkGroup);\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\tfor (const parent of chunkGroup.parentsIterable) {\n\t\t\t\t\t\tconst availableModulesInParent = availableModulesMap.get(parent);\n\t\t\t\t\t\tif (availableModulesInParent !== undefined) {\n\t\t\t\t\t\t\t// If we know the available modules in parent: process these\n\t\t\t\t\t\t\tif (availableModules === undefined) {\n\t\t\t\t\t\t\t\t// if we have not own info yet: create new entry\n\t\t\t\t\t\t\t\tavailableModules = new Set(availableModulesInParent);\n\t\t\t\t\t\t\t\tfor (const chunk of parent.chunks) {\n\t\t\t\t\t\t\t\t\tfor (const m of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\t\t\t\t\t\t\t\tavailableModules.add(m);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tavailableModulesMap.set(chunkGroup, availableModules);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const m of availableModules) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!chunkGraph.isModuleInChunkGroup(m, parent) &&\n\t\t\t\t\t\t\t\t\t\t!availableModulesInParent.has(m)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tavailableModules.delete(m);\n\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t// if something changed: enqueue our children\n\t\t\t\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\t\t\t\tqueue.enqueue(child);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// now we have available modules for every chunk\n\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\tconst availableModulesSets = Array.from(\n\t\t\t\t\t\tchunk.groupsIterable,\n\t\t\t\t\t\tchunkGroup => availableModulesMap.get(chunkGroup)\n\t\t\t\t\t);\n\t\t\t\t\tif (availableModulesSets.some(s => s === undefined)) continue; // No info about this chunk group\n\t\t\t\t\tconst availableModules =\n\t\t\t\t\t\tavailableModulesSets.length === 1\n\t\t\t\t\t\t\t? availableModulesSets[0]\n\t\t\t\t\t\t\t: intersect(availableModulesSets);\n\t\t\t\t\tconst numberOfModules = chunkGraph.getNumberOfChunkModules(chunk);\n\t\t\t\t\tconst toRemove = new Set();\n\t\t\t\t\tif (numberOfModules < availableModules.size) {\n\t\t\t\t\t\tfor (const m of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\t\t\t\t\tif (availableModules.has(m)) {\n\t\t\t\t\t\t\t\ttoRemove.add(m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const m of availableModules) {\n\t\t\t\t\t\t\tif (chunkGraph.isModuleInChunk(m, chunk)) {\n\t\t\t\t\t\t\t\ttoRemove.add(m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const module of toRemove) {\n\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t{\n\t\t\t\t\tname: \"RemoveParentModulesPlugin\",\n\t\t\t\t\tstage: STAGE_BASIC\n\t\t\t\t},\n\t\t\t\thandler\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = RemoveParentModulesPlugin;\n"]},"metadata":{},"sourceType":"script"}