{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\n\nconst {\n  ConcatSource,\n  RawSource\n} = require(\"webpack-sources\");\n\nconst Compilation = require(\"./Compilation\");\n\nconst ModuleFilenameHelpers = require(\"./ModuleFilenameHelpers\");\n\nconst ProgressPlugin = require(\"./ProgressPlugin\");\n\nconst SourceMapDevToolModuleOptionsPlugin = require(\"./SourceMapDevToolModuleOptionsPlugin\");\n\nconst createSchemaValidation = require(\"./util/create-schema-validation\");\n\nconst createHash = require(\"./util/createHash\");\n\nconst {\n  relative,\n  dirname\n} = require(\"./util/fs\");\n\nconst {\n  makePathsAbsolute\n} = require(\"./util/identifier\");\n/** @typedef {import(\"webpack-sources\").MapOptions} MapOptions */\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../declarations/plugins/SourceMapDevToolPlugin\").SourceMapDevToolPluginOptions} SourceMapDevToolPluginOptions */\n\n/** @typedef {import(\"./Cache\").Etag} Etag */\n\n/** @typedef {import(\"./CacheFacade\").ItemCacheFacade} ItemCacheFacade */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./NormalModule\").SourceMap} SourceMap */\n\n/** @typedef {import(\"./util/Hash\")} Hash */\n\n\nconst validate = createSchemaValidation(require(\"../schemas/plugins/SourceMapDevToolPlugin.check.js\"), () => require(\"../schemas/plugins/SourceMapDevToolPlugin.json\"), {\n  name: \"SourceMap DevTool Plugin\",\n  baseDataPath: \"options\"\n});\n/**\n * @typedef {object} SourceMapTask\n * @property {Source} asset\n * @property {AssetInfo} assetInfo\n * @property {(string | Module)[]} modules\n * @property {string} source\n * @property {string} file\n * @property {SourceMap} sourceMap\n * @property {ItemCacheFacade} cacheItem cache item\n */\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\n\nconst quoteMeta = str => {\n  return str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n/**\n * Creating {@link SourceMapTask} for given file\n * @param {string} file current compiled file\n * @param {Source} asset the asset\n * @param {AssetInfo} assetInfo the asset info\n * @param {MapOptions} options source map options\n * @param {Compilation} compilation compilation instance\n * @param {ItemCacheFacade} cacheItem cache item\n * @returns {SourceMapTask | undefined} created task instance or `undefined`\n */\n\n\nconst getTaskForFile = (file, asset, assetInfo, options, compilation, cacheItem) => {\n  let source;\n  /** @type {SourceMap} */\n\n  let sourceMap;\n  /**\n   * Check if asset can build source map\n   */\n\n  if (asset.sourceAndMap) {\n    const sourceAndMap = asset.sourceAndMap(options);\n    sourceMap =\n    /** @type {SourceMap} */\n    sourceAndMap.map;\n    source = sourceAndMap.source;\n  } else {\n    sourceMap =\n    /** @type {SourceMap} */\n    asset.map(options);\n    source = asset.source();\n  }\n\n  if (!sourceMap || typeof source !== \"string\") return;\n  const context = compilation.options.context;\n  const root = compilation.compiler.root;\n  const cachedAbsolutify = makePathsAbsolute.bindContextCache(context, root);\n  const modules = sourceMap.sources.map(source => {\n    if (!source.startsWith(\"webpack://\")) return source;\n    source = cachedAbsolutify(source.slice(10));\n    const module = compilation.findModule(source);\n    return module || source;\n  });\n  return {\n    file,\n    asset,\n    source,\n    assetInfo,\n    sourceMap,\n    modules,\n    cacheItem\n  };\n};\n\nclass SourceMapDevToolPlugin {\n  /**\n   * @param {SourceMapDevToolPluginOptions} [options] options object\n   * @throws {Error} throws error, if got more than 1 arguments\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    validate(options);\n    /** @type {string | false} */\n\n    this.sourceMapFilename = options.filename;\n    /** @type {string | false} */\n\n    this.sourceMappingURLComment = options.append === false ? false : options.append || \"\\n//# source\" + \"MappingURL=[url]\";\n    /** @type {string | Function} */\n\n    this.moduleFilenameTemplate = options.moduleFilenameTemplate || \"webpack://[namespace]/[resourcePath]\";\n    /** @type {string | Function} */\n\n    this.fallbackModuleFilenameTemplate = options.fallbackModuleFilenameTemplate || \"webpack://[namespace]/[resourcePath]?[hash]\";\n    /** @type {string} */\n\n    this.namespace = options.namespace || \"\";\n    /** @type {SourceMapDevToolPluginOptions} */\n\n    this.options = options;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const outputFs = compiler.outputFileSystem;\n    const sourceMapFilename = this.sourceMapFilename;\n    const sourceMappingURLComment = this.sourceMappingURLComment;\n    const moduleFilenameTemplate = this.moduleFilenameTemplate;\n    const namespace = this.namespace;\n    const fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;\n    const requestShortener = compiler.requestShortener;\n    const options = this.options;\n    options.test = options.test || /\\.((c|m)?js|css)($|\\?)/i;\n    const matchObject = ModuleFilenameHelpers.matchObject.bind(undefined, options);\n    compiler.hooks.compilation.tap(\"SourceMapDevToolPlugin\", compilation => {\n      new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);\n      compilation.hooks.processAssets.tapAsync({\n        name: \"SourceMapDevToolPlugin\",\n        stage: Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING,\n        additionalAssets: true\n      }, (assets, callback) => {\n        const chunkGraph = compilation.chunkGraph;\n        const cache = compilation.getCache(\"SourceMapDevToolPlugin\");\n        /** @type {Map<string | Module, string>} */\n\n        const moduleToSourceNameMapping = new Map();\n        /**\n         * @type {Function}\n         * @returns {void}\n         */\n\n        const reportProgress = ProgressPlugin.getReporter(compilation.compiler) || (() => {});\n        /** @type {Map<string, Chunk>} */\n\n\n        const fileToChunk = new Map();\n\n        for (const chunk of compilation.chunks) {\n          for (const file of chunk.files) {\n            fileToChunk.set(file, chunk);\n          }\n\n          for (const file of chunk.auxiliaryFiles) {\n            fileToChunk.set(file, chunk);\n          }\n        }\n        /** @type {string[]} */\n\n\n        const files = [];\n\n        for (const file of Object.keys(assets)) {\n          if (matchObject(file)) {\n            files.push(file);\n          }\n        }\n\n        reportProgress(0.0);\n        /** @type {SourceMapTask[]} */\n\n        const tasks = [];\n        let fileIndex = 0;\n        asyncLib.each(files, (file, callback) => {\n          const asset = compilation.getAsset(file);\n\n          if (asset.info.related && asset.info.related.sourceMap) {\n            fileIndex++;\n            return callback();\n          }\n\n          const cacheItem = cache.getItemCache(file, cache.mergeEtags(cache.getLazyHashedEtag(asset.source), namespace));\n          cacheItem.get((err, cacheEntry) => {\n            if (err) {\n              return callback(err);\n            }\n            /**\n             * If presented in cache, reassigns assets. Cache assets already have source maps.\n             */\n\n\n            if (cacheEntry) {\n              const {\n                assets,\n                assetsInfo\n              } = cacheEntry;\n\n              for (const cachedFile of Object.keys(assets)) {\n                if (cachedFile === file) {\n                  compilation.updateAsset(cachedFile, assets[cachedFile], assetsInfo[cachedFile]);\n                } else {\n                  compilation.emitAsset(cachedFile, assets[cachedFile], assetsInfo[cachedFile]);\n                }\n                /**\n                 * Add file to chunk, if not presented there\n                 */\n\n\n                if (cachedFile !== file) {\n                  const chunk = fileToChunk.get(file);\n                  if (chunk !== undefined) chunk.auxiliaryFiles.add(cachedFile);\n                }\n              }\n\n              reportProgress(0.5 * ++fileIndex / files.length, file, \"restored cached SourceMap\");\n              return callback();\n            }\n\n            reportProgress(0.5 * fileIndex / files.length, file, \"generate SourceMap\");\n            /** @type {SourceMapTask | undefined} */\n\n            const task = getTaskForFile(file, asset.source, asset.info, {\n              module: options.module,\n              columns: options.columns\n            }, compilation, cacheItem);\n\n            if (task) {\n              const modules = task.modules;\n\n              for (let idx = 0; idx < modules.length; idx++) {\n                const module = modules[idx];\n\n                if (!moduleToSourceNameMapping.get(module)) {\n                  moduleToSourceNameMapping.set(module, ModuleFilenameHelpers.createFilename(module, {\n                    moduleFilenameTemplate: moduleFilenameTemplate,\n                    namespace: namespace\n                  }, {\n                    requestShortener,\n                    chunkGraph,\n                    hashFunction: compilation.outputOptions.hashFunction\n                  }));\n                }\n              }\n\n              tasks.push(task);\n            }\n\n            reportProgress(0.5 * ++fileIndex / files.length, file, \"generated SourceMap\");\n            callback();\n          });\n        }, err => {\n          if (err) {\n            return callback(err);\n          }\n\n          reportProgress(0.5, \"resolve sources\");\n          /** @type {Set<string>} */\n\n          const usedNamesSet = new Set(moduleToSourceNameMapping.values());\n          /** @type {Set<string>} */\n\n          const conflictDetectionSet = new Set();\n          /**\n           * all modules in defined order (longest identifier first)\n           * @type {Array<string | Module>}\n           */\n\n          const allModules = Array.from(moduleToSourceNameMapping.keys()).sort((a, b) => {\n            const ai = typeof a === \"string\" ? a : a.identifier();\n            const bi = typeof b === \"string\" ? b : b.identifier();\n            return ai.length - bi.length;\n          }); // find modules with conflicting source names\n\n          for (let idx = 0; idx < allModules.length; idx++) {\n            const module = allModules[idx];\n            let sourceName = moduleToSourceNameMapping.get(module);\n            let hasName = conflictDetectionSet.has(sourceName);\n\n            if (!hasName) {\n              conflictDetectionSet.add(sourceName);\n              continue;\n            } // try the fallback name first\n\n\n            sourceName = ModuleFilenameHelpers.createFilename(module, {\n              moduleFilenameTemplate: fallbackModuleFilenameTemplate,\n              namespace: namespace\n            }, {\n              requestShortener,\n              chunkGraph,\n              hashFunction: compilation.outputOptions.hashFunction\n            });\n            hasName = usedNamesSet.has(sourceName);\n\n            if (!hasName) {\n              moduleToSourceNameMapping.set(module, sourceName);\n              usedNamesSet.add(sourceName);\n              continue;\n            } // otherwise just append stars until we have a valid name\n\n\n            while (hasName) {\n              sourceName += \"*\";\n              hasName = usedNamesSet.has(sourceName);\n            }\n\n            moduleToSourceNameMapping.set(module, sourceName);\n            usedNamesSet.add(sourceName);\n          }\n\n          let taskIndex = 0;\n          asyncLib.each(tasks, (task, callback) => {\n            const assets = Object.create(null);\n            const assetsInfo = Object.create(null);\n            const file = task.file;\n            const chunk = fileToChunk.get(file);\n            const sourceMap = task.sourceMap;\n            const source = task.source;\n            const modules = task.modules;\n            reportProgress(0.5 + 0.5 * taskIndex / tasks.length, file, \"attach SourceMap\");\n            const moduleFilenames = modules.map(m => moduleToSourceNameMapping.get(m));\n            sourceMap.sources = moduleFilenames;\n\n            if (options.noSources) {\n              sourceMap.sourcesContent = undefined;\n            }\n\n            sourceMap.sourceRoot = options.sourceRoot || \"\";\n            sourceMap.file = file;\n            const usesContentHash = sourceMapFilename && /\\[contenthash(:\\w+)?\\]/.test(sourceMapFilename); // If SourceMap and asset uses contenthash, avoid a circular dependency by hiding hash in `file`\n\n            if (usesContentHash && task.assetInfo.contenthash) {\n              const contenthash = task.assetInfo.contenthash;\n              let pattern;\n\n              if (Array.isArray(contenthash)) {\n                pattern = contenthash.map(quoteMeta).join(\"|\");\n              } else {\n                pattern = quoteMeta(contenthash);\n              }\n\n              sourceMap.file = sourceMap.file.replace(new RegExp(pattern, \"g\"), m => \"x\".repeat(m.length));\n            }\n            /** @type {string | false} */\n\n\n            let currentSourceMappingURLComment = sourceMappingURLComment;\n\n            if (currentSourceMappingURLComment !== false && /\\.css($|\\?)/i.test(file)) {\n              currentSourceMappingURLComment = currentSourceMappingURLComment.replace(/^\\n\\/\\/(.*)$/, \"\\n/*$1*/\");\n            }\n\n            const sourceMapString = JSON.stringify(sourceMap);\n\n            if (sourceMapFilename) {\n              let filename = file;\n              const sourceMapContentHash = usesContentHash &&\n              /** @type {string} */\n              createHash(compilation.outputOptions.hashFunction).update(sourceMapString).digest(\"hex\");\n              const pathParams = {\n                chunk,\n                filename: options.fileContext ? relative(outputFs, `/${options.fileContext}`, `/${filename}`) : filename,\n                contentHash: sourceMapContentHash\n              };\n              const {\n                path: sourceMapFile,\n                info: sourceMapInfo\n              } = compilation.getPathWithInfo(sourceMapFilename, pathParams);\n              const sourceMapUrl = options.publicPath ? options.publicPath + sourceMapFile : relative(outputFs, dirname(outputFs, `/${file}`), `/${sourceMapFile}`);\n              /** @type {Source} */\n\n              let asset = new RawSource(source);\n\n              if (currentSourceMappingURLComment !== false) {\n                // Add source map url to compilation asset, if currentSourceMappingURLComment is set\n                asset = new ConcatSource(asset, compilation.getPath(currentSourceMappingURLComment, Object.assign({\n                  url: sourceMapUrl\n                }, pathParams)));\n              }\n\n              const assetInfo = {\n                related: {\n                  sourceMap: sourceMapFile\n                }\n              };\n              assets[file] = asset;\n              assetsInfo[file] = assetInfo;\n              compilation.updateAsset(file, asset, assetInfo); // Add source map file to compilation assets and chunk files\n\n              const sourceMapAsset = new RawSource(sourceMapString);\n              const sourceMapAssetInfo = { ...sourceMapInfo,\n                development: true\n              };\n              assets[sourceMapFile] = sourceMapAsset;\n              assetsInfo[sourceMapFile] = sourceMapAssetInfo;\n              compilation.emitAsset(sourceMapFile, sourceMapAsset, sourceMapAssetInfo);\n              if (chunk !== undefined) chunk.auxiliaryFiles.add(sourceMapFile);\n            } else {\n              if (currentSourceMappingURLComment === false) {\n                throw new Error(\"SourceMapDevToolPlugin: append can't be false when no filename is provided\");\n              }\n              /**\n               * Add source map as data url to asset\n               */\n\n\n              const asset = new ConcatSource(new RawSource(source), currentSourceMappingURLComment.replace(/\\[map\\]/g, () => sourceMapString).replace(/\\[url\\]/g, () => `data:application/json;charset=utf-8;base64,${Buffer.from(sourceMapString, \"utf-8\").toString(\"base64\")}`));\n              assets[file] = asset;\n              assetsInfo[file] = undefined;\n              compilation.updateAsset(file, asset);\n            }\n\n            task.cacheItem.store({\n              assets,\n              assetsInfo\n            }, err => {\n              reportProgress(0.5 + 0.5 * ++taskIndex / tasks.length, task.file, \"attached SourceMap\");\n\n              if (err) {\n                return callback(err);\n              }\n\n              callback();\n            });\n          }, err => {\n            reportProgress(1.0);\n            callback(err);\n          });\n        });\n      });\n    });\n  }\n\n}\n\nmodule.exports = SourceMapDevToolPlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/SourceMapDevToolPlugin.js"],"names":["asyncLib","require","ConcatSource","RawSource","Compilation","ModuleFilenameHelpers","ProgressPlugin","SourceMapDevToolModuleOptionsPlugin","createSchemaValidation","createHash","relative","dirname","makePathsAbsolute","validate","name","baseDataPath","quoteMeta","str","replace","getTaskForFile","file","asset","assetInfo","options","compilation","cacheItem","source","sourceMap","sourceAndMap","map","context","root","compiler","cachedAbsolutify","bindContextCache","modules","sources","startsWith","slice","module","findModule","SourceMapDevToolPlugin","constructor","sourceMapFilename","filename","sourceMappingURLComment","append","moduleFilenameTemplate","fallbackModuleFilenameTemplate","namespace","apply","outputFs","outputFileSystem","requestShortener","test","matchObject","bind","undefined","hooks","tap","processAssets","tapAsync","stage","PROCESS_ASSETS_STAGE_DEV_TOOLING","additionalAssets","assets","callback","chunkGraph","cache","getCache","moduleToSourceNameMapping","Map","reportProgress","getReporter","fileToChunk","chunk","chunks","files","set","auxiliaryFiles","Object","keys","push","tasks","fileIndex","each","getAsset","info","related","getItemCache","mergeEtags","getLazyHashedEtag","get","err","cacheEntry","assetsInfo","cachedFile","updateAsset","emitAsset","add","length","task","columns","idx","createFilename","hashFunction","outputOptions","usedNamesSet","Set","values","conflictDetectionSet","allModules","Array","from","sort","a","b","ai","identifier","bi","sourceName","hasName","has","taskIndex","create","moduleFilenames","m","noSources","sourcesContent","sourceRoot","usesContentHash","contenthash","pattern","isArray","join","RegExp","repeat","currentSourceMappingURLComment","sourceMapString","JSON","stringify","sourceMapContentHash","update","digest","pathParams","fileContext","contentHash","path","sourceMapFile","sourceMapInfo","getPathWithInfo","sourceMapUrl","publicPath","getPath","assign","url","sourceMapAsset","sourceMapAssetInfo","development","Error","Buffer","toString","store","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst { ConcatSource, RawSource } = require(\"webpack-sources\");\nconst Compilation = require(\"./Compilation\");\nconst ModuleFilenameHelpers = require(\"./ModuleFilenameHelpers\");\nconst ProgressPlugin = require(\"./ProgressPlugin\");\nconst SourceMapDevToolModuleOptionsPlugin = require(\"./SourceMapDevToolModuleOptionsPlugin\");\nconst createSchemaValidation = require(\"./util/create-schema-validation\");\nconst createHash = require(\"./util/createHash\");\nconst { relative, dirname } = require(\"./util/fs\");\nconst { makePathsAbsolute } = require(\"./util/identifier\");\n\n/** @typedef {import(\"webpack-sources\").MapOptions} MapOptions */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../declarations/plugins/SourceMapDevToolPlugin\").SourceMapDevToolPluginOptions} SourceMapDevToolPluginOptions */\n/** @typedef {import(\"./Cache\").Etag} Etag */\n/** @typedef {import(\"./CacheFacade\").ItemCacheFacade} ItemCacheFacade */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./NormalModule\").SourceMap} SourceMap */\n/** @typedef {import(\"./util/Hash\")} Hash */\n\nconst validate = createSchemaValidation(\n\trequire(\"../schemas/plugins/SourceMapDevToolPlugin.check.js\"),\n\t() => require(\"../schemas/plugins/SourceMapDevToolPlugin.json\"),\n\t{\n\t\tname: \"SourceMap DevTool Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n/**\n * @typedef {object} SourceMapTask\n * @property {Source} asset\n * @property {AssetInfo} assetInfo\n * @property {(string | Module)[]} modules\n * @property {string} source\n * @property {string} file\n * @property {SourceMap} sourceMap\n * @property {ItemCacheFacade} cacheItem cache item\n */\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nconst quoteMeta = str => {\n\treturn str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\n/**\n * Creating {@link SourceMapTask} for given file\n * @param {string} file current compiled file\n * @param {Source} asset the asset\n * @param {AssetInfo} assetInfo the asset info\n * @param {MapOptions} options source map options\n * @param {Compilation} compilation compilation instance\n * @param {ItemCacheFacade} cacheItem cache item\n * @returns {SourceMapTask | undefined} created task instance or `undefined`\n */\nconst getTaskForFile = (\n\tfile,\n\tasset,\n\tassetInfo,\n\toptions,\n\tcompilation,\n\tcacheItem\n) => {\n\tlet source;\n\t/** @type {SourceMap} */\n\tlet sourceMap;\n\t/**\n\t * Check if asset can build source map\n\t */\n\tif (asset.sourceAndMap) {\n\t\tconst sourceAndMap = asset.sourceAndMap(options);\n\t\tsourceMap = /** @type {SourceMap} */ (sourceAndMap.map);\n\t\tsource = sourceAndMap.source;\n\t} else {\n\t\tsourceMap = /** @type {SourceMap} */ (asset.map(options));\n\t\tsource = asset.source();\n\t}\n\tif (!sourceMap || typeof source !== \"string\") return;\n\tconst context = compilation.options.context;\n\tconst root = compilation.compiler.root;\n\tconst cachedAbsolutify = makePathsAbsolute.bindContextCache(context, root);\n\tconst modules = sourceMap.sources.map(source => {\n\t\tif (!source.startsWith(\"webpack://\")) return source;\n\t\tsource = cachedAbsolutify(source.slice(10));\n\t\tconst module = compilation.findModule(source);\n\t\treturn module || source;\n\t});\n\n\treturn {\n\t\tfile,\n\t\tasset,\n\t\tsource,\n\t\tassetInfo,\n\t\tsourceMap,\n\t\tmodules,\n\t\tcacheItem\n\t};\n};\n\nclass SourceMapDevToolPlugin {\n\t/**\n\t * @param {SourceMapDevToolPluginOptions} [options] options object\n\t * @throws {Error} throws error, if got more than 1 arguments\n\t */\n\tconstructor(options = {}) {\n\t\tvalidate(options);\n\n\t\t/** @type {string | false} */\n\t\tthis.sourceMapFilename = options.filename;\n\t\t/** @type {string | false} */\n\t\tthis.sourceMappingURLComment =\n\t\t\toptions.append === false\n\t\t\t\t? false\n\t\t\t\t: options.append || \"\\n//# source\" + \"MappingURL=[url]\";\n\t\t/** @type {string | Function} */\n\t\tthis.moduleFilenameTemplate =\n\t\t\toptions.moduleFilenameTemplate || \"webpack://[namespace]/[resourcePath]\";\n\t\t/** @type {string | Function} */\n\t\tthis.fallbackModuleFilenameTemplate =\n\t\t\toptions.fallbackModuleFilenameTemplate ||\n\t\t\t\"webpack://[namespace]/[resourcePath]?[hash]\";\n\t\t/** @type {string} */\n\t\tthis.namespace = options.namespace || \"\";\n\t\t/** @type {SourceMapDevToolPluginOptions} */\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst outputFs = compiler.outputFileSystem;\n\t\tconst sourceMapFilename = this.sourceMapFilename;\n\t\tconst sourceMappingURLComment = this.sourceMappingURLComment;\n\t\tconst moduleFilenameTemplate = this.moduleFilenameTemplate;\n\t\tconst namespace = this.namespace;\n\t\tconst fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;\n\t\tconst requestShortener = compiler.requestShortener;\n\t\tconst options = this.options;\n\t\toptions.test = options.test || /\\.((c|m)?js|css)($|\\?)/i;\n\n\t\tconst matchObject = ModuleFilenameHelpers.matchObject.bind(\n\t\t\tundefined,\n\t\t\toptions\n\t\t);\n\n\t\tcompiler.hooks.compilation.tap(\"SourceMapDevToolPlugin\", compilation => {\n\t\t\tnew SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);\n\n\t\t\tcompilation.hooks.processAssets.tapAsync(\n\t\t\t\t{\n\t\t\t\t\tname: \"SourceMapDevToolPlugin\",\n\t\t\t\t\tstage: Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING,\n\t\t\t\t\tadditionalAssets: true\n\t\t\t\t},\n\t\t\t\t(assets, callback) => {\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\tconst cache = compilation.getCache(\"SourceMapDevToolPlugin\");\n\t\t\t\t\t/** @type {Map<string | Module, string>} */\n\t\t\t\t\tconst moduleToSourceNameMapping = new Map();\n\t\t\t\t\t/**\n\t\t\t\t\t * @type {Function}\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst reportProgress =\n\t\t\t\t\t\tProgressPlugin.getReporter(compilation.compiler) || (() => {});\n\n\t\t\t\t\t/** @type {Map<string, Chunk>} */\n\t\t\t\t\tconst fileToChunk = new Map();\n\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\tfor (const file of chunk.files) {\n\t\t\t\t\t\t\tfileToChunk.set(file, chunk);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const file of chunk.auxiliaryFiles) {\n\t\t\t\t\t\t\tfileToChunk.set(file, chunk);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/** @type {string[]} */\n\t\t\t\t\tconst files = [];\n\t\t\t\t\tfor (const file of Object.keys(assets)) {\n\t\t\t\t\t\tif (matchObject(file)) {\n\t\t\t\t\t\t\tfiles.push(file);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treportProgress(0.0);\n\t\t\t\t\t/** @type {SourceMapTask[]} */\n\t\t\t\t\tconst tasks = [];\n\t\t\t\t\tlet fileIndex = 0;\n\n\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\tfiles,\n\t\t\t\t\t\t(file, callback) => {\n\t\t\t\t\t\t\tconst asset = compilation.getAsset(file);\n\t\t\t\t\t\t\tif (asset.info.related && asset.info.related.sourceMap) {\n\t\t\t\t\t\t\t\tfileIndex++;\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst cacheItem = cache.getItemCache(\n\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\tcache.mergeEtags(\n\t\t\t\t\t\t\t\t\tcache.getLazyHashedEtag(asset.source),\n\t\t\t\t\t\t\t\t\tnamespace\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tcacheItem.get((err, cacheEntry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * If presented in cache, reassigns assets. Cache assets already have source maps.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tif (cacheEntry) {\n\t\t\t\t\t\t\t\t\tconst { assets, assetsInfo } = cacheEntry;\n\t\t\t\t\t\t\t\t\tfor (const cachedFile of Object.keys(assets)) {\n\t\t\t\t\t\t\t\t\t\tif (cachedFile === file) {\n\t\t\t\t\t\t\t\t\t\t\tcompilation.updateAsset(\n\t\t\t\t\t\t\t\t\t\t\t\tcachedFile,\n\t\t\t\t\t\t\t\t\t\t\t\tassets[cachedFile],\n\t\t\t\t\t\t\t\t\t\t\t\tassetsInfo[cachedFile]\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tcompilation.emitAsset(\n\t\t\t\t\t\t\t\t\t\t\t\tcachedFile,\n\t\t\t\t\t\t\t\t\t\t\t\tassets[cachedFile],\n\t\t\t\t\t\t\t\t\t\t\t\tassetsInfo[cachedFile]\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t\t * Add file to chunk, if not presented there\n\t\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\t\tif (cachedFile !== file) {\n\t\t\t\t\t\t\t\t\t\t\tconst chunk = fileToChunk.get(file);\n\t\t\t\t\t\t\t\t\t\t\tif (chunk !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\tchunk.auxiliaryFiles.add(cachedFile);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t(0.5 * ++fileIndex) / files.length,\n\t\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t\t\"restored cached SourceMap\"\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t(0.5 * fileIndex) / files.length,\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t\"generate SourceMap\"\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t/** @type {SourceMapTask | undefined} */\n\t\t\t\t\t\t\t\tconst task = getTaskForFile(\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\tasset.source,\n\t\t\t\t\t\t\t\t\tasset.info,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmodule: options.module,\n\t\t\t\t\t\t\t\t\t\tcolumns: options.columns\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\t\t\tcacheItem\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif (task) {\n\t\t\t\t\t\t\t\t\tconst modules = task.modules;\n\n\t\t\t\t\t\t\t\t\tfor (let idx = 0; idx < modules.length; idx++) {\n\t\t\t\t\t\t\t\t\t\tconst module = modules[idx];\n\t\t\t\t\t\t\t\t\t\tif (!moduleToSourceNameMapping.get(module)) {\n\t\t\t\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.set(\n\t\t\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\t\t\tModuleFilenameHelpers.createFilename(\n\t\t\t\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleFilenameTemplate: moduleFilenameTemplate,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnamespace: namespace\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trequestShortener,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thashFunction: compilation.outputOptions.hashFunction\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttasks.push(task);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t(0.5 * ++fileIndex) / files.length,\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t\"generated SourceMap\"\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treportProgress(0.5, \"resolve sources\");\n\t\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\t\tconst usedNamesSet = new Set(moduleToSourceNameMapping.values());\n\t\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\t\tconst conflictDetectionSet = new Set();\n\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * all modules in defined order (longest identifier first)\n\t\t\t\t\t\t\t * @type {Array<string | Module>}\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst allModules = Array.from(\n\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.keys()\n\t\t\t\t\t\t\t).sort((a, b) => {\n\t\t\t\t\t\t\t\tconst ai = typeof a === \"string\" ? a : a.identifier();\n\t\t\t\t\t\t\t\tconst bi = typeof b === \"string\" ? b : b.identifier();\n\t\t\t\t\t\t\t\treturn ai.length - bi.length;\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// find modules with conflicting source names\n\t\t\t\t\t\t\tfor (let idx = 0; idx < allModules.length; idx++) {\n\t\t\t\t\t\t\t\tconst module = allModules[idx];\n\t\t\t\t\t\t\t\tlet sourceName = moduleToSourceNameMapping.get(module);\n\t\t\t\t\t\t\t\tlet hasName = conflictDetectionSet.has(sourceName);\n\t\t\t\t\t\t\t\tif (!hasName) {\n\t\t\t\t\t\t\t\t\tconflictDetectionSet.add(sourceName);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// try the fallback name first\n\t\t\t\t\t\t\t\tsourceName = ModuleFilenameHelpers.createFilename(\n\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmoduleFilenameTemplate: fallbackModuleFilenameTemplate,\n\t\t\t\t\t\t\t\t\t\tnamespace: namespace\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\trequestShortener,\n\t\t\t\t\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\t\t\t\t\thashFunction: compilation.outputOptions.hashFunction\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\thasName = usedNamesSet.has(sourceName);\n\t\t\t\t\t\t\t\tif (!hasName) {\n\t\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.set(module, sourceName);\n\t\t\t\t\t\t\t\t\tusedNamesSet.add(sourceName);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// otherwise just append stars until we have a valid name\n\t\t\t\t\t\t\t\twhile (hasName) {\n\t\t\t\t\t\t\t\t\tsourceName += \"*\";\n\t\t\t\t\t\t\t\t\thasName = usedNamesSet.has(sourceName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.set(module, sourceName);\n\t\t\t\t\t\t\t\tusedNamesSet.add(sourceName);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlet taskIndex = 0;\n\n\t\t\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\t\t\ttasks,\n\t\t\t\t\t\t\t\t(task, callback) => {\n\t\t\t\t\t\t\t\t\tconst assets = Object.create(null);\n\t\t\t\t\t\t\t\t\tconst assetsInfo = Object.create(null);\n\t\t\t\t\t\t\t\t\tconst file = task.file;\n\t\t\t\t\t\t\t\t\tconst chunk = fileToChunk.get(file);\n\t\t\t\t\t\t\t\t\tconst sourceMap = task.sourceMap;\n\t\t\t\t\t\t\t\t\tconst source = task.source;\n\t\t\t\t\t\t\t\t\tconst modules = task.modules;\n\n\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t0.5 + (0.5 * taskIndex) / tasks.length,\n\t\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t\t\"attach SourceMap\"\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tconst moduleFilenames = modules.map(m =>\n\t\t\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.get(m)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tsourceMap.sources = moduleFilenames;\n\t\t\t\t\t\t\t\t\tif (options.noSources) {\n\t\t\t\t\t\t\t\t\t\tsourceMap.sourcesContent = undefined;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tsourceMap.sourceRoot = options.sourceRoot || \"\";\n\t\t\t\t\t\t\t\t\tsourceMap.file = file;\n\t\t\t\t\t\t\t\t\tconst usesContentHash =\n\t\t\t\t\t\t\t\t\t\tsourceMapFilename &&\n\t\t\t\t\t\t\t\t\t\t/\\[contenthash(:\\w+)?\\]/.test(sourceMapFilename);\n\n\t\t\t\t\t\t\t\t\t// If SourceMap and asset uses contenthash, avoid a circular dependency by hiding hash in `file`\n\t\t\t\t\t\t\t\t\tif (usesContentHash && task.assetInfo.contenthash) {\n\t\t\t\t\t\t\t\t\t\tconst contenthash = task.assetInfo.contenthash;\n\t\t\t\t\t\t\t\t\t\tlet pattern;\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(contenthash)) {\n\t\t\t\t\t\t\t\t\t\t\tpattern = contenthash.map(quoteMeta).join(\"|\");\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tpattern = quoteMeta(contenthash);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tsourceMap.file = sourceMap.file.replace(\n\t\t\t\t\t\t\t\t\t\t\tnew RegExp(pattern, \"g\"),\n\t\t\t\t\t\t\t\t\t\t\tm => \"x\".repeat(m.length)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t/** @type {string | false} */\n\t\t\t\t\t\t\t\t\tlet currentSourceMappingURLComment = sourceMappingURLComment;\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment !== false &&\n\t\t\t\t\t\t\t\t\t\t/\\.css($|\\?)/i.test(file)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment =\n\t\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment.replace(\n\t\t\t\t\t\t\t\t\t\t\t\t/^\\n\\/\\/(.*)$/,\n\t\t\t\t\t\t\t\t\t\t\t\t\"\\n/*$1*/\"\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst sourceMapString = JSON.stringify(sourceMap);\n\t\t\t\t\t\t\t\t\tif (sourceMapFilename) {\n\t\t\t\t\t\t\t\t\t\tlet filename = file;\n\t\t\t\t\t\t\t\t\t\tconst sourceMapContentHash =\n\t\t\t\t\t\t\t\t\t\t\tusesContentHash &&\n\t\t\t\t\t\t\t\t\t\t\t/** @type {string} */ (\n\t\t\t\t\t\t\t\t\t\t\t\tcreateHash(compilation.outputOptions.hashFunction)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.update(sourceMapString)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.digest(\"hex\")\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tconst pathParams = {\n\t\t\t\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\t\t\t\tfilename: options.fileContext\n\t\t\t\t\t\t\t\t\t\t\t\t? relative(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\toutputFs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`/${options.fileContext}`,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`/${filename}`\n\t\t\t\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t\t\t\t: filename,\n\t\t\t\t\t\t\t\t\t\t\tcontentHash: sourceMapContentHash\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tconst { path: sourceMapFile, info: sourceMapInfo } =\n\t\t\t\t\t\t\t\t\t\t\tcompilation.getPathWithInfo(\n\t\t\t\t\t\t\t\t\t\t\t\tsourceMapFilename,\n\t\t\t\t\t\t\t\t\t\t\t\tpathParams\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tconst sourceMapUrl = options.publicPath\n\t\t\t\t\t\t\t\t\t\t\t? options.publicPath + sourceMapFile\n\t\t\t\t\t\t\t\t\t\t\t: relative(\n\t\t\t\t\t\t\t\t\t\t\t\t\toutputFs,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdirname(outputFs, `/${file}`),\n\t\t\t\t\t\t\t\t\t\t\t\t\t`/${sourceMapFile}`\n\t\t\t\t\t\t\t\t\t\t\t  );\n\t\t\t\t\t\t\t\t\t\t/** @type {Source} */\n\t\t\t\t\t\t\t\t\t\tlet asset = new RawSource(source);\n\t\t\t\t\t\t\t\t\t\tif (currentSourceMappingURLComment !== false) {\n\t\t\t\t\t\t\t\t\t\t\t// Add source map url to compilation asset, if currentSourceMappingURLComment is set\n\t\t\t\t\t\t\t\t\t\t\tasset = new ConcatSource(\n\t\t\t\t\t\t\t\t\t\t\t\tasset,\n\t\t\t\t\t\t\t\t\t\t\t\tcompilation.getPath(\n\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment,\n\t\t\t\t\t\t\t\t\t\t\t\t\tObject.assign({ url: sourceMapUrl }, pathParams)\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst assetInfo = {\n\t\t\t\t\t\t\t\t\t\t\trelated: { sourceMap: sourceMapFile }\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tassets[file] = asset;\n\t\t\t\t\t\t\t\t\t\tassetsInfo[file] = assetInfo;\n\t\t\t\t\t\t\t\t\t\tcompilation.updateAsset(file, asset, assetInfo);\n\t\t\t\t\t\t\t\t\t\t// Add source map file to compilation assets and chunk files\n\t\t\t\t\t\t\t\t\t\tconst sourceMapAsset = new RawSource(sourceMapString);\n\t\t\t\t\t\t\t\t\t\tconst sourceMapAssetInfo = {\n\t\t\t\t\t\t\t\t\t\t\t...sourceMapInfo,\n\t\t\t\t\t\t\t\t\t\t\tdevelopment: true\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tassets[sourceMapFile] = sourceMapAsset;\n\t\t\t\t\t\t\t\t\t\tassetsInfo[sourceMapFile] = sourceMapAssetInfo;\n\t\t\t\t\t\t\t\t\t\tcompilation.emitAsset(\n\t\t\t\t\t\t\t\t\t\t\tsourceMapFile,\n\t\t\t\t\t\t\t\t\t\t\tsourceMapAsset,\n\t\t\t\t\t\t\t\t\t\t\tsourceMapAssetInfo\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tif (chunk !== undefined)\n\t\t\t\t\t\t\t\t\t\t\tchunk.auxiliaryFiles.add(sourceMapFile);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif (currentSourceMappingURLComment === false) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\"SourceMapDevToolPlugin: append can't be false when no filename is provided\"\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t\t * Add source map as data url to asset\n\t\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\t\tconst asset = new ConcatSource(\n\t\t\t\t\t\t\t\t\t\t\tnew RawSource(source),\n\t\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment\n\t\t\t\t\t\t\t\t\t\t\t\t.replace(/\\[map\\]/g, () => sourceMapString)\n\t\t\t\t\t\t\t\t\t\t\t\t.replace(\n\t\t\t\t\t\t\t\t\t\t\t\t\t/\\[url\\]/g,\n\t\t\t\t\t\t\t\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`data:application/json;charset=utf-8;base64,${Buffer.from(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsourceMapString,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"utf-8\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t).toString(\"base64\")}`\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tassets[file] = asset;\n\t\t\t\t\t\t\t\t\t\tassetsInfo[file] = undefined;\n\t\t\t\t\t\t\t\t\t\tcompilation.updateAsset(file, asset);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttask.cacheItem.store({ assets, assetsInfo }, err => {\n\t\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t\t0.5 + (0.5 * ++taskIndex) / tasks.length,\n\t\t\t\t\t\t\t\t\t\t\ttask.file,\n\t\t\t\t\t\t\t\t\t\t\t\"attached SourceMap\"\n\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\treportProgress(1.0);\n\t\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = SourceMapDevToolPlugin;\n"]},"metadata":{},"sourceType":"script"}