{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst ChunkGraph = require(\"./ChunkGraph\");\n\nconst Entrypoint = require(\"./Entrypoint\");\n\nconst {\n  intersect\n} = require(\"./util/SetHelpers\");\n\nconst SortableSet = require(\"./util/SortableSet\");\n\nconst StringXor = require(\"./util/StringXor\");\n\nconst {\n  compareModulesByIdentifier,\n  compareChunkGroupsByIndex,\n  compareModulesById\n} = require(\"./util/comparators\");\n\nconst {\n  createArrayToSetDeprecationSet\n} = require(\"./util/deprecation\");\n\nconst {\n  mergeRuntime\n} = require(\"./util/runtime\");\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"./ChunkGraph\").ChunkFilterPredicate} ChunkFilterPredicate */\n\n/** @typedef {import(\"./ChunkGraph\").ChunkSizeOptions} ChunkSizeOptions */\n\n/** @typedef {import(\"./ChunkGraph\").ModuleFilterPredicate} ModuleFilterPredicate */\n\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"./Compilation\")} Compilation */\n\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n\n/** @typedef {import(\"./Compilation\").PathData} PathData */\n\n/** @typedef {import(\"./Entrypoint\").EntryOptions} EntryOptions */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n\n/** @typedef {import(\"./util/Hash\")} Hash */\n\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n\nconst ChunkFilesSet = createArrayToSetDeprecationSet(\"chunk.files\");\n/**\n * @typedef {Object} WithId an object who has an id property *\n * @property {string | number} id the id of the object\n */\n\n/**\n * @deprecated\n * @typedef {Object} ChunkMaps\n * @property {Record<string|number, string>} hash\n * @property {Record<string|number, Record<string, string>>} contentHash\n * @property {Record<string|number, string>} name\n */\n\n/**\n * @deprecated\n * @typedef {Object} ChunkModuleMaps\n * @property {Record<string|number, (string|number)[]>} id\n * @property {Record<string|number, string>} hash\n */\n\nlet debugId = 1000;\n/**\n * A Chunk is a unit of encapsulation for Modules.\n * Chunks are \"rendered\" into bundles that get emitted when the build completes.\n */\n\nclass Chunk {\n  /**\n   * @param {string=} name of chunk being created, is optional (for subclasses)\n   * @param {boolean} backCompat enable backward-compatibility\n   */\n  constructor(name) {\n    let backCompat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    /** @type {number | string | null} */\n    this.id = null;\n    /** @type {(number|string)[] | null} */\n\n    this.ids = null;\n    /** @type {number} */\n\n    this.debugId = debugId++;\n    /** @type {string} */\n\n    this.name = name;\n    /** @type {SortableSet<string>} */\n\n    this.idNameHints = new SortableSet();\n    /** @type {boolean} */\n\n    this.preventIntegration = false;\n    /** @type {(string | function(PathData, AssetInfo=): string)?} */\n\n    this.filenameTemplate = undefined;\n    /** @type {(string | function(PathData, AssetInfo=): string)?} */\n\n    this.cssFilenameTemplate = undefined;\n    /** @private @type {SortableSet<ChunkGroup>} */\n\n    this._groups = new SortableSet(undefined, compareChunkGroupsByIndex);\n    /** @type {RuntimeSpec} */\n\n    this.runtime = undefined;\n    /** @type {Set<string>} */\n\n    this.files = backCompat ? new ChunkFilesSet() : new Set();\n    /** @type {Set<string>} */\n\n    this.auxiliaryFiles = new Set();\n    /** @type {boolean} */\n\n    this.rendered = false;\n    /** @type {string=} */\n\n    this.hash = undefined;\n    /** @type {Record<string, string>} */\n\n    this.contentHash = Object.create(null);\n    /** @type {string=} */\n\n    this.renderedHash = undefined;\n    /** @type {string=} */\n\n    this.chunkReason = undefined;\n    /** @type {boolean} */\n\n    this.extraAsync = false;\n  } // TODO remove in webpack 6\n  // BACKWARD-COMPAT START\n\n\n  get entryModule() {\n    const entryModules = Array.from(ChunkGraph.getChunkGraphForChunk(this, \"Chunk.entryModule\", \"DEP_WEBPACK_CHUNK_ENTRY_MODULE\").getChunkEntryModulesIterable(this));\n\n    if (entryModules.length === 0) {\n      return undefined;\n    } else if (entryModules.length === 1) {\n      return entryModules[0];\n    } else {\n      throw new Error(\"Module.entryModule: Multiple entry modules are not supported by the deprecated API (Use the new ChunkGroup API)\");\n    }\n  }\n  /**\n   * @returns {boolean} true, if the chunk contains an entry module\n   */\n\n\n  hasEntryModule() {\n    return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.hasEntryModule\", \"DEP_WEBPACK_CHUNK_HAS_ENTRY_MODULE\").getNumberOfEntryModules(this) > 0;\n  }\n  /**\n   * @param {Module} module the module\n   * @returns {boolean} true, if the chunk could be added\n   */\n\n\n  addModule(module) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.addModule\", \"DEP_WEBPACK_CHUNK_ADD_MODULE\");\n    if (chunkGraph.isModuleInChunk(module, this)) return false;\n    chunkGraph.connectChunkAndModule(this, module);\n    return true;\n  }\n  /**\n   * @param {Module} module the module\n   * @returns {void}\n   */\n\n\n  removeModule(module) {\n    ChunkGraph.getChunkGraphForChunk(this, \"Chunk.removeModule\", \"DEP_WEBPACK_CHUNK_REMOVE_MODULE\").disconnectChunkAndModule(this, module);\n  }\n  /**\n   * @returns {number} the number of module which are contained in this chunk\n   */\n\n\n  getNumberOfModules() {\n    return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.getNumberOfModules\", \"DEP_WEBPACK_CHUNK_GET_NUMBER_OF_MODULES\").getNumberOfChunkModules(this);\n  }\n\n  get modulesIterable() {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.modulesIterable\", \"DEP_WEBPACK_CHUNK_MODULES_ITERABLE\");\n    return chunkGraph.getOrderedChunkModulesIterable(this, compareModulesByIdentifier);\n  }\n  /**\n   * @param {Chunk} otherChunk the chunk to compare with\n   * @returns {-1|0|1} the comparison result\n   */\n\n\n  compareTo(otherChunk) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.compareTo\", \"DEP_WEBPACK_CHUNK_COMPARE_TO\");\n    return chunkGraph.compareChunks(this, otherChunk);\n  }\n  /**\n   * @param {Module} module the module\n   * @returns {boolean} true, if the chunk contains the module\n   */\n\n\n  containsModule(module) {\n    return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.containsModule\", \"DEP_WEBPACK_CHUNK_CONTAINS_MODULE\").isModuleInChunk(module, this);\n  }\n  /**\n   * @returns {Module[]} the modules for this chunk\n   */\n\n\n  getModules() {\n    return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.getModules\", \"DEP_WEBPACK_CHUNK_GET_MODULES\").getChunkModules(this);\n  }\n  /**\n   * @returns {void}\n   */\n\n\n  remove() {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.remove\", \"DEP_WEBPACK_CHUNK_REMOVE\");\n    chunkGraph.disconnectChunk(this);\n    this.disconnectFromGroups();\n  }\n  /**\n   * @param {Module} module the module\n   * @param {Chunk} otherChunk the target chunk\n   * @returns {void}\n   */\n\n\n  moveModule(module, otherChunk) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.moveModule\", \"DEP_WEBPACK_CHUNK_MOVE_MODULE\");\n    chunkGraph.disconnectChunkAndModule(this, module);\n    chunkGraph.connectChunkAndModule(otherChunk, module);\n  }\n  /**\n   * @param {Chunk} otherChunk the other chunk\n   * @returns {boolean} true, if the specified chunk has been integrated\n   */\n\n\n  integrate(otherChunk) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.integrate\", \"DEP_WEBPACK_CHUNK_INTEGRATE\");\n\n    if (chunkGraph.canChunksBeIntegrated(this, otherChunk)) {\n      chunkGraph.integrateChunks(this, otherChunk);\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /**\n   * @param {Chunk} otherChunk the other chunk\n   * @returns {boolean} true, if chunks could be integrated\n   */\n\n\n  canBeIntegrated(otherChunk) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.canBeIntegrated\", \"DEP_WEBPACK_CHUNK_CAN_BE_INTEGRATED\");\n    return chunkGraph.canChunksBeIntegrated(this, otherChunk);\n  }\n  /**\n   * @returns {boolean} true, if this chunk contains no module\n   */\n\n\n  isEmpty() {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.isEmpty\", \"DEP_WEBPACK_CHUNK_IS_EMPTY\");\n    return chunkGraph.getNumberOfChunkModules(this) === 0;\n  }\n  /**\n   * @returns {number} total size of all modules in this chunk\n   */\n\n\n  modulesSize() {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.modulesSize\", \"DEP_WEBPACK_CHUNK_MODULES_SIZE\");\n    return chunkGraph.getChunkModulesSize(this);\n  }\n  /**\n   * @param {ChunkSizeOptions} options options object\n   * @returns {number} total size of this chunk\n   */\n\n\n  size() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.size\", \"DEP_WEBPACK_CHUNK_SIZE\");\n    return chunkGraph.getChunkSize(this, options);\n  }\n  /**\n   * @param {Chunk} otherChunk the other chunk\n   * @param {ChunkSizeOptions} options options object\n   * @returns {number} total size of the chunk or false if the chunk can't be integrated\n   */\n\n\n  integratedSize(otherChunk, options) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.integratedSize\", \"DEP_WEBPACK_CHUNK_INTEGRATED_SIZE\");\n    return chunkGraph.getIntegratedChunksSize(this, otherChunk, options);\n  }\n  /**\n   * @param {ModuleFilterPredicate} filterFn function used to filter modules\n   * @returns {ChunkModuleMaps} module map information\n   */\n\n\n  getChunkModuleMaps(filterFn) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.getChunkModuleMaps\", \"DEP_WEBPACK_CHUNK_GET_CHUNK_MODULE_MAPS\");\n    /** @type {Record<string|number, (string|number)[]>} */\n\n    const chunkModuleIdMap = Object.create(null);\n    /** @type {Record<string|number, string>} */\n\n    const chunkModuleHashMap = Object.create(null);\n\n    for (const asyncChunk of this.getAllAsyncChunks()) {\n      /** @type {(string|number)[]} */\n      let array;\n\n      for (const module of chunkGraph.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(chunkGraph))) {\n        if (filterFn(module)) {\n          if (array === undefined) {\n            array = [];\n            chunkModuleIdMap[asyncChunk.id] = array;\n          }\n\n          const moduleId = chunkGraph.getModuleId(module);\n          array.push(moduleId);\n          chunkModuleHashMap[moduleId] = chunkGraph.getRenderedModuleHash(module, undefined);\n        }\n      }\n    }\n\n    return {\n      id: chunkModuleIdMap,\n      hash: chunkModuleHashMap\n    };\n  }\n  /**\n   * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\n   * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\n   * @returns {boolean} return true if module exists in graph\n   */\n\n\n  hasModuleInGraph(filterFn, filterChunkFn) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.hasModuleInGraph\", \"DEP_WEBPACK_CHUNK_HAS_MODULE_IN_GRAPH\");\n    return chunkGraph.hasModuleInGraph(this, filterFn, filterChunkFn);\n  }\n  /**\n   * @deprecated\n   * @param {boolean} realHash whether the full hash or the rendered hash is to be used\n   * @returns {ChunkMaps} the chunk map information\n   */\n\n\n  getChunkMaps(realHash) {\n    /** @type {Record<string|number, string>} */\n    const chunkHashMap = Object.create(null);\n    /** @type {Record<string|number, Record<string, string>>} */\n\n    const chunkContentHashMap = Object.create(null);\n    /** @type {Record<string|number, string>} */\n\n    const chunkNameMap = Object.create(null);\n\n    for (const chunk of this.getAllAsyncChunks()) {\n      chunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;\n\n      for (const key of Object.keys(chunk.contentHash)) {\n        if (!chunkContentHashMap[key]) {\n          chunkContentHashMap[key] = Object.create(null);\n        }\n\n        chunkContentHashMap[key][chunk.id] = chunk.contentHash[key];\n      }\n\n      if (chunk.name) {\n        chunkNameMap[chunk.id] = chunk.name;\n      }\n    }\n\n    return {\n      hash: chunkHashMap,\n      contentHash: chunkContentHashMap,\n      name: chunkNameMap\n    };\n  } // BACKWARD-COMPAT END\n\n  /**\n   * @returns {boolean} whether or not the Chunk will have a runtime\n   */\n\n\n  hasRuntime() {\n    for (const chunkGroup of this._groups) {\n      if (chunkGroup instanceof Entrypoint && chunkGroup.getRuntimeChunk() === this) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * @returns {boolean} whether or not this chunk can be an initial chunk\n   */\n\n\n  canBeInitial() {\n    for (const chunkGroup of this._groups) {\n      if (chunkGroup.isInitial()) return true;\n    }\n\n    return false;\n  }\n  /**\n   * @returns {boolean} whether this chunk can only be an initial chunk\n   */\n\n\n  isOnlyInitial() {\n    if (this._groups.size <= 0) return false;\n\n    for (const chunkGroup of this._groups) {\n      if (!chunkGroup.isInitial()) return false;\n    }\n\n    return true;\n  }\n  /**\n   * @returns {EntryOptions | undefined} the entry options for this chunk\n   */\n\n\n  getEntryOptions() {\n    for (const chunkGroup of this._groups) {\n      if (chunkGroup instanceof Entrypoint) {\n        return chunkGroup.options;\n      }\n    }\n\n    return undefined;\n  }\n  /**\n   * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added\n   * @returns {void}\n   */\n\n\n  addGroup(chunkGroup) {\n    this._groups.add(chunkGroup);\n  }\n  /**\n   * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from\n   * @returns {void}\n   */\n\n\n  removeGroup(chunkGroup) {\n    this._groups.delete(chunkGroup);\n  }\n  /**\n   * @param {ChunkGroup} chunkGroup the chunkGroup to check\n   * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup\n   */\n\n\n  isInGroup(chunkGroup) {\n    return this._groups.has(chunkGroup);\n  }\n  /**\n   * @returns {number} the amount of groups that the said chunk is in\n   */\n\n\n  getNumberOfGroups() {\n    return this._groups.size;\n  }\n  /**\n   * @returns {Iterable<ChunkGroup>} the chunkGroups that the said chunk is referenced in\n   */\n\n\n  get groupsIterable() {\n    this._groups.sort();\n\n    return this._groups;\n  }\n  /**\n   * @returns {void}\n   */\n\n\n  disconnectFromGroups() {\n    for (const chunkGroup of this._groups) {\n      chunkGroup.removeChunk(this);\n    }\n  }\n  /**\n   * @param {Chunk} newChunk the new chunk that will be split out of\n   * @returns {void}\n   */\n\n\n  split(newChunk) {\n    for (const chunkGroup of this._groups) {\n      chunkGroup.insertChunk(newChunk, this);\n      newChunk.addGroup(chunkGroup);\n    }\n\n    for (const idHint of this.idNameHints) {\n      newChunk.idNameHints.add(idHint);\n    }\n\n    newChunk.runtime = mergeRuntime(newChunk.runtime, this.runtime);\n  }\n  /**\n   * @param {Hash} hash hash (will be modified)\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @returns {void}\n   */\n\n\n  updateHash(hash, chunkGraph) {\n    hash.update(`${this.id} ${this.ids ? this.ids.join() : \"\"} ${this.name || \"\"} `);\n    const xor = new StringXor();\n\n    for (const m of chunkGraph.getChunkModulesIterable(this)) {\n      xor.add(chunkGraph.getModuleHash(m, this.runtime));\n    }\n\n    xor.updateHash(hash);\n    const entryModules = chunkGraph.getChunkEntryModulesWithChunkGroupIterable(this);\n\n    for (const [m, chunkGroup] of entryModules) {\n      hash.update(`entry${chunkGraph.getModuleId(m)}${chunkGroup.id}`);\n    }\n  }\n  /**\n   * @returns {Set<Chunk>} a set of all the async chunks\n   */\n\n\n  getAllAsyncChunks() {\n    const queue = new Set();\n    const chunks = new Set();\n    const initialChunks = intersect(Array.from(this.groupsIterable, g => new Set(g.chunks)));\n    const initialQueue = new Set(this.groupsIterable);\n\n    for (const chunkGroup of initialQueue) {\n      for (const child of chunkGroup.childrenIterable) {\n        if (child instanceof Entrypoint) {\n          initialQueue.add(child);\n        } else {\n          queue.add(child);\n        }\n      }\n    }\n\n    for (const chunkGroup of queue) {\n      for (const chunk of chunkGroup.chunks) {\n        if (!initialChunks.has(chunk)) {\n          chunks.add(chunk);\n        }\n      }\n\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n\n    return chunks;\n  }\n  /**\n   * @returns {Set<Chunk>} a set of all the initial chunks (including itself)\n   */\n\n\n  getAllInitialChunks() {\n    const chunks = new Set();\n    const queue = new Set(this.groupsIterable);\n\n    for (const group of queue) {\n      if (group.isInitial()) {\n        for (const c of group.chunks) chunks.add(c);\n\n        for (const g of group.childrenIterable) queue.add(g);\n      }\n    }\n\n    return chunks;\n  }\n  /**\n   * @returns {Set<Chunk>} a set of all the referenced chunks (including itself)\n   */\n\n\n  getAllReferencedChunks() {\n    const queue = new Set(this.groupsIterable);\n    const chunks = new Set();\n\n    for (const chunkGroup of queue) {\n      for (const chunk of chunkGroup.chunks) {\n        chunks.add(chunk);\n      }\n\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n\n    return chunks;\n  }\n  /**\n   * @returns {Set<Entrypoint>} a set of all the referenced entrypoints\n   */\n\n\n  getAllReferencedAsyncEntrypoints() {\n    const queue = new Set(this.groupsIterable);\n    const entrypoints = new Set();\n\n    for (const chunkGroup of queue) {\n      for (const entrypoint of chunkGroup.asyncEntrypointsIterable) {\n        entrypoints.add(entrypoint);\n      }\n\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n\n    return entrypoints;\n  }\n  /**\n   * @returns {boolean} true, if the chunk references async chunks\n   */\n\n\n  hasAsyncChunks() {\n    const queue = new Set();\n    const initialChunks = intersect(Array.from(this.groupsIterable, g => new Set(g.chunks)));\n\n    for (const chunkGroup of this.groupsIterable) {\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n\n    for (const chunkGroup of queue) {\n      for (const chunk of chunkGroup.chunks) {\n        if (!initialChunks.has(chunk)) {\n          return true;\n        }\n      }\n\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n\n    return false;\n  }\n  /**\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\n   * @returns {Record<string, (string | number)[]>} a record object of names to lists of child ids(?)\n   */\n\n\n  getChildIdsByOrders(chunkGraph, filterFn) {\n    /** @type {Map<string, {order: number, group: ChunkGroup}[]>} */\n    const lists = new Map();\n\n    for (const group of this.groupsIterable) {\n      if (group.chunks[group.chunks.length - 1] === this) {\n        for (const childGroup of group.childrenIterable) {\n          for (const key of Object.keys(childGroup.options)) {\n            if (key.endsWith(\"Order\")) {\n              const name = key.substr(0, key.length - \"Order\".length);\n              let list = lists.get(name);\n\n              if (list === undefined) {\n                list = [];\n                lists.set(name, list);\n              }\n\n              list.push({\n                order: childGroup.options[key],\n                group: childGroup\n              });\n            }\n          }\n        }\n      }\n    }\n    /** @type {Record<string, (string | number)[]>} */\n\n\n    const result = Object.create(null);\n\n    for (const [name, list] of lists) {\n      list.sort((a, b) => {\n        const cmp = b.order - a.order;\n        if (cmp !== 0) return cmp;\n        return a.group.compareTo(chunkGraph, b.group);\n      });\n      /** @type {Set<string | number>} */\n\n      const chunkIdSet = new Set();\n\n      for (const item of list) {\n        for (const chunk of item.group.chunks) {\n          if (filterFn && !filterFn(chunk, chunkGraph)) continue;\n          chunkIdSet.add(chunk.id);\n        }\n      }\n\n      if (chunkIdSet.size > 0) {\n        result[name] = Array.from(chunkIdSet);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @param {string} type option name\n   * @returns {{ onChunks: Chunk[], chunks: Set<Chunk> }[]} referenced chunks for a specific type\n   */\n\n\n  getChildrenOfTypeInOrder(chunkGraph, type) {\n    const list = [];\n\n    for (const group of this.groupsIterable) {\n      for (const childGroup of group.childrenIterable) {\n        const order = childGroup.options[type];\n        if (order === undefined) continue;\n        list.push({\n          order,\n          group,\n          childGroup\n        });\n      }\n    }\n\n    if (list.length === 0) return undefined;\n    list.sort((a, b) => {\n      const cmp = b.order - a.order;\n      if (cmp !== 0) return cmp;\n      return a.group.compareTo(chunkGraph, b.group);\n    });\n    const result = [];\n    let lastEntry;\n\n    for (const {\n      group,\n      childGroup\n    } of list) {\n      if (lastEntry && lastEntry.onChunks === group.chunks) {\n        for (const chunk of childGroup.chunks) {\n          lastEntry.chunks.add(chunk);\n        }\n      } else {\n        result.push(lastEntry = {\n          onChunks: group.chunks,\n          chunks: new Set(childGroup.chunks)\n        });\n      }\n    }\n\n    return result;\n  }\n  /**\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @param {boolean=} includeDirectChildren include direct children (by default only children of async children are included)\n   * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\n   * @returns {Record<string|number, Record<string, (string | number)[]>>} a record object of names to lists of child ids(?) by chunk id\n   */\n\n\n  getChildIdsByOrdersMap(chunkGraph, includeDirectChildren, filterFn) {\n    /** @type {Record<string|number, Record<string, (string | number)[]>>} */\n    const chunkMaps = Object.create(null);\n    /**\n     * @param {Chunk} chunk a chunk\n     * @returns {void}\n     */\n\n    const addChildIdsByOrdersToMap = chunk => {\n      const data = chunk.getChildIdsByOrders(chunkGraph, filterFn);\n\n      for (const key of Object.keys(data)) {\n        let chunkMap = chunkMaps[key];\n\n        if (chunkMap === undefined) {\n          chunkMaps[key] = chunkMap = Object.create(null);\n        }\n\n        chunkMap[chunk.id] = data[key];\n      }\n    };\n\n    if (includeDirectChildren) {\n      /** @type {Set<Chunk>} */\n      const chunks = new Set();\n\n      for (const chunkGroup of this.groupsIterable) {\n        for (const chunk of chunkGroup.chunks) {\n          chunks.add(chunk);\n        }\n      }\n\n      for (const chunk of chunks) {\n        addChildIdsByOrdersToMap(chunk);\n      }\n    }\n\n    for (const chunk of this.getAllAsyncChunks()) {\n      addChildIdsByOrdersToMap(chunk);\n    }\n\n    return chunkMaps;\n  }\n\n}\n\nmodule.exports = Chunk;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/Chunk.js"],"names":["ChunkGraph","require","Entrypoint","intersect","SortableSet","StringXor","compareModulesByIdentifier","compareChunkGroupsByIndex","compareModulesById","createArrayToSetDeprecationSet","mergeRuntime","ChunkFilesSet","debugId","Chunk","constructor","name","backCompat","id","ids","idNameHints","preventIntegration","filenameTemplate","undefined","cssFilenameTemplate","_groups","runtime","files","Set","auxiliaryFiles","rendered","hash","contentHash","Object","create","renderedHash","chunkReason","extraAsync","entryModule","entryModules","Array","from","getChunkGraphForChunk","getChunkEntryModulesIterable","length","Error","hasEntryModule","getNumberOfEntryModules","addModule","module","chunkGraph","isModuleInChunk","connectChunkAndModule","removeModule","disconnectChunkAndModule","getNumberOfModules","getNumberOfChunkModules","modulesIterable","getOrderedChunkModulesIterable","compareTo","otherChunk","compareChunks","containsModule","getModules","getChunkModules","remove","disconnectChunk","disconnectFromGroups","moveModule","integrate","canChunksBeIntegrated","integrateChunks","canBeIntegrated","isEmpty","modulesSize","getChunkModulesSize","size","options","getChunkSize","integratedSize","getIntegratedChunksSize","getChunkModuleMaps","filterFn","chunkModuleIdMap","chunkModuleHashMap","asyncChunk","getAllAsyncChunks","array","moduleId","getModuleId","push","getRenderedModuleHash","hasModuleInGraph","filterChunkFn","getChunkMaps","realHash","chunkHashMap","chunkContentHashMap","chunkNameMap","chunk","key","keys","hasRuntime","chunkGroup","getRuntimeChunk","canBeInitial","isInitial","isOnlyInitial","getEntryOptions","addGroup","add","removeGroup","delete","isInGroup","has","getNumberOfGroups","groupsIterable","sort","removeChunk","split","newChunk","insertChunk","idHint","updateHash","update","join","xor","m","getChunkModulesIterable","getModuleHash","getChunkEntryModulesWithChunkGroupIterable","queue","chunks","initialChunks","g","initialQueue","child","childrenIterable","getAllInitialChunks","group","c","getAllReferencedChunks","getAllReferencedAsyncEntrypoints","entrypoints","entrypoint","asyncEntrypointsIterable","hasAsyncChunks","getChildIdsByOrders","lists","Map","childGroup","endsWith","substr","list","get","set","order","result","a","b","cmp","chunkIdSet","item","getChildrenOfTypeInOrder","type","lastEntry","onChunks","getChildIdsByOrdersMap","includeDirectChildren","chunkMaps","addChildIdsByOrdersToMap","data","chunkMap","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,UAAU,GAAGC,OAAO,CAAC,cAAD,CAA1B;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,cAAD,CAA1B;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAgBF,OAAO,CAAC,mBAAD,CAA7B;;AACA,MAAMG,WAAW,GAAGH,OAAO,CAAC,oBAAD,CAA3B;;AACA,MAAMI,SAAS,GAAGJ,OAAO,CAAC,kBAAD,CAAzB;;AACA,MAAM;AACLK,EAAAA,0BADK;AAELC,EAAAA,yBAFK;AAGLC,EAAAA;AAHK,IAIFP,OAAO,CAAC,oBAAD,CAJX;;AAKA,MAAM;AAAEQ,EAAAA;AAAF,IAAqCR,OAAO,CAAC,oBAAD,CAAlD;;AACA,MAAM;AAAES,EAAAA;AAAF,IAAmBT,OAAO,CAAC,gBAAD,CAAhC;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;AAEA,MAAMU,aAAa,GAAGF,8BAA8B,CAAC,aAAD,CAApD;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIG,OAAO,GAAG,IAAd;AAEA;AACA;AACA;AACA;;AACA,MAAMC,KAAN,CAAY;AACX;AACD;AACA;AACA;AACCC,EAAAA,WAAW,CAACC,IAAD,EAA0B;AAAA,QAAnBC,UAAmB,uEAAN,IAAM;;AACpC;AACA,SAAKC,EAAL,GAAU,IAAV;AACA;;AACA,SAAKC,GAAL,GAAW,IAAX;AACA;;AACA,SAAKN,OAAL,GAAeA,OAAO,EAAtB;AACA;;AACA,SAAKG,IAAL,GAAYA,IAAZ;AACA;;AACA,SAAKI,WAAL,GAAmB,IAAIf,WAAJ,EAAnB;AACA;;AACA,SAAKgB,kBAAL,GAA0B,KAA1B;AACA;;AACA,SAAKC,gBAAL,GAAwBC,SAAxB;AACA;;AACA,SAAKC,mBAAL,GAA2BD,SAA3B;AACA;;AACA,SAAKE,OAAL,GAAe,IAAIpB,WAAJ,CAAgBkB,SAAhB,EAA2Bf,yBAA3B,CAAf;AACA;;AACA,SAAKkB,OAAL,GAAeH,SAAf;AACA;;AACA,SAAKI,KAAL,GAAaV,UAAU,GAAG,IAAIL,aAAJ,EAAH,GAAyB,IAAIgB,GAAJ,EAAhD;AACA;;AACA,SAAKC,cAAL,GAAsB,IAAID,GAAJ,EAAtB;AACA;;AACA,SAAKE,QAAL,GAAgB,KAAhB;AACA;;AACA,SAAKC,IAAL,GAAYR,SAAZ;AACA;;AACA,SAAKS,WAAL,GAAmBC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAnB;AACA;;AACA,SAAKC,YAAL,GAAoBZ,SAApB;AACA;;AACA,SAAKa,WAAL,GAAmBb,SAAnB;AACA;;AACA,SAAKc,UAAL,GAAkB,KAAlB;AACA,GA1CU,CA4CX;AACA;;;AACe,MAAXC,WAAW,GAAG;AACjB,UAAMC,YAAY,GAAGC,KAAK,CAACC,IAAN,CACpBxC,UAAU,CAACyC,qBAAX,CACC,IADD,EAEC,mBAFD,EAGC,gCAHD,EAIEC,4BAJF,CAI+B,IAJ/B,CADoB,CAArB;;AAOA,QAAIJ,YAAY,CAACK,MAAb,KAAwB,CAA5B,EAA+B;AAC9B,aAAOrB,SAAP;AACA,KAFD,MAEO,IAAIgB,YAAY,CAACK,MAAb,KAAwB,CAA5B,EAA+B;AACrC,aAAOL,YAAY,CAAC,CAAD,CAAnB;AACA,KAFM,MAEA;AACN,YAAM,IAAIM,KAAJ,CACL,iHADK,CAAN;AAGA;AACD;AAED;AACD;AACA;;;AACCC,EAAAA,cAAc,GAAG;AAChB,WACC7C,UAAU,CAACyC,qBAAX,CACC,IADD,EAEC,sBAFD,EAGC,oCAHD,EAIEK,uBAJF,CAI0B,IAJ1B,IAIkC,CALnC;AAOA;AAED;AACD;AACA;AACA;;;AACCC,EAAAA,SAAS,CAACC,MAAD,EAAS;AACjB,UAAMC,UAAU,GAAGjD,UAAU,CAACyC,qBAAX,CAClB,IADkB,EAElB,iBAFkB,EAGlB,8BAHkB,CAAnB;AAKA,QAAIQ,UAAU,CAACC,eAAX,CAA2BF,MAA3B,EAAmC,IAAnC,CAAJ,EAA8C,OAAO,KAAP;AAC9CC,IAAAA,UAAU,CAACE,qBAAX,CAAiC,IAAjC,EAAuCH,MAAvC;AACA,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;;;AACCI,EAAAA,YAAY,CAACJ,MAAD,EAAS;AACpBhD,IAAAA,UAAU,CAACyC,qBAAX,CACC,IADD,EAEC,oBAFD,EAGC,iCAHD,EAIEY,wBAJF,CAI2B,IAJ3B,EAIiCL,MAJjC;AAKA;AAED;AACD;AACA;;;AACCM,EAAAA,kBAAkB,GAAG;AACpB,WAAOtD,UAAU,CAACyC,qBAAX,CACN,IADM,EAEN,0BAFM,EAGN,yCAHM,EAILc,uBAJK,CAImB,IAJnB,CAAP;AAKA;;AAEkB,MAAfC,eAAe,GAAG;AACrB,UAAMP,UAAU,GAAGjD,UAAU,CAACyC,qBAAX,CAClB,IADkB,EAElB,uBAFkB,EAGlB,oCAHkB,CAAnB;AAKA,WAAOQ,UAAU,CAACQ,8BAAX,CACN,IADM,EAENnD,0BAFM,CAAP;AAIA;AAED;AACD;AACA;AACA;;;AACCoD,EAAAA,SAAS,CAACC,UAAD,EAAa;AACrB,UAAMV,UAAU,GAAGjD,UAAU,CAACyC,qBAAX,CAClB,IADkB,EAElB,iBAFkB,EAGlB,8BAHkB,CAAnB;AAKA,WAAOQ,UAAU,CAACW,aAAX,CAAyB,IAAzB,EAA+BD,UAA/B,CAAP;AACA;AAED;AACD;AACA;AACA;;;AACCE,EAAAA,cAAc,CAACb,MAAD,EAAS;AACtB,WAAOhD,UAAU,CAACyC,qBAAX,CACN,IADM,EAEN,sBAFM,EAGN,mCAHM,EAILS,eAJK,CAIWF,MAJX,EAImB,IAJnB,CAAP;AAKA;AAED;AACD;AACA;;;AACCc,EAAAA,UAAU,GAAG;AACZ,WAAO9D,UAAU,CAACyC,qBAAX,CACN,IADM,EAEN,kBAFM,EAGN,+BAHM,EAILsB,eAJK,CAIW,IAJX,CAAP;AAKA;AAED;AACD;AACA;;;AACCC,EAAAA,MAAM,GAAG;AACR,UAAMf,UAAU,GAAGjD,UAAU,CAACyC,qBAAX,CAClB,IADkB,EAElB,cAFkB,EAGlB,0BAHkB,CAAnB;AAKAQ,IAAAA,UAAU,CAACgB,eAAX,CAA2B,IAA3B;AACA,SAAKC,oBAAL;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCC,EAAAA,UAAU,CAACnB,MAAD,EAASW,UAAT,EAAqB;AAC9B,UAAMV,UAAU,GAAGjD,UAAU,CAACyC,qBAAX,CAClB,IADkB,EAElB,kBAFkB,EAGlB,+BAHkB,CAAnB;AAKAQ,IAAAA,UAAU,CAACI,wBAAX,CAAoC,IAApC,EAA0CL,MAA1C;AACAC,IAAAA,UAAU,CAACE,qBAAX,CAAiCQ,UAAjC,EAA6CX,MAA7C;AACA;AAED;AACD;AACA;AACA;;;AACCoB,EAAAA,SAAS,CAACT,UAAD,EAAa;AACrB,UAAMV,UAAU,GAAGjD,UAAU,CAACyC,qBAAX,CAClB,IADkB,EAElB,iBAFkB,EAGlB,6BAHkB,CAAnB;;AAKA,QAAIQ,UAAU,CAACoB,qBAAX,CAAiC,IAAjC,EAAuCV,UAAvC,CAAJ,EAAwD;AACvDV,MAAAA,UAAU,CAACqB,eAAX,CAA2B,IAA3B,EAAiCX,UAAjC;AACA,aAAO,IAAP;AACA,KAHD,MAGO;AACN,aAAO,KAAP;AACA;AACD;AAED;AACD;AACA;AACA;;;AACCY,EAAAA,eAAe,CAACZ,UAAD,EAAa;AAC3B,UAAMV,UAAU,GAAGjD,UAAU,CAACyC,qBAAX,CAClB,IADkB,EAElB,uBAFkB,EAGlB,qCAHkB,CAAnB;AAKA,WAAOQ,UAAU,CAACoB,qBAAX,CAAiC,IAAjC,EAAuCV,UAAvC,CAAP;AACA;AAED;AACD;AACA;;;AACCa,EAAAA,OAAO,GAAG;AACT,UAAMvB,UAAU,GAAGjD,UAAU,CAACyC,qBAAX,CAClB,IADkB,EAElB,eAFkB,EAGlB,4BAHkB,CAAnB;AAKA,WAAOQ,UAAU,CAACM,uBAAX,CAAmC,IAAnC,MAA6C,CAApD;AACA;AAED;AACD;AACA;;;AACCkB,EAAAA,WAAW,GAAG;AACb,UAAMxB,UAAU,GAAGjD,UAAU,CAACyC,qBAAX,CAClB,IADkB,EAElB,mBAFkB,EAGlB,gCAHkB,CAAnB;AAKA,WAAOQ,UAAU,CAACyB,mBAAX,CAA+B,IAA/B,CAAP;AACA;AAED;AACD;AACA;AACA;;;AACCC,EAAAA,IAAI,GAAe;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AAClB,UAAM3B,UAAU,GAAGjD,UAAU,CAACyC,qBAAX,CAClB,IADkB,EAElB,YAFkB,EAGlB,wBAHkB,CAAnB;AAKA,WAAOQ,UAAU,CAAC4B,YAAX,CAAwB,IAAxB,EAA8BD,OAA9B,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCE,EAAAA,cAAc,CAACnB,UAAD,EAAaiB,OAAb,EAAsB;AACnC,UAAM3B,UAAU,GAAGjD,UAAU,CAACyC,qBAAX,CAClB,IADkB,EAElB,sBAFkB,EAGlB,mCAHkB,CAAnB;AAKA,WAAOQ,UAAU,CAAC8B,uBAAX,CAAmC,IAAnC,EAAyCpB,UAAzC,EAAqDiB,OAArD,CAAP;AACA;AAED;AACD;AACA;AACA;;;AACCI,EAAAA,kBAAkB,CAACC,QAAD,EAAW;AAC5B,UAAMhC,UAAU,GAAGjD,UAAU,CAACyC,qBAAX,CAClB,IADkB,EAElB,0BAFkB,EAGlB,yCAHkB,CAAnB;AAKA;;AACA,UAAMyC,gBAAgB,GAAGlD,MAAM,CAACC,MAAP,CAAc,IAAd,CAAzB;AACA;;AACA,UAAMkD,kBAAkB,GAAGnD,MAAM,CAACC,MAAP,CAAc,IAAd,CAA3B;;AAEA,SAAK,MAAMmD,UAAX,IAAyB,KAAKC,iBAAL,EAAzB,EAAmD;AAClD;AACA,UAAIC,KAAJ;;AACA,WAAK,MAAMtC,MAAX,IAAqBC,UAAU,CAACQ,8BAAX,CACpB2B,UADoB,EAEpB5E,kBAAkB,CAACyC,UAAD,CAFE,CAArB,EAGG;AACF,YAAIgC,QAAQ,CAACjC,MAAD,CAAZ,EAAsB;AACrB,cAAIsC,KAAK,KAAKhE,SAAd,EAAyB;AACxBgE,YAAAA,KAAK,GAAG,EAAR;AACAJ,YAAAA,gBAAgB,CAACE,UAAU,CAACnE,EAAZ,CAAhB,GAAkCqE,KAAlC;AACA;;AACD,gBAAMC,QAAQ,GAAGtC,UAAU,CAACuC,WAAX,CAAuBxC,MAAvB,CAAjB;AACAsC,UAAAA,KAAK,CAACG,IAAN,CAAWF,QAAX;AACAJ,UAAAA,kBAAkB,CAACI,QAAD,CAAlB,GAA+BtC,UAAU,CAACyC,qBAAX,CAC9B1C,MAD8B,EAE9B1B,SAF8B,CAA/B;AAIA;AACD;AACD;;AAED,WAAO;AACNL,MAAAA,EAAE,EAAEiE,gBADE;AAENpD,MAAAA,IAAI,EAAEqD;AAFA,KAAP;AAIA;AAED;AACD;AACA;AACA;AACA;;;AACCQ,EAAAA,gBAAgB,CAACV,QAAD,EAAWW,aAAX,EAA0B;AACzC,UAAM3C,UAAU,GAAGjD,UAAU,CAACyC,qBAAX,CAClB,IADkB,EAElB,wBAFkB,EAGlB,uCAHkB,CAAnB;AAKA,WAAOQ,UAAU,CAAC0C,gBAAX,CAA4B,IAA5B,EAAkCV,QAAlC,EAA4CW,aAA5C,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCC,EAAAA,YAAY,CAACC,QAAD,EAAW;AACtB;AACA,UAAMC,YAAY,GAAG/D,MAAM,CAACC,MAAP,CAAc,IAAd,CAArB;AACA;;AACA,UAAM+D,mBAAmB,GAAGhE,MAAM,CAACC,MAAP,CAAc,IAAd,CAA5B;AACA;;AACA,UAAMgE,YAAY,GAAGjE,MAAM,CAACC,MAAP,CAAc,IAAd,CAArB;;AAEA,SAAK,MAAMiE,KAAX,IAAoB,KAAKb,iBAAL,EAApB,EAA8C;AAC7CU,MAAAA,YAAY,CAACG,KAAK,CAACjF,EAAP,CAAZ,GAAyB6E,QAAQ,GAAGI,KAAK,CAACpE,IAAT,GAAgBoE,KAAK,CAAChE,YAAvD;;AACA,WAAK,MAAMiE,GAAX,IAAkBnE,MAAM,CAACoE,IAAP,CAAYF,KAAK,CAACnE,WAAlB,CAAlB,EAAkD;AACjD,YAAI,CAACiE,mBAAmB,CAACG,GAAD,CAAxB,EAA+B;AAC9BH,UAAAA,mBAAmB,CAACG,GAAD,CAAnB,GAA2BnE,MAAM,CAACC,MAAP,CAAc,IAAd,CAA3B;AACA;;AACD+D,QAAAA,mBAAmB,CAACG,GAAD,CAAnB,CAAyBD,KAAK,CAACjF,EAA/B,IAAqCiF,KAAK,CAACnE,WAAN,CAAkBoE,GAAlB,CAArC;AACA;;AACD,UAAID,KAAK,CAACnF,IAAV,EAAgB;AACfkF,QAAAA,YAAY,CAACC,KAAK,CAACjF,EAAP,CAAZ,GAAyBiF,KAAK,CAACnF,IAA/B;AACA;AACD;;AAED,WAAO;AACNe,MAAAA,IAAI,EAAEiE,YADA;AAENhE,MAAAA,WAAW,EAAEiE,mBAFP;AAGNjF,MAAAA,IAAI,EAAEkF;AAHA,KAAP;AAKA,GA1WU,CA2WX;;AAEA;AACD;AACA;;;AACCI,EAAAA,UAAU,GAAG;AACZ,SAAK,MAAMC,UAAX,IAAyB,KAAK9E,OAA9B,EAAuC;AACtC,UACC8E,UAAU,YAAYpG,UAAtB,IACAoG,UAAU,CAACC,eAAX,OAAiC,IAFlC,EAGE;AACD,eAAO,IAAP;AACA;AACD;;AACD,WAAO,KAAP;AACA;AAED;AACD;AACA;;;AACCC,EAAAA,YAAY,GAAG;AACd,SAAK,MAAMF,UAAX,IAAyB,KAAK9E,OAA9B,EAAuC;AACtC,UAAI8E,UAAU,CAACG,SAAX,EAAJ,EAA4B,OAAO,IAAP;AAC5B;;AACD,WAAO,KAAP;AACA;AAED;AACD;AACA;;;AACCC,EAAAA,aAAa,GAAG;AACf,QAAI,KAAKlF,OAAL,CAAamD,IAAb,IAAqB,CAAzB,EAA4B,OAAO,KAAP;;AAC5B,SAAK,MAAM2B,UAAX,IAAyB,KAAK9E,OAA9B,EAAuC;AACtC,UAAI,CAAC8E,UAAU,CAACG,SAAX,EAAL,EAA6B,OAAO,KAAP;AAC7B;;AACD,WAAO,IAAP;AACA;AAED;AACD;AACA;;;AACCE,EAAAA,eAAe,GAAG;AACjB,SAAK,MAAML,UAAX,IAAyB,KAAK9E,OAA9B,EAAuC;AACtC,UAAI8E,UAAU,YAAYpG,UAA1B,EAAsC;AACrC,eAAOoG,UAAU,CAAC1B,OAAlB;AACA;AACD;;AACD,WAAOtD,SAAP;AACA;AAED;AACD;AACA;AACA;;;AACCsF,EAAAA,QAAQ,CAACN,UAAD,EAAa;AACpB,SAAK9E,OAAL,CAAaqF,GAAb,CAAiBP,UAAjB;AACA;AAED;AACD;AACA;AACA;;;AACCQ,EAAAA,WAAW,CAACR,UAAD,EAAa;AACvB,SAAK9E,OAAL,CAAauF,MAAb,CAAoBT,UAApB;AACA;AAED;AACD;AACA;AACA;;;AACCU,EAAAA,SAAS,CAACV,UAAD,EAAa;AACrB,WAAO,KAAK9E,OAAL,CAAayF,GAAb,CAAiBX,UAAjB,CAAP;AACA;AAED;AACD;AACA;;;AACCY,EAAAA,iBAAiB,GAAG;AACnB,WAAO,KAAK1F,OAAL,CAAamD,IAApB;AACA;AAED;AACD;AACA;;;AACmB,MAAdwC,cAAc,GAAG;AACpB,SAAK3F,OAAL,CAAa4F,IAAb;;AACA,WAAO,KAAK5F,OAAZ;AACA;AAED;AACD;AACA;;;AACC0C,EAAAA,oBAAoB,GAAG;AACtB,SAAK,MAAMoC,UAAX,IAAyB,KAAK9E,OAA9B,EAAuC;AACtC8E,MAAAA,UAAU,CAACe,WAAX,CAAuB,IAAvB;AACA;AACD;AAED;AACD;AACA;AACA;;;AACCC,EAAAA,KAAK,CAACC,QAAD,EAAW;AACf,SAAK,MAAMjB,UAAX,IAAyB,KAAK9E,OAA9B,EAAuC;AACtC8E,MAAAA,UAAU,CAACkB,WAAX,CAAuBD,QAAvB,EAAiC,IAAjC;AACAA,MAAAA,QAAQ,CAACX,QAAT,CAAkBN,UAAlB;AACA;;AACD,SAAK,MAAMmB,MAAX,IAAqB,KAAKtG,WAA1B,EAAuC;AACtCoG,MAAAA,QAAQ,CAACpG,WAAT,CAAqB0F,GAArB,CAAyBY,MAAzB;AACA;;AACDF,IAAAA,QAAQ,CAAC9F,OAAT,GAAmBf,YAAY,CAAC6G,QAAQ,CAAC9F,OAAV,EAAmB,KAAKA,OAAxB,CAA/B;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCiG,EAAAA,UAAU,CAAC5F,IAAD,EAAOmB,UAAP,EAAmB;AAC5BnB,IAAAA,IAAI,CAAC6F,MAAL,CACE,GAAE,KAAK1G,EAAG,IAAG,KAAKC,GAAL,GAAW,KAAKA,GAAL,CAAS0G,IAAT,EAAX,GAA6B,EAAG,IAAG,KAAK7G,IAAL,IAAa,EAAG,GADlE;AAGA,UAAM8G,GAAG,GAAG,IAAIxH,SAAJ,EAAZ;;AACA,SAAK,MAAMyH,CAAX,IAAgB7E,UAAU,CAAC8E,uBAAX,CAAmC,IAAnC,CAAhB,EAA0D;AACzDF,MAAAA,GAAG,CAAChB,GAAJ,CAAQ5D,UAAU,CAAC+E,aAAX,CAAyBF,CAAzB,EAA4B,KAAKrG,OAAjC,CAAR;AACA;;AACDoG,IAAAA,GAAG,CAACH,UAAJ,CAAe5F,IAAf;AACA,UAAMQ,YAAY,GACjBW,UAAU,CAACgF,0CAAX,CAAsD,IAAtD,CADD;;AAEA,SAAK,MAAM,CAACH,CAAD,EAAIxB,UAAJ,CAAX,IAA8BhE,YAA9B,EAA4C;AAC3CR,MAAAA,IAAI,CAAC6F,MAAL,CAAa,QAAO1E,UAAU,CAACuC,WAAX,CAAuBsC,CAAvB,CAA0B,GAAExB,UAAU,CAACrF,EAAG,EAA9D;AACA;AACD;AAED;AACD;AACA;;;AACCoE,EAAAA,iBAAiB,GAAG;AACnB,UAAM6C,KAAK,GAAG,IAAIvG,GAAJ,EAAd;AACA,UAAMwG,MAAM,GAAG,IAAIxG,GAAJ,EAAf;AAEA,UAAMyG,aAAa,GAAGjI,SAAS,CAC9BoC,KAAK,CAACC,IAAN,CAAW,KAAK2E,cAAhB,EAAgCkB,CAAC,IAAI,IAAI1G,GAAJ,CAAQ0G,CAAC,CAACF,MAAV,CAArC,CAD8B,CAA/B;AAIA,UAAMG,YAAY,GAAG,IAAI3G,GAAJ,CAAQ,KAAKwF,cAAb,CAArB;;AAEA,SAAK,MAAMb,UAAX,IAAyBgC,YAAzB,EAAuC;AACtC,WAAK,MAAMC,KAAX,IAAoBjC,UAAU,CAACkC,gBAA/B,EAAiD;AAChD,YAAID,KAAK,YAAYrI,UAArB,EAAiC;AAChCoI,UAAAA,YAAY,CAACzB,GAAb,CAAiB0B,KAAjB;AACA,SAFD,MAEO;AACNL,UAAAA,KAAK,CAACrB,GAAN,CAAU0B,KAAV;AACA;AACD;AACD;;AAED,SAAK,MAAMjC,UAAX,IAAyB4B,KAAzB,EAAgC;AAC/B,WAAK,MAAMhC,KAAX,IAAoBI,UAAU,CAAC6B,MAA/B,EAAuC;AACtC,YAAI,CAACC,aAAa,CAACnB,GAAd,CAAkBf,KAAlB,CAAL,EAA+B;AAC9BiC,UAAAA,MAAM,CAACtB,GAAP,CAAWX,KAAX;AACA;AACD;;AACD,WAAK,MAAMqC,KAAX,IAAoBjC,UAAU,CAACkC,gBAA/B,EAAiD;AAChDN,QAAAA,KAAK,CAACrB,GAAN,CAAU0B,KAAV;AACA;AACD;;AAED,WAAOJ,MAAP;AACA;AAED;AACD;AACA;;;AACCM,EAAAA,mBAAmB,GAAG;AACrB,UAAMN,MAAM,GAAG,IAAIxG,GAAJ,EAAf;AACA,UAAMuG,KAAK,GAAG,IAAIvG,GAAJ,CAAQ,KAAKwF,cAAb,CAAd;;AACA,SAAK,MAAMuB,KAAX,IAAoBR,KAApB,EAA2B;AAC1B,UAAIQ,KAAK,CAACjC,SAAN,EAAJ,EAAuB;AACtB,aAAK,MAAMkC,CAAX,IAAgBD,KAAK,CAACP,MAAtB,EAA8BA,MAAM,CAACtB,GAAP,CAAW8B,CAAX;;AAC9B,aAAK,MAAMN,CAAX,IAAgBK,KAAK,CAACF,gBAAtB,EAAwCN,KAAK,CAACrB,GAAN,CAAUwB,CAAV;AACxC;AACD;;AACD,WAAOF,MAAP;AACA;AAED;AACD;AACA;;;AACCS,EAAAA,sBAAsB,GAAG;AACxB,UAAMV,KAAK,GAAG,IAAIvG,GAAJ,CAAQ,KAAKwF,cAAb,CAAd;AACA,UAAMgB,MAAM,GAAG,IAAIxG,GAAJ,EAAf;;AAEA,SAAK,MAAM2E,UAAX,IAAyB4B,KAAzB,EAAgC;AAC/B,WAAK,MAAMhC,KAAX,IAAoBI,UAAU,CAAC6B,MAA/B,EAAuC;AACtCA,QAAAA,MAAM,CAACtB,GAAP,CAAWX,KAAX;AACA;;AACD,WAAK,MAAMqC,KAAX,IAAoBjC,UAAU,CAACkC,gBAA/B,EAAiD;AAChDN,QAAAA,KAAK,CAACrB,GAAN,CAAU0B,KAAV;AACA;AACD;;AAED,WAAOJ,MAAP;AACA;AAED;AACD;AACA;;;AACCU,EAAAA,gCAAgC,GAAG;AAClC,UAAMX,KAAK,GAAG,IAAIvG,GAAJ,CAAQ,KAAKwF,cAAb,CAAd;AACA,UAAM2B,WAAW,GAAG,IAAInH,GAAJ,EAApB;;AAEA,SAAK,MAAM2E,UAAX,IAAyB4B,KAAzB,EAAgC;AAC/B,WAAK,MAAMa,UAAX,IAAyBzC,UAAU,CAAC0C,wBAApC,EAA8D;AAC7DF,QAAAA,WAAW,CAACjC,GAAZ,CAAgBkC,UAAhB;AACA;;AACD,WAAK,MAAMR,KAAX,IAAoBjC,UAAU,CAACkC,gBAA/B,EAAiD;AAChDN,QAAAA,KAAK,CAACrB,GAAN,CAAU0B,KAAV;AACA;AACD;;AAED,WAAOO,WAAP;AACA;AAED;AACD;AACA;;;AACCG,EAAAA,cAAc,GAAG;AAChB,UAAMf,KAAK,GAAG,IAAIvG,GAAJ,EAAd;AAEA,UAAMyG,aAAa,GAAGjI,SAAS,CAC9BoC,KAAK,CAACC,IAAN,CAAW,KAAK2E,cAAhB,EAAgCkB,CAAC,IAAI,IAAI1G,GAAJ,CAAQ0G,CAAC,CAACF,MAAV,CAArC,CAD8B,CAA/B;;AAIA,SAAK,MAAM7B,UAAX,IAAyB,KAAKa,cAA9B,EAA8C;AAC7C,WAAK,MAAMoB,KAAX,IAAoBjC,UAAU,CAACkC,gBAA/B,EAAiD;AAChDN,QAAAA,KAAK,CAACrB,GAAN,CAAU0B,KAAV;AACA;AACD;;AAED,SAAK,MAAMjC,UAAX,IAAyB4B,KAAzB,EAAgC;AAC/B,WAAK,MAAMhC,KAAX,IAAoBI,UAAU,CAAC6B,MAA/B,EAAuC;AACtC,YAAI,CAACC,aAAa,CAACnB,GAAd,CAAkBf,KAAlB,CAAL,EAA+B;AAC9B,iBAAO,IAAP;AACA;AACD;;AACD,WAAK,MAAMqC,KAAX,IAAoBjC,UAAU,CAACkC,gBAA/B,EAAiD;AAChDN,QAAAA,KAAK,CAACrB,GAAN,CAAU0B,KAAV;AACA;AACD;;AAED,WAAO,KAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCW,EAAAA,mBAAmB,CAACjG,UAAD,EAAagC,QAAb,EAAuB;AACzC;AACA,UAAMkE,KAAK,GAAG,IAAIC,GAAJ,EAAd;;AACA,SAAK,MAAMV,KAAX,IAAoB,KAAKvB,cAAzB,EAAyC;AACxC,UAAIuB,KAAK,CAACP,MAAN,CAAaO,KAAK,CAACP,MAAN,CAAaxF,MAAb,GAAsB,CAAnC,MAA0C,IAA9C,EAAoD;AACnD,aAAK,MAAM0G,UAAX,IAAyBX,KAAK,CAACF,gBAA/B,EAAiD;AAChD,eAAK,MAAMrC,GAAX,IAAkBnE,MAAM,CAACoE,IAAP,CAAYiD,UAAU,CAACzE,OAAvB,CAAlB,EAAmD;AAClD,gBAAIuB,GAAG,CAACmD,QAAJ,CAAa,OAAb,CAAJ,EAA2B;AAC1B,oBAAMvI,IAAI,GAAGoF,GAAG,CAACoD,MAAJ,CAAW,CAAX,EAAcpD,GAAG,CAACxD,MAAJ,GAAa,QAAQA,MAAnC,CAAb;AACA,kBAAI6G,IAAI,GAAGL,KAAK,CAACM,GAAN,CAAU1I,IAAV,CAAX;;AACA,kBAAIyI,IAAI,KAAKlI,SAAb,EAAwB;AACvBkI,gBAAAA,IAAI,GAAG,EAAP;AACAL,gBAAAA,KAAK,CAACO,GAAN,CAAU3I,IAAV,EAAgByI,IAAhB;AACA;;AACDA,cAAAA,IAAI,CAAC/D,IAAL,CAAU;AACTkE,gBAAAA,KAAK,EAAEN,UAAU,CAACzE,OAAX,CAAmBuB,GAAnB,CADE;AAETuC,gBAAAA,KAAK,EAAEW;AAFE,eAAV;AAIA;AACD;AACD;AACD;AACD;AACD;;;AACA,UAAMO,MAAM,GAAG5H,MAAM,CAACC,MAAP,CAAc,IAAd,CAAf;;AACA,SAAK,MAAM,CAAClB,IAAD,EAAOyI,IAAP,CAAX,IAA2BL,KAA3B,EAAkC;AACjCK,MAAAA,IAAI,CAACpC,IAAL,CAAU,CAACyC,CAAD,EAAIC,CAAJ,KAAU;AACnB,cAAMC,GAAG,GAAGD,CAAC,CAACH,KAAF,GAAUE,CAAC,CAACF,KAAxB;AACA,YAAII,GAAG,KAAK,CAAZ,EAAe,OAAOA,GAAP;AACf,eAAOF,CAAC,CAACnB,KAAF,CAAQhF,SAAR,CAAkBT,UAAlB,EAA8B6G,CAAC,CAACpB,KAAhC,CAAP;AACA,OAJD;AAKA;;AACA,YAAMsB,UAAU,GAAG,IAAIrI,GAAJ,EAAnB;;AACA,WAAK,MAAMsI,IAAX,IAAmBT,IAAnB,EAAyB;AACxB,aAAK,MAAMtD,KAAX,IAAoB+D,IAAI,CAACvB,KAAL,CAAWP,MAA/B,EAAuC;AACtC,cAAIlD,QAAQ,IAAI,CAACA,QAAQ,CAACiB,KAAD,EAAQjD,UAAR,CAAzB,EAA8C;AAC9C+G,UAAAA,UAAU,CAACnD,GAAX,CAAeX,KAAK,CAACjF,EAArB;AACA;AACD;;AACD,UAAI+I,UAAU,CAACrF,IAAX,GAAkB,CAAtB,EAAyB;AACxBiF,QAAAA,MAAM,CAAC7I,IAAD,CAAN,GAAewB,KAAK,CAACC,IAAN,CAAWwH,UAAX,CAAf;AACA;AACD;;AACD,WAAOJ,MAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCM,EAAAA,wBAAwB,CAACjH,UAAD,EAAakH,IAAb,EAAmB;AAC1C,UAAMX,IAAI,GAAG,EAAb;;AACA,SAAK,MAAMd,KAAX,IAAoB,KAAKvB,cAAzB,EAAyC;AACxC,WAAK,MAAMkC,UAAX,IAAyBX,KAAK,CAACF,gBAA/B,EAAiD;AAChD,cAAMmB,KAAK,GAAGN,UAAU,CAACzE,OAAX,CAAmBuF,IAAnB,CAAd;AACA,YAAIR,KAAK,KAAKrI,SAAd,EAAyB;AACzBkI,QAAAA,IAAI,CAAC/D,IAAL,CAAU;AACTkE,UAAAA,KADS;AAETjB,UAAAA,KAFS;AAGTW,UAAAA;AAHS,SAAV;AAKA;AACD;;AACD,QAAIG,IAAI,CAAC7G,MAAL,KAAgB,CAApB,EAAuB,OAAOrB,SAAP;AACvBkI,IAAAA,IAAI,CAACpC,IAAL,CAAU,CAACyC,CAAD,EAAIC,CAAJ,KAAU;AACnB,YAAMC,GAAG,GAAGD,CAAC,CAACH,KAAF,GAAUE,CAAC,CAACF,KAAxB;AACA,UAAII,GAAG,KAAK,CAAZ,EAAe,OAAOA,GAAP;AACf,aAAOF,CAAC,CAACnB,KAAF,CAAQhF,SAAR,CAAkBT,UAAlB,EAA8B6G,CAAC,CAACpB,KAAhC,CAAP;AACA,KAJD;AAKA,UAAMkB,MAAM,GAAG,EAAf;AACA,QAAIQ,SAAJ;;AACA,SAAK,MAAM;AAAE1B,MAAAA,KAAF;AAASW,MAAAA;AAAT,KAAX,IAAoCG,IAApC,EAA0C;AACzC,UAAIY,SAAS,IAAIA,SAAS,CAACC,QAAV,KAAuB3B,KAAK,CAACP,MAA9C,EAAsD;AACrD,aAAK,MAAMjC,KAAX,IAAoBmD,UAAU,CAAClB,MAA/B,EAAuC;AACtCiC,UAAAA,SAAS,CAACjC,MAAV,CAAiBtB,GAAjB,CAAqBX,KAArB;AACA;AACD,OAJD,MAIO;AACN0D,QAAAA,MAAM,CAACnE,IAAP,CACE2E,SAAS,GAAG;AACZC,UAAAA,QAAQ,EAAE3B,KAAK,CAACP,MADJ;AAEZA,UAAAA,MAAM,EAAE,IAAIxG,GAAJ,CAAQ0H,UAAU,CAAClB,MAAnB;AAFI,SADd;AAMA;AACD;;AACD,WAAOyB,MAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCU,EAAAA,sBAAsB,CAACrH,UAAD,EAAasH,qBAAb,EAAoCtF,QAApC,EAA8C;AACnE;AACA,UAAMuF,SAAS,GAAGxI,MAAM,CAACC,MAAP,CAAc,IAAd,CAAlB;AAEA;AACF;AACA;AACA;;AACE,UAAMwI,wBAAwB,GAAGvE,KAAK,IAAI;AACzC,YAAMwE,IAAI,GAAGxE,KAAK,CAACgD,mBAAN,CAA0BjG,UAA1B,EAAsCgC,QAAtC,CAAb;;AACA,WAAK,MAAMkB,GAAX,IAAkBnE,MAAM,CAACoE,IAAP,CAAYsE,IAAZ,CAAlB,EAAqC;AACpC,YAAIC,QAAQ,GAAGH,SAAS,CAACrE,GAAD,CAAxB;;AACA,YAAIwE,QAAQ,KAAKrJ,SAAjB,EAA4B;AAC3BkJ,UAAAA,SAAS,CAACrE,GAAD,CAAT,GAAiBwE,QAAQ,GAAG3I,MAAM,CAACC,MAAP,CAAc,IAAd,CAA5B;AACA;;AACD0I,QAAAA,QAAQ,CAACzE,KAAK,CAACjF,EAAP,CAAR,GAAqByJ,IAAI,CAACvE,GAAD,CAAzB;AACA;AACD,KATD;;AAWA,QAAIoE,qBAAJ,EAA2B;AAC1B;AACA,YAAMpC,MAAM,GAAG,IAAIxG,GAAJ,EAAf;;AACA,WAAK,MAAM2E,UAAX,IAAyB,KAAKa,cAA9B,EAA8C;AAC7C,aAAK,MAAMjB,KAAX,IAAoBI,UAAU,CAAC6B,MAA/B,EAAuC;AACtCA,UAAAA,MAAM,CAACtB,GAAP,CAAWX,KAAX;AACA;AACD;;AACD,WAAK,MAAMA,KAAX,IAAoBiC,MAApB,EAA4B;AAC3BsC,QAAAA,wBAAwB,CAACvE,KAAD,CAAxB;AACA;AACD;;AAED,SAAK,MAAMA,KAAX,IAAoB,KAAKb,iBAAL,EAApB,EAA8C;AAC7CoF,MAAAA,wBAAwB,CAACvE,KAAD,CAAxB;AACA;;AAED,WAAOsE,SAAP;AACA;;AAlvBU;;AAqvBZxH,MAAM,CAAC4H,OAAP,GAAiB/J,KAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst ChunkGraph = require(\"./ChunkGraph\");\nconst Entrypoint = require(\"./Entrypoint\");\nconst { intersect } = require(\"./util/SetHelpers\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst StringXor = require(\"./util/StringXor\");\nconst {\n\tcompareModulesByIdentifier,\n\tcompareChunkGroupsByIndex,\n\tcompareModulesById\n} = require(\"./util/comparators\");\nconst { createArrayToSetDeprecationSet } = require(\"./util/deprecation\");\nconst { mergeRuntime } = require(\"./util/runtime\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./ChunkGraph\").ChunkFilterPredicate} ChunkFilterPredicate */\n/** @typedef {import(\"./ChunkGraph\").ChunkSizeOptions} ChunkSizeOptions */\n/** @typedef {import(\"./ChunkGraph\").ModuleFilterPredicate} ModuleFilterPredicate */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"./Compilation\").PathData} PathData */\n/** @typedef {import(\"./Entrypoint\").EntryOptions} EntryOptions */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\nconst ChunkFilesSet = createArrayToSetDeprecationSet(\"chunk.files\");\n\n/**\n * @typedef {Object} WithId an object who has an id property *\n * @property {string | number} id the id of the object\n */\n\n/**\n * @deprecated\n * @typedef {Object} ChunkMaps\n * @property {Record<string|number, string>} hash\n * @property {Record<string|number, Record<string, string>>} contentHash\n * @property {Record<string|number, string>} name\n */\n\n/**\n * @deprecated\n * @typedef {Object} ChunkModuleMaps\n * @property {Record<string|number, (string|number)[]>} id\n * @property {Record<string|number, string>} hash\n */\n\nlet debugId = 1000;\n\n/**\n * A Chunk is a unit of encapsulation for Modules.\n * Chunks are \"rendered\" into bundles that get emitted when the build completes.\n */\nclass Chunk {\n\t/**\n\t * @param {string=} name of chunk being created, is optional (for subclasses)\n\t * @param {boolean} backCompat enable backward-compatibility\n\t */\n\tconstructor(name, backCompat = true) {\n\t\t/** @type {number | string | null} */\n\t\tthis.id = null;\n\t\t/** @type {(number|string)[] | null} */\n\t\tthis.ids = null;\n\t\t/** @type {number} */\n\t\tthis.debugId = debugId++;\n\t\t/** @type {string} */\n\t\tthis.name = name;\n\t\t/** @type {SortableSet<string>} */\n\t\tthis.idNameHints = new SortableSet();\n\t\t/** @type {boolean} */\n\t\tthis.preventIntegration = false;\n\t\t/** @type {(string | function(PathData, AssetInfo=): string)?} */\n\t\tthis.filenameTemplate = undefined;\n\t\t/** @type {(string | function(PathData, AssetInfo=): string)?} */\n\t\tthis.cssFilenameTemplate = undefined;\n\t\t/** @private @type {SortableSet<ChunkGroup>} */\n\t\tthis._groups = new SortableSet(undefined, compareChunkGroupsByIndex);\n\t\t/** @type {RuntimeSpec} */\n\t\tthis.runtime = undefined;\n\t\t/** @type {Set<string>} */\n\t\tthis.files = backCompat ? new ChunkFilesSet() : new Set();\n\t\t/** @type {Set<string>} */\n\t\tthis.auxiliaryFiles = new Set();\n\t\t/** @type {boolean} */\n\t\tthis.rendered = false;\n\t\t/** @type {string=} */\n\t\tthis.hash = undefined;\n\t\t/** @type {Record<string, string>} */\n\t\tthis.contentHash = Object.create(null);\n\t\t/** @type {string=} */\n\t\tthis.renderedHash = undefined;\n\t\t/** @type {string=} */\n\t\tthis.chunkReason = undefined;\n\t\t/** @type {boolean} */\n\t\tthis.extraAsync = false;\n\t}\n\n\t// TODO remove in webpack 6\n\t// BACKWARD-COMPAT START\n\tget entryModule() {\n\t\tconst entryModules = Array.from(\n\t\t\tChunkGraph.getChunkGraphForChunk(\n\t\t\t\tthis,\n\t\t\t\t\"Chunk.entryModule\",\n\t\t\t\t\"DEP_WEBPACK_CHUNK_ENTRY_MODULE\"\n\t\t\t).getChunkEntryModulesIterable(this)\n\t\t);\n\t\tif (entryModules.length === 0) {\n\t\t\treturn undefined;\n\t\t} else if (entryModules.length === 1) {\n\t\t\treturn entryModules[0];\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t\"Module.entryModule: Multiple entry modules are not supported by the deprecated API (Use the new ChunkGroup API)\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {boolean} true, if the chunk contains an entry module\n\t */\n\thasEntryModule() {\n\t\treturn (\n\t\t\tChunkGraph.getChunkGraphForChunk(\n\t\t\t\tthis,\n\t\t\t\t\"Chunk.hasEntryModule\",\n\t\t\t\t\"DEP_WEBPACK_CHUNK_HAS_ENTRY_MODULE\"\n\t\t\t).getNumberOfEntryModules(this) > 0\n\t\t);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {boolean} true, if the chunk could be added\n\t */\n\taddModule(module) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.addModule\",\n\t\t\t\"DEP_WEBPACK_CHUNK_ADD_MODULE\"\n\t\t);\n\t\tif (chunkGraph.isModuleInChunk(module, this)) return false;\n\t\tchunkGraph.connectChunkAndModule(this, module);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tremoveModule(module) {\n\t\tChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.removeModule\",\n\t\t\t\"DEP_WEBPACK_CHUNK_REMOVE_MODULE\"\n\t\t).disconnectChunkAndModule(this, module);\n\t}\n\n\t/**\n\t * @returns {number} the number of module which are contained in this chunk\n\t */\n\tgetNumberOfModules() {\n\t\treturn ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.getNumberOfModules\",\n\t\t\t\"DEP_WEBPACK_CHUNK_GET_NUMBER_OF_MODULES\"\n\t\t).getNumberOfChunkModules(this);\n\t}\n\n\tget modulesIterable() {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.modulesIterable\",\n\t\t\t\"DEP_WEBPACK_CHUNK_MODULES_ITERABLE\"\n\t\t);\n\t\treturn chunkGraph.getOrderedChunkModulesIterable(\n\t\t\tthis,\n\t\t\tcompareModulesByIdentifier\n\t\t);\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the chunk to compare with\n\t * @returns {-1|0|1} the comparison result\n\t */\n\tcompareTo(otherChunk) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.compareTo\",\n\t\t\t\"DEP_WEBPACK_CHUNK_COMPARE_TO\"\n\t\t);\n\t\treturn chunkGraph.compareChunks(this, otherChunk);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {boolean} true, if the chunk contains the module\n\t */\n\tcontainsModule(module) {\n\t\treturn ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.containsModule\",\n\t\t\t\"DEP_WEBPACK_CHUNK_CONTAINS_MODULE\"\n\t\t).isModuleInChunk(module, this);\n\t}\n\n\t/**\n\t * @returns {Module[]} the modules for this chunk\n\t */\n\tgetModules() {\n\t\treturn ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.getModules\",\n\t\t\t\"DEP_WEBPACK_CHUNK_GET_MODULES\"\n\t\t).getChunkModules(this);\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tremove() {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.remove\",\n\t\t\t\"DEP_WEBPACK_CHUNK_REMOVE\"\n\t\t);\n\t\tchunkGraph.disconnectChunk(this);\n\t\tthis.disconnectFromGroups();\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {Chunk} otherChunk the target chunk\n\t * @returns {void}\n\t */\n\tmoveModule(module, otherChunk) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.moveModule\",\n\t\t\t\"DEP_WEBPACK_CHUNK_MOVE_MODULE\"\n\t\t);\n\t\tchunkGraph.disconnectChunkAndModule(this, module);\n\t\tchunkGraph.connectChunkAndModule(otherChunk, module);\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the other chunk\n\t * @returns {boolean} true, if the specified chunk has been integrated\n\t */\n\tintegrate(otherChunk) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.integrate\",\n\t\t\t\"DEP_WEBPACK_CHUNK_INTEGRATE\"\n\t\t);\n\t\tif (chunkGraph.canChunksBeIntegrated(this, otherChunk)) {\n\t\t\tchunkGraph.integrateChunks(this, otherChunk);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the other chunk\n\t * @returns {boolean} true, if chunks could be integrated\n\t */\n\tcanBeIntegrated(otherChunk) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.canBeIntegrated\",\n\t\t\t\"DEP_WEBPACK_CHUNK_CAN_BE_INTEGRATED\"\n\t\t);\n\t\treturn chunkGraph.canChunksBeIntegrated(this, otherChunk);\n\t}\n\n\t/**\n\t * @returns {boolean} true, if this chunk contains no module\n\t */\n\tisEmpty() {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.isEmpty\",\n\t\t\t\"DEP_WEBPACK_CHUNK_IS_EMPTY\"\n\t\t);\n\t\treturn chunkGraph.getNumberOfChunkModules(this) === 0;\n\t}\n\n\t/**\n\t * @returns {number} total size of all modules in this chunk\n\t */\n\tmodulesSize() {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.modulesSize\",\n\t\t\t\"DEP_WEBPACK_CHUNK_MODULES_SIZE\"\n\t\t);\n\t\treturn chunkGraph.getChunkModulesSize(this);\n\t}\n\n\t/**\n\t * @param {ChunkSizeOptions} options options object\n\t * @returns {number} total size of this chunk\n\t */\n\tsize(options = {}) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.size\",\n\t\t\t\"DEP_WEBPACK_CHUNK_SIZE\"\n\t\t);\n\t\treturn chunkGraph.getChunkSize(this, options);\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the other chunk\n\t * @param {ChunkSizeOptions} options options object\n\t * @returns {number} total size of the chunk or false if the chunk can't be integrated\n\t */\n\tintegratedSize(otherChunk, options) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.integratedSize\",\n\t\t\t\"DEP_WEBPACK_CHUNK_INTEGRATED_SIZE\"\n\t\t);\n\t\treturn chunkGraph.getIntegratedChunksSize(this, otherChunk, options);\n\t}\n\n\t/**\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\n\t * @returns {ChunkModuleMaps} module map information\n\t */\n\tgetChunkModuleMaps(filterFn) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.getChunkModuleMaps\",\n\t\t\t\"DEP_WEBPACK_CHUNK_GET_CHUNK_MODULE_MAPS\"\n\t\t);\n\t\t/** @type {Record<string|number, (string|number)[]>} */\n\t\tconst chunkModuleIdMap = Object.create(null);\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkModuleHashMap = Object.create(null);\n\n\t\tfor (const asyncChunk of this.getAllAsyncChunks()) {\n\t\t\t/** @type {(string|number)[]} */\n\t\t\tlet array;\n\t\t\tfor (const module of chunkGraph.getOrderedChunkModulesIterable(\n\t\t\t\tasyncChunk,\n\t\t\t\tcompareModulesById(chunkGraph)\n\t\t\t)) {\n\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\tchunkModuleIdMap[asyncChunk.id] = array;\n\t\t\t\t\t}\n\t\t\t\t\tconst moduleId = chunkGraph.getModuleId(module);\n\t\t\t\t\tarray.push(moduleId);\n\t\t\t\t\tchunkModuleHashMap[moduleId] = chunkGraph.getRenderedModuleHash(\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tundefined\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tid: chunkModuleIdMap,\n\t\t\thash: chunkModuleHashMap\n\t\t};\n\t}\n\n\t/**\n\t * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\n\t * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\n\t * @returns {boolean} return true if module exists in graph\n\t */\n\thasModuleInGraph(filterFn, filterChunkFn) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.hasModuleInGraph\",\n\t\t\t\"DEP_WEBPACK_CHUNK_HAS_MODULE_IN_GRAPH\"\n\t\t);\n\t\treturn chunkGraph.hasModuleInGraph(this, filterFn, filterChunkFn);\n\t}\n\n\t/**\n\t * @deprecated\n\t * @param {boolean} realHash whether the full hash or the rendered hash is to be used\n\t * @returns {ChunkMaps} the chunk map information\n\t */\n\tgetChunkMaps(realHash) {\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkHashMap = Object.create(null);\n\t\t/** @type {Record<string|number, Record<string, string>>} */\n\t\tconst chunkContentHashMap = Object.create(null);\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkNameMap = Object.create(null);\n\n\t\tfor (const chunk of this.getAllAsyncChunks()) {\n\t\t\tchunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;\n\t\t\tfor (const key of Object.keys(chunk.contentHash)) {\n\t\t\t\tif (!chunkContentHashMap[key]) {\n\t\t\t\t\tchunkContentHashMap[key] = Object.create(null);\n\t\t\t\t}\n\t\t\t\tchunkContentHashMap[key][chunk.id] = chunk.contentHash[key];\n\t\t\t}\n\t\t\tif (chunk.name) {\n\t\t\t\tchunkNameMap[chunk.id] = chunk.name;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\thash: chunkHashMap,\n\t\t\tcontentHash: chunkContentHashMap,\n\t\t\tname: chunkNameMap\n\t\t};\n\t}\n\t// BACKWARD-COMPAT END\n\n\t/**\n\t * @returns {boolean} whether or not the Chunk will have a runtime\n\t */\n\thasRuntime() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (\n\t\t\t\tchunkGroup instanceof Entrypoint &&\n\t\t\t\tchunkGroup.getRuntimeChunk() === this\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {boolean} whether or not this chunk can be an initial chunk\n\t */\n\tcanBeInitial() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (chunkGroup.isInitial()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {boolean} whether this chunk can only be an initial chunk\n\t */\n\tisOnlyInitial() {\n\t\tif (this._groups.size <= 0) return false;\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (!chunkGroup.isInitial()) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @returns {EntryOptions | undefined} the entry options for this chunk\n\t */\n\tgetEntryOptions() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (chunkGroup instanceof Entrypoint) {\n\t\t\t\treturn chunkGroup.options;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added\n\t * @returns {void}\n\t */\n\taddGroup(chunkGroup) {\n\t\tthis._groups.add(chunkGroup);\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from\n\t * @returns {void}\n\t */\n\tremoveGroup(chunkGroup) {\n\t\tthis._groups.delete(chunkGroup);\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup to check\n\t * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup\n\t */\n\tisInGroup(chunkGroup) {\n\t\treturn this._groups.has(chunkGroup);\n\t}\n\n\t/**\n\t * @returns {number} the amount of groups that the said chunk is in\n\t */\n\tgetNumberOfGroups() {\n\t\treturn this._groups.size;\n\t}\n\n\t/**\n\t * @returns {Iterable<ChunkGroup>} the chunkGroups that the said chunk is referenced in\n\t */\n\tget groupsIterable() {\n\t\tthis._groups.sort();\n\t\treturn this._groups;\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tdisconnectFromGroups() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tchunkGroup.removeChunk(this);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} newChunk the new chunk that will be split out of\n\t * @returns {void}\n\t */\n\tsplit(newChunk) {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tchunkGroup.insertChunk(newChunk, this);\n\t\t\tnewChunk.addGroup(chunkGroup);\n\t\t}\n\t\tfor (const idHint of this.idNameHints) {\n\t\t\tnewChunk.idNameHints.add(idHint);\n\t\t}\n\t\tnewChunk.runtime = mergeRuntime(newChunk.runtime, this.runtime);\n\t}\n\n\t/**\n\t * @param {Hash} hash hash (will be modified)\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @returns {void}\n\t */\n\tupdateHash(hash, chunkGraph) {\n\t\thash.update(\n\t\t\t`${this.id} ${this.ids ? this.ids.join() : \"\"} ${this.name || \"\"} `\n\t\t);\n\t\tconst xor = new StringXor();\n\t\tfor (const m of chunkGraph.getChunkModulesIterable(this)) {\n\t\t\txor.add(chunkGraph.getModuleHash(m, this.runtime));\n\t\t}\n\t\txor.updateHash(hash);\n\t\tconst entryModules =\n\t\t\tchunkGraph.getChunkEntryModulesWithChunkGroupIterable(this);\n\t\tfor (const [m, chunkGroup] of entryModules) {\n\t\t\thash.update(`entry${chunkGraph.getModuleId(m)}${chunkGroup.id}`);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {Set<Chunk>} a set of all the async chunks\n\t */\n\tgetAllAsyncChunks() {\n\t\tconst queue = new Set();\n\t\tconst chunks = new Set();\n\n\t\tconst initialChunks = intersect(\n\t\t\tArray.from(this.groupsIterable, g => new Set(g.chunks))\n\t\t);\n\n\t\tconst initialQueue = new Set(this.groupsIterable);\n\n\t\tfor (const chunkGroup of initialQueue) {\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tif (child instanceof Entrypoint) {\n\t\t\t\t\tinitialQueue.add(child);\n\t\t\t\t} else {\n\t\t\t\t\tqueue.add(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tif (!initialChunks.has(chunk)) {\n\t\t\t\t\tchunks.add(chunk);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn chunks;\n\t}\n\n\t/**\n\t * @returns {Set<Chunk>} a set of all the initial chunks (including itself)\n\t */\n\tgetAllInitialChunks() {\n\t\tconst chunks = new Set();\n\t\tconst queue = new Set(this.groupsIterable);\n\t\tfor (const group of queue) {\n\t\t\tif (group.isInitial()) {\n\t\t\t\tfor (const c of group.chunks) chunks.add(c);\n\t\t\t\tfor (const g of group.childrenIterable) queue.add(g);\n\t\t\t}\n\t\t}\n\t\treturn chunks;\n\t}\n\n\t/**\n\t * @returns {Set<Chunk>} a set of all the referenced chunks (including itself)\n\t */\n\tgetAllReferencedChunks() {\n\t\tconst queue = new Set(this.groupsIterable);\n\t\tconst chunks = new Set();\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tchunks.add(chunk);\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn chunks;\n\t}\n\n\t/**\n\t * @returns {Set<Entrypoint>} a set of all the referenced entrypoints\n\t */\n\tgetAllReferencedAsyncEntrypoints() {\n\t\tconst queue = new Set(this.groupsIterable);\n\t\tconst entrypoints = new Set();\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const entrypoint of chunkGroup.asyncEntrypointsIterable) {\n\t\t\t\tentrypoints.add(entrypoint);\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn entrypoints;\n\t}\n\n\t/**\n\t * @returns {boolean} true, if the chunk references async chunks\n\t */\n\thasAsyncChunks() {\n\t\tconst queue = new Set();\n\n\t\tconst initialChunks = intersect(\n\t\t\tArray.from(this.groupsIterable, g => new Set(g.chunks))\n\t\t);\n\n\t\tfor (const chunkGroup of this.groupsIterable) {\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tif (!initialChunks.has(chunk)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\n\t * @returns {Record<string, (string | number)[]>} a record object of names to lists of child ids(?)\n\t */\n\tgetChildIdsByOrders(chunkGraph, filterFn) {\n\t\t/** @type {Map<string, {order: number, group: ChunkGroup}[]>} */\n\t\tconst lists = new Map();\n\t\tfor (const group of this.groupsIterable) {\n\t\t\tif (group.chunks[group.chunks.length - 1] === this) {\n\t\t\t\tfor (const childGroup of group.childrenIterable) {\n\t\t\t\t\tfor (const key of Object.keys(childGroup.options)) {\n\t\t\t\t\t\tif (key.endsWith(\"Order\")) {\n\t\t\t\t\t\t\tconst name = key.substr(0, key.length - \"Order\".length);\n\t\t\t\t\t\t\tlet list = lists.get(name);\n\t\t\t\t\t\t\tif (list === undefined) {\n\t\t\t\t\t\t\t\tlist = [];\n\t\t\t\t\t\t\t\tlists.set(name, list);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlist.push({\n\t\t\t\t\t\t\t\torder: childGroup.options[key],\n\t\t\t\t\t\t\t\tgroup: childGroup\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/** @type {Record<string, (string | number)[]>} */\n\t\tconst result = Object.create(null);\n\t\tfor (const [name, list] of lists) {\n\t\t\tlist.sort((a, b) => {\n\t\t\t\tconst cmp = b.order - a.order;\n\t\t\t\tif (cmp !== 0) return cmp;\n\t\t\t\treturn a.group.compareTo(chunkGraph, b.group);\n\t\t\t});\n\t\t\t/** @type {Set<string | number>} */\n\t\t\tconst chunkIdSet = new Set();\n\t\t\tfor (const item of list) {\n\t\t\t\tfor (const chunk of item.group.chunks) {\n\t\t\t\t\tif (filterFn && !filterFn(chunk, chunkGraph)) continue;\n\t\t\t\t\tchunkIdSet.add(chunk.id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chunkIdSet.size > 0) {\n\t\t\t\tresult[name] = Array.from(chunkIdSet);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {string} type option name\n\t * @returns {{ onChunks: Chunk[], chunks: Set<Chunk> }[]} referenced chunks for a specific type\n\t */\n\tgetChildrenOfTypeInOrder(chunkGraph, type) {\n\t\tconst list = [];\n\t\tfor (const group of this.groupsIterable) {\n\t\t\tfor (const childGroup of group.childrenIterable) {\n\t\t\t\tconst order = childGroup.options[type];\n\t\t\t\tif (order === undefined) continue;\n\t\t\t\tlist.push({\n\t\t\t\t\torder,\n\t\t\t\t\tgroup,\n\t\t\t\t\tchildGroup\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (list.length === 0) return undefined;\n\t\tlist.sort((a, b) => {\n\t\t\tconst cmp = b.order - a.order;\n\t\t\tif (cmp !== 0) return cmp;\n\t\t\treturn a.group.compareTo(chunkGraph, b.group);\n\t\t});\n\t\tconst result = [];\n\t\tlet lastEntry;\n\t\tfor (const { group, childGroup } of list) {\n\t\t\tif (lastEntry && lastEntry.onChunks === group.chunks) {\n\t\t\t\tfor (const chunk of childGroup.chunks) {\n\t\t\t\t\tlastEntry.chunks.add(chunk);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult.push(\n\t\t\t\t\t(lastEntry = {\n\t\t\t\t\t\tonChunks: group.chunks,\n\t\t\t\t\t\tchunks: new Set(childGroup.chunks)\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {boolean=} includeDirectChildren include direct children (by default only children of async children are included)\n\t * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\n\t * @returns {Record<string|number, Record<string, (string | number)[]>>} a record object of names to lists of child ids(?) by chunk id\n\t */\n\tgetChildIdsByOrdersMap(chunkGraph, includeDirectChildren, filterFn) {\n\t\t/** @type {Record<string|number, Record<string, (string | number)[]>>} */\n\t\tconst chunkMaps = Object.create(null);\n\n\t\t/**\n\t\t * @param {Chunk} chunk a chunk\n\t\t * @returns {void}\n\t\t */\n\t\tconst addChildIdsByOrdersToMap = chunk => {\n\t\t\tconst data = chunk.getChildIdsByOrders(chunkGraph, filterFn);\n\t\t\tfor (const key of Object.keys(data)) {\n\t\t\t\tlet chunkMap = chunkMaps[key];\n\t\t\t\tif (chunkMap === undefined) {\n\t\t\t\t\tchunkMaps[key] = chunkMap = Object.create(null);\n\t\t\t\t}\n\t\t\t\tchunkMap[chunk.id] = data[key];\n\t\t\t}\n\t\t};\n\n\t\tif (includeDirectChildren) {\n\t\t\t/** @type {Set<Chunk>} */\n\t\t\tconst chunks = new Set();\n\t\t\tfor (const chunkGroup of this.groupsIterable) {\n\t\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\t\tchunks.add(chunk);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const chunk of chunks) {\n\t\t\t\taddChildIdsByOrdersToMap(chunk);\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunk of this.getAllAsyncChunks()) {\n\t\t\taddChildIdsByOrdersToMap(chunk);\n\t\t}\n\n\t\treturn chunkMaps;\n\t}\n}\n\nmodule.exports = Chunk;\n"]},"metadata":{},"sourceType":"script"}