{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/**\n * @template {any[]} T\n */\n\nclass TupleSet {\n  constructor(init) {\n    this._map = new Map();\n    this.size = 0;\n\n    if (init) {\n      for (const tuple of init) {\n        this.add(...tuple);\n      }\n    }\n  }\n  /**\n   * @param  {T} args tuple\n   * @returns {void}\n   */\n\n\n  add() {\n    var _ref, _ref2;\n\n    let map = this._map;\n\n    for (let i = 0; i < arguments.length - 2; i++) {\n      const arg = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      const innerMap = map.get(arg);\n\n      if (innerMap === undefined) {\n        map.set(arg, map = new Map());\n      } else {\n        map = innerMap;\n      }\n    }\n\n    const beforeLast = (_ref = arguments.length - 2, _ref < 0 || arguments.length <= _ref ? undefined : arguments[_ref]);\n    let set = map.get(beforeLast);\n\n    if (set === undefined) {\n      map.set(beforeLast, set = new Set());\n    }\n\n    const last = (_ref2 = arguments.length - 1, _ref2 < 0 || arguments.length <= _ref2 ? undefined : arguments[_ref2]);\n    this.size -= set.size;\n    set.add(last);\n    this.size += set.size;\n  }\n  /**\n   * @param  {T} args tuple\n   * @returns {boolean} true, if the tuple is in the Set\n   */\n\n\n  has() {\n    var _ref3, _ref4;\n\n    let map = this._map;\n\n    for (let i = 0; i < arguments.length - 2; i++) {\n      const arg = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      map = map.get(arg);\n\n      if (map === undefined) {\n        return false;\n      }\n    }\n\n    const beforeLast = (_ref3 = arguments.length - 2, _ref3 < 0 || arguments.length <= _ref3 ? undefined : arguments[_ref3]);\n    let set = map.get(beforeLast);\n\n    if (set === undefined) {\n      return false;\n    }\n\n    const last = (_ref4 = arguments.length - 1, _ref4 < 0 || arguments.length <= _ref4 ? undefined : arguments[_ref4]);\n    return set.has(last);\n  }\n  /**\n   * @param {T} args tuple\n   * @returns {void}\n   */\n\n\n  delete() {\n    var _ref5, _ref6;\n\n    let map = this._map;\n\n    for (let i = 0; i < arguments.length - 2; i++) {\n      const arg = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      map = map.get(arg);\n\n      if (map === undefined) {\n        return;\n      }\n    }\n\n    const beforeLast = (_ref5 = arguments.length - 2, _ref5 < 0 || arguments.length <= _ref5 ? undefined : arguments[_ref5]);\n    let set = map.get(beforeLast);\n\n    if (set === undefined) {\n      return;\n    }\n\n    const last = (_ref6 = arguments.length - 1, _ref6 < 0 || arguments.length <= _ref6 ? undefined : arguments[_ref6]);\n    this.size -= set.size;\n    set.delete(last);\n    this.size += set.size;\n  }\n  /**\n   * @returns {Iterator<T>} iterator\n   */\n\n\n  [Symbol.iterator]() {\n    const iteratorStack = [];\n    const tuple = [];\n    let currentSetIterator = undefined;\n\n    const next = it => {\n      const result = it.next();\n\n      if (result.done) {\n        if (iteratorStack.length === 0) return false;\n        tuple.pop();\n        return next(iteratorStack.pop());\n      }\n\n      const [key, value] = result.value;\n      iteratorStack.push(it);\n      tuple.push(key);\n\n      if (value instanceof Set) {\n        currentSetIterator = value[Symbol.iterator]();\n        return true;\n      } else {\n        return next(value[Symbol.iterator]());\n      }\n    };\n\n    next(this._map[Symbol.iterator]());\n    return {\n      next() {\n        while (currentSetIterator) {\n          const result = currentSetIterator.next();\n\n          if (result.done) {\n            tuple.pop();\n\n            if (!next(iteratorStack.pop())) {\n              currentSetIterator = undefined;\n            }\n          } else {\n            return {\n              done: false,\n              value:\n              /** @type {T} */\n              tuple.concat(result.value)\n            };\n          }\n        }\n\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n\n    };\n  }\n\n}\n\nmodule.exports = TupleSet;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/util/TupleSet.js"],"names":["TupleSet","constructor","init","_map","Map","size","tuple","add","map","i","length","arg","innerMap","get","undefined","set","beforeLast","Set","last","has","delete","Symbol","iterator","iteratorStack","currentSetIterator","next","it","result","done","pop","key","value","push","concat","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/**\n * @template {any[]} T\n */\nclass TupleSet {\n\tconstructor(init) {\n\t\tthis._map = new Map();\n\t\tthis.size = 0;\n\t\tif (init) {\n\t\t\tfor (const tuple of init) {\n\t\t\t\tthis.add(...tuple);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param  {T} args tuple\n\t * @returns {void}\n\t */\n\tadd(...args) {\n\t\tlet map = this._map;\n\t\tfor (let i = 0; i < args.length - 2; i++) {\n\t\t\tconst arg = args[i];\n\t\t\tconst innerMap = map.get(arg);\n\t\t\tif (innerMap === undefined) {\n\t\t\t\tmap.set(arg, (map = new Map()));\n\t\t\t} else {\n\t\t\t\tmap = innerMap;\n\t\t\t}\n\t\t}\n\n\t\tconst beforeLast = args[args.length - 2];\n\t\tlet set = map.get(beforeLast);\n\t\tif (set === undefined) {\n\t\t\tmap.set(beforeLast, (set = new Set()));\n\t\t}\n\n\t\tconst last = args[args.length - 1];\n\t\tthis.size -= set.size;\n\t\tset.add(last);\n\t\tthis.size += set.size;\n\t}\n\n\t/**\n\t * @param  {T} args tuple\n\t * @returns {boolean} true, if the tuple is in the Set\n\t */\n\thas(...args) {\n\t\tlet map = this._map;\n\t\tfor (let i = 0; i < args.length - 2; i++) {\n\t\t\tconst arg = args[i];\n\t\t\tmap = map.get(arg);\n\t\t\tif (map === undefined) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tconst beforeLast = args[args.length - 2];\n\t\tlet set = map.get(beforeLast);\n\t\tif (set === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst last = args[args.length - 1];\n\t\treturn set.has(last);\n\t}\n\n\t/**\n\t * @param {T} args tuple\n\t * @returns {void}\n\t */\n\tdelete(...args) {\n\t\tlet map = this._map;\n\t\tfor (let i = 0; i < args.length - 2; i++) {\n\t\t\tconst arg = args[i];\n\t\t\tmap = map.get(arg);\n\t\t\tif (map === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst beforeLast = args[args.length - 2];\n\t\tlet set = map.get(beforeLast);\n\t\tif (set === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst last = args[args.length - 1];\n\t\tthis.size -= set.size;\n\t\tset.delete(last);\n\t\tthis.size += set.size;\n\t}\n\n\t/**\n\t * @returns {Iterator<T>} iterator\n\t */\n\t[Symbol.iterator]() {\n\t\tconst iteratorStack = [];\n\t\tconst tuple = [];\n\t\tlet currentSetIterator = undefined;\n\n\t\tconst next = it => {\n\t\t\tconst result = it.next();\n\t\t\tif (result.done) {\n\t\t\t\tif (iteratorStack.length === 0) return false;\n\t\t\t\ttuple.pop();\n\t\t\t\treturn next(iteratorStack.pop());\n\t\t\t}\n\t\t\tconst [key, value] = result.value;\n\t\t\titeratorStack.push(it);\n\t\t\ttuple.push(key);\n\t\t\tif (value instanceof Set) {\n\t\t\t\tcurrentSetIterator = value[Symbol.iterator]();\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn next(value[Symbol.iterator]());\n\t\t\t}\n\t\t};\n\n\t\tnext(this._map[Symbol.iterator]());\n\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\twhile (currentSetIterator) {\n\t\t\t\t\tconst result = currentSetIterator.next();\n\t\t\t\t\tif (result.done) {\n\t\t\t\t\t\ttuple.pop();\n\t\t\t\t\t\tif (!next(iteratorStack.pop())) {\n\t\t\t\t\t\t\tcurrentSetIterator = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\t\tvalue: /** @type {T} */ (tuple.concat(result.value))\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn { done: true, value: undefined };\n\t\t\t}\n\t\t};\n\t}\n}\n\nmodule.exports = TupleSet;\n"]},"metadata":{},"sourceType":"script"}