{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst EventEmitter = require(\"events\").EventEmitter;\n\nconst fs = require(\"graceful-fs\");\n\nconst path = require(\"path\");\n\nconst watchEventSource = require(\"./watchEventSource\");\n\nconst EXISTANCE_ONLY_TIME_ENTRY = Object.freeze({});\nlet FS_ACCURACY = 1000;\nconst IS_OSX = require(\"os\").platform() === \"darwin\";\nconst WATCHPACK_POLLING = process.env.WATCHPACK_POLLING;\nconst FORCE_POLLING = `${+WATCHPACK_POLLING}` === WATCHPACK_POLLING ? +WATCHPACK_POLLING : !!WATCHPACK_POLLING && WATCHPACK_POLLING !== \"false\";\n\nfunction withoutCase(str) {\n  return str.toLowerCase();\n}\n\nfunction needCalls(times, callback) {\n  return function () {\n    if (--times === 0) {\n      return callback();\n    }\n  };\n}\n\nclass Watcher extends EventEmitter {\n  constructor(directoryWatcher, filePath, startTime) {\n    super();\n    this.directoryWatcher = directoryWatcher;\n    this.path = filePath;\n    this.startTime = startTime && +startTime;\n  }\n\n  checkStartTime(mtime, initial) {\n    const startTime = this.startTime;\n    if (typeof startTime !== \"number\") return !initial;\n    return startTime <= mtime;\n  }\n\n  close() {\n    this.emit(\"closed\");\n  }\n\n}\n\nclass DirectoryWatcher extends EventEmitter {\n  constructor(watcherManager, directoryPath, options) {\n    super();\n\n    if (FORCE_POLLING) {\n      options.poll = FORCE_POLLING;\n    }\n\n    this.watcherManager = watcherManager;\n    this.options = options;\n    this.path = directoryPath; // safeTime is the point in time after which reading is safe to be unchanged\n    // timestamp is a value that should be compared with another timestamp (mtime)\n\n    /** @type {Map<string, { safeTime: number, timestamp: number }} */\n\n    this.files = new Map();\n    /** @type {Map<string, number>} */\n\n    this.filesWithoutCase = new Map();\n    this.directories = new Map();\n    this.lastWatchEvent = 0;\n    this.initialScan = true;\n\n    this.ignored = options.ignored || (() => false);\n\n    this.nestedWatching = false;\n    this.polledWatching = typeof options.poll === \"number\" ? options.poll : options.poll ? 5007 : false;\n    this.timeout = undefined;\n    this.initialScanRemoved = new Set();\n    this.initialScanFinished = undefined;\n    /** @type {Map<string, Set<Watcher>>} */\n\n    this.watchers = new Map();\n    this.parentWatcher = null;\n    this.refs = 0;\n    this._activeEvents = new Map();\n    this.closed = false;\n    this.scanning = false;\n    this.scanAgain = false;\n    this.scanAgainInitial = false;\n    this.createWatcher();\n    this.doScan(true);\n  }\n\n  createWatcher() {\n    try {\n      if (this.polledWatching) {\n        this.watcher = {\n          close: () => {\n            if (this.timeout) {\n              clearTimeout(this.timeout);\n              this.timeout = undefined;\n            }\n          }\n        };\n      } else {\n        if (IS_OSX) {\n          this.watchInParentDirectory();\n        }\n\n        this.watcher = watchEventSource.watch(this.path);\n        this.watcher.on(\"change\", this.onWatchEvent.bind(this));\n        this.watcher.on(\"error\", this.onWatcherError.bind(this));\n      }\n    } catch (err) {\n      this.onWatcherError(err);\n    }\n  }\n\n  forEachWatcher(path, fn) {\n    const watchers = this.watchers.get(withoutCase(path));\n\n    if (watchers !== undefined) {\n      for (const w of watchers) {\n        fn(w);\n      }\n    }\n  }\n\n  setMissing(itemPath, initial, type) {\n    if (this.initialScan) {\n      this.initialScanRemoved.add(itemPath);\n    }\n\n    const oldDirectory = this.directories.get(itemPath);\n\n    if (oldDirectory) {\n      if (this.nestedWatching) oldDirectory.close();\n      this.directories.delete(itemPath);\n      this.forEachWatcher(itemPath, w => w.emit(\"remove\", type));\n\n      if (!initial) {\n        this.forEachWatcher(this.path, w => w.emit(\"change\", itemPath, null, type, initial));\n      }\n    }\n\n    const oldFile = this.files.get(itemPath);\n\n    if (oldFile) {\n      this.files.delete(itemPath);\n      const key = withoutCase(itemPath);\n      const count = this.filesWithoutCase.get(key) - 1;\n\n      if (count <= 0) {\n        this.filesWithoutCase.delete(key);\n        this.forEachWatcher(itemPath, w => w.emit(\"remove\", type));\n      } else {\n        this.filesWithoutCase.set(key, count);\n      }\n\n      if (!initial) {\n        this.forEachWatcher(this.path, w => w.emit(\"change\", itemPath, null, type, initial));\n      }\n    }\n  }\n\n  setFileTime(filePath, mtime, initial, ignoreWhenEqual, type) {\n    const now = Date.now();\n    if (this.ignored(filePath)) return;\n    const old = this.files.get(filePath);\n    let safeTime, accuracy;\n\n    if (initial) {\n      safeTime = Math.min(now, mtime) + FS_ACCURACY;\n      accuracy = FS_ACCURACY;\n    } else {\n      safeTime = now;\n      accuracy = 0;\n\n      if (old && old.timestamp === mtime && mtime + FS_ACCURACY < now - 1000) {\n        // We are sure that mtime is untouched\n        // This can be caused by some file attribute change\n        // e. g. when access time has been changed\n        // but the file content is untouched\n        return;\n      }\n    }\n\n    if (ignoreWhenEqual && old && old.timestamp === mtime) return;\n    this.files.set(filePath, {\n      safeTime,\n      accuracy,\n      timestamp: mtime\n    });\n\n    if (!old) {\n      const key = withoutCase(filePath);\n      const count = this.filesWithoutCase.get(key);\n      this.filesWithoutCase.set(key, (count || 0) + 1);\n\n      if (count !== undefined) {\n        // There is already a file with case-insensitive-equal name\n        // On a case-insensitive filesystem we may miss the renaming\n        // when only casing is changed.\n        // To be sure that our information is correct\n        // we trigger a rescan here\n        this.doScan(false);\n      }\n\n      this.forEachWatcher(filePath, w => {\n        if (!initial || w.checkStartTime(safeTime, initial)) {\n          w.emit(\"change\", mtime, type);\n        }\n      });\n    } else if (!initial) {\n      this.forEachWatcher(filePath, w => w.emit(\"change\", mtime, type));\n    }\n\n    this.forEachWatcher(this.path, w => {\n      if (!initial || w.checkStartTime(safeTime, initial)) {\n        w.emit(\"change\", filePath, safeTime, type, initial);\n      }\n    });\n  }\n\n  setDirectory(directoryPath, birthtime, initial, type) {\n    if (this.ignored(directoryPath)) return;\n\n    if (directoryPath === this.path) {\n      if (!initial) {\n        this.forEachWatcher(this.path, w => w.emit(\"change\", directoryPath, birthtime, type, initial));\n      }\n    } else {\n      const old = this.directories.get(directoryPath);\n\n      if (!old) {\n        const now = Date.now();\n\n        if (this.nestedWatching) {\n          this.createNestedWatcher(directoryPath);\n        } else {\n          this.directories.set(directoryPath, true);\n        }\n\n        let safeTime;\n\n        if (initial) {\n          safeTime = Math.min(now, birthtime) + FS_ACCURACY;\n        } else {\n          safeTime = now;\n        }\n\n        this.forEachWatcher(directoryPath, w => {\n          if (!initial || w.checkStartTime(safeTime, false)) {\n            w.emit(\"change\", birthtime, type);\n          }\n        });\n        this.forEachWatcher(this.path, w => {\n          if (!initial || w.checkStartTime(safeTime, initial)) {\n            w.emit(\"change\", directoryPath, safeTime, type, initial);\n          }\n        });\n      }\n    }\n  }\n\n  createNestedWatcher(directoryPath) {\n    const watcher = this.watcherManager.watchDirectory(directoryPath, 1);\n    watcher.on(\"change\", (filePath, mtime, type, initial) => {\n      this.forEachWatcher(this.path, w => {\n        if (!initial || w.checkStartTime(mtime, initial)) {\n          w.emit(\"change\", filePath, mtime, type, initial);\n        }\n      });\n    });\n    this.directories.set(directoryPath, watcher);\n  }\n\n  setNestedWatching(flag) {\n    if (this.nestedWatching !== !!flag) {\n      this.nestedWatching = !!flag;\n\n      if (this.nestedWatching) {\n        for (const directory of this.directories.keys()) {\n          this.createNestedWatcher(directory);\n        }\n      } else {\n        for (const [directory, watcher] of this.directories) {\n          watcher.close();\n          this.directories.set(directory, true);\n        }\n      }\n    }\n  }\n\n  watch(filePath, startTime) {\n    const key = withoutCase(filePath);\n    let watchers = this.watchers.get(key);\n\n    if (watchers === undefined) {\n      watchers = new Set();\n      this.watchers.set(key, watchers);\n    }\n\n    this.refs++;\n    const watcher = new Watcher(this, filePath, startTime);\n    watcher.on(\"closed\", () => {\n      if (--this.refs <= 0) {\n        this.close();\n        return;\n      }\n\n      watchers.delete(watcher);\n\n      if (watchers.size === 0) {\n        this.watchers.delete(key);\n        if (this.path === filePath) this.setNestedWatching(false);\n      }\n    });\n    watchers.add(watcher);\n    let safeTime;\n\n    if (filePath === this.path) {\n      this.setNestedWatching(true);\n      safeTime = this.lastWatchEvent;\n\n      for (const entry of this.files.values()) {\n        fixupEntryAccuracy(entry);\n        safeTime = Math.max(safeTime, entry.safeTime);\n      }\n    } else {\n      const entry = this.files.get(filePath);\n\n      if (entry) {\n        fixupEntryAccuracy(entry);\n        safeTime = entry.safeTime;\n      } else {\n        safeTime = 0;\n      }\n    }\n\n    if (safeTime) {\n      if (safeTime >= startTime) {\n        process.nextTick(() => {\n          if (this.closed) return;\n\n          if (filePath === this.path) {\n            watcher.emit(\"change\", filePath, safeTime, \"watch (outdated on attach)\", true);\n          } else {\n            watcher.emit(\"change\", safeTime, \"watch (outdated on attach)\", true);\n          }\n        });\n      }\n    } else if (this.initialScan) {\n      if (this.initialScanRemoved.has(filePath)) {\n        process.nextTick(() => {\n          if (this.closed) return;\n          watcher.emit(\"remove\");\n        });\n      }\n    } else if (!this.directories.has(filePath) && watcher.checkStartTime(this.initialScanFinished, false)) {\n      process.nextTick(() => {\n        if (this.closed) return;\n        watcher.emit(\"initial-missing\", \"watch (missing on attach)\");\n      });\n    }\n\n    return watcher;\n  }\n\n  onWatchEvent(eventType, filename) {\n    if (this.closed) return;\n\n    if (!filename) {\n      // In some cases no filename is provided\n      // This seem to happen on windows\n      // So some event happened but we don't know which file is affected\n      // We have to do a full scan of the directory\n      this.doScan(false);\n      return;\n    }\n\n    const filePath = path.join(this.path, filename);\n    if (this.ignored(filePath)) return;\n\n    if (this._activeEvents.get(filename) === undefined) {\n      this._activeEvents.set(filename, false);\n\n      const checkStats = () => {\n        if (this.closed) return;\n\n        this._activeEvents.set(filename, false);\n\n        fs.lstat(filePath, (err, stats) => {\n          if (this.closed) return;\n\n          if (this._activeEvents.get(filename) === true) {\n            process.nextTick(checkStats);\n            return;\n          }\n\n          this._activeEvents.delete(filename); // ENOENT happens when the file/directory doesn't exist\n          // EPERM happens when the containing directory doesn't exist\n\n\n          if (err) {\n            if (err.code !== \"ENOENT\" && err.code !== \"EPERM\" && err.code !== \"EBUSY\") {\n              this.onStatsError(err);\n            } else {\n              if (filename === path.basename(this.path)) {\n                // This may indicate that the directory itself was removed\n                if (!fs.existsSync(this.path)) {\n                  this.onDirectoryRemoved(\"stat failed\");\n                }\n              }\n            }\n          }\n\n          this.lastWatchEvent = Date.now();\n\n          if (!stats) {\n            this.setMissing(filePath, false, eventType);\n          } else if (stats.isDirectory()) {\n            this.setDirectory(filePath, +stats.birthtime || 1, false, eventType);\n          } else if (stats.isFile() || stats.isSymbolicLink()) {\n            if (stats.mtime) {\n              ensureFsAccuracy(stats.mtime);\n            }\n\n            this.setFileTime(filePath, +stats.mtime || +stats.ctime || 1, false, false, eventType);\n          }\n        });\n      };\n\n      process.nextTick(checkStats);\n    } else {\n      this._activeEvents.set(filename, true);\n    }\n  }\n\n  onWatcherError(err) {\n    if (this.closed) return;\n\n    if (err) {\n      if (err.code !== \"EPERM\" && err.code !== \"ENOENT\") {\n        console.error(\"Watchpack Error (watcher): \" + err);\n      }\n\n      this.onDirectoryRemoved(\"watch error\");\n    }\n  }\n\n  onStatsError(err) {\n    if (err) {\n      console.error(\"Watchpack Error (stats): \" + err);\n    }\n  }\n\n  onScanError(err) {\n    if (err) {\n      console.error(\"Watchpack Error (initial scan): \" + err);\n    }\n\n    this.onScanFinished();\n  }\n\n  onScanFinished() {\n    if (this.polledWatching) {\n      this.timeout = setTimeout(() => {\n        if (this.closed) return;\n        this.doScan(false);\n      }, this.polledWatching);\n    }\n  }\n\n  onDirectoryRemoved(reason) {\n    if (this.watcher) {\n      this.watcher.close();\n      this.watcher = null;\n    }\n\n    this.watchInParentDirectory();\n    const type = `directory-removed (${reason})`;\n\n    for (const directory of this.directories.keys()) {\n      this.setMissing(directory, null, type);\n    }\n\n    for (const file of this.files.keys()) {\n      this.setMissing(file, null, type);\n    }\n  }\n\n  watchInParentDirectory() {\n    if (!this.parentWatcher) {\n      const parentDir = path.dirname(this.path); // avoid watching in the root directory\n      // removing directories in the root directory is not supported\n\n      if (path.dirname(parentDir) === parentDir) return;\n      this.parentWatcher = this.watcherManager.watchFile(this.path, 1);\n      this.parentWatcher.on(\"change\", (mtime, type) => {\n        if (this.closed) return; // On non-osx platforms we don't need this watcher to detect\n        // directory removal, as an EPERM error indicates that\n\n        if ((!IS_OSX || this.polledWatching) && this.parentWatcher) {\n          this.parentWatcher.close();\n          this.parentWatcher = null;\n        } // Try to create the watcher when parent directory is found\n\n\n        if (!this.watcher) {\n          this.createWatcher();\n          this.doScan(false); // directory was created so we emit an event\n\n          this.forEachWatcher(this.path, w => w.emit(\"change\", this.path, mtime, type, false));\n        }\n      });\n      this.parentWatcher.on(\"remove\", () => {\n        this.onDirectoryRemoved(\"parent directory removed\");\n      });\n    }\n  }\n\n  doScan(initial) {\n    if (this.scanning) {\n      if (this.scanAgain) {\n        if (!initial) this.scanAgainInitial = false;\n      } else {\n        this.scanAgain = true;\n        this.scanAgainInitial = initial;\n      }\n\n      return;\n    }\n\n    this.scanning = true;\n\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n      this.timeout = undefined;\n    }\n\n    process.nextTick(() => {\n      if (this.closed) return;\n      fs.readdir(this.path, (err, items) => {\n        if (this.closed) return;\n\n        if (err) {\n          if (err.code === \"ENOENT\" || err.code === \"EPERM\") {\n            this.onDirectoryRemoved(\"scan readdir failed\");\n          } else {\n            this.onScanError(err);\n          }\n\n          this.initialScan = false;\n          this.initialScanFinished = Date.now();\n\n          if (initial) {\n            for (const watchers of this.watchers.values()) {\n              for (const watcher of watchers) {\n                if (watcher.checkStartTime(this.initialScanFinished, false)) {\n                  watcher.emit(\"initial-missing\", \"scan (parent directory missing in initial scan)\");\n                }\n              }\n            }\n          }\n\n          if (this.scanAgain) {\n            this.scanAgain = false;\n            this.doScan(this.scanAgainInitial);\n          } else {\n            this.scanning = false;\n          }\n\n          return;\n        }\n\n        const itemPaths = new Set(items.map(item => path.join(this.path, item.normalize(\"NFC\"))));\n\n        for (const file of this.files.keys()) {\n          if (!itemPaths.has(file)) {\n            this.setMissing(file, initial, \"scan (missing)\");\n          }\n        }\n\n        for (const directory of this.directories.keys()) {\n          if (!itemPaths.has(directory)) {\n            this.setMissing(directory, initial, \"scan (missing)\");\n          }\n        }\n\n        if (this.scanAgain) {\n          // Early repeat of scan\n          this.scanAgain = false;\n          this.doScan(initial);\n          return;\n        }\n\n        const itemFinished = needCalls(itemPaths.size + 1, () => {\n          if (this.closed) return;\n          this.initialScan = false;\n          this.initialScanRemoved = null;\n          this.initialScanFinished = Date.now();\n\n          if (initial) {\n            const missingWatchers = new Map(this.watchers);\n            missingWatchers.delete(withoutCase(this.path));\n\n            for (const item of itemPaths) {\n              missingWatchers.delete(withoutCase(item));\n            }\n\n            for (const watchers of missingWatchers.values()) {\n              for (const watcher of watchers) {\n                if (watcher.checkStartTime(this.initialScanFinished, false)) {\n                  watcher.emit(\"initial-missing\", \"scan (missing in initial scan)\");\n                }\n              }\n            }\n          }\n\n          if (this.scanAgain) {\n            this.scanAgain = false;\n            this.doScan(this.scanAgainInitial);\n          } else {\n            this.scanning = false;\n            this.onScanFinished();\n          }\n        });\n\n        for (const itemPath of itemPaths) {\n          fs.lstat(itemPath, (err2, stats) => {\n            if (this.closed) return;\n\n            if (err2) {\n              if (err2.code === \"ENOENT\" || err2.code === \"EPERM\" || err2.code === \"EACCES\" || err2.code === \"EBUSY\") {\n                this.setMissing(itemPath, initial, \"scan (\" + err2.code + \")\");\n              } else {\n                this.onScanError(err2);\n              }\n\n              itemFinished();\n              return;\n            }\n\n            if (stats.isFile() || stats.isSymbolicLink()) {\n              if (stats.mtime) {\n                ensureFsAccuracy(stats.mtime);\n              }\n\n              this.setFileTime(itemPath, +stats.mtime || +stats.ctime || 1, initial, true, \"scan (file)\");\n            } else if (stats.isDirectory()) {\n              if (!initial || !this.directories.has(itemPath)) this.setDirectory(itemPath, +stats.birthtime || 1, initial, \"scan (dir)\");\n            }\n\n            itemFinished();\n          });\n        }\n\n        itemFinished();\n      });\n    });\n  }\n\n  getTimes() {\n    const obj = Object.create(null);\n    let safeTime = this.lastWatchEvent;\n\n    for (const [file, entry] of this.files) {\n      fixupEntryAccuracy(entry);\n      safeTime = Math.max(safeTime, entry.safeTime);\n      obj[file] = Math.max(entry.safeTime, entry.timestamp);\n    }\n\n    if (this.nestedWatching) {\n      for (const w of this.directories.values()) {\n        const times = w.directoryWatcher.getTimes();\n\n        for (const file of Object.keys(times)) {\n          const time = times[file];\n          safeTime = Math.max(safeTime, time);\n          obj[file] = time;\n        }\n      }\n\n      obj[this.path] = safeTime;\n    }\n\n    if (!this.initialScan) {\n      for (const watchers of this.watchers.values()) {\n        for (const watcher of watchers) {\n          const path = watcher.path;\n\n          if (!Object.prototype.hasOwnProperty.call(obj, path)) {\n            obj[path] = null;\n          }\n        }\n      }\n    }\n\n    return obj;\n  }\n\n  collectTimeInfoEntries(fileTimestamps, directoryTimestamps) {\n    let safeTime = this.lastWatchEvent;\n\n    for (const [file, entry] of this.files) {\n      fixupEntryAccuracy(entry);\n      safeTime = Math.max(safeTime, entry.safeTime);\n      fileTimestamps.set(file, entry);\n    }\n\n    if (this.nestedWatching) {\n      for (const w of this.directories.values()) {\n        safeTime = Math.max(safeTime, w.directoryWatcher.collectTimeInfoEntries(fileTimestamps, directoryTimestamps));\n      }\n\n      fileTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY);\n      directoryTimestamps.set(this.path, {\n        safeTime\n      });\n    } else {\n      for (const dir of this.directories.keys()) {\n        // No additional info about this directory\n        // but maybe another DirectoryWatcher has info\n        fileTimestamps.set(dir, EXISTANCE_ONLY_TIME_ENTRY);\n        if (!directoryTimestamps.has(dir)) directoryTimestamps.set(dir, EXISTANCE_ONLY_TIME_ENTRY);\n      }\n\n      fileTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY);\n      directoryTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY);\n    }\n\n    if (!this.initialScan) {\n      for (const watchers of this.watchers.values()) {\n        for (const watcher of watchers) {\n          const path = watcher.path;\n\n          if (!fileTimestamps.has(path)) {\n            fileTimestamps.set(path, null);\n          }\n        }\n      }\n    }\n\n    return safeTime;\n  }\n\n  close() {\n    this.closed = true;\n    this.initialScan = false;\n\n    if (this.watcher) {\n      this.watcher.close();\n      this.watcher = null;\n    }\n\n    if (this.nestedWatching) {\n      for (const w of this.directories.values()) {\n        w.close();\n      }\n\n      this.directories.clear();\n    }\n\n    if (this.parentWatcher) {\n      this.parentWatcher.close();\n      this.parentWatcher = null;\n    }\n\n    this.emit(\"closed\");\n  }\n\n}\n\nmodule.exports = DirectoryWatcher;\nmodule.exports.EXISTANCE_ONLY_TIME_ENTRY = EXISTANCE_ONLY_TIME_ENTRY;\n\nfunction fixupEntryAccuracy(entry) {\n  if (entry.accuracy > FS_ACCURACY) {\n    entry.safeTime = entry.safeTime - entry.accuracy + FS_ACCURACY;\n    entry.accuracy = FS_ACCURACY;\n  }\n}\n\nfunction ensureFsAccuracy(mtime) {\n  if (!mtime) return;\n  if (FS_ACCURACY > 1 && mtime % 1 !== 0) FS_ACCURACY = 1;else if (FS_ACCURACY > 10 && mtime % 10 !== 0) FS_ACCURACY = 10;else if (FS_ACCURACY > 100 && mtime % 100 !== 0) FS_ACCURACY = 100;\n}","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/watchpack/lib/DirectoryWatcher.js"],"names":["EventEmitter","require","fs","path","watchEventSource","EXISTANCE_ONLY_TIME_ENTRY","Object","freeze","FS_ACCURACY","IS_OSX","platform","WATCHPACK_POLLING","process","env","FORCE_POLLING","withoutCase","str","toLowerCase","needCalls","times","callback","Watcher","constructor","directoryWatcher","filePath","startTime","checkStartTime","mtime","initial","close","emit","DirectoryWatcher","watcherManager","directoryPath","options","poll","files","Map","filesWithoutCase","directories","lastWatchEvent","initialScan","ignored","nestedWatching","polledWatching","timeout","undefined","initialScanRemoved","Set","initialScanFinished","watchers","parentWatcher","refs","_activeEvents","closed","scanning","scanAgain","scanAgainInitial","createWatcher","doScan","watcher","clearTimeout","watchInParentDirectory","watch","on","onWatchEvent","bind","onWatcherError","err","forEachWatcher","fn","get","w","setMissing","itemPath","type","add","oldDirectory","delete","oldFile","key","count","set","setFileTime","ignoreWhenEqual","now","Date","old","safeTime","accuracy","Math","min","timestamp","setDirectory","birthtime","createNestedWatcher","watchDirectory","setNestedWatching","flag","directory","keys","size","entry","values","fixupEntryAccuracy","max","nextTick","has","eventType","filename","join","checkStats","lstat","stats","code","onStatsError","basename","existsSync","onDirectoryRemoved","isDirectory","isFile","isSymbolicLink","ensureFsAccuracy","ctime","console","error","onScanError","onScanFinished","setTimeout","reason","file","parentDir","dirname","watchFile","readdir","items","itemPaths","map","item","normalize","itemFinished","missingWatchers","err2","getTimes","obj","create","time","prototype","hasOwnProperty","call","collectTimeInfoEntries","fileTimestamps","directoryTimestamps","dir","clear","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst EventEmitter = require(\"events\").EventEmitter;\nconst fs = require(\"graceful-fs\");\nconst path = require(\"path\");\n\nconst watchEventSource = require(\"./watchEventSource\");\n\nconst EXISTANCE_ONLY_TIME_ENTRY = Object.freeze({});\n\nlet FS_ACCURACY = 1000;\n\nconst IS_OSX = require(\"os\").platform() === \"darwin\";\nconst WATCHPACK_POLLING = process.env.WATCHPACK_POLLING;\nconst FORCE_POLLING =\n\t`${+WATCHPACK_POLLING}` === WATCHPACK_POLLING\n\t\t? +WATCHPACK_POLLING\n\t\t: !!WATCHPACK_POLLING && WATCHPACK_POLLING !== \"false\";\n\nfunction withoutCase(str) {\n\treturn str.toLowerCase();\n}\n\nfunction needCalls(times, callback) {\n\treturn function() {\n\t\tif (--times === 0) {\n\t\t\treturn callback();\n\t\t}\n\t};\n}\n\nclass Watcher extends EventEmitter {\n\tconstructor(directoryWatcher, filePath, startTime) {\n\t\tsuper();\n\t\tthis.directoryWatcher = directoryWatcher;\n\t\tthis.path = filePath;\n\t\tthis.startTime = startTime && +startTime;\n\t}\n\n\tcheckStartTime(mtime, initial) {\n\t\tconst startTime = this.startTime;\n\t\tif (typeof startTime !== \"number\") return !initial;\n\t\treturn startTime <= mtime;\n\t}\n\n\tclose() {\n\t\tthis.emit(\"closed\");\n\t}\n}\n\nclass DirectoryWatcher extends EventEmitter {\n\tconstructor(watcherManager, directoryPath, options) {\n\t\tsuper();\n\t\tif (FORCE_POLLING) {\n\t\t\toptions.poll = FORCE_POLLING;\n\t\t}\n\t\tthis.watcherManager = watcherManager;\n\t\tthis.options = options;\n\t\tthis.path = directoryPath;\n\t\t// safeTime is the point in time after which reading is safe to be unchanged\n\t\t// timestamp is a value that should be compared with another timestamp (mtime)\n\t\t/** @type {Map<string, { safeTime: number, timestamp: number }} */\n\t\tthis.files = new Map();\n\t\t/** @type {Map<string, number>} */\n\t\tthis.filesWithoutCase = new Map();\n\t\tthis.directories = new Map();\n\t\tthis.lastWatchEvent = 0;\n\t\tthis.initialScan = true;\n\t\tthis.ignored = options.ignored || (() => false);\n\t\tthis.nestedWatching = false;\n\t\tthis.polledWatching =\n\t\t\ttypeof options.poll === \"number\"\n\t\t\t\t? options.poll\n\t\t\t\t: options.poll\n\t\t\t\t? 5007\n\t\t\t\t: false;\n\t\tthis.timeout = undefined;\n\t\tthis.initialScanRemoved = new Set();\n\t\tthis.initialScanFinished = undefined;\n\t\t/** @type {Map<string, Set<Watcher>>} */\n\t\tthis.watchers = new Map();\n\t\tthis.parentWatcher = null;\n\t\tthis.refs = 0;\n\t\tthis._activeEvents = new Map();\n\t\tthis.closed = false;\n\t\tthis.scanning = false;\n\t\tthis.scanAgain = false;\n\t\tthis.scanAgainInitial = false;\n\n\t\tthis.createWatcher();\n\t\tthis.doScan(true);\n\t}\n\n\tcreateWatcher() {\n\t\ttry {\n\t\t\tif (this.polledWatching) {\n\t\t\t\tthis.watcher = {\n\t\t\t\t\tclose: () => {\n\t\t\t\t\t\tif (this.timeout) {\n\t\t\t\t\t\t\tclearTimeout(this.timeout);\n\t\t\t\t\t\t\tthis.timeout = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tif (IS_OSX) {\n\t\t\t\t\tthis.watchInParentDirectory();\n\t\t\t\t}\n\t\t\t\tthis.watcher = watchEventSource.watch(this.path);\n\t\t\t\tthis.watcher.on(\"change\", this.onWatchEvent.bind(this));\n\t\t\t\tthis.watcher.on(\"error\", this.onWatcherError.bind(this));\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tthis.onWatcherError(err);\n\t\t}\n\t}\n\n\tforEachWatcher(path, fn) {\n\t\tconst watchers = this.watchers.get(withoutCase(path));\n\t\tif (watchers !== undefined) {\n\t\t\tfor (const w of watchers) {\n\t\t\t\tfn(w);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetMissing(itemPath, initial, type) {\n\t\tif (this.initialScan) {\n\t\t\tthis.initialScanRemoved.add(itemPath);\n\t\t}\n\n\t\tconst oldDirectory = this.directories.get(itemPath);\n\t\tif (oldDirectory) {\n\t\t\tif (this.nestedWatching) oldDirectory.close();\n\t\t\tthis.directories.delete(itemPath);\n\n\t\t\tthis.forEachWatcher(itemPath, w => w.emit(\"remove\", type));\n\t\t\tif (!initial) {\n\t\t\t\tthis.forEachWatcher(this.path, w =>\n\t\t\t\t\tw.emit(\"change\", itemPath, null, type, initial)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst oldFile = this.files.get(itemPath);\n\t\tif (oldFile) {\n\t\t\tthis.files.delete(itemPath);\n\t\t\tconst key = withoutCase(itemPath);\n\t\t\tconst count = this.filesWithoutCase.get(key) - 1;\n\t\t\tif (count <= 0) {\n\t\t\t\tthis.filesWithoutCase.delete(key);\n\t\t\t\tthis.forEachWatcher(itemPath, w => w.emit(\"remove\", type));\n\t\t\t} else {\n\t\t\t\tthis.filesWithoutCase.set(key, count);\n\t\t\t}\n\n\t\t\tif (!initial) {\n\t\t\t\tthis.forEachWatcher(this.path, w =>\n\t\t\t\t\tw.emit(\"change\", itemPath, null, type, initial)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetFileTime(filePath, mtime, initial, ignoreWhenEqual, type) {\n\t\tconst now = Date.now();\n\n\t\tif (this.ignored(filePath)) return;\n\n\t\tconst old = this.files.get(filePath);\n\n\t\tlet safeTime, accuracy;\n\t\tif (initial) {\n\t\t\tsafeTime = Math.min(now, mtime) + FS_ACCURACY;\n\t\t\taccuracy = FS_ACCURACY;\n\t\t} else {\n\t\t\tsafeTime = now;\n\t\t\taccuracy = 0;\n\n\t\t\tif (old && old.timestamp === mtime && mtime + FS_ACCURACY < now - 1000) {\n\t\t\t\t// We are sure that mtime is untouched\n\t\t\t\t// This can be caused by some file attribute change\n\t\t\t\t// e. g. when access time has been changed\n\t\t\t\t// but the file content is untouched\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (ignoreWhenEqual && old && old.timestamp === mtime) return;\n\n\t\tthis.files.set(filePath, {\n\t\t\tsafeTime,\n\t\t\taccuracy,\n\t\t\ttimestamp: mtime\n\t\t});\n\n\t\tif (!old) {\n\t\t\tconst key = withoutCase(filePath);\n\t\t\tconst count = this.filesWithoutCase.get(key);\n\t\t\tthis.filesWithoutCase.set(key, (count || 0) + 1);\n\t\t\tif (count !== undefined) {\n\t\t\t\t// There is already a file with case-insensitive-equal name\n\t\t\t\t// On a case-insensitive filesystem we may miss the renaming\n\t\t\t\t// when only casing is changed.\n\t\t\t\t// To be sure that our information is correct\n\t\t\t\t// we trigger a rescan here\n\t\t\t\tthis.doScan(false);\n\t\t\t}\n\n\t\t\tthis.forEachWatcher(filePath, w => {\n\t\t\t\tif (!initial || w.checkStartTime(safeTime, initial)) {\n\t\t\t\t\tw.emit(\"change\", mtime, type);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (!initial) {\n\t\t\tthis.forEachWatcher(filePath, w => w.emit(\"change\", mtime, type));\n\t\t}\n\t\tthis.forEachWatcher(this.path, w => {\n\t\t\tif (!initial || w.checkStartTime(safeTime, initial)) {\n\t\t\t\tw.emit(\"change\", filePath, safeTime, type, initial);\n\t\t\t}\n\t\t});\n\t}\n\n\tsetDirectory(directoryPath, birthtime, initial, type) {\n\t\tif (this.ignored(directoryPath)) return;\n\t\tif (directoryPath === this.path) {\n\t\t\tif (!initial) {\n\t\t\t\tthis.forEachWatcher(this.path, w =>\n\t\t\t\t\tw.emit(\"change\", directoryPath, birthtime, type, initial)\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tconst old = this.directories.get(directoryPath);\n\t\t\tif (!old) {\n\t\t\t\tconst now = Date.now();\n\n\t\t\t\tif (this.nestedWatching) {\n\t\t\t\t\tthis.createNestedWatcher(directoryPath);\n\t\t\t\t} else {\n\t\t\t\t\tthis.directories.set(directoryPath, true);\n\t\t\t\t}\n\n\t\t\t\tlet safeTime;\n\t\t\t\tif (initial) {\n\t\t\t\t\tsafeTime = Math.min(now, birthtime) + FS_ACCURACY;\n\t\t\t\t} else {\n\t\t\t\t\tsafeTime = now;\n\t\t\t\t}\n\n\t\t\t\tthis.forEachWatcher(directoryPath, w => {\n\t\t\t\t\tif (!initial || w.checkStartTime(safeTime, false)) {\n\t\t\t\t\t\tw.emit(\"change\", birthtime, type);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tthis.forEachWatcher(this.path, w => {\n\t\t\t\t\tif (!initial || w.checkStartTime(safeTime, initial)) {\n\t\t\t\t\t\tw.emit(\"change\", directoryPath, safeTime, type, initial);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tcreateNestedWatcher(directoryPath) {\n\t\tconst watcher = this.watcherManager.watchDirectory(directoryPath, 1);\n\t\twatcher.on(\"change\", (filePath, mtime, type, initial) => {\n\t\t\tthis.forEachWatcher(this.path, w => {\n\t\t\t\tif (!initial || w.checkStartTime(mtime, initial)) {\n\t\t\t\t\tw.emit(\"change\", filePath, mtime, type, initial);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tthis.directories.set(directoryPath, watcher);\n\t}\n\n\tsetNestedWatching(flag) {\n\t\tif (this.nestedWatching !== !!flag) {\n\t\t\tthis.nestedWatching = !!flag;\n\t\t\tif (this.nestedWatching) {\n\t\t\t\tfor (const directory of this.directories.keys()) {\n\t\t\t\t\tthis.createNestedWatcher(directory);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (const [directory, watcher] of this.directories) {\n\t\t\t\t\twatcher.close();\n\t\t\t\t\tthis.directories.set(directory, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twatch(filePath, startTime) {\n\t\tconst key = withoutCase(filePath);\n\t\tlet watchers = this.watchers.get(key);\n\t\tif (watchers === undefined) {\n\t\t\twatchers = new Set();\n\t\t\tthis.watchers.set(key, watchers);\n\t\t}\n\t\tthis.refs++;\n\t\tconst watcher = new Watcher(this, filePath, startTime);\n\t\twatcher.on(\"closed\", () => {\n\t\t\tif (--this.refs <= 0) {\n\t\t\t\tthis.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twatchers.delete(watcher);\n\t\t\tif (watchers.size === 0) {\n\t\t\t\tthis.watchers.delete(key);\n\t\t\t\tif (this.path === filePath) this.setNestedWatching(false);\n\t\t\t}\n\t\t});\n\t\twatchers.add(watcher);\n\t\tlet safeTime;\n\t\tif (filePath === this.path) {\n\t\t\tthis.setNestedWatching(true);\n\t\t\tsafeTime = this.lastWatchEvent;\n\t\t\tfor (const entry of this.files.values()) {\n\t\t\t\tfixupEntryAccuracy(entry);\n\t\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\t}\n\t\t} else {\n\t\t\tconst entry = this.files.get(filePath);\n\t\t\tif (entry) {\n\t\t\t\tfixupEntryAccuracy(entry);\n\t\t\t\tsafeTime = entry.safeTime;\n\t\t\t} else {\n\t\t\t\tsafeTime = 0;\n\t\t\t}\n\t\t}\n\t\tif (safeTime) {\n\t\t\tif (safeTime >= startTime) {\n\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\tif (this.closed) return;\n\t\t\t\t\tif (filePath === this.path) {\n\t\t\t\t\t\twatcher.emit(\n\t\t\t\t\t\t\t\"change\",\n\t\t\t\t\t\t\tfilePath,\n\t\t\t\t\t\t\tsafeTime,\n\t\t\t\t\t\t\t\"watch (outdated on attach)\",\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twatcher.emit(\n\t\t\t\t\t\t\t\"change\",\n\t\t\t\t\t\t\tsafeTime,\n\t\t\t\t\t\t\t\"watch (outdated on attach)\",\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (this.initialScan) {\n\t\t\tif (this.initialScanRemoved.has(filePath)) {\n\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\tif (this.closed) return;\n\t\t\t\t\twatcher.emit(\"remove\");\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (\n\t\t\t!this.directories.has(filePath) &&\n\t\t\twatcher.checkStartTime(this.initialScanFinished, false)\n\t\t) {\n\t\t\tprocess.nextTick(() => {\n\t\t\t\tif (this.closed) return;\n\t\t\t\twatcher.emit(\"initial-missing\", \"watch (missing on attach)\");\n\t\t\t});\n\t\t}\n\t\treturn watcher;\n\t}\n\n\tonWatchEvent(eventType, filename) {\n\t\tif (this.closed) return;\n\t\tif (!filename) {\n\t\t\t// In some cases no filename is provided\n\t\t\t// This seem to happen on windows\n\t\t\t// So some event happened but we don't know which file is affected\n\t\t\t// We have to do a full scan of the directory\n\t\t\tthis.doScan(false);\n\t\t\treturn;\n\t\t}\n\n\t\tconst filePath = path.join(this.path, filename);\n\t\tif (this.ignored(filePath)) return;\n\n\t\tif (this._activeEvents.get(filename) === undefined) {\n\t\t\tthis._activeEvents.set(filename, false);\n\t\t\tconst checkStats = () => {\n\t\t\t\tif (this.closed) return;\n\t\t\t\tthis._activeEvents.set(filename, false);\n\t\t\t\tfs.lstat(filePath, (err, stats) => {\n\t\t\t\t\tif (this.closed) return;\n\t\t\t\t\tif (this._activeEvents.get(filename) === true) {\n\t\t\t\t\t\tprocess.nextTick(checkStats);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis._activeEvents.delete(filename);\n\t\t\t\t\t// ENOENT happens when the file/directory doesn't exist\n\t\t\t\t\t// EPERM happens when the containing directory doesn't exist\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\terr.code !== \"ENOENT\" &&\n\t\t\t\t\t\t\terr.code !== \"EPERM\" &&\n\t\t\t\t\t\t\terr.code !== \"EBUSY\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthis.onStatsError(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (filename === path.basename(this.path)) {\n\t\t\t\t\t\t\t\t// This may indicate that the directory itself was removed\n\t\t\t\t\t\t\t\tif (!fs.existsSync(this.path)) {\n\t\t\t\t\t\t\t\t\tthis.onDirectoryRemoved(\"stat failed\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.lastWatchEvent = Date.now();\n\t\t\t\t\tif (!stats) {\n\t\t\t\t\t\tthis.setMissing(filePath, false, eventType);\n\t\t\t\t\t} else if (stats.isDirectory()) {\n\t\t\t\t\t\tthis.setDirectory(\n\t\t\t\t\t\t\tfilePath,\n\t\t\t\t\t\t\t+stats.birthtime || 1,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\teventType\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (stats.isFile() || stats.isSymbolicLink()) {\n\t\t\t\t\t\tif (stats.mtime) {\n\t\t\t\t\t\t\tensureFsAccuracy(stats.mtime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.setFileTime(\n\t\t\t\t\t\t\tfilePath,\n\t\t\t\t\t\t\t+stats.mtime || +stats.ctime || 1,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\teventType\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t\tprocess.nextTick(checkStats);\n\t\t} else {\n\t\t\tthis._activeEvents.set(filename, true);\n\t\t}\n\t}\n\n\tonWatcherError(err) {\n\t\tif (this.closed) return;\n\t\tif (err) {\n\t\t\tif (err.code !== \"EPERM\" && err.code !== \"ENOENT\") {\n\t\t\t\tconsole.error(\"Watchpack Error (watcher): \" + err);\n\t\t\t}\n\t\t\tthis.onDirectoryRemoved(\"watch error\");\n\t\t}\n\t}\n\n\tonStatsError(err) {\n\t\tif (err) {\n\t\t\tconsole.error(\"Watchpack Error (stats): \" + err);\n\t\t}\n\t}\n\n\tonScanError(err) {\n\t\tif (err) {\n\t\t\tconsole.error(\"Watchpack Error (initial scan): \" + err);\n\t\t}\n\t\tthis.onScanFinished();\n\t}\n\n\tonScanFinished() {\n\t\tif (this.polledWatching) {\n\t\t\tthis.timeout = setTimeout(() => {\n\t\t\t\tif (this.closed) return;\n\t\t\t\tthis.doScan(false);\n\t\t\t}, this.polledWatching);\n\t\t}\n\t}\n\n\tonDirectoryRemoved(reason) {\n\t\tif (this.watcher) {\n\t\t\tthis.watcher.close();\n\t\t\tthis.watcher = null;\n\t\t}\n\t\tthis.watchInParentDirectory();\n\t\tconst type = `directory-removed (${reason})`;\n\t\tfor (const directory of this.directories.keys()) {\n\t\t\tthis.setMissing(directory, null, type);\n\t\t}\n\t\tfor (const file of this.files.keys()) {\n\t\t\tthis.setMissing(file, null, type);\n\t\t}\n\t}\n\n\twatchInParentDirectory() {\n\t\tif (!this.parentWatcher) {\n\t\t\tconst parentDir = path.dirname(this.path);\n\t\t\t// avoid watching in the root directory\n\t\t\t// removing directories in the root directory is not supported\n\t\t\tif (path.dirname(parentDir) === parentDir) return;\n\n\t\t\tthis.parentWatcher = this.watcherManager.watchFile(this.path, 1);\n\t\t\tthis.parentWatcher.on(\"change\", (mtime, type) => {\n\t\t\t\tif (this.closed) return;\n\n\t\t\t\t// On non-osx platforms we don't need this watcher to detect\n\t\t\t\t// directory removal, as an EPERM error indicates that\n\t\t\t\tif ((!IS_OSX || this.polledWatching) && this.parentWatcher) {\n\t\t\t\t\tthis.parentWatcher.close();\n\t\t\t\t\tthis.parentWatcher = null;\n\t\t\t\t}\n\t\t\t\t// Try to create the watcher when parent directory is found\n\t\t\t\tif (!this.watcher) {\n\t\t\t\t\tthis.createWatcher();\n\t\t\t\t\tthis.doScan(false);\n\n\t\t\t\t\t// directory was created so we emit an event\n\t\t\t\t\tthis.forEachWatcher(this.path, w =>\n\t\t\t\t\t\tw.emit(\"change\", this.path, mtime, type, false)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.parentWatcher.on(\"remove\", () => {\n\t\t\t\tthis.onDirectoryRemoved(\"parent directory removed\");\n\t\t\t});\n\t\t}\n\t}\n\n\tdoScan(initial) {\n\t\tif (this.scanning) {\n\t\t\tif (this.scanAgain) {\n\t\t\t\tif (!initial) this.scanAgainInitial = false;\n\t\t\t} else {\n\t\t\t\tthis.scanAgain = true;\n\t\t\t\tthis.scanAgainInitial = initial;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis.scanning = true;\n\t\tif (this.timeout) {\n\t\t\tclearTimeout(this.timeout);\n\t\t\tthis.timeout = undefined;\n\t\t}\n\t\tprocess.nextTick(() => {\n\t\t\tif (this.closed) return;\n\t\t\tfs.readdir(this.path, (err, items) => {\n\t\t\t\tif (this.closed) return;\n\t\t\t\tif (err) {\n\t\t\t\t\tif (err.code === \"ENOENT\" || err.code === \"EPERM\") {\n\t\t\t\t\t\tthis.onDirectoryRemoved(\"scan readdir failed\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.onScanError(err);\n\t\t\t\t\t}\n\t\t\t\t\tthis.initialScan = false;\n\t\t\t\t\tthis.initialScanFinished = Date.now();\n\t\t\t\t\tif (initial) {\n\t\t\t\t\t\tfor (const watchers of this.watchers.values()) {\n\t\t\t\t\t\t\tfor (const watcher of watchers) {\n\t\t\t\t\t\t\t\tif (watcher.checkStartTime(this.initialScanFinished, false)) {\n\t\t\t\t\t\t\t\t\twatcher.emit(\n\t\t\t\t\t\t\t\t\t\t\"initial-missing\",\n\t\t\t\t\t\t\t\t\t\t\"scan (parent directory missing in initial scan)\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this.scanAgain) {\n\t\t\t\t\t\tthis.scanAgain = false;\n\t\t\t\t\t\tthis.doScan(this.scanAgainInitial);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.scanning = false;\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst itemPaths = new Set(\n\t\t\t\t\titems.map(item => path.join(this.path, item.normalize(\"NFC\")))\n\t\t\t\t);\n\t\t\t\tfor (const file of this.files.keys()) {\n\t\t\t\t\tif (!itemPaths.has(file)) {\n\t\t\t\t\t\tthis.setMissing(file, initial, \"scan (missing)\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const directory of this.directories.keys()) {\n\t\t\t\t\tif (!itemPaths.has(directory)) {\n\t\t\t\t\t\tthis.setMissing(directory, initial, \"scan (missing)\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.scanAgain) {\n\t\t\t\t\t// Early repeat of scan\n\t\t\t\t\tthis.scanAgain = false;\n\t\t\t\t\tthis.doScan(initial);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst itemFinished = needCalls(itemPaths.size + 1, () => {\n\t\t\t\t\tif (this.closed) return;\n\t\t\t\t\tthis.initialScan = false;\n\t\t\t\t\tthis.initialScanRemoved = null;\n\t\t\t\t\tthis.initialScanFinished = Date.now();\n\t\t\t\t\tif (initial) {\n\t\t\t\t\t\tconst missingWatchers = new Map(this.watchers);\n\t\t\t\t\t\tmissingWatchers.delete(withoutCase(this.path));\n\t\t\t\t\t\tfor (const item of itemPaths) {\n\t\t\t\t\t\t\tmissingWatchers.delete(withoutCase(item));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const watchers of missingWatchers.values()) {\n\t\t\t\t\t\t\tfor (const watcher of watchers) {\n\t\t\t\t\t\t\t\tif (watcher.checkStartTime(this.initialScanFinished, false)) {\n\t\t\t\t\t\t\t\t\twatcher.emit(\n\t\t\t\t\t\t\t\t\t\t\"initial-missing\",\n\t\t\t\t\t\t\t\t\t\t\"scan (missing in initial scan)\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this.scanAgain) {\n\t\t\t\t\t\tthis.scanAgain = false;\n\t\t\t\t\t\tthis.doScan(this.scanAgainInitial);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.scanning = false;\n\t\t\t\t\t\tthis.onScanFinished();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tfor (const itemPath of itemPaths) {\n\t\t\t\t\tfs.lstat(itemPath, (err2, stats) => {\n\t\t\t\t\t\tif (this.closed) return;\n\t\t\t\t\t\tif (err2) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\terr2.code === \"ENOENT\" ||\n\t\t\t\t\t\t\t\terr2.code === \"EPERM\" ||\n\t\t\t\t\t\t\t\terr2.code === \"EACCES\" ||\n\t\t\t\t\t\t\t\terr2.code === \"EBUSY\"\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tthis.setMissing(itemPath, initial, \"scan (\" + err2.code + \")\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.onScanError(err2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titemFinished();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (stats.isFile() || stats.isSymbolicLink()) {\n\t\t\t\t\t\t\tif (stats.mtime) {\n\t\t\t\t\t\t\t\tensureFsAccuracy(stats.mtime);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.setFileTime(\n\t\t\t\t\t\t\t\titemPath,\n\t\t\t\t\t\t\t\t+stats.mtime || +stats.ctime || 1,\n\t\t\t\t\t\t\t\tinitial,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\t\"scan (file)\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (stats.isDirectory()) {\n\t\t\t\t\t\t\tif (!initial || !this.directories.has(itemPath))\n\t\t\t\t\t\t\t\tthis.setDirectory(\n\t\t\t\t\t\t\t\t\titemPath,\n\t\t\t\t\t\t\t\t\t+stats.birthtime || 1,\n\t\t\t\t\t\t\t\t\tinitial,\n\t\t\t\t\t\t\t\t\t\"scan (dir)\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\titemFinished();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\titemFinished();\n\t\t\t});\n\t\t});\n\t}\n\n\tgetTimes() {\n\t\tconst obj = Object.create(null);\n\t\tlet safeTime = this.lastWatchEvent;\n\t\tfor (const [file, entry] of this.files) {\n\t\t\tfixupEntryAccuracy(entry);\n\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\tobj[file] = Math.max(entry.safeTime, entry.timestamp);\n\t\t}\n\t\tif (this.nestedWatching) {\n\t\t\tfor (const w of this.directories.values()) {\n\t\t\t\tconst times = w.directoryWatcher.getTimes();\n\t\t\t\tfor (const file of Object.keys(times)) {\n\t\t\t\t\tconst time = times[file];\n\t\t\t\t\tsafeTime = Math.max(safeTime, time);\n\t\t\t\t\tobj[file] = time;\n\t\t\t\t}\n\t\t\t}\n\t\t\tobj[this.path] = safeTime;\n\t\t}\n\t\tif (!this.initialScan) {\n\t\t\tfor (const watchers of this.watchers.values()) {\n\t\t\t\tfor (const watcher of watchers) {\n\t\t\t\t\tconst path = watcher.path;\n\t\t\t\t\tif (!Object.prototype.hasOwnProperty.call(obj, path)) {\n\t\t\t\t\t\tobj[path] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn obj;\n\t}\n\n\tcollectTimeInfoEntries(fileTimestamps, directoryTimestamps) {\n\t\tlet safeTime = this.lastWatchEvent;\n\t\tfor (const [file, entry] of this.files) {\n\t\t\tfixupEntryAccuracy(entry);\n\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\tfileTimestamps.set(file, entry);\n\t\t}\n\t\tif (this.nestedWatching) {\n\t\t\tfor (const w of this.directories.values()) {\n\t\t\t\tsafeTime = Math.max(\n\t\t\t\t\tsafeTime,\n\t\t\t\t\tw.directoryWatcher.collectTimeInfoEntries(\n\t\t\t\t\t\tfileTimestamps,\n\t\t\t\t\t\tdirectoryTimestamps\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tfileTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY);\n\t\t\tdirectoryTimestamps.set(this.path, {\n\t\t\t\tsafeTime\n\t\t\t});\n\t\t} else {\n\t\t\tfor (const dir of this.directories.keys()) {\n\t\t\t\t// No additional info about this directory\n\t\t\t\t// but maybe another DirectoryWatcher has info\n\t\t\t\tfileTimestamps.set(dir, EXISTANCE_ONLY_TIME_ENTRY);\n\t\t\t\tif (!directoryTimestamps.has(dir))\n\t\t\t\t\tdirectoryTimestamps.set(dir, EXISTANCE_ONLY_TIME_ENTRY);\n\t\t\t}\n\t\t\tfileTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY);\n\t\t\tdirectoryTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY);\n\t\t}\n\t\tif (!this.initialScan) {\n\t\t\tfor (const watchers of this.watchers.values()) {\n\t\t\t\tfor (const watcher of watchers) {\n\t\t\t\t\tconst path = watcher.path;\n\t\t\t\t\tif (!fileTimestamps.has(path)) {\n\t\t\t\t\t\tfileTimestamps.set(path, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn safeTime;\n\t}\n\n\tclose() {\n\t\tthis.closed = true;\n\t\tthis.initialScan = false;\n\t\tif (this.watcher) {\n\t\t\tthis.watcher.close();\n\t\t\tthis.watcher = null;\n\t\t}\n\t\tif (this.nestedWatching) {\n\t\t\tfor (const w of this.directories.values()) {\n\t\t\t\tw.close();\n\t\t\t}\n\t\t\tthis.directories.clear();\n\t\t}\n\t\tif (this.parentWatcher) {\n\t\t\tthis.parentWatcher.close();\n\t\t\tthis.parentWatcher = null;\n\t\t}\n\t\tthis.emit(\"closed\");\n\t}\n}\n\nmodule.exports = DirectoryWatcher;\nmodule.exports.EXISTANCE_ONLY_TIME_ENTRY = EXISTANCE_ONLY_TIME_ENTRY;\n\nfunction fixupEntryAccuracy(entry) {\n\tif (entry.accuracy > FS_ACCURACY) {\n\t\tentry.safeTime = entry.safeTime - entry.accuracy + FS_ACCURACY;\n\t\tentry.accuracy = FS_ACCURACY;\n\t}\n}\n\nfunction ensureFsAccuracy(mtime) {\n\tif (!mtime) return;\n\tif (FS_ACCURACY > 1 && mtime % 1 !== 0) FS_ACCURACY = 1;\n\telse if (FS_ACCURACY > 10 && mtime % 10 !== 0) FS_ACCURACY = 10;\n\telse if (FS_ACCURACY > 100 && mtime % 100 !== 0) FS_ACCURACY = 100;\n}\n"]},"metadata":{},"sourceType":"script"}