{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst util = require(\"util\");\n/** @typedef {import(\"./RuleSetCompiler\")} RuleSetCompiler */\n\n/** @typedef {import(\"./RuleSetCompiler\").Effect} Effect */\n\n\nclass UseEffectRulePlugin {\n  /**\n   * @param {RuleSetCompiler} ruleSetCompiler the rule set compiler\n   * @returns {void}\n   */\n  apply(ruleSetCompiler) {\n    ruleSetCompiler.hooks.rule.tap(\"UseEffectRulePlugin\", (path, rule, unhandledProperties, result, references) => {\n      const conflictWith = (property, correctProperty) => {\n        if (unhandledProperties.has(property)) {\n          throw ruleSetCompiler.error(`${path}.${property}`, rule[property], `A Rule must not have a '${property}' property when it has a '${correctProperty}' property`);\n        }\n      };\n\n      if (unhandledProperties.has(\"use\")) {\n        unhandledProperties.delete(\"use\");\n        unhandledProperties.delete(\"enforce\");\n        conflictWith(\"loader\", \"use\");\n        conflictWith(\"options\", \"use\");\n        const use = rule.use;\n        const enforce = rule.enforce;\n        const type = enforce ? `use-${enforce}` : \"use\";\n        /**\n         *\n         * @param {string} path options path\n         * @param {string} defaultIdent default ident when none is provided\n         * @param {object} item user provided use value\n         * @returns {Effect|function(any): Effect[]} effect\n         */\n\n        const useToEffect = (path, defaultIdent, item) => {\n          if (typeof item === \"function\") {\n            return data => useToEffectsWithoutIdent(path, item(data));\n          } else {\n            return useToEffectRaw(path, defaultIdent, item);\n          }\n        };\n        /**\n         *\n         * @param {string} path options path\n         * @param {string} defaultIdent default ident when none is provided\n         * @param {object} item user provided use value\n         * @returns {Effect} effect\n         */\n\n\n        const useToEffectRaw = (path, defaultIdent, item) => {\n          if (typeof item === \"string\") {\n            return {\n              type,\n              value: {\n                loader: item,\n                options: undefined,\n                ident: undefined\n              }\n            };\n          } else {\n            const loader = item.loader;\n            const options = item.options;\n            let ident = item.ident;\n\n            if (options && typeof options === \"object\") {\n              if (!ident) ident = defaultIdent;\n              references.set(ident, options);\n            }\n\n            if (typeof options === \"string\") {\n              util.deprecate(() => {}, `Using a string as loader options is deprecated (${path}.options)`, \"DEP_WEBPACK_RULE_LOADER_OPTIONS_STRING\")();\n            }\n\n            return {\n              type: enforce ? `use-${enforce}` : \"use\",\n              value: {\n                loader,\n                options,\n                ident\n              }\n            };\n          }\n        };\n        /**\n         * @param {string} path options path\n         * @param {any} items user provided use value\n         * @returns {Effect[]} effects\n         */\n\n\n        const useToEffectsWithoutIdent = (path, items) => {\n          if (Array.isArray(items)) {\n            return items.map((item, idx) => useToEffectRaw(`${path}[${idx}]`, \"[[missing ident]]\", item));\n          }\n\n          return [useToEffectRaw(path, \"[[missing ident]]\", items)];\n        };\n        /**\n         * @param {string} path current path\n         * @param {any} items user provided use value\n         * @returns {(Effect|function(any): Effect[])[]} effects\n         */\n\n\n        const useToEffects = (path, items) => {\n          if (Array.isArray(items)) {\n            return items.map((item, idx) => {\n              const subPath = `${path}[${idx}]`;\n              return useToEffect(subPath, subPath, item);\n            });\n          }\n\n          return [useToEffect(path, path, items)];\n        };\n\n        if (typeof use === \"function\") {\n          result.effects.push(data => useToEffectsWithoutIdent(`${path}.use`, use(data)));\n        } else {\n          for (const effect of useToEffects(`${path}.use`, use)) {\n            result.effects.push(effect);\n          }\n        }\n      }\n\n      if (unhandledProperties.has(\"loader\")) {\n        unhandledProperties.delete(\"loader\");\n        unhandledProperties.delete(\"options\");\n        unhandledProperties.delete(\"enforce\");\n        const loader = rule.loader;\n        const options = rule.options;\n        const enforce = rule.enforce;\n\n        if (loader.includes(\"!\")) {\n          throw ruleSetCompiler.error(`${path}.loader`, loader, \"Exclamation mark separated loader lists has been removed in favor of the 'use' property with arrays\");\n        }\n\n        if (loader.includes(\"?\")) {\n          throw ruleSetCompiler.error(`${path}.loader`, loader, \"Query arguments on 'loader' has been removed in favor of the 'options' property\");\n        }\n\n        if (typeof options === \"string\") {\n          util.deprecate(() => {}, `Using a string as loader options is deprecated (${path}.options)`, \"DEP_WEBPACK_RULE_LOADER_OPTIONS_STRING\")();\n        }\n\n        const ident = options && typeof options === \"object\" ? path : undefined;\n        references.set(ident, options);\n        result.effects.push({\n          type: enforce ? `use-${enforce}` : \"use\",\n          value: {\n            loader,\n            options,\n            ident\n          }\n        });\n      }\n    });\n  }\n\n  useItemToEffects(path, item) {}\n\n}\n\nmodule.exports = UseEffectRulePlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/rules/UseEffectRulePlugin.js"],"names":["util","require","UseEffectRulePlugin","apply","ruleSetCompiler","hooks","rule","tap","path","unhandledProperties","result","references","conflictWith","property","correctProperty","has","error","delete","use","enforce","type","useToEffect","defaultIdent","item","data","useToEffectsWithoutIdent","useToEffectRaw","value","loader","options","undefined","ident","set","deprecate","items","Array","isArray","map","idx","useToEffects","subPath","effects","push","effect","includes","useItemToEffects","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst util = require(\"util\");\n\n/** @typedef {import(\"./RuleSetCompiler\")} RuleSetCompiler */\n/** @typedef {import(\"./RuleSetCompiler\").Effect} Effect */\n\nclass UseEffectRulePlugin {\n\t/**\n\t * @param {RuleSetCompiler} ruleSetCompiler the rule set compiler\n\t * @returns {void}\n\t */\n\tapply(ruleSetCompiler) {\n\t\truleSetCompiler.hooks.rule.tap(\n\t\t\t\"UseEffectRulePlugin\",\n\t\t\t(path, rule, unhandledProperties, result, references) => {\n\t\t\t\tconst conflictWith = (property, correctProperty) => {\n\t\t\t\t\tif (unhandledProperties.has(property)) {\n\t\t\t\t\t\tthrow ruleSetCompiler.error(\n\t\t\t\t\t\t\t`${path}.${property}`,\n\t\t\t\t\t\t\trule[property],\n\t\t\t\t\t\t\t`A Rule must not have a '${property}' property when it has a '${correctProperty}' property`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tif (unhandledProperties.has(\"use\")) {\n\t\t\t\t\tunhandledProperties.delete(\"use\");\n\t\t\t\t\tunhandledProperties.delete(\"enforce\");\n\n\t\t\t\t\tconflictWith(\"loader\", \"use\");\n\t\t\t\t\tconflictWith(\"options\", \"use\");\n\n\t\t\t\t\tconst use = rule.use;\n\t\t\t\t\tconst enforce = rule.enforce;\n\n\t\t\t\t\tconst type = enforce ? `use-${enforce}` : \"use\";\n\n\t\t\t\t\t/**\n\t\t\t\t\t *\n\t\t\t\t\t * @param {string} path options path\n\t\t\t\t\t * @param {string} defaultIdent default ident when none is provided\n\t\t\t\t\t * @param {object} item user provided use value\n\t\t\t\t\t * @returns {Effect|function(any): Effect[]} effect\n\t\t\t\t\t */\n\t\t\t\t\tconst useToEffect = (path, defaultIdent, item) => {\n\t\t\t\t\t\tif (typeof item === \"function\") {\n\t\t\t\t\t\t\treturn data => useToEffectsWithoutIdent(path, item(data));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn useToEffectRaw(path, defaultIdent, item);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t *\n\t\t\t\t\t * @param {string} path options path\n\t\t\t\t\t * @param {string} defaultIdent default ident when none is provided\n\t\t\t\t\t * @param {object} item user provided use value\n\t\t\t\t\t * @returns {Effect} effect\n\t\t\t\t\t */\n\t\t\t\t\tconst useToEffectRaw = (path, defaultIdent, item) => {\n\t\t\t\t\t\tif (typeof item === \"string\") {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\tloader: item,\n\t\t\t\t\t\t\t\t\toptions: undefined,\n\t\t\t\t\t\t\t\t\tident: undefined\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst loader = item.loader;\n\t\t\t\t\t\t\tconst options = item.options;\n\t\t\t\t\t\t\tlet ident = item.ident;\n\t\t\t\t\t\t\tif (options && typeof options === \"object\") {\n\t\t\t\t\t\t\t\tif (!ident) ident = defaultIdent;\n\t\t\t\t\t\t\t\treferences.set(ident, options);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (typeof options === \"string\") {\n\t\t\t\t\t\t\t\tutil.deprecate(\n\t\t\t\t\t\t\t\t\t() => {},\n\t\t\t\t\t\t\t\t\t`Using a string as loader options is deprecated (${path}.options)`,\n\t\t\t\t\t\t\t\t\t\"DEP_WEBPACK_RULE_LOADER_OPTIONS_STRING\"\n\t\t\t\t\t\t\t\t)();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\ttype: enforce ? `use-${enforce}` : \"use\",\n\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\tloader,\n\t\t\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\t\t\tident\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} path options path\n\t\t\t\t\t * @param {any} items user provided use value\n\t\t\t\t\t * @returns {Effect[]} effects\n\t\t\t\t\t */\n\t\t\t\t\tconst useToEffectsWithoutIdent = (path, items) => {\n\t\t\t\t\t\tif (Array.isArray(items)) {\n\t\t\t\t\t\t\treturn items.map((item, idx) =>\n\t\t\t\t\t\t\t\tuseToEffectRaw(`${path}[${idx}]`, \"[[missing ident]]\", item)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn [useToEffectRaw(path, \"[[missing ident]]\", items)];\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} path current path\n\t\t\t\t\t * @param {any} items user provided use value\n\t\t\t\t\t * @returns {(Effect|function(any): Effect[])[]} effects\n\t\t\t\t\t */\n\t\t\t\t\tconst useToEffects = (path, items) => {\n\t\t\t\t\t\tif (Array.isArray(items)) {\n\t\t\t\t\t\t\treturn items.map((item, idx) => {\n\t\t\t\t\t\t\t\tconst subPath = `${path}[${idx}]`;\n\t\t\t\t\t\t\t\treturn useToEffect(subPath, subPath, item);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn [useToEffect(path, path, items)];\n\t\t\t\t\t};\n\n\t\t\t\t\tif (typeof use === \"function\") {\n\t\t\t\t\t\tresult.effects.push(data =>\n\t\t\t\t\t\t\tuseToEffectsWithoutIdent(`${path}.use`, use(data))\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const effect of useToEffects(`${path}.use`, use)) {\n\t\t\t\t\t\t\tresult.effects.push(effect);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (unhandledProperties.has(\"loader\")) {\n\t\t\t\t\tunhandledProperties.delete(\"loader\");\n\t\t\t\t\tunhandledProperties.delete(\"options\");\n\t\t\t\t\tunhandledProperties.delete(\"enforce\");\n\n\t\t\t\t\tconst loader = rule.loader;\n\t\t\t\t\tconst options = rule.options;\n\t\t\t\t\tconst enforce = rule.enforce;\n\n\t\t\t\t\tif (loader.includes(\"!\")) {\n\t\t\t\t\t\tthrow ruleSetCompiler.error(\n\t\t\t\t\t\t\t`${path}.loader`,\n\t\t\t\t\t\t\tloader,\n\t\t\t\t\t\t\t\"Exclamation mark separated loader lists has been removed in favor of the 'use' property with arrays\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (loader.includes(\"?\")) {\n\t\t\t\t\t\tthrow ruleSetCompiler.error(\n\t\t\t\t\t\t\t`${path}.loader`,\n\t\t\t\t\t\t\tloader,\n\t\t\t\t\t\t\t\"Query arguments on 'loader' has been removed in favor of the 'options' property\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof options === \"string\") {\n\t\t\t\t\t\tutil.deprecate(\n\t\t\t\t\t\t\t() => {},\n\t\t\t\t\t\t\t`Using a string as loader options is deprecated (${path}.options)`,\n\t\t\t\t\t\t\t\"DEP_WEBPACK_RULE_LOADER_OPTIONS_STRING\"\n\t\t\t\t\t\t)();\n\t\t\t\t\t}\n\n\t\t\t\t\tconst ident =\n\t\t\t\t\t\toptions && typeof options === \"object\" ? path : undefined;\n\t\t\t\t\treferences.set(ident, options);\n\t\t\t\t\tresult.effects.push({\n\t\t\t\t\t\ttype: enforce ? `use-${enforce}` : \"use\",\n\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\tloader,\n\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\tident\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\n\tuseItemToEffects(path, item) {}\n}\n\nmodule.exports = UseEffectRulePlugin;\n"]},"metadata":{},"sourceType":"script"}