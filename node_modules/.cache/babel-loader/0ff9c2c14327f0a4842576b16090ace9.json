{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst parseJson = require(\"json-parse-better-errors\");\n\nconst asyncLib = require(\"neo-async\");\n\nconst {\n  SyncHook,\n  SyncBailHook,\n  AsyncParallelHook,\n  AsyncSeriesHook\n} = require(\"tapable\");\n\nconst {\n  SizeOnlySource\n} = require(\"webpack-sources\");\n\nconst webpack = require(\"./\");\n\nconst Cache = require(\"./Cache\");\n\nconst CacheFacade = require(\"./CacheFacade\");\n\nconst ChunkGraph = require(\"./ChunkGraph\");\n\nconst Compilation = require(\"./Compilation\");\n\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\n\nconst ContextModuleFactory = require(\"./ContextModuleFactory\");\n\nconst ModuleGraph = require(\"./ModuleGraph\");\n\nconst NormalModuleFactory = require(\"./NormalModuleFactory\");\n\nconst RequestShortener = require(\"./RequestShortener\");\n\nconst ResolverFactory = require(\"./ResolverFactory\");\n\nconst Stats = require(\"./Stats\");\n\nconst Watching = require(\"./Watching\");\n\nconst WebpackError = require(\"./WebpackError\");\n\nconst {\n  Logger\n} = require(\"./logging/Logger\");\n\nconst {\n  join,\n  dirname,\n  mkdirp\n} = require(\"./util/fs\");\n\nconst {\n  makePathsRelative\n} = require(\"./util/identifier\");\n\nconst {\n  isSourceEqual\n} = require(\"./util/source\");\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../declarations/WebpackOptions\").EntryNormalized} Entry */\n\n/** @typedef {import(\"../declarations/WebpackOptions\").OutputNormalized} OutputOptions */\n\n/** @typedef {import(\"../declarations/WebpackOptions\").WatchOptions} WatchOptions */\n\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackOptionsNormalized} WebpackOptions */\n\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackPluginInstance} WebpackPluginInstance */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./Dependency\")} Dependency */\n\n/** @typedef {import(\"./FileSystemInfo\").FileSystemInfoEntry} FileSystemInfoEntry */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./util/WeakTupleMap\")} WeakTupleMap */\n\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n\n/** @typedef {import(\"./util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n\n/** @typedef {import(\"./util/fs\").WatchFileSystem} WatchFileSystem */\n\n/**\n * @typedef {Object} CompilationParams\n * @property {NormalModuleFactory} normalModuleFactory\n * @property {ContextModuleFactory} contextModuleFactory\n */\n\n/**\n * @template T\n * @callback Callback\n * @param {(Error | null)=} err\n * @param {T=} result\n */\n\n/**\n * @callback RunAsChildCallback\n * @param {(Error | null)=} err\n * @param {Chunk[]=} entries\n * @param {Compilation=} compilation\n */\n\n/**\n * @typedef {Object} AssetEmittedInfo\n * @property {Buffer} content\n * @property {Source} source\n * @property {Compilation} compilation\n * @property {string} outputPath\n * @property {string} targetPath\n */\n\n/**\n * @param {string[]} array an array\n * @returns {boolean} true, if the array is sorted\n */\n\n\nconst isSorted = array => {\n  for (let i = 1; i < array.length; i++) {\n    if (array[i - 1] > array[i]) return false;\n  }\n\n  return true;\n};\n/**\n * @param {Object} obj an object\n * @param {string[]} keys the keys of the object\n * @returns {Object} the object with properties sorted by property name\n */\n\n\nconst sortObject = (obj, keys) => {\n  const o = {};\n\n  for (const k of keys.sort()) {\n    o[k] = obj[k];\n  }\n\n  return o;\n};\n/**\n * @param {string} filename filename\n * @param {string | string[] | undefined} hashes list of hashes\n * @returns {boolean} true, if the filename contains any hash\n */\n\n\nconst includesHash = (filename, hashes) => {\n  if (!hashes) return false;\n\n  if (Array.isArray(hashes)) {\n    return hashes.some(hash => filename.includes(hash));\n  } else {\n    return filename.includes(hashes);\n  }\n};\n\nclass Compiler {\n  /**\n   * @param {string} context the compilation path\n   * @param {WebpackOptions} options options\n   */\n  constructor(context) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] :\n    /** @type {WebpackOptions} */\n    {};\n    this.hooks = Object.freeze({\n      /** @type {SyncHook<[]>} */\n      initialize: new SyncHook([]),\n\n      /** @type {SyncBailHook<[Compilation], boolean>} */\n      shouldEmit: new SyncBailHook([\"compilation\"]),\n\n      /** @type {AsyncSeriesHook<[Stats]>} */\n      done: new AsyncSeriesHook([\"stats\"]),\n\n      /** @type {SyncHook<[Stats]>} */\n      afterDone: new SyncHook([\"stats\"]),\n\n      /** @type {AsyncSeriesHook<[]>} */\n      additionalPass: new AsyncSeriesHook([]),\n\n      /** @type {AsyncSeriesHook<[Compiler]>} */\n      beforeRun: new AsyncSeriesHook([\"compiler\"]),\n\n      /** @type {AsyncSeriesHook<[Compiler]>} */\n      run: new AsyncSeriesHook([\"compiler\"]),\n\n      /** @type {AsyncSeriesHook<[Compilation]>} */\n      emit: new AsyncSeriesHook([\"compilation\"]),\n\n      /** @type {AsyncSeriesHook<[string, AssetEmittedInfo]>} */\n      assetEmitted: new AsyncSeriesHook([\"file\", \"info\"]),\n\n      /** @type {AsyncSeriesHook<[Compilation]>} */\n      afterEmit: new AsyncSeriesHook([\"compilation\"]),\n\n      /** @type {SyncHook<[Compilation, CompilationParams]>} */\n      thisCompilation: new SyncHook([\"compilation\", \"params\"]),\n\n      /** @type {SyncHook<[Compilation, CompilationParams]>} */\n      compilation: new SyncHook([\"compilation\", \"params\"]),\n\n      /** @type {SyncHook<[NormalModuleFactory]>} */\n      normalModuleFactory: new SyncHook([\"normalModuleFactory\"]),\n\n      /** @type {SyncHook<[ContextModuleFactory]>}  */\n      contextModuleFactory: new SyncHook([\"contextModuleFactory\"]),\n\n      /** @type {AsyncSeriesHook<[CompilationParams]>} */\n      beforeCompile: new AsyncSeriesHook([\"params\"]),\n\n      /** @type {SyncHook<[CompilationParams]>} */\n      compile: new SyncHook([\"params\"]),\n\n      /** @type {AsyncParallelHook<[Compilation]>} */\n      make: new AsyncParallelHook([\"compilation\"]),\n\n      /** @type {AsyncParallelHook<[Compilation]>} */\n      finishMake: new AsyncSeriesHook([\"compilation\"]),\n\n      /** @type {AsyncSeriesHook<[Compilation]>} */\n      afterCompile: new AsyncSeriesHook([\"compilation\"]),\n\n      /** @type {AsyncSeriesHook<[]>} */\n      readRecords: new AsyncSeriesHook([]),\n\n      /** @type {AsyncSeriesHook<[]>} */\n      emitRecords: new AsyncSeriesHook([]),\n\n      /** @type {AsyncSeriesHook<[Compiler]>} */\n      watchRun: new AsyncSeriesHook([\"compiler\"]),\n\n      /** @type {SyncHook<[Error]>} */\n      failed: new SyncHook([\"error\"]),\n\n      /** @type {SyncHook<[string | null, number]>} */\n      invalid: new SyncHook([\"filename\", \"changeTime\"]),\n\n      /** @type {SyncHook<[]>} */\n      watchClose: new SyncHook([]),\n\n      /** @type {AsyncSeriesHook<[]>} */\n      shutdown: new AsyncSeriesHook([]),\n\n      /** @type {SyncBailHook<[string, string, any[]], true>} */\n      infrastructureLog: new SyncBailHook([\"origin\", \"type\", \"args\"]),\n      // TODO the following hooks are weirdly located here\n      // TODO move them for webpack 5\n\n      /** @type {SyncHook<[]>} */\n      environment: new SyncHook([]),\n\n      /** @type {SyncHook<[]>} */\n      afterEnvironment: new SyncHook([]),\n\n      /** @type {SyncHook<[Compiler]>} */\n      afterPlugins: new SyncHook([\"compiler\"]),\n\n      /** @type {SyncHook<[Compiler]>} */\n      afterResolvers: new SyncHook([\"compiler\"]),\n\n      /** @type {SyncBailHook<[string, Entry], boolean>} */\n      entryOption: new SyncBailHook([\"context\", \"entry\"])\n    });\n    this.webpack = webpack;\n    /** @type {string=} */\n\n    this.name = undefined;\n    /** @type {Compilation=} */\n\n    this.parentCompilation = undefined;\n    /** @type {Compiler} */\n\n    this.root = this;\n    /** @type {string} */\n\n    this.outputPath = \"\";\n    /** @type {Watching} */\n\n    this.watching = undefined;\n    /** @type {OutputFileSystem} */\n\n    this.outputFileSystem = null;\n    /** @type {IntermediateFileSystem} */\n\n    this.intermediateFileSystem = null;\n    /** @type {InputFileSystem} */\n\n    this.inputFileSystem = null;\n    /** @type {WatchFileSystem} */\n\n    this.watchFileSystem = null;\n    /** @type {string|null} */\n\n    this.recordsInputPath = null;\n    /** @type {string|null} */\n\n    this.recordsOutputPath = null;\n    this.records = {};\n    /** @type {Set<string | RegExp>} */\n\n    this.managedPaths = new Set();\n    /** @type {Set<string | RegExp>} */\n\n    this.immutablePaths = new Set();\n    /** @type {ReadonlySet<string>} */\n\n    this.modifiedFiles = undefined;\n    /** @type {ReadonlySet<string>} */\n\n    this.removedFiles = undefined;\n    /** @type {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} */\n\n    this.fileTimestamps = undefined;\n    /** @type {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} */\n\n    this.contextTimestamps = undefined;\n    /** @type {number} */\n\n    this.fsStartTime = undefined;\n    /** @type {ResolverFactory} */\n\n    this.resolverFactory = new ResolverFactory();\n    this.infrastructureLogger = undefined;\n    this.options = options;\n    this.context = context;\n    this.requestShortener = new RequestShortener(context, this.root);\n    this.cache = new Cache();\n    /** @type {Map<Module, { buildInfo: object, references: WeakMap<Dependency, Module>, memCache: WeakTupleMap }> | undefined} */\n\n    this.moduleMemCaches = undefined;\n    this.compilerPath = \"\";\n    /** @type {boolean} */\n\n    this.running = false;\n    /** @type {boolean} */\n\n    this.idle = false;\n    /** @type {boolean} */\n\n    this.watchMode = false;\n    this._backCompat = this.options.experiments.backCompat !== false;\n    /** @type {Compilation} */\n\n    this._lastCompilation = undefined;\n    /** @type {NormalModuleFactory} */\n\n    this._lastNormalModuleFactory = undefined;\n    /** @private @type {WeakMap<Source, { sizeOnlySource: SizeOnlySource, writtenTo: Map<string, number> }>} */\n\n    this._assetEmittingSourceCache = new WeakMap();\n    /** @private @type {Map<string, number>} */\n\n    this._assetEmittingWrittenFiles = new Map();\n    /** @private @type {Set<string>} */\n\n    this._assetEmittingPreviousFiles = new Set();\n  }\n  /**\n   * @param {string} name cache name\n   * @returns {CacheFacade} the cache facade instance\n   */\n\n\n  getCache(name) {\n    return new CacheFacade(this.cache, `${this.compilerPath}${name}`, this.options.output.hashFunction);\n  }\n  /**\n   * @param {string | (function(): string)} name name of the logger, or function called once to get the logger name\n   * @returns {Logger} a logger with that name\n   */\n\n\n  getInfrastructureLogger(name) {\n    if (!name) {\n      throw new TypeError(\"Compiler.getInfrastructureLogger(name) called without a name\");\n    }\n\n    return new Logger((type, args) => {\n      if (typeof name === \"function\") {\n        name = name();\n\n        if (!name) {\n          throw new TypeError(\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\");\n        }\n      }\n\n      if (this.hooks.infrastructureLog.call(name, type, args) === undefined) {\n        if (this.infrastructureLogger !== undefined) {\n          this.infrastructureLogger(name, type, args);\n        }\n      }\n    }, childName => {\n      if (typeof name === \"function\") {\n        if (typeof childName === \"function\") {\n          return this.getInfrastructureLogger(() => {\n            if (typeof name === \"function\") {\n              name = name();\n\n              if (!name) {\n                throw new TypeError(\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\");\n              }\n            }\n\n            if (typeof childName === \"function\") {\n              childName = childName();\n\n              if (!childName) {\n                throw new TypeError(\"Logger.getChildLogger(name) called with a function not returning a name\");\n              }\n            }\n\n            return `${name}/${childName}`;\n          });\n        } else {\n          return this.getInfrastructureLogger(() => {\n            if (typeof name === \"function\") {\n              name = name();\n\n              if (!name) {\n                throw new TypeError(\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\");\n              }\n            }\n\n            return `${name}/${childName}`;\n          });\n        }\n      } else {\n        if (typeof childName === \"function\") {\n          return this.getInfrastructureLogger(() => {\n            if (typeof childName === \"function\") {\n              childName = childName();\n\n              if (!childName) {\n                throw new TypeError(\"Logger.getChildLogger(name) called with a function not returning a name\");\n              }\n            }\n\n            return `${name}/${childName}`;\n          });\n        } else {\n          return this.getInfrastructureLogger(`${name}/${childName}`);\n        }\n      }\n    });\n  } // TODO webpack 6: solve this in a better way\n  // e.g. move compilation specific info from Modules into ModuleGraph\n\n\n  _cleanupLastCompilation() {\n    if (this._lastCompilation !== undefined) {\n      for (const module of this._lastCompilation.modules) {\n        ChunkGraph.clearChunkGraphForModule(module);\n        ModuleGraph.clearModuleGraphForModule(module);\n        module.cleanupForCache();\n      }\n\n      for (const chunk of this._lastCompilation.chunks) {\n        ChunkGraph.clearChunkGraphForChunk(chunk);\n      }\n\n      this._lastCompilation = undefined;\n    }\n  } // TODO webpack 6: solve this in a better way\n\n\n  _cleanupLastNormalModuleFactory() {\n    if (this._lastNormalModuleFactory !== undefined) {\n      this._lastNormalModuleFactory.cleanupForCache();\n\n      this._lastNormalModuleFactory = undefined;\n    }\n  }\n  /**\n   * @param {WatchOptions} watchOptions the watcher's options\n   * @param {Callback<Stats>} handler signals when the call finishes\n   * @returns {Watching} a compiler watcher\n   */\n\n\n  watch(watchOptions, handler) {\n    if (this.running) {\n      return handler(new ConcurrentCompilationError());\n    }\n\n    this.running = true;\n    this.watchMode = true;\n    this.watching = new Watching(this, watchOptions, handler);\n    return this.watching;\n  }\n  /**\n   * @param {Callback<Stats>} callback signals when the call finishes\n   * @returns {void}\n   */\n\n\n  run(callback) {\n    if (this.running) {\n      return callback(new ConcurrentCompilationError());\n    }\n\n    let logger;\n\n    const finalCallback = (err, stats) => {\n      if (logger) logger.time(\"beginIdle\");\n      this.idle = true;\n      this.cache.beginIdle();\n      this.idle = true;\n      if (logger) logger.timeEnd(\"beginIdle\");\n      this.running = false;\n\n      if (err) {\n        this.hooks.failed.call(err);\n      }\n\n      if (callback !== undefined) callback(err, stats);\n      this.hooks.afterDone.call(stats);\n    };\n\n    const startTime = Date.now();\n    this.running = true;\n\n    const onCompiled = (err, compilation) => {\n      if (err) return finalCallback(err);\n\n      if (this.hooks.shouldEmit.call(compilation) === false) {\n        compilation.startTime = startTime;\n        compilation.endTime = Date.now();\n        const stats = new Stats(compilation);\n        this.hooks.done.callAsync(stats, err => {\n          if (err) return finalCallback(err);\n          return finalCallback(null, stats);\n        });\n        return;\n      }\n\n      process.nextTick(() => {\n        logger = compilation.getLogger(\"webpack.Compiler\");\n        logger.time(\"emitAssets\");\n        this.emitAssets(compilation, err => {\n          logger.timeEnd(\"emitAssets\");\n          if (err) return finalCallback(err);\n\n          if (compilation.hooks.needAdditionalPass.call()) {\n            compilation.needAdditionalPass = true;\n            compilation.startTime = startTime;\n            compilation.endTime = Date.now();\n            logger.time(\"done hook\");\n            const stats = new Stats(compilation);\n            this.hooks.done.callAsync(stats, err => {\n              logger.timeEnd(\"done hook\");\n              if (err) return finalCallback(err);\n              this.hooks.additionalPass.callAsync(err => {\n                if (err) return finalCallback(err);\n                this.compile(onCompiled);\n              });\n            });\n            return;\n          }\n\n          logger.time(\"emitRecords\");\n          this.emitRecords(err => {\n            logger.timeEnd(\"emitRecords\");\n            if (err) return finalCallback(err);\n            compilation.startTime = startTime;\n            compilation.endTime = Date.now();\n            logger.time(\"done hook\");\n            const stats = new Stats(compilation);\n            this.hooks.done.callAsync(stats, err => {\n              logger.timeEnd(\"done hook\");\n              if (err) return finalCallback(err);\n              this.cache.storeBuildDependencies(compilation.buildDependencies, err => {\n                if (err) return finalCallback(err);\n                return finalCallback(null, stats);\n              });\n            });\n          });\n        });\n      });\n    };\n\n    const run = () => {\n      this.hooks.beforeRun.callAsync(this, err => {\n        if (err) return finalCallback(err);\n        this.hooks.run.callAsync(this, err => {\n          if (err) return finalCallback(err);\n          this.readRecords(err => {\n            if (err) return finalCallback(err);\n            this.compile(onCompiled);\n          });\n        });\n      });\n    };\n\n    if (this.idle) {\n      this.cache.endIdle(err => {\n        if (err) return finalCallback(err);\n        this.idle = false;\n        run();\n      });\n    } else {\n      run();\n    }\n  }\n  /**\n   * @param {RunAsChildCallback} callback signals when the call finishes\n   * @returns {void}\n   */\n\n\n  runAsChild(callback) {\n    const startTime = Date.now();\n    this.compile((err, compilation) => {\n      if (err) return callback(err);\n      this.parentCompilation.children.push(compilation);\n\n      for (const {\n        name,\n        source,\n        info\n      } of compilation.getAssets()) {\n        this.parentCompilation.emitAsset(name, source, info);\n      }\n\n      const entries = [];\n\n      for (const ep of compilation.entrypoints.values()) {\n        entries.push(...ep.chunks);\n      }\n\n      compilation.startTime = startTime;\n      compilation.endTime = Date.now();\n      return callback(null, entries, compilation);\n    });\n  }\n\n  purgeInputFileSystem() {\n    if (this.inputFileSystem && this.inputFileSystem.purge) {\n      this.inputFileSystem.purge();\n    }\n  }\n  /**\n   * @param {Compilation} compilation the compilation\n   * @param {Callback<void>} callback signals when the assets are emitted\n   * @returns {void}\n   */\n\n\n  emitAssets(compilation, callback) {\n    let outputPath;\n\n    const emitFiles = err => {\n      if (err) return callback(err);\n      const assets = compilation.getAssets();\n      compilation.assets = { ...compilation.assets\n      };\n      /** @type {Map<string, { path: string, source: Source, size: number, waiting: { cacheEntry: any, file: string }[] }>} */\n\n      const caseInsensitiveMap = new Map();\n      /** @type {Set<string>} */\n\n      const allTargetPaths = new Set();\n      asyncLib.forEachLimit(assets, 15, (_ref, callback) => {\n        let {\n          name: file,\n          source,\n          info\n        } = _ref;\n        let targetFile = file;\n        let immutable = info.immutable;\n        const queryStringIdx = targetFile.indexOf(\"?\");\n\n        if (queryStringIdx >= 0) {\n          targetFile = targetFile.substr(0, queryStringIdx); // We may remove the hash, which is in the query string\n          // So we recheck if the file is immutable\n          // This doesn't cover all cases, but immutable is only a performance optimization anyway\n\n          immutable = immutable && (includesHash(targetFile, info.contenthash) || includesHash(targetFile, info.chunkhash) || includesHash(targetFile, info.modulehash) || includesHash(targetFile, info.fullhash));\n        }\n\n        const writeOut = err => {\n          if (err) return callback(err);\n          const targetPath = join(this.outputFileSystem, outputPath, targetFile);\n          allTargetPaths.add(targetPath); // check if the target file has already been written by this Compiler\n\n          const targetFileGeneration = this._assetEmittingWrittenFiles.get(targetPath); // create an cache entry for this Source if not already existing\n\n\n          let cacheEntry = this._assetEmittingSourceCache.get(source);\n\n          if (cacheEntry === undefined) {\n            cacheEntry = {\n              sizeOnlySource: undefined,\n              writtenTo: new Map()\n            };\n\n            this._assetEmittingSourceCache.set(source, cacheEntry);\n          }\n\n          let similarEntry;\n\n          const checkSimilarFile = () => {\n            const caseInsensitiveTargetPath = targetPath.toLowerCase();\n            similarEntry = caseInsensitiveMap.get(caseInsensitiveTargetPath);\n\n            if (similarEntry !== undefined) {\n              const {\n                path: other,\n                source: otherSource\n              } = similarEntry;\n\n              if (isSourceEqual(otherSource, source)) {\n                // Size may or may not be available at this point.\n                // If it's not available add to \"waiting\" list and it will be updated once available\n                if (similarEntry.size !== undefined) {\n                  updateWithReplacementSource(similarEntry.size);\n                } else {\n                  if (!similarEntry.waiting) similarEntry.waiting = [];\n                  similarEntry.waiting.push({\n                    file,\n                    cacheEntry\n                  });\n                }\n\n                alreadyWritten();\n              } else {\n                const err = new WebpackError(`Prevent writing to file that only differs in casing or query string from already written file.\nThis will lead to a race-condition and corrupted files on case-insensitive file systems.\n${targetPath}\n${other}`);\n                err.file = file;\n                callback(err);\n              }\n\n              return true;\n            } else {\n              caseInsensitiveMap.set(caseInsensitiveTargetPath, similarEntry = {\n                path: targetPath,\n                source,\n                size: undefined,\n                waiting: undefined\n              });\n              return false;\n            }\n          };\n          /**\n           * get the binary (Buffer) content from the Source\n           * @returns {Buffer} content for the source\n           */\n\n\n          const getContent = () => {\n            if (typeof source.buffer === \"function\") {\n              return source.buffer();\n            } else {\n              const bufferOrString = source.source();\n\n              if (Buffer.isBuffer(bufferOrString)) {\n                return bufferOrString;\n              } else {\n                return Buffer.from(bufferOrString, \"utf8\");\n              }\n            }\n          };\n\n          const alreadyWritten = () => {\n            // cache the information that the Source has been already been written to that location\n            if (targetFileGeneration === undefined) {\n              const newGeneration = 1;\n\n              this._assetEmittingWrittenFiles.set(targetPath, newGeneration);\n\n              cacheEntry.writtenTo.set(targetPath, newGeneration);\n            } else {\n              cacheEntry.writtenTo.set(targetPath, targetFileGeneration);\n            }\n\n            callback();\n          };\n          /**\n           * Write the file to output file system\n           * @param {Buffer} content content to be written\n           * @returns {void}\n           */\n\n\n          const doWrite = content => {\n            this.outputFileSystem.writeFile(targetPath, content, err => {\n              if (err) return callback(err); // information marker that the asset has been emitted\n\n              compilation.emittedAssets.add(file); // cache the information that the Source has been written to that location\n\n              const newGeneration = targetFileGeneration === undefined ? 1 : targetFileGeneration + 1;\n              cacheEntry.writtenTo.set(targetPath, newGeneration);\n\n              this._assetEmittingWrittenFiles.set(targetPath, newGeneration);\n\n              this.hooks.assetEmitted.callAsync(file, {\n                content,\n                source,\n                outputPath,\n                compilation,\n                targetPath\n              }, callback);\n            });\n          };\n\n          const updateWithReplacementSource = size => {\n            updateFileWithReplacementSource(file, cacheEntry, size);\n            similarEntry.size = size;\n\n            if (similarEntry.waiting !== undefined) {\n              for (const {\n                file,\n                cacheEntry\n              } of similarEntry.waiting) {\n                updateFileWithReplacementSource(file, cacheEntry, size);\n              }\n            }\n          };\n\n          const updateFileWithReplacementSource = (file, cacheEntry, size) => {\n            // Create a replacement resource which only allows to ask for size\n            // This allows to GC all memory allocated by the Source\n            // (expect when the Source is stored in any other cache)\n            if (!cacheEntry.sizeOnlySource) {\n              cacheEntry.sizeOnlySource = new SizeOnlySource(size);\n            }\n\n            compilation.updateAsset(file, cacheEntry.sizeOnlySource, {\n              size\n            });\n          };\n\n          const processExistingFile = stats => {\n            // skip emitting if it's already there and an immutable file\n            if (immutable) {\n              updateWithReplacementSource(stats.size);\n              return alreadyWritten();\n            }\n\n            const content = getContent();\n            updateWithReplacementSource(content.length); // if it exists and content on disk matches content\n            // skip writing the same content again\n            // (to keep mtime and don't trigger watchers)\n            // for a fast negative match file size is compared first\n\n            if (content.length === stats.size) {\n              compilation.comparedForEmitAssets.add(file);\n              return this.outputFileSystem.readFile(targetPath, (err, existingContent) => {\n                if (err || !content.equals(\n                /** @type {Buffer} */\n                existingContent)) {\n                  return doWrite(content);\n                } else {\n                  return alreadyWritten();\n                }\n              });\n            }\n\n            return doWrite(content);\n          };\n\n          const processMissingFile = () => {\n            const content = getContent();\n            updateWithReplacementSource(content.length);\n            return doWrite(content);\n          }; // if the target file has already been written\n\n\n          if (targetFileGeneration !== undefined) {\n            // check if the Source has been written to this target file\n            const writtenGeneration = cacheEntry.writtenTo.get(targetPath);\n\n            if (writtenGeneration === targetFileGeneration) {\n              // if yes, we may skip writing the file\n              // if it's already there\n              // (we assume one doesn't modify files while the Compiler is running, other then removing them)\n              if (this._assetEmittingPreviousFiles.has(targetPath)) {\n                // We assume that assets from the last compilation say intact on disk (they are not removed)\n                compilation.updateAsset(file, cacheEntry.sizeOnlySource, {\n                  size: cacheEntry.sizeOnlySource.size()\n                });\n                return callback();\n              } else {\n                // Settings immutable will make it accept file content without comparing when file exist\n                immutable = true;\n              }\n            } else if (!immutable) {\n              if (checkSimilarFile()) return; // We wrote to this file before which has very likely a different content\n              // skip comparing and assume content is different for performance\n              // This case happens often during watch mode.\n\n              return processMissingFile();\n            }\n          }\n\n          if (checkSimilarFile()) return;\n\n          if (this.options.output.compareBeforeEmit) {\n            this.outputFileSystem.stat(targetPath, (err, stats) => {\n              const exists = !err && stats.isFile();\n\n              if (exists) {\n                processExistingFile(stats);\n              } else {\n                processMissingFile();\n              }\n            });\n          } else {\n            processMissingFile();\n          }\n        };\n\n        if (targetFile.match(/\\/|\\\\/)) {\n          const fs = this.outputFileSystem;\n          const dir = dirname(fs, join(fs, outputPath, targetFile));\n          mkdirp(fs, dir, writeOut);\n        } else {\n          writeOut();\n        }\n      }, err => {\n        // Clear map to free up memory\n        caseInsensitiveMap.clear();\n\n        if (err) {\n          this._assetEmittingPreviousFiles.clear();\n\n          return callback(err);\n        }\n\n        this._assetEmittingPreviousFiles = allTargetPaths;\n        this.hooks.afterEmit.callAsync(compilation, err => {\n          if (err) return callback(err);\n          return callback();\n        });\n      });\n    };\n\n    this.hooks.emit.callAsync(compilation, err => {\n      if (err) return callback(err);\n      outputPath = compilation.getPath(this.outputPath, {});\n      mkdirp(this.outputFileSystem, outputPath, emitFiles);\n    });\n  }\n  /**\n   * @param {Callback<void>} callback signals when the call finishes\n   * @returns {void}\n   */\n\n\n  emitRecords(callback) {\n    if (this.hooks.emitRecords.isUsed()) {\n      if (this.recordsOutputPath) {\n        asyncLib.parallel([cb => this.hooks.emitRecords.callAsync(cb), this._emitRecords.bind(this)], err => callback(err));\n      } else {\n        this.hooks.emitRecords.callAsync(callback);\n      }\n    } else {\n      if (this.recordsOutputPath) {\n        this._emitRecords(callback);\n      } else {\n        callback();\n      }\n    }\n  }\n  /**\n   * @param {Callback<void>} callback signals when the call finishes\n   * @returns {void}\n   */\n\n\n  _emitRecords(callback) {\n    const writeFile = () => {\n      this.outputFileSystem.writeFile(this.recordsOutputPath, JSON.stringify(this.records, (n, value) => {\n        if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n          const keys = Object.keys(value);\n\n          if (!isSorted(keys)) {\n            return sortObject(value, keys);\n          }\n        }\n\n        return value;\n      }, 2), callback);\n    };\n\n    const recordsOutputPathDirectory = dirname(this.outputFileSystem, this.recordsOutputPath);\n\n    if (!recordsOutputPathDirectory) {\n      return writeFile();\n    }\n\n    mkdirp(this.outputFileSystem, recordsOutputPathDirectory, err => {\n      if (err) return callback(err);\n      writeFile();\n    });\n  }\n  /**\n   * @param {Callback<void>} callback signals when the call finishes\n   * @returns {void}\n   */\n\n\n  readRecords(callback) {\n    if (this.hooks.readRecords.isUsed()) {\n      if (this.recordsInputPath) {\n        asyncLib.parallel([cb => this.hooks.readRecords.callAsync(cb), this._readRecords.bind(this)]);\n      } else {\n        this.records = {};\n        this.hooks.readRecords.callAsync(callback);\n      }\n    } else {\n      if (this.recordsInputPath) {\n        this._readRecords(callback);\n      } else {\n        this.records = {};\n        callback();\n      }\n    }\n  }\n  /**\n   * @param {Callback<void>} callback signals when the call finishes\n   * @returns {void}\n   */\n\n\n  _readRecords(callback) {\n    if (!this.recordsInputPath) {\n      this.records = {};\n      return callback();\n    }\n\n    this.inputFileSystem.stat(this.recordsInputPath, err => {\n      // It doesn't exist\n      // We can ignore this.\n      if (err) return callback();\n      this.inputFileSystem.readFile(this.recordsInputPath, (err, content) => {\n        if (err) return callback(err);\n\n        try {\n          this.records = parseJson(content.toString(\"utf-8\"));\n        } catch (e) {\n          e.message = \"Cannot parse records: \" + e.message;\n          return callback(e);\n        }\n\n        return callback();\n      });\n    });\n  }\n  /**\n   * @param {Compilation} compilation the compilation\n   * @param {string} compilerName the compiler's name\n   * @param {number} compilerIndex the compiler's index\n   * @param {OutputOptions=} outputOptions the output options\n   * @param {WebpackPluginInstance[]=} plugins the plugins to apply\n   * @returns {Compiler} a child compiler\n   */\n\n\n  createChildCompiler(compilation, compilerName, compilerIndex, outputOptions, plugins) {\n    const childCompiler = new Compiler(this.context, { ...this.options,\n      output: { ...this.options.output,\n        ...outputOptions\n      }\n    });\n    childCompiler.name = compilerName;\n    childCompiler.outputPath = this.outputPath;\n    childCompiler.inputFileSystem = this.inputFileSystem;\n    childCompiler.outputFileSystem = null;\n    childCompiler.resolverFactory = this.resolverFactory;\n    childCompiler.modifiedFiles = this.modifiedFiles;\n    childCompiler.removedFiles = this.removedFiles;\n    childCompiler.fileTimestamps = this.fileTimestamps;\n    childCompiler.contextTimestamps = this.contextTimestamps;\n    childCompiler.fsStartTime = this.fsStartTime;\n    childCompiler.cache = this.cache;\n    childCompiler.compilerPath = `${this.compilerPath}${compilerName}|${compilerIndex}|`;\n    childCompiler._backCompat = this._backCompat;\n    const relativeCompilerName = makePathsRelative(this.context, compilerName, this.root);\n\n    if (!this.records[relativeCompilerName]) {\n      this.records[relativeCompilerName] = [];\n    }\n\n    if (this.records[relativeCompilerName][compilerIndex]) {\n      childCompiler.records = this.records[relativeCompilerName][compilerIndex];\n    } else {\n      this.records[relativeCompilerName].push(childCompiler.records = {});\n    }\n\n    childCompiler.parentCompilation = compilation;\n    childCompiler.root = this.root;\n\n    if (Array.isArray(plugins)) {\n      for (const plugin of plugins) {\n        plugin.apply(childCompiler);\n      }\n    }\n\n    for (const name in this.hooks) {\n      if (![\"make\", \"compile\", \"emit\", \"afterEmit\", \"invalid\", \"done\", \"thisCompilation\"].includes(name)) {\n        if (childCompiler.hooks[name]) {\n          childCompiler.hooks[name].taps = this.hooks[name].taps.slice();\n        }\n      }\n    }\n\n    compilation.hooks.childCompiler.call(childCompiler, compilerName, compilerIndex);\n    return childCompiler;\n  }\n\n  isChild() {\n    return !!this.parentCompilation;\n  }\n\n  createCompilation(params) {\n    this._cleanupLastCompilation();\n\n    return this._lastCompilation = new Compilation(this, params);\n  }\n  /**\n   * @param {CompilationParams} params the compilation parameters\n   * @returns {Compilation} the created compilation\n   */\n\n\n  newCompilation(params) {\n    const compilation = this.createCompilation(params);\n    compilation.name = this.name;\n    compilation.records = this.records;\n    this.hooks.thisCompilation.call(compilation, params);\n    this.hooks.compilation.call(compilation, params);\n    return compilation;\n  }\n\n  createNormalModuleFactory() {\n    this._cleanupLastNormalModuleFactory();\n\n    const normalModuleFactory = new NormalModuleFactory({\n      context: this.options.context,\n      fs: this.inputFileSystem,\n      resolverFactory: this.resolverFactory,\n      options: this.options.module,\n      associatedObjectForCache: this.root,\n      layers: this.options.experiments.layers\n    });\n    this._lastNormalModuleFactory = normalModuleFactory;\n    this.hooks.normalModuleFactory.call(normalModuleFactory);\n    return normalModuleFactory;\n  }\n\n  createContextModuleFactory() {\n    const contextModuleFactory = new ContextModuleFactory(this.resolverFactory);\n    this.hooks.contextModuleFactory.call(contextModuleFactory);\n    return contextModuleFactory;\n  }\n\n  newCompilationParams() {\n    const params = {\n      normalModuleFactory: this.createNormalModuleFactory(),\n      contextModuleFactory: this.createContextModuleFactory()\n    };\n    return params;\n  }\n  /**\n   * @param {Callback<Compilation>} callback signals when the compilation finishes\n   * @returns {void}\n   */\n\n\n  compile(callback) {\n    const params = this.newCompilationParams();\n    this.hooks.beforeCompile.callAsync(params, err => {\n      if (err) return callback(err);\n      this.hooks.compile.call(params);\n      const compilation = this.newCompilation(params);\n      const logger = compilation.getLogger(\"webpack.Compiler\");\n      logger.time(\"make hook\");\n      this.hooks.make.callAsync(compilation, err => {\n        logger.timeEnd(\"make hook\");\n        if (err) return callback(err);\n        logger.time(\"finish make hook\");\n        this.hooks.finishMake.callAsync(compilation, err => {\n          logger.timeEnd(\"finish make hook\");\n          if (err) return callback(err);\n          process.nextTick(() => {\n            logger.time(\"finish compilation\");\n            compilation.finish(err => {\n              logger.timeEnd(\"finish compilation\");\n              if (err) return callback(err);\n              logger.time(\"seal compilation\");\n              compilation.seal(err => {\n                logger.timeEnd(\"seal compilation\");\n                if (err) return callback(err);\n                logger.time(\"afterCompile hook\");\n                this.hooks.afterCompile.callAsync(compilation, err => {\n                  logger.timeEnd(\"afterCompile hook\");\n                  if (err) return callback(err);\n                  return callback(null, compilation);\n                });\n              });\n            });\n          });\n        });\n      });\n    });\n  }\n  /**\n   * @param {Callback<void>} callback signals when the compiler closes\n   * @returns {void}\n   */\n\n\n  close(callback) {\n    if (this.watching) {\n      // When there is still an active watching, close this first\n      this.watching.close(err => {\n        this.close(callback);\n      });\n      return;\n    }\n\n    this.hooks.shutdown.callAsync(err => {\n      if (err) return callback(err); // Get rid of reference to last compilation to avoid leaking memory\n      // We can't run this._cleanupLastCompilation() as the Stats to this compilation\n      // might be still in use. We try to get rid of the reference to the cache instead.\n\n      this._lastCompilation = undefined;\n      this._lastNormalModuleFactory = undefined;\n      this.cache.shutdown(callback);\n    });\n  }\n\n}\n\nmodule.exports = Compiler;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/Compiler.js"],"names":["parseJson","require","asyncLib","SyncHook","SyncBailHook","AsyncParallelHook","AsyncSeriesHook","SizeOnlySource","webpack","Cache","CacheFacade","ChunkGraph","Compilation","ConcurrentCompilationError","ContextModuleFactory","ModuleGraph","NormalModuleFactory","RequestShortener","ResolverFactory","Stats","Watching","WebpackError","Logger","join","dirname","mkdirp","makePathsRelative","isSourceEqual","isSorted","array","i","length","sortObject","obj","keys","o","k","sort","includesHash","filename","hashes","Array","isArray","some","hash","includes","Compiler","constructor","context","options","hooks","Object","freeze","initialize","shouldEmit","done","afterDone","additionalPass","beforeRun","run","emit","assetEmitted","afterEmit","thisCompilation","compilation","normalModuleFactory","contextModuleFactory","beforeCompile","compile","make","finishMake","afterCompile","readRecords","emitRecords","watchRun","failed","invalid","watchClose","shutdown","infrastructureLog","environment","afterEnvironment","afterPlugins","afterResolvers","entryOption","name","undefined","parentCompilation","root","outputPath","watching","outputFileSystem","intermediateFileSystem","inputFileSystem","watchFileSystem","recordsInputPath","recordsOutputPath","records","managedPaths","Set","immutablePaths","modifiedFiles","removedFiles","fileTimestamps","contextTimestamps","fsStartTime","resolverFactory","infrastructureLogger","requestShortener","cache","moduleMemCaches","compilerPath","running","idle","watchMode","_backCompat","experiments","backCompat","_lastCompilation","_lastNormalModuleFactory","_assetEmittingSourceCache","WeakMap","_assetEmittingWrittenFiles","Map","_assetEmittingPreviousFiles","getCache","output","hashFunction","getInfrastructureLogger","TypeError","type","args","call","childName","_cleanupLastCompilation","module","modules","clearChunkGraphForModule","clearModuleGraphForModule","cleanupForCache","chunk","chunks","clearChunkGraphForChunk","_cleanupLastNormalModuleFactory","watch","watchOptions","handler","callback","logger","finalCallback","err","stats","time","beginIdle","timeEnd","startTime","Date","now","onCompiled","endTime","callAsync","process","nextTick","getLogger","emitAssets","needAdditionalPass","storeBuildDependencies","buildDependencies","endIdle","runAsChild","children","push","source","info","getAssets","emitAsset","entries","ep","entrypoints","values","purgeInputFileSystem","purge","emitFiles","assets","caseInsensitiveMap","allTargetPaths","forEachLimit","file","targetFile","immutable","queryStringIdx","indexOf","substr","contenthash","chunkhash","modulehash","fullhash","writeOut","targetPath","add","targetFileGeneration","get","cacheEntry","sizeOnlySource","writtenTo","set","similarEntry","checkSimilarFile","caseInsensitiveTargetPath","toLowerCase","path","other","otherSource","size","updateWithReplacementSource","waiting","alreadyWritten","getContent","buffer","bufferOrString","Buffer","isBuffer","from","newGeneration","doWrite","content","writeFile","emittedAssets","updateFileWithReplacementSource","updateAsset","processExistingFile","comparedForEmitAssets","readFile","existingContent","equals","processMissingFile","writtenGeneration","has","compareBeforeEmit","stat","exists","isFile","match","fs","dir","clear","getPath","isUsed","parallel","cb","_emitRecords","bind","JSON","stringify","n","value","recordsOutputPathDirectory","_readRecords","toString","e","message","createChildCompiler","compilerName","compilerIndex","outputOptions","plugins","childCompiler","relativeCompilerName","plugin","apply","taps","slice","isChild","createCompilation","params","newCompilation","createNormalModuleFactory","associatedObjectForCache","layers","createContextModuleFactory","newCompilationParams","finish","seal","close","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst parseJson = require(\"json-parse-better-errors\");\nconst asyncLib = require(\"neo-async\");\nconst {\n\tSyncHook,\n\tSyncBailHook,\n\tAsyncParallelHook,\n\tAsyncSeriesHook\n} = require(\"tapable\");\nconst { SizeOnlySource } = require(\"webpack-sources\");\nconst webpack = require(\"./\");\nconst Cache = require(\"./Cache\");\nconst CacheFacade = require(\"./CacheFacade\");\nconst ChunkGraph = require(\"./ChunkGraph\");\nconst Compilation = require(\"./Compilation\");\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\nconst ContextModuleFactory = require(\"./ContextModuleFactory\");\nconst ModuleGraph = require(\"./ModuleGraph\");\nconst NormalModuleFactory = require(\"./NormalModuleFactory\");\nconst RequestShortener = require(\"./RequestShortener\");\nconst ResolverFactory = require(\"./ResolverFactory\");\nconst Stats = require(\"./Stats\");\nconst Watching = require(\"./Watching\");\nconst WebpackError = require(\"./WebpackError\");\nconst { Logger } = require(\"./logging/Logger\");\nconst { join, dirname, mkdirp } = require(\"./util/fs\");\nconst { makePathsRelative } = require(\"./util/identifier\");\nconst { isSourceEqual } = require(\"./util/source\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../declarations/WebpackOptions\").EntryNormalized} Entry */\n/** @typedef {import(\"../declarations/WebpackOptions\").OutputNormalized} OutputOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").WatchOptions} WatchOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackOptionsNormalized} WebpackOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackPluginInstance} WebpackPluginInstance */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./FileSystemInfo\").FileSystemInfoEntry} FileSystemInfoEntry */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./util/WeakTupleMap\")} WeakTupleMap */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n/** @typedef {import(\"./util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n/** @typedef {import(\"./util/fs\").WatchFileSystem} WatchFileSystem */\n\n/**\n * @typedef {Object} CompilationParams\n * @property {NormalModuleFactory} normalModuleFactory\n * @property {ContextModuleFactory} contextModuleFactory\n */\n\n/**\n * @template T\n * @callback Callback\n * @param {(Error | null)=} err\n * @param {T=} result\n */\n\n/**\n * @callback RunAsChildCallback\n * @param {(Error | null)=} err\n * @param {Chunk[]=} entries\n * @param {Compilation=} compilation\n */\n\n/**\n * @typedef {Object} AssetEmittedInfo\n * @property {Buffer} content\n * @property {Source} source\n * @property {Compilation} compilation\n * @property {string} outputPath\n * @property {string} targetPath\n */\n\n/**\n * @param {string[]} array an array\n * @returns {boolean} true, if the array is sorted\n */\nconst isSorted = array => {\n\tfor (let i = 1; i < array.length; i++) {\n\t\tif (array[i - 1] > array[i]) return false;\n\t}\n\treturn true;\n};\n\n/**\n * @param {Object} obj an object\n * @param {string[]} keys the keys of the object\n * @returns {Object} the object with properties sorted by property name\n */\nconst sortObject = (obj, keys) => {\n\tconst o = {};\n\tfor (const k of keys.sort()) {\n\t\to[k] = obj[k];\n\t}\n\treturn o;\n};\n\n/**\n * @param {string} filename filename\n * @param {string | string[] | undefined} hashes list of hashes\n * @returns {boolean} true, if the filename contains any hash\n */\nconst includesHash = (filename, hashes) => {\n\tif (!hashes) return false;\n\tif (Array.isArray(hashes)) {\n\t\treturn hashes.some(hash => filename.includes(hash));\n\t} else {\n\t\treturn filename.includes(hashes);\n\t}\n};\n\nclass Compiler {\n\t/**\n\t * @param {string} context the compilation path\n\t * @param {WebpackOptions} options options\n\t */\n\tconstructor(context, options = /** @type {WebpackOptions} */ ({})) {\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\tinitialize: new SyncHook([]),\n\n\t\t\t/** @type {SyncBailHook<[Compilation], boolean>} */\n\t\t\tshouldEmit: new SyncBailHook([\"compilation\"]),\n\t\t\t/** @type {AsyncSeriesHook<[Stats]>} */\n\t\t\tdone: new AsyncSeriesHook([\"stats\"]),\n\t\t\t/** @type {SyncHook<[Stats]>} */\n\t\t\tafterDone: new SyncHook([\"stats\"]),\n\t\t\t/** @type {AsyncSeriesHook<[]>} */\n\t\t\tadditionalPass: new AsyncSeriesHook([]),\n\t\t\t/** @type {AsyncSeriesHook<[Compiler]>} */\n\t\t\tbeforeRun: new AsyncSeriesHook([\"compiler\"]),\n\t\t\t/** @type {AsyncSeriesHook<[Compiler]>} */\n\t\t\trun: new AsyncSeriesHook([\"compiler\"]),\n\t\t\t/** @type {AsyncSeriesHook<[Compilation]>} */\n\t\t\temit: new AsyncSeriesHook([\"compilation\"]),\n\t\t\t/** @type {AsyncSeriesHook<[string, AssetEmittedInfo]>} */\n\t\t\tassetEmitted: new AsyncSeriesHook([\"file\", \"info\"]),\n\t\t\t/** @type {AsyncSeriesHook<[Compilation]>} */\n\t\t\tafterEmit: new AsyncSeriesHook([\"compilation\"]),\n\n\t\t\t/** @type {SyncHook<[Compilation, CompilationParams]>} */\n\t\t\tthisCompilation: new SyncHook([\"compilation\", \"params\"]),\n\t\t\t/** @type {SyncHook<[Compilation, CompilationParams]>} */\n\t\t\tcompilation: new SyncHook([\"compilation\", \"params\"]),\n\t\t\t/** @type {SyncHook<[NormalModuleFactory]>} */\n\t\t\tnormalModuleFactory: new SyncHook([\"normalModuleFactory\"]),\n\t\t\t/** @type {SyncHook<[ContextModuleFactory]>}  */\n\t\t\tcontextModuleFactory: new SyncHook([\"contextModuleFactory\"]),\n\n\t\t\t/** @type {AsyncSeriesHook<[CompilationParams]>} */\n\t\t\tbeforeCompile: new AsyncSeriesHook([\"params\"]),\n\t\t\t/** @type {SyncHook<[CompilationParams]>} */\n\t\t\tcompile: new SyncHook([\"params\"]),\n\t\t\t/** @type {AsyncParallelHook<[Compilation]>} */\n\t\t\tmake: new AsyncParallelHook([\"compilation\"]),\n\t\t\t/** @type {AsyncParallelHook<[Compilation]>} */\n\t\t\tfinishMake: new AsyncSeriesHook([\"compilation\"]),\n\t\t\t/** @type {AsyncSeriesHook<[Compilation]>} */\n\t\t\tafterCompile: new AsyncSeriesHook([\"compilation\"]),\n\n\t\t\t/** @type {AsyncSeriesHook<[]>} */\n\t\t\treadRecords: new AsyncSeriesHook([]),\n\t\t\t/** @type {AsyncSeriesHook<[]>} */\n\t\t\temitRecords: new AsyncSeriesHook([]),\n\n\t\t\t/** @type {AsyncSeriesHook<[Compiler]>} */\n\t\t\twatchRun: new AsyncSeriesHook([\"compiler\"]),\n\t\t\t/** @type {SyncHook<[Error]>} */\n\t\t\tfailed: new SyncHook([\"error\"]),\n\t\t\t/** @type {SyncHook<[string | null, number]>} */\n\t\t\tinvalid: new SyncHook([\"filename\", \"changeTime\"]),\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\twatchClose: new SyncHook([]),\n\t\t\t/** @type {AsyncSeriesHook<[]>} */\n\t\t\tshutdown: new AsyncSeriesHook([]),\n\n\t\t\t/** @type {SyncBailHook<[string, string, any[]], true>} */\n\t\t\tinfrastructureLog: new SyncBailHook([\"origin\", \"type\", \"args\"]),\n\n\t\t\t// TODO the following hooks are weirdly located here\n\t\t\t// TODO move them for webpack 5\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\tenvironment: new SyncHook([]),\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\tafterEnvironment: new SyncHook([]),\n\t\t\t/** @type {SyncHook<[Compiler]>} */\n\t\t\tafterPlugins: new SyncHook([\"compiler\"]),\n\t\t\t/** @type {SyncHook<[Compiler]>} */\n\t\t\tafterResolvers: new SyncHook([\"compiler\"]),\n\t\t\t/** @type {SyncBailHook<[string, Entry], boolean>} */\n\t\t\tentryOption: new SyncBailHook([\"context\", \"entry\"])\n\t\t});\n\n\t\tthis.webpack = webpack;\n\n\t\t/** @type {string=} */\n\t\tthis.name = undefined;\n\t\t/** @type {Compilation=} */\n\t\tthis.parentCompilation = undefined;\n\t\t/** @type {Compiler} */\n\t\tthis.root = this;\n\t\t/** @type {string} */\n\t\tthis.outputPath = \"\";\n\t\t/** @type {Watching} */\n\t\tthis.watching = undefined;\n\n\t\t/** @type {OutputFileSystem} */\n\t\tthis.outputFileSystem = null;\n\t\t/** @type {IntermediateFileSystem} */\n\t\tthis.intermediateFileSystem = null;\n\t\t/** @type {InputFileSystem} */\n\t\tthis.inputFileSystem = null;\n\t\t/** @type {WatchFileSystem} */\n\t\tthis.watchFileSystem = null;\n\n\t\t/** @type {string|null} */\n\t\tthis.recordsInputPath = null;\n\t\t/** @type {string|null} */\n\t\tthis.recordsOutputPath = null;\n\t\tthis.records = {};\n\t\t/** @type {Set<string | RegExp>} */\n\t\tthis.managedPaths = new Set();\n\t\t/** @type {Set<string | RegExp>} */\n\t\tthis.immutablePaths = new Set();\n\n\t\t/** @type {ReadonlySet<string>} */\n\t\tthis.modifiedFiles = undefined;\n\t\t/** @type {ReadonlySet<string>} */\n\t\tthis.removedFiles = undefined;\n\t\t/** @type {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} */\n\t\tthis.fileTimestamps = undefined;\n\t\t/** @type {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} */\n\t\tthis.contextTimestamps = undefined;\n\t\t/** @type {number} */\n\t\tthis.fsStartTime = undefined;\n\n\t\t/** @type {ResolverFactory} */\n\t\tthis.resolverFactory = new ResolverFactory();\n\n\t\tthis.infrastructureLogger = undefined;\n\n\t\tthis.options = options;\n\n\t\tthis.context = context;\n\n\t\tthis.requestShortener = new RequestShortener(context, this.root);\n\n\t\tthis.cache = new Cache();\n\n\t\t/** @type {Map<Module, { buildInfo: object, references: WeakMap<Dependency, Module>, memCache: WeakTupleMap }> | undefined} */\n\t\tthis.moduleMemCaches = undefined;\n\n\t\tthis.compilerPath = \"\";\n\n\t\t/** @type {boolean} */\n\t\tthis.running = false;\n\n\t\t/** @type {boolean} */\n\t\tthis.idle = false;\n\n\t\t/** @type {boolean} */\n\t\tthis.watchMode = false;\n\n\t\tthis._backCompat = this.options.experiments.backCompat !== false;\n\n\t\t/** @type {Compilation} */\n\t\tthis._lastCompilation = undefined;\n\t\t/** @type {NormalModuleFactory} */\n\t\tthis._lastNormalModuleFactory = undefined;\n\n\t\t/** @private @type {WeakMap<Source, { sizeOnlySource: SizeOnlySource, writtenTo: Map<string, number> }>} */\n\t\tthis._assetEmittingSourceCache = new WeakMap();\n\t\t/** @private @type {Map<string, number>} */\n\t\tthis._assetEmittingWrittenFiles = new Map();\n\t\t/** @private @type {Set<string>} */\n\t\tthis._assetEmittingPreviousFiles = new Set();\n\t}\n\n\t/**\n\t * @param {string} name cache name\n\t * @returns {CacheFacade} the cache facade instance\n\t */\n\tgetCache(name) {\n\t\treturn new CacheFacade(\n\t\t\tthis.cache,\n\t\t\t`${this.compilerPath}${name}`,\n\t\t\tthis.options.output.hashFunction\n\t\t);\n\t}\n\n\t/**\n\t * @param {string | (function(): string)} name name of the logger, or function called once to get the logger name\n\t * @returns {Logger} a logger with that name\n\t */\n\tgetInfrastructureLogger(name) {\n\t\tif (!name) {\n\t\t\tthrow new TypeError(\n\t\t\t\t\"Compiler.getInfrastructureLogger(name) called without a name\"\n\t\t\t);\n\t\t}\n\t\treturn new Logger(\n\t\t\t(type, args) => {\n\t\t\t\tif (typeof name === \"function\") {\n\t\t\t\t\tname = name();\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\t\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.hooks.infrastructureLog.call(name, type, args) === undefined) {\n\t\t\t\t\tif (this.infrastructureLogger !== undefined) {\n\t\t\t\t\t\tthis.infrastructureLogger(name, type, args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tchildName => {\n\t\t\t\tif (typeof name === \"function\") {\n\t\t\t\t\tif (typeof childName === \"function\") {\n\t\t\t\t\t\treturn this.getInfrastructureLogger(() => {\n\t\t\t\t\t\t\tif (typeof name === \"function\") {\n\t\t\t\t\t\t\t\tname = name();\n\t\t\t\t\t\t\t\tif (!name) {\n\t\t\t\t\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\t\t\t\t\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (typeof childName === \"function\") {\n\t\t\t\t\t\t\t\tchildName = childName();\n\t\t\t\t\t\t\t\tif (!childName) {\n\t\t\t\t\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\t\t\t\t\"Logger.getChildLogger(name) called with a function not returning a name\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn `${name}/${childName}`;\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this.getInfrastructureLogger(() => {\n\t\t\t\t\t\t\tif (typeof name === \"function\") {\n\t\t\t\t\t\t\t\tname = name();\n\t\t\t\t\t\t\t\tif (!name) {\n\t\t\t\t\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\t\t\t\t\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn `${name}/${childName}`;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (typeof childName === \"function\") {\n\t\t\t\t\t\treturn this.getInfrastructureLogger(() => {\n\t\t\t\t\t\t\tif (typeof childName === \"function\") {\n\t\t\t\t\t\t\t\tchildName = childName();\n\t\t\t\t\t\t\t\tif (!childName) {\n\t\t\t\t\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\t\t\t\t\"Logger.getChildLogger(name) called with a function not returning a name\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn `${name}/${childName}`;\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this.getInfrastructureLogger(`${name}/${childName}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\n\t// TODO webpack 6: solve this in a better way\n\t// e.g. move compilation specific info from Modules into ModuleGraph\n\t_cleanupLastCompilation() {\n\t\tif (this._lastCompilation !== undefined) {\n\t\t\tfor (const module of this._lastCompilation.modules) {\n\t\t\t\tChunkGraph.clearChunkGraphForModule(module);\n\t\t\t\tModuleGraph.clearModuleGraphForModule(module);\n\t\t\t\tmodule.cleanupForCache();\n\t\t\t}\n\t\t\tfor (const chunk of this._lastCompilation.chunks) {\n\t\t\t\tChunkGraph.clearChunkGraphForChunk(chunk);\n\t\t\t}\n\t\t\tthis._lastCompilation = undefined;\n\t\t}\n\t}\n\n\t// TODO webpack 6: solve this in a better way\n\t_cleanupLastNormalModuleFactory() {\n\t\tif (this._lastNormalModuleFactory !== undefined) {\n\t\t\tthis._lastNormalModuleFactory.cleanupForCache();\n\t\t\tthis._lastNormalModuleFactory = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {WatchOptions} watchOptions the watcher's options\n\t * @param {Callback<Stats>} handler signals when the call finishes\n\t * @returns {Watching} a compiler watcher\n\t */\n\twatch(watchOptions, handler) {\n\t\tif (this.running) {\n\t\t\treturn handler(new ConcurrentCompilationError());\n\t\t}\n\n\t\tthis.running = true;\n\t\tthis.watchMode = true;\n\t\tthis.watching = new Watching(this, watchOptions, handler);\n\t\treturn this.watching;\n\t}\n\n\t/**\n\t * @param {Callback<Stats>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\trun(callback) {\n\t\tif (this.running) {\n\t\t\treturn callback(new ConcurrentCompilationError());\n\t\t}\n\n\t\tlet logger;\n\n\t\tconst finalCallback = (err, stats) => {\n\t\t\tif (logger) logger.time(\"beginIdle\");\n\t\t\tthis.idle = true;\n\t\t\tthis.cache.beginIdle();\n\t\t\tthis.idle = true;\n\t\t\tif (logger) logger.timeEnd(\"beginIdle\");\n\t\t\tthis.running = false;\n\t\t\tif (err) {\n\t\t\t\tthis.hooks.failed.call(err);\n\t\t\t}\n\t\t\tif (callback !== undefined) callback(err, stats);\n\t\t\tthis.hooks.afterDone.call(stats);\n\t\t};\n\n\t\tconst startTime = Date.now();\n\n\t\tthis.running = true;\n\n\t\tconst onCompiled = (err, compilation) => {\n\t\t\tif (err) return finalCallback(err);\n\n\t\t\tif (this.hooks.shouldEmit.call(compilation) === false) {\n\t\t\t\tcompilation.startTime = startTime;\n\t\t\t\tcompilation.endTime = Date.now();\n\t\t\t\tconst stats = new Stats(compilation);\n\t\t\t\tthis.hooks.done.callAsync(stats, err => {\n\t\t\t\t\tif (err) return finalCallback(err);\n\t\t\t\t\treturn finalCallback(null, stats);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tprocess.nextTick(() => {\n\t\t\t\tlogger = compilation.getLogger(\"webpack.Compiler\");\n\t\t\t\tlogger.time(\"emitAssets\");\n\t\t\t\tthis.emitAssets(compilation, err => {\n\t\t\t\t\tlogger.timeEnd(\"emitAssets\");\n\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\tif (compilation.hooks.needAdditionalPass.call()) {\n\t\t\t\t\t\tcompilation.needAdditionalPass = true;\n\n\t\t\t\t\t\tcompilation.startTime = startTime;\n\t\t\t\t\t\tcompilation.endTime = Date.now();\n\t\t\t\t\t\tlogger.time(\"done hook\");\n\t\t\t\t\t\tconst stats = new Stats(compilation);\n\t\t\t\t\t\tthis.hooks.done.callAsync(stats, err => {\n\t\t\t\t\t\t\tlogger.timeEnd(\"done hook\");\n\t\t\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\t\t\tthis.hooks.additionalPass.callAsync(err => {\n\t\t\t\t\t\t\t\tif (err) return finalCallback(err);\n\t\t\t\t\t\t\t\tthis.compile(onCompiled);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tlogger.time(\"emitRecords\");\n\t\t\t\t\tthis.emitRecords(err => {\n\t\t\t\t\t\tlogger.timeEnd(\"emitRecords\");\n\t\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\t\tcompilation.startTime = startTime;\n\t\t\t\t\t\tcompilation.endTime = Date.now();\n\t\t\t\t\t\tlogger.time(\"done hook\");\n\t\t\t\t\t\tconst stats = new Stats(compilation);\n\t\t\t\t\t\tthis.hooks.done.callAsync(stats, err => {\n\t\t\t\t\t\t\tlogger.timeEnd(\"done hook\");\n\t\t\t\t\t\t\tif (err) return finalCallback(err);\n\t\t\t\t\t\t\tthis.cache.storeBuildDependencies(\n\t\t\t\t\t\t\t\tcompilation.buildDependencies,\n\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\tif (err) return finalCallback(err);\n\t\t\t\t\t\t\t\t\treturn finalCallback(null, stats);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\tconst run = () => {\n\t\t\tthis.hooks.beforeRun.callAsync(this, err => {\n\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\tthis.hooks.run.callAsync(this, err => {\n\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\tthis.readRecords(err => {\n\t\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\t\tthis.compile(onCompiled);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\tif (this.idle) {\n\t\t\tthis.cache.endIdle(err => {\n\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\tthis.idle = false;\n\t\t\t\trun();\n\t\t\t});\n\t\t} else {\n\t\t\trun();\n\t\t}\n\t}\n\n\t/**\n\t * @param {RunAsChildCallback} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\trunAsChild(callback) {\n\t\tconst startTime = Date.now();\n\t\tthis.compile((err, compilation) => {\n\t\t\tif (err) return callback(err);\n\n\t\t\tthis.parentCompilation.children.push(compilation);\n\t\t\tfor (const { name, source, info } of compilation.getAssets()) {\n\t\t\t\tthis.parentCompilation.emitAsset(name, source, info);\n\t\t\t}\n\n\t\t\tconst entries = [];\n\t\t\tfor (const ep of compilation.entrypoints.values()) {\n\t\t\t\tentries.push(...ep.chunks);\n\t\t\t}\n\n\t\t\tcompilation.startTime = startTime;\n\t\t\tcompilation.endTime = Date.now();\n\n\t\t\treturn callback(null, entries, compilation);\n\t\t});\n\t}\n\n\tpurgeInputFileSystem() {\n\t\tif (this.inputFileSystem && this.inputFileSystem.purge) {\n\t\t\tthis.inputFileSystem.purge();\n\t\t}\n\t}\n\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @param {Callback<void>} callback signals when the assets are emitted\n\t * @returns {void}\n\t */\n\temitAssets(compilation, callback) {\n\t\tlet outputPath;\n\n\t\tconst emitFiles = err => {\n\t\t\tif (err) return callback(err);\n\n\t\t\tconst assets = compilation.getAssets();\n\t\t\tcompilation.assets = { ...compilation.assets };\n\t\t\t/** @type {Map<string, { path: string, source: Source, size: number, waiting: { cacheEntry: any, file: string }[] }>} */\n\t\t\tconst caseInsensitiveMap = new Map();\n\t\t\t/** @type {Set<string>} */\n\t\t\tconst allTargetPaths = new Set();\n\t\t\tasyncLib.forEachLimit(\n\t\t\t\tassets,\n\t\t\t\t15,\n\t\t\t\t({ name: file, source, info }, callback) => {\n\t\t\t\t\tlet targetFile = file;\n\t\t\t\t\tlet immutable = info.immutable;\n\t\t\t\t\tconst queryStringIdx = targetFile.indexOf(\"?\");\n\t\t\t\t\tif (queryStringIdx >= 0) {\n\t\t\t\t\t\ttargetFile = targetFile.substr(0, queryStringIdx);\n\t\t\t\t\t\t// We may remove the hash, which is in the query string\n\t\t\t\t\t\t// So we recheck if the file is immutable\n\t\t\t\t\t\t// This doesn't cover all cases, but immutable is only a performance optimization anyway\n\t\t\t\t\t\timmutable =\n\t\t\t\t\t\t\timmutable &&\n\t\t\t\t\t\t\t(includesHash(targetFile, info.contenthash) ||\n\t\t\t\t\t\t\t\tincludesHash(targetFile, info.chunkhash) ||\n\t\t\t\t\t\t\t\tincludesHash(targetFile, info.modulehash) ||\n\t\t\t\t\t\t\t\tincludesHash(targetFile, info.fullhash));\n\t\t\t\t\t}\n\n\t\t\t\t\tconst writeOut = err => {\n\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\tconst targetPath = join(\n\t\t\t\t\t\t\tthis.outputFileSystem,\n\t\t\t\t\t\t\toutputPath,\n\t\t\t\t\t\t\ttargetFile\n\t\t\t\t\t\t);\n\t\t\t\t\t\tallTargetPaths.add(targetPath);\n\n\t\t\t\t\t\t// check if the target file has already been written by this Compiler\n\t\t\t\t\t\tconst targetFileGeneration =\n\t\t\t\t\t\t\tthis._assetEmittingWrittenFiles.get(targetPath);\n\n\t\t\t\t\t\t// create an cache entry for this Source if not already existing\n\t\t\t\t\t\tlet cacheEntry = this._assetEmittingSourceCache.get(source);\n\t\t\t\t\t\tif (cacheEntry === undefined) {\n\t\t\t\t\t\t\tcacheEntry = {\n\t\t\t\t\t\t\t\tsizeOnlySource: undefined,\n\t\t\t\t\t\t\t\twrittenTo: new Map()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tthis._assetEmittingSourceCache.set(source, cacheEntry);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet similarEntry;\n\n\t\t\t\t\t\tconst checkSimilarFile = () => {\n\t\t\t\t\t\t\tconst caseInsensitiveTargetPath = targetPath.toLowerCase();\n\t\t\t\t\t\t\tsimilarEntry = caseInsensitiveMap.get(caseInsensitiveTargetPath);\n\t\t\t\t\t\t\tif (similarEntry !== undefined) {\n\t\t\t\t\t\t\t\tconst { path: other, source: otherSource } = similarEntry;\n\t\t\t\t\t\t\t\tif (isSourceEqual(otherSource, source)) {\n\t\t\t\t\t\t\t\t\t// Size may or may not be available at this point.\n\t\t\t\t\t\t\t\t\t// If it's not available add to \"waiting\" list and it will be updated once available\n\t\t\t\t\t\t\t\t\tif (similarEntry.size !== undefined) {\n\t\t\t\t\t\t\t\t\t\tupdateWithReplacementSource(similarEntry.size);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif (!similarEntry.waiting) similarEntry.waiting = [];\n\t\t\t\t\t\t\t\t\t\tsimilarEntry.waiting.push({ file, cacheEntry });\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\talreadyWritten();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst err =\n\t\t\t\t\t\t\t\t\t\tnew WebpackError(`Prevent writing to file that only differs in casing or query string from already written file.\nThis will lead to a race-condition and corrupted files on case-insensitive file systems.\n${targetPath}\n${other}`);\n\t\t\t\t\t\t\t\t\terr.file = file;\n\t\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcaseInsensitiveMap.set(\n\t\t\t\t\t\t\t\t\tcaseInsensitiveTargetPath,\n\t\t\t\t\t\t\t\t\t(similarEntry = {\n\t\t\t\t\t\t\t\t\t\tpath: targetPath,\n\t\t\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\t\t\tsize: undefined,\n\t\t\t\t\t\t\t\t\t\twaiting: undefined\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * get the binary (Buffer) content from the Source\n\t\t\t\t\t\t * @returns {Buffer} content for the source\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst getContent = () => {\n\t\t\t\t\t\t\tif (typeof source.buffer === \"function\") {\n\t\t\t\t\t\t\t\treturn source.buffer();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst bufferOrString = source.source();\n\t\t\t\t\t\t\t\tif (Buffer.isBuffer(bufferOrString)) {\n\t\t\t\t\t\t\t\t\treturn bufferOrString;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn Buffer.from(bufferOrString, \"utf8\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst alreadyWritten = () => {\n\t\t\t\t\t\t\t// cache the information that the Source has been already been written to that location\n\t\t\t\t\t\t\tif (targetFileGeneration === undefined) {\n\t\t\t\t\t\t\t\tconst newGeneration = 1;\n\t\t\t\t\t\t\t\tthis._assetEmittingWrittenFiles.set(targetPath, newGeneration);\n\t\t\t\t\t\t\t\tcacheEntry.writtenTo.set(targetPath, newGeneration);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcacheEntry.writtenTo.set(targetPath, targetFileGeneration);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Write the file to output file system\n\t\t\t\t\t\t * @param {Buffer} content content to be written\n\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst doWrite = content => {\n\t\t\t\t\t\t\tthis.outputFileSystem.writeFile(targetPath, content, err => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\t// information marker that the asset has been emitted\n\t\t\t\t\t\t\t\tcompilation.emittedAssets.add(file);\n\n\t\t\t\t\t\t\t\t// cache the information that the Source has been written to that location\n\t\t\t\t\t\t\t\tconst newGeneration =\n\t\t\t\t\t\t\t\t\ttargetFileGeneration === undefined\n\t\t\t\t\t\t\t\t\t\t? 1\n\t\t\t\t\t\t\t\t\t\t: targetFileGeneration + 1;\n\t\t\t\t\t\t\t\tcacheEntry.writtenTo.set(targetPath, newGeneration);\n\t\t\t\t\t\t\t\tthis._assetEmittingWrittenFiles.set(targetPath, newGeneration);\n\t\t\t\t\t\t\t\tthis.hooks.assetEmitted.callAsync(\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tcontent,\n\t\t\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\t\t\toutputPath,\n\t\t\t\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\t\t\t\ttargetPath\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst updateWithReplacementSource = size => {\n\t\t\t\t\t\t\tupdateFileWithReplacementSource(file, cacheEntry, size);\n\t\t\t\t\t\t\tsimilarEntry.size = size;\n\t\t\t\t\t\t\tif (similarEntry.waiting !== undefined) {\n\t\t\t\t\t\t\t\tfor (const { file, cacheEntry } of similarEntry.waiting) {\n\t\t\t\t\t\t\t\t\tupdateFileWithReplacementSource(file, cacheEntry, size);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst updateFileWithReplacementSource = (\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\tcacheEntry,\n\t\t\t\t\t\t\tsize\n\t\t\t\t\t\t) => {\n\t\t\t\t\t\t\t// Create a replacement resource which only allows to ask for size\n\t\t\t\t\t\t\t// This allows to GC all memory allocated by the Source\n\t\t\t\t\t\t\t// (expect when the Source is stored in any other cache)\n\t\t\t\t\t\t\tif (!cacheEntry.sizeOnlySource) {\n\t\t\t\t\t\t\t\tcacheEntry.sizeOnlySource = new SizeOnlySource(size);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcompilation.updateAsset(file, cacheEntry.sizeOnlySource, {\n\t\t\t\t\t\t\t\tsize\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst processExistingFile = stats => {\n\t\t\t\t\t\t\t// skip emitting if it's already there and an immutable file\n\t\t\t\t\t\t\tif (immutable) {\n\t\t\t\t\t\t\t\tupdateWithReplacementSource(stats.size);\n\t\t\t\t\t\t\t\treturn alreadyWritten();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst content = getContent();\n\n\t\t\t\t\t\t\tupdateWithReplacementSource(content.length);\n\n\t\t\t\t\t\t\t// if it exists and content on disk matches content\n\t\t\t\t\t\t\t// skip writing the same content again\n\t\t\t\t\t\t\t// (to keep mtime and don't trigger watchers)\n\t\t\t\t\t\t\t// for a fast negative match file size is compared first\n\t\t\t\t\t\t\tif (content.length === stats.size) {\n\t\t\t\t\t\t\t\tcompilation.comparedForEmitAssets.add(file);\n\t\t\t\t\t\t\t\treturn this.outputFileSystem.readFile(\n\t\t\t\t\t\t\t\t\ttargetPath,\n\t\t\t\t\t\t\t\t\t(err, existingContent) => {\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\terr ||\n\t\t\t\t\t\t\t\t\t\t\t!content.equals(/** @type {Buffer} */ (existingContent))\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\treturn doWrite(content);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\treturn alreadyWritten();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn doWrite(content);\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst processMissingFile = () => {\n\t\t\t\t\t\t\tconst content = getContent();\n\n\t\t\t\t\t\t\tupdateWithReplacementSource(content.length);\n\n\t\t\t\t\t\t\treturn doWrite(content);\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// if the target file has already been written\n\t\t\t\t\t\tif (targetFileGeneration !== undefined) {\n\t\t\t\t\t\t\t// check if the Source has been written to this target file\n\t\t\t\t\t\t\tconst writtenGeneration = cacheEntry.writtenTo.get(targetPath);\n\t\t\t\t\t\t\tif (writtenGeneration === targetFileGeneration) {\n\t\t\t\t\t\t\t\t// if yes, we may skip writing the file\n\t\t\t\t\t\t\t\t// if it's already there\n\t\t\t\t\t\t\t\t// (we assume one doesn't modify files while the Compiler is running, other then removing them)\n\n\t\t\t\t\t\t\t\tif (this._assetEmittingPreviousFiles.has(targetPath)) {\n\t\t\t\t\t\t\t\t\t// We assume that assets from the last compilation say intact on disk (they are not removed)\n\t\t\t\t\t\t\t\t\tcompilation.updateAsset(file, cacheEntry.sizeOnlySource, {\n\t\t\t\t\t\t\t\t\t\tsize: cacheEntry.sizeOnlySource.size()\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Settings immutable will make it accept file content without comparing when file exist\n\t\t\t\t\t\t\t\t\timmutable = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (!immutable) {\n\t\t\t\t\t\t\t\tif (checkSimilarFile()) return;\n\t\t\t\t\t\t\t\t// We wrote to this file before which has very likely a different content\n\t\t\t\t\t\t\t\t// skip comparing and assume content is different for performance\n\t\t\t\t\t\t\t\t// This case happens often during watch mode.\n\t\t\t\t\t\t\t\treturn processMissingFile();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (checkSimilarFile()) return;\n\t\t\t\t\t\tif (this.options.output.compareBeforeEmit) {\n\t\t\t\t\t\t\tthis.outputFileSystem.stat(targetPath, (err, stats) => {\n\t\t\t\t\t\t\t\tconst exists = !err && stats.isFile();\n\n\t\t\t\t\t\t\t\tif (exists) {\n\t\t\t\t\t\t\t\t\tprocessExistingFile(stats);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tprocessMissingFile();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprocessMissingFile();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tif (targetFile.match(/\\/|\\\\/)) {\n\t\t\t\t\t\tconst fs = this.outputFileSystem;\n\t\t\t\t\t\tconst dir = dirname(fs, join(fs, outputPath, targetFile));\n\t\t\t\t\t\tmkdirp(fs, dir, writeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twriteOut();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\terr => {\n\t\t\t\t\t// Clear map to free up memory\n\t\t\t\t\tcaseInsensitiveMap.clear();\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tthis._assetEmittingPreviousFiles.clear();\n\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._assetEmittingPreviousFiles = allTargetPaths;\n\n\t\t\t\t\tthis.hooks.afterEmit.callAsync(compilation, err => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\treturn callback();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t);\n\t\t};\n\n\t\tthis.hooks.emit.callAsync(compilation, err => {\n\t\t\tif (err) return callback(err);\n\t\t\toutputPath = compilation.getPath(this.outputPath, {});\n\t\t\tmkdirp(this.outputFileSystem, outputPath, emitFiles);\n\t\t});\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\temitRecords(callback) {\n\t\tif (this.hooks.emitRecords.isUsed()) {\n\t\t\tif (this.recordsOutputPath) {\n\t\t\t\tasyncLib.parallel(\n\t\t\t\t\t[\n\t\t\t\t\t\tcb => this.hooks.emitRecords.callAsync(cb),\n\t\t\t\t\t\tthis._emitRecords.bind(this)\n\t\t\t\t\t],\n\t\t\t\t\terr => callback(err)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.hooks.emitRecords.callAsync(callback);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.recordsOutputPath) {\n\t\t\t\tthis._emitRecords(callback);\n\t\t\t} else {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\t_emitRecords(callback) {\n\t\tconst writeFile = () => {\n\t\t\tthis.outputFileSystem.writeFile(\n\t\t\t\tthis.recordsOutputPath,\n\t\t\t\tJSON.stringify(\n\t\t\t\t\tthis.records,\n\t\t\t\t\t(n, value) => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttypeof value === \"object\" &&\n\t\t\t\t\t\t\tvalue !== null &&\n\t\t\t\t\t\t\t!Array.isArray(value)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst keys = Object.keys(value);\n\t\t\t\t\t\t\tif (!isSorted(keys)) {\n\t\t\t\t\t\t\t\treturn sortObject(value, keys);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t},\n\t\t\t\t\t2\n\t\t\t\t),\n\t\t\t\tcallback\n\t\t\t);\n\t\t};\n\n\t\tconst recordsOutputPathDirectory = dirname(\n\t\t\tthis.outputFileSystem,\n\t\t\tthis.recordsOutputPath\n\t\t);\n\t\tif (!recordsOutputPathDirectory) {\n\t\t\treturn writeFile();\n\t\t}\n\t\tmkdirp(this.outputFileSystem, recordsOutputPathDirectory, err => {\n\t\t\tif (err) return callback(err);\n\t\t\twriteFile();\n\t\t});\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\treadRecords(callback) {\n\t\tif (this.hooks.readRecords.isUsed()) {\n\t\t\tif (this.recordsInputPath) {\n\t\t\t\tasyncLib.parallel([\n\t\t\t\t\tcb => this.hooks.readRecords.callAsync(cb),\n\t\t\t\t\tthis._readRecords.bind(this)\n\t\t\t\t]);\n\t\t\t} else {\n\t\t\t\tthis.records = {};\n\t\t\t\tthis.hooks.readRecords.callAsync(callback);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.recordsInputPath) {\n\t\t\t\tthis._readRecords(callback);\n\t\t\t} else {\n\t\t\t\tthis.records = {};\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\t_readRecords(callback) {\n\t\tif (!this.recordsInputPath) {\n\t\t\tthis.records = {};\n\t\t\treturn callback();\n\t\t}\n\t\tthis.inputFileSystem.stat(this.recordsInputPath, err => {\n\t\t\t// It doesn't exist\n\t\t\t// We can ignore this.\n\t\t\tif (err) return callback();\n\n\t\t\tthis.inputFileSystem.readFile(this.recordsInputPath, (err, content) => {\n\t\t\t\tif (err) return callback(err);\n\n\t\t\t\ttry {\n\t\t\t\t\tthis.records = parseJson(content.toString(\"utf-8\"));\n\t\t\t\t} catch (e) {\n\t\t\t\t\te.message = \"Cannot parse records: \" + e.message;\n\t\t\t\t\treturn callback(e);\n\t\t\t\t}\n\n\t\t\t\treturn callback();\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @param {string} compilerName the compiler's name\n\t * @param {number} compilerIndex the compiler's index\n\t * @param {OutputOptions=} outputOptions the output options\n\t * @param {WebpackPluginInstance[]=} plugins the plugins to apply\n\t * @returns {Compiler} a child compiler\n\t */\n\tcreateChildCompiler(\n\t\tcompilation,\n\t\tcompilerName,\n\t\tcompilerIndex,\n\t\toutputOptions,\n\t\tplugins\n\t) {\n\t\tconst childCompiler = new Compiler(this.context, {\n\t\t\t...this.options,\n\t\t\toutput: {\n\t\t\t\t...this.options.output,\n\t\t\t\t...outputOptions\n\t\t\t}\n\t\t});\n\t\tchildCompiler.name = compilerName;\n\t\tchildCompiler.outputPath = this.outputPath;\n\t\tchildCompiler.inputFileSystem = this.inputFileSystem;\n\t\tchildCompiler.outputFileSystem = null;\n\t\tchildCompiler.resolverFactory = this.resolverFactory;\n\t\tchildCompiler.modifiedFiles = this.modifiedFiles;\n\t\tchildCompiler.removedFiles = this.removedFiles;\n\t\tchildCompiler.fileTimestamps = this.fileTimestamps;\n\t\tchildCompiler.contextTimestamps = this.contextTimestamps;\n\t\tchildCompiler.fsStartTime = this.fsStartTime;\n\t\tchildCompiler.cache = this.cache;\n\t\tchildCompiler.compilerPath = `${this.compilerPath}${compilerName}|${compilerIndex}|`;\n\t\tchildCompiler._backCompat = this._backCompat;\n\n\t\tconst relativeCompilerName = makePathsRelative(\n\t\t\tthis.context,\n\t\t\tcompilerName,\n\t\t\tthis.root\n\t\t);\n\t\tif (!this.records[relativeCompilerName]) {\n\t\t\tthis.records[relativeCompilerName] = [];\n\t\t}\n\t\tif (this.records[relativeCompilerName][compilerIndex]) {\n\t\t\tchildCompiler.records = this.records[relativeCompilerName][compilerIndex];\n\t\t} else {\n\t\t\tthis.records[relativeCompilerName].push((childCompiler.records = {}));\n\t\t}\n\n\t\tchildCompiler.parentCompilation = compilation;\n\t\tchildCompiler.root = this.root;\n\t\tif (Array.isArray(plugins)) {\n\t\t\tfor (const plugin of plugins) {\n\t\t\t\tplugin.apply(childCompiler);\n\t\t\t}\n\t\t}\n\t\tfor (const name in this.hooks) {\n\t\t\tif (\n\t\t\t\t![\n\t\t\t\t\t\"make\",\n\t\t\t\t\t\"compile\",\n\t\t\t\t\t\"emit\",\n\t\t\t\t\t\"afterEmit\",\n\t\t\t\t\t\"invalid\",\n\t\t\t\t\t\"done\",\n\t\t\t\t\t\"thisCompilation\"\n\t\t\t\t].includes(name)\n\t\t\t) {\n\t\t\t\tif (childCompiler.hooks[name]) {\n\t\t\t\t\tchildCompiler.hooks[name].taps = this.hooks[name].taps.slice();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcompilation.hooks.childCompiler.call(\n\t\t\tchildCompiler,\n\t\t\tcompilerName,\n\t\t\tcompilerIndex\n\t\t);\n\n\t\treturn childCompiler;\n\t}\n\n\tisChild() {\n\t\treturn !!this.parentCompilation;\n\t}\n\n\tcreateCompilation(params) {\n\t\tthis._cleanupLastCompilation();\n\t\treturn (this._lastCompilation = new Compilation(this, params));\n\t}\n\n\t/**\n\t * @param {CompilationParams} params the compilation parameters\n\t * @returns {Compilation} the created compilation\n\t */\n\tnewCompilation(params) {\n\t\tconst compilation = this.createCompilation(params);\n\t\tcompilation.name = this.name;\n\t\tcompilation.records = this.records;\n\t\tthis.hooks.thisCompilation.call(compilation, params);\n\t\tthis.hooks.compilation.call(compilation, params);\n\t\treturn compilation;\n\t}\n\n\tcreateNormalModuleFactory() {\n\t\tthis._cleanupLastNormalModuleFactory();\n\t\tconst normalModuleFactory = new NormalModuleFactory({\n\t\t\tcontext: this.options.context,\n\t\t\tfs: this.inputFileSystem,\n\t\t\tresolverFactory: this.resolverFactory,\n\t\t\toptions: this.options.module,\n\t\t\tassociatedObjectForCache: this.root,\n\t\t\tlayers: this.options.experiments.layers\n\t\t});\n\t\tthis._lastNormalModuleFactory = normalModuleFactory;\n\t\tthis.hooks.normalModuleFactory.call(normalModuleFactory);\n\t\treturn normalModuleFactory;\n\t}\n\n\tcreateContextModuleFactory() {\n\t\tconst contextModuleFactory = new ContextModuleFactory(this.resolverFactory);\n\t\tthis.hooks.contextModuleFactory.call(contextModuleFactory);\n\t\treturn contextModuleFactory;\n\t}\n\n\tnewCompilationParams() {\n\t\tconst params = {\n\t\t\tnormalModuleFactory: this.createNormalModuleFactory(),\n\t\t\tcontextModuleFactory: this.createContextModuleFactory()\n\t\t};\n\t\treturn params;\n\t}\n\n\t/**\n\t * @param {Callback<Compilation>} callback signals when the compilation finishes\n\t * @returns {void}\n\t */\n\tcompile(callback) {\n\t\tconst params = this.newCompilationParams();\n\t\tthis.hooks.beforeCompile.callAsync(params, err => {\n\t\t\tif (err) return callback(err);\n\n\t\t\tthis.hooks.compile.call(params);\n\n\t\t\tconst compilation = this.newCompilation(params);\n\n\t\t\tconst logger = compilation.getLogger(\"webpack.Compiler\");\n\n\t\t\tlogger.time(\"make hook\");\n\t\t\tthis.hooks.make.callAsync(compilation, err => {\n\t\t\t\tlogger.timeEnd(\"make hook\");\n\t\t\t\tif (err) return callback(err);\n\n\t\t\t\tlogger.time(\"finish make hook\");\n\t\t\t\tthis.hooks.finishMake.callAsync(compilation, err => {\n\t\t\t\t\tlogger.timeEnd(\"finish make hook\");\n\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\t\tlogger.time(\"finish compilation\");\n\t\t\t\t\t\tcompilation.finish(err => {\n\t\t\t\t\t\t\tlogger.timeEnd(\"finish compilation\");\n\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\tlogger.time(\"seal compilation\");\n\t\t\t\t\t\t\tcompilation.seal(err => {\n\t\t\t\t\t\t\t\tlogger.timeEnd(\"seal compilation\");\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\tlogger.time(\"afterCompile hook\");\n\t\t\t\t\t\t\t\tthis.hooks.afterCompile.callAsync(compilation, err => {\n\t\t\t\t\t\t\t\t\tlogger.timeEnd(\"afterCompile hook\");\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\t\treturn callback(null, compilation);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the compiler closes\n\t * @returns {void}\n\t */\n\tclose(callback) {\n\t\tif (this.watching) {\n\t\t\t// When there is still an active watching, close this first\n\t\t\tthis.watching.close(err => {\n\t\t\t\tthis.close(callback);\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tthis.hooks.shutdown.callAsync(err => {\n\t\t\tif (err) return callback(err);\n\t\t\t// Get rid of reference to last compilation to avoid leaking memory\n\t\t\t// We can't run this._cleanupLastCompilation() as the Stats to this compilation\n\t\t\t// might be still in use. We try to get rid of the reference to the cache instead.\n\t\t\tthis._lastCompilation = undefined;\n\t\t\tthis._lastNormalModuleFactory = undefined;\n\t\t\tthis.cache.shutdown(callback);\n\t\t});\n\t}\n}\n\nmodule.exports = Compiler;\n"]},"metadata":{},"sourceType":"script"}