{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  UsageState\n} = require(\"../ExportsInfo\");\n\nconst makeSerializable = require(\"../util/makeSerializable\");\n\nconst {\n  filterRuntime\n} = require(\"../util/runtime\");\n\nconst NullDependency = require(\"./NullDependency\");\n/** @typedef {import(\"webpack-sources\").ReplaceSource} ReplaceSource */\n\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n\n/** @typedef {import(\"../Dependency\")} Dependency */\n\n/** @typedef {import(\"../Dependency\").UpdateHashContext} UpdateHashContext */\n\n/** @typedef {import(\"../DependencyTemplate\").DependencyTemplateContext} DependencyTemplateContext */\n\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n\n/** @typedef {import(\"../ModuleGraphConnection\").ConnectionState} ConnectionState */\n\n/** @typedef {import(\"../util/Hash\")} Hash */\n\n\nclass PureExpressionDependency extends NullDependency {\n  /**\n   * @param {[number, number]} range the source range\n   */\n  constructor(range) {\n    super();\n    this.range = range;\n    /** @type {Set<string> | false} */\n\n    this.usedByExports = false;\n    this._hashUpdate = undefined;\n  }\n  /**\n   * Update the hash\n   * @param {Hash} hash hash to be updated\n   * @param {UpdateHashContext} context context\n   * @returns {void}\n   */\n\n\n  updateHash(hash, context) {\n    if (this._hashUpdate === undefined) {\n      this._hashUpdate = this.range + \"\";\n    }\n\n    hash.update(this._hashUpdate);\n  }\n  /**\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @returns {ConnectionState} how this dependency connects the module to referencing modules\n   */\n\n\n  getModuleEvaluationSideEffectsState(moduleGraph) {\n    return false;\n  }\n\n  serialize(context) {\n    const {\n      write\n    } = context;\n    write(this.range);\n    write(this.usedByExports);\n    super.serialize(context);\n  }\n\n  deserialize(context) {\n    const {\n      read\n    } = context;\n    this.range = read();\n    this.usedByExports = read();\n    super.deserialize(context);\n  }\n\n}\n\nmakeSerializable(PureExpressionDependency, \"webpack/lib/dependencies/PureExpressionDependency\");\nPureExpressionDependency.Template = class PureExpressionDependencyTemplate extends NullDependency.Template {\n  /**\n   * @param {Dependency} dependency the dependency for which the template should be applied\n   * @param {ReplaceSource} source the current replace source which can be modified\n   * @param {DependencyTemplateContext} templateContext the context object\n   * @returns {void}\n   */\n  apply(dependency, source, _ref) {\n    let {\n      chunkGraph,\n      moduleGraph,\n      runtime,\n      runtimeTemplate,\n      runtimeRequirements\n    } = _ref;\n    const dep =\n    /** @type {PureExpressionDependency} */\n    dependency;\n    const usedByExports = dep.usedByExports;\n\n    if (usedByExports !== false) {\n      const selfModule = moduleGraph.getParentModule(dep);\n      const exportsInfo = moduleGraph.getExportsInfo(selfModule);\n      const runtimeCondition = filterRuntime(runtime, runtime => {\n        for (const exportName of usedByExports) {\n          if (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused) {\n            return true;\n          }\n        }\n\n        return false;\n      });\n      if (runtimeCondition === true) return;\n\n      if (runtimeCondition !== false) {\n        const condition = runtimeTemplate.runtimeConditionExpression({\n          chunkGraph,\n          runtime,\n          runtimeCondition,\n          runtimeRequirements\n        });\n        source.insert(dep.range[0], `(/* runtime-dependent pure expression or super */ ${condition} ? (`);\n        source.insert(dep.range[1], \") : null)\");\n        return;\n      }\n    }\n\n    source.insert(dep.range[0], `(/* unused pure expression or super */ null && (`);\n    source.insert(dep.range[1], \"))\");\n  }\n\n};\nmodule.exports = PureExpressionDependency;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/dependencies/PureExpressionDependency.js"],"names":["UsageState","require","makeSerializable","filterRuntime","NullDependency","PureExpressionDependency","constructor","range","usedByExports","_hashUpdate","undefined","updateHash","hash","context","update","getModuleEvaluationSideEffectsState","moduleGraph","serialize","write","deserialize","read","Template","PureExpressionDependencyTemplate","apply","dependency","source","chunkGraph","runtime","runtimeTemplate","runtimeRequirements","dep","selfModule","getParentModule","exportsInfo","getExportsInfo","runtimeCondition","exportName","getUsed","Unused","condition","runtimeConditionExpression","insert","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { UsageState } = require(\"../ExportsInfo\");\nconst makeSerializable = require(\"../util/makeSerializable\");\nconst { filterRuntime } = require(\"../util/runtime\");\nconst NullDependency = require(\"./NullDependency\");\n\n/** @typedef {import(\"webpack-sources\").ReplaceSource} ReplaceSource */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../Dependency\").UpdateHashContext} UpdateHashContext */\n/** @typedef {import(\"../DependencyTemplate\").DependencyTemplateContext} DependencyTemplateContext */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../ModuleGraphConnection\").ConnectionState} ConnectionState */\n/** @typedef {import(\"../util/Hash\")} Hash */\n\nclass PureExpressionDependency extends NullDependency {\n\t/**\n\t * @param {[number, number]} range the source range\n\t */\n\tconstructor(range) {\n\t\tsuper();\n\t\tthis.range = range;\n\t\t/** @type {Set<string> | false} */\n\t\tthis.usedByExports = false;\n\t\tthis._hashUpdate = undefined;\n\t}\n\n\t/**\n\t * Update the hash\n\t * @param {Hash} hash hash to be updated\n\t * @param {UpdateHashContext} context context\n\t * @returns {void}\n\t */\n\tupdateHash(hash, context) {\n\t\tif (this._hashUpdate === undefined) {\n\t\t\tthis._hashUpdate = this.range + \"\";\n\t\t}\n\t\thash.update(this._hashUpdate);\n\t}\n\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @returns {ConnectionState} how this dependency connects the module to referencing modules\n\t */\n\tgetModuleEvaluationSideEffectsState(moduleGraph) {\n\t\treturn false;\n\t}\n\n\tserialize(context) {\n\t\tconst { write } = context;\n\t\twrite(this.range);\n\t\twrite(this.usedByExports);\n\t\tsuper.serialize(context);\n\t}\n\n\tdeserialize(context) {\n\t\tconst { read } = context;\n\t\tthis.range = read();\n\t\tthis.usedByExports = read();\n\t\tsuper.deserialize(context);\n\t}\n}\n\nmakeSerializable(\n\tPureExpressionDependency,\n\t\"webpack/lib/dependencies/PureExpressionDependency\"\n);\n\nPureExpressionDependency.Template = class PureExpressionDependencyTemplate extends (\n\tNullDependency.Template\n) {\n\t/**\n\t * @param {Dependency} dependency the dependency for which the template should be applied\n\t * @param {ReplaceSource} source the current replace source which can be modified\n\t * @param {DependencyTemplateContext} templateContext the context object\n\t * @returns {void}\n\t */\n\tapply(\n\t\tdependency,\n\t\tsource,\n\t\t{ chunkGraph, moduleGraph, runtime, runtimeTemplate, runtimeRequirements }\n\t) {\n\t\tconst dep = /** @type {PureExpressionDependency} */ (dependency);\n\n\t\tconst usedByExports = dep.usedByExports;\n\t\tif (usedByExports !== false) {\n\t\t\tconst selfModule = moduleGraph.getParentModule(dep);\n\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(selfModule);\n\t\t\tconst runtimeCondition = filterRuntime(runtime, runtime => {\n\t\t\t\tfor (const exportName of usedByExports) {\n\t\t\t\t\tif (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\t\t\tif (runtimeCondition === true) return;\n\t\t\tif (runtimeCondition !== false) {\n\t\t\t\tconst condition = runtimeTemplate.runtimeConditionExpression({\n\t\t\t\t\tchunkGraph,\n\t\t\t\t\truntime,\n\t\t\t\t\truntimeCondition,\n\t\t\t\t\truntimeRequirements\n\t\t\t\t});\n\t\t\t\tsource.insert(\n\t\t\t\t\tdep.range[0],\n\t\t\t\t\t`(/* runtime-dependent pure expression or super */ ${condition} ? (`\n\t\t\t\t);\n\t\t\t\tsource.insert(dep.range[1], \") : null)\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tsource.insert(\n\t\t\tdep.range[0],\n\t\t\t`(/* unused pure expression or super */ null && (`\n\t\t);\n\t\tsource.insert(dep.range[1], \"))\");\n\t}\n};\n\nmodule.exports = PureExpressionDependency;\n"]},"metadata":{},"sourceType":"script"}