{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst LazySet = require(\"../util/LazySet\");\n\nconst makeSerializable = require(\"../util/makeSerializable\");\n/** @typedef {import(\"enhanced-resolve/lib/Resolver\")} Resolver */\n\n/** @typedef {import(\"../CacheFacade\").ItemCacheFacade} ItemCacheFacade */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../FileSystemInfo\")} FileSystemInfo */\n\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\n\n\nclass CacheEntry {\n  constructor(result, snapshot) {\n    this.result = result;\n    this.snapshot = snapshot;\n  }\n\n  serialize(_ref) {\n    let {\n      write\n    } = _ref;\n    write(this.result);\n    write(this.snapshot);\n  }\n\n  deserialize(_ref2) {\n    let {\n      read\n    } = _ref2;\n    this.result = read();\n    this.snapshot = read();\n  }\n\n}\n\nmakeSerializable(CacheEntry, \"webpack/lib/cache/ResolverCachePlugin\");\n/**\n * @template T\n * @param {Set<T> | LazySet<T>} set set to add items to\n * @param {Set<T> | LazySet<T>} otherSet set to add items from\n * @returns {void}\n */\n\nconst addAllToSet = (set, otherSet) => {\n  if (set instanceof LazySet) {\n    set.addAll(otherSet);\n  } else {\n    for (const item of otherSet) {\n      set.add(item);\n    }\n  }\n};\n/**\n * @param {Object} object an object\n * @param {boolean} excludeContext if true, context is not included in string\n * @returns {string} stringified version\n */\n\n\nconst objectToString = (object, excludeContext) => {\n  let str = \"\";\n\n  for (const key in object) {\n    if (excludeContext && key === \"context\") continue;\n    const value = object[key];\n\n    if (typeof value === \"object\" && value !== null) {\n      str += `|${key}=[${objectToString(value, false)}|]`;\n    } else {\n      str += `|${key}=|${value}`;\n    }\n  }\n\n  return str;\n};\n\nclass ResolverCachePlugin {\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    const cache = compiler.getCache(\"ResolverCachePlugin\");\n    /** @type {FileSystemInfo} */\n\n    let fileSystemInfo;\n    let snapshotOptions;\n    let realResolves = 0;\n    let cachedResolves = 0;\n    let cacheInvalidResolves = 0;\n    let concurrentResolves = 0;\n    compiler.hooks.thisCompilation.tap(\"ResolverCachePlugin\", compilation => {\n      snapshotOptions = compilation.options.snapshot.resolve;\n      fileSystemInfo = compilation.fileSystemInfo;\n      compilation.hooks.finishModules.tap(\"ResolverCachePlugin\", () => {\n        if (realResolves + cachedResolves > 0) {\n          const logger = compilation.getLogger(\"webpack.ResolverCachePlugin\");\n          logger.log(`${Math.round(100 * realResolves / (realResolves + cachedResolves))}% really resolved (${realResolves} real resolves with ${cacheInvalidResolves} cached but invalid, ${cachedResolves} cached valid, ${concurrentResolves} concurrent)`);\n          realResolves = 0;\n          cachedResolves = 0;\n          cacheInvalidResolves = 0;\n          concurrentResolves = 0;\n        }\n      });\n    });\n    /**\n     * @param {ItemCacheFacade} itemCache cache\n     * @param {Resolver} resolver the resolver\n     * @param {Object} resolveContext context for resolving meta info\n     * @param {Object} request the request info object\n     * @param {function((Error | null)=, Object=): void} callback callback function\n     * @returns {void}\n     */\n\n    const doRealResolve = (itemCache, resolver, resolveContext, request, callback) => {\n      realResolves++;\n      const newRequest = {\n        _ResolverCachePluginCacheMiss: true,\n        ...request\n      };\n      const newResolveContext = { ...resolveContext,\n        stack: new Set(),\n        missingDependencies: new LazySet(),\n        fileDependencies: new LazySet(),\n        contextDependencies: new LazySet()\n      };\n      let yieldResult;\n      let withYield = false;\n\n      if (typeof newResolveContext.yield === \"function\") {\n        yieldResult = [];\n        withYield = true;\n\n        newResolveContext.yield = obj => yieldResult.push(obj);\n      }\n\n      const propagate = key => {\n        if (resolveContext[key]) {\n          addAllToSet(resolveContext[key], newResolveContext[key]);\n        }\n      };\n\n      const resolveTime = Date.now();\n      resolver.doResolve(resolver.hooks.resolve, newRequest, \"Cache miss\", newResolveContext, (err, result) => {\n        propagate(\"fileDependencies\");\n        propagate(\"contextDependencies\");\n        propagate(\"missingDependencies\");\n        if (err) return callback(err);\n        const fileDependencies = newResolveContext.fileDependencies;\n        const contextDependencies = newResolveContext.contextDependencies;\n        const missingDependencies = newResolveContext.missingDependencies;\n        fileSystemInfo.createSnapshot(resolveTime, fileDependencies, contextDependencies, missingDependencies, snapshotOptions, (err, snapshot) => {\n          if (err) return callback(err);\n          const resolveResult = withYield ? yieldResult : result; // since we intercept resolve hook\n          // we still can get result in callback\n\n          if (withYield && result) yieldResult.push(result);\n\n          if (!snapshot) {\n            if (resolveResult) return callback(null, resolveResult);\n            return callback();\n          }\n\n          itemCache.store(new CacheEntry(resolveResult, snapshot), storeErr => {\n            if (storeErr) return callback(storeErr);\n            if (resolveResult) return callback(null, resolveResult);\n            callback();\n          });\n        });\n      });\n    };\n\n    compiler.resolverFactory.hooks.resolver.intercept({\n      factory(type, hook) {\n        /** @type {Map<string, (function(Error=, Object=): void)[]>} */\n        const activeRequests = new Map();\n        /** @type {Map<string, [function(Error=, Object=): void, function(Error=, Object=): void][]>} */\n\n        const activeRequestsWithYield = new Map();\n        hook.tap(\"ResolverCachePlugin\",\n        /**\n         * @param {Resolver} resolver the resolver\n         * @param {Object} options resolve options\n         * @param {Object} userOptions resolve options passed by the user\n         * @returns {void}\n         */\n        (resolver, options, userOptions) => {\n          if (options.cache !== true) return;\n          const optionsIdent = objectToString(userOptions, false);\n          const cacheWithContext = options.cacheWithContext !== undefined ? options.cacheWithContext : false;\n          resolver.hooks.resolve.tapAsync({\n            name: \"ResolverCachePlugin\",\n            stage: -100\n          }, (request, resolveContext, callback) => {\n            if (request._ResolverCachePluginCacheMiss || !fileSystemInfo) {\n              return callback();\n            }\n\n            const withYield = typeof resolveContext.yield === \"function\";\n            const identifier = `${type}${withYield ? \"|yield\" : \"|default\"}${optionsIdent}${objectToString(request, !cacheWithContext)}`;\n\n            if (withYield) {\n              const activeRequest = activeRequestsWithYield.get(identifier);\n\n              if (activeRequest) {\n                activeRequest[0].push(callback);\n                activeRequest[1].push(resolveContext.yield);\n                return;\n              }\n            } else {\n              const activeRequest = activeRequests.get(identifier);\n\n              if (activeRequest) {\n                activeRequest.push(callback);\n                return;\n              }\n            }\n\n            const itemCache = cache.getItemCache(identifier, null);\n            let callbacks, yields;\n            const done = withYield ? (err, result) => {\n              if (callbacks === undefined) {\n                if (err) {\n                  callback(err);\n                } else {\n                  if (result) for (const r of result) resolveContext.yield(r);\n                  callback(null, null);\n                }\n\n                yields = undefined;\n                callbacks = false;\n              } else {\n                if (err) {\n                  for (const cb of callbacks) cb(err);\n                } else {\n                  for (let i = 0; i < callbacks.length; i++) {\n                    const cb = callbacks[i];\n                    const yield_ = yields[i];\n                    if (result) for (const r of result) yield_(r);\n                    cb(null, null);\n                  }\n                }\n\n                activeRequestsWithYield.delete(identifier);\n                yields = undefined;\n                callbacks = false;\n              }\n            } : (err, result) => {\n              if (callbacks === undefined) {\n                callback(err, result);\n                callbacks = false;\n              } else {\n                for (const callback of callbacks) {\n                  callback(err, result);\n                }\n\n                activeRequests.delete(identifier);\n                callbacks = false;\n              }\n            };\n            /**\n             * @param {Error=} err error if any\n             * @param {CacheEntry=} cacheEntry cache entry\n             * @returns {void}\n             */\n\n            const processCacheResult = (err, cacheEntry) => {\n              if (err) return done(err);\n\n              if (cacheEntry) {\n                const {\n                  snapshot,\n                  result\n                } = cacheEntry;\n                fileSystemInfo.checkSnapshotValid(snapshot, (err, valid) => {\n                  if (err || !valid) {\n                    cacheInvalidResolves++;\n                    return doRealResolve(itemCache, resolver, resolveContext, request, done);\n                  }\n\n                  cachedResolves++;\n\n                  if (resolveContext.missingDependencies) {\n                    addAllToSet(resolveContext.missingDependencies, snapshot.getMissingIterable());\n                  }\n\n                  if (resolveContext.fileDependencies) {\n                    addAllToSet(resolveContext.fileDependencies, snapshot.getFileIterable());\n                  }\n\n                  if (resolveContext.contextDependencies) {\n                    addAllToSet(resolveContext.contextDependencies, snapshot.getContextIterable());\n                  }\n\n                  done(null, result);\n                });\n              } else {\n                doRealResolve(itemCache, resolver, resolveContext, request, done);\n              }\n            };\n\n            itemCache.get(processCacheResult);\n\n            if (withYield && callbacks === undefined) {\n              callbacks = [callback];\n              yields = [resolveContext.yield];\n              activeRequestsWithYield.set(identifier,\n              /** @type {[any, any]} */\n              [callbacks, yields]);\n            } else if (callbacks === undefined) {\n              callbacks = [callback];\n              activeRequests.set(identifier, callbacks);\n            }\n          });\n        });\n        return hook;\n      }\n\n    });\n  }\n\n}\n\nmodule.exports = ResolverCachePlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/cache/ResolverCachePlugin.js"],"names":["LazySet","require","makeSerializable","CacheEntry","constructor","result","snapshot","serialize","write","deserialize","read","addAllToSet","set","otherSet","addAll","item","add","objectToString","object","excludeContext","str","key","value","ResolverCachePlugin","apply","compiler","cache","getCache","fileSystemInfo","snapshotOptions","realResolves","cachedResolves","cacheInvalidResolves","concurrentResolves","hooks","thisCompilation","tap","compilation","options","resolve","finishModules","logger","getLogger","log","Math","round","doRealResolve","itemCache","resolver","resolveContext","request","callback","newRequest","_ResolverCachePluginCacheMiss","newResolveContext","stack","Set","missingDependencies","fileDependencies","contextDependencies","yieldResult","withYield","yield","obj","push","propagate","resolveTime","Date","now","doResolve","err","createSnapshot","resolveResult","store","storeErr","resolverFactory","intercept","factory","type","hook","activeRequests","Map","activeRequestsWithYield","userOptions","optionsIdent","cacheWithContext","undefined","tapAsync","name","stage","identifier","activeRequest","get","getItemCache","callbacks","yields","done","r","cb","i","length","yield_","delete","processCacheResult","cacheEntry","checkSnapshotValid","valid","getMissingIterable","getFileIterable","getContextIterable","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst LazySet = require(\"../util/LazySet\");\nconst makeSerializable = require(\"../util/makeSerializable\");\n\n/** @typedef {import(\"enhanced-resolve/lib/Resolver\")} Resolver */\n/** @typedef {import(\"../CacheFacade\").ItemCacheFacade} ItemCacheFacade */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../FileSystemInfo\")} FileSystemInfo */\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\n\nclass CacheEntry {\n\tconstructor(result, snapshot) {\n\t\tthis.result = result;\n\t\tthis.snapshot = snapshot;\n\t}\n\n\tserialize({ write }) {\n\t\twrite(this.result);\n\t\twrite(this.snapshot);\n\t}\n\n\tdeserialize({ read }) {\n\t\tthis.result = read();\n\t\tthis.snapshot = read();\n\t}\n}\n\nmakeSerializable(CacheEntry, \"webpack/lib/cache/ResolverCachePlugin\");\n\n/**\n * @template T\n * @param {Set<T> | LazySet<T>} set set to add items to\n * @param {Set<T> | LazySet<T>} otherSet set to add items from\n * @returns {void}\n */\nconst addAllToSet = (set, otherSet) => {\n\tif (set instanceof LazySet) {\n\t\tset.addAll(otherSet);\n\t} else {\n\t\tfor (const item of otherSet) {\n\t\t\tset.add(item);\n\t\t}\n\t}\n};\n\n/**\n * @param {Object} object an object\n * @param {boolean} excludeContext if true, context is not included in string\n * @returns {string} stringified version\n */\nconst objectToString = (object, excludeContext) => {\n\tlet str = \"\";\n\tfor (const key in object) {\n\t\tif (excludeContext && key === \"context\") continue;\n\t\tconst value = object[key];\n\t\tif (typeof value === \"object\" && value !== null) {\n\t\t\tstr += `|${key}=[${objectToString(value, false)}|]`;\n\t\t} else {\n\t\t\tstr += `|${key}=|${value}`;\n\t\t}\n\t}\n\treturn str;\n};\n\nclass ResolverCachePlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst cache = compiler.getCache(\"ResolverCachePlugin\");\n\t\t/** @type {FileSystemInfo} */\n\t\tlet fileSystemInfo;\n\t\tlet snapshotOptions;\n\t\tlet realResolves = 0;\n\t\tlet cachedResolves = 0;\n\t\tlet cacheInvalidResolves = 0;\n\t\tlet concurrentResolves = 0;\n\t\tcompiler.hooks.thisCompilation.tap(\"ResolverCachePlugin\", compilation => {\n\t\t\tsnapshotOptions = compilation.options.snapshot.resolve;\n\t\t\tfileSystemInfo = compilation.fileSystemInfo;\n\t\t\tcompilation.hooks.finishModules.tap(\"ResolverCachePlugin\", () => {\n\t\t\t\tif (realResolves + cachedResolves > 0) {\n\t\t\t\t\tconst logger = compilation.getLogger(\"webpack.ResolverCachePlugin\");\n\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t`${Math.round(\n\t\t\t\t\t\t\t(100 * realResolves) / (realResolves + cachedResolves)\n\t\t\t\t\t\t)}% really resolved (${realResolves} real resolves with ${cacheInvalidResolves} cached but invalid, ${cachedResolves} cached valid, ${concurrentResolves} concurrent)`\n\t\t\t\t\t);\n\t\t\t\t\trealResolves = 0;\n\t\t\t\t\tcachedResolves = 0;\n\t\t\t\t\tcacheInvalidResolves = 0;\n\t\t\t\t\tconcurrentResolves = 0;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\t/**\n\t\t * @param {ItemCacheFacade} itemCache cache\n\t\t * @param {Resolver} resolver the resolver\n\t\t * @param {Object} resolveContext context for resolving meta info\n\t\t * @param {Object} request the request info object\n\t\t * @param {function((Error | null)=, Object=): void} callback callback function\n\t\t * @returns {void}\n\t\t */\n\t\tconst doRealResolve = (\n\t\t\titemCache,\n\t\t\tresolver,\n\t\t\tresolveContext,\n\t\t\trequest,\n\t\t\tcallback\n\t\t) => {\n\t\t\trealResolves++;\n\t\t\tconst newRequest = {\n\t\t\t\t_ResolverCachePluginCacheMiss: true,\n\t\t\t\t...request\n\t\t\t};\n\t\t\tconst newResolveContext = {\n\t\t\t\t...resolveContext,\n\t\t\t\tstack: new Set(),\n\t\t\t\tmissingDependencies: new LazySet(),\n\t\t\t\tfileDependencies: new LazySet(),\n\t\t\t\tcontextDependencies: new LazySet()\n\t\t\t};\n\t\t\tlet yieldResult;\n\t\t\tlet withYield = false;\n\t\t\tif (typeof newResolveContext.yield === \"function\") {\n\t\t\t\tyieldResult = [];\n\t\t\t\twithYield = true;\n\t\t\t\tnewResolveContext.yield = obj => yieldResult.push(obj);\n\t\t\t}\n\t\t\tconst propagate = key => {\n\t\t\t\tif (resolveContext[key]) {\n\t\t\t\t\taddAllToSet(resolveContext[key], newResolveContext[key]);\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst resolveTime = Date.now();\n\t\t\tresolver.doResolve(\n\t\t\t\tresolver.hooks.resolve,\n\t\t\t\tnewRequest,\n\t\t\t\t\"Cache miss\",\n\t\t\t\tnewResolveContext,\n\t\t\t\t(err, result) => {\n\t\t\t\t\tpropagate(\"fileDependencies\");\n\t\t\t\t\tpropagate(\"contextDependencies\");\n\t\t\t\t\tpropagate(\"missingDependencies\");\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tconst fileDependencies = newResolveContext.fileDependencies;\n\t\t\t\t\tconst contextDependencies = newResolveContext.contextDependencies;\n\t\t\t\t\tconst missingDependencies = newResolveContext.missingDependencies;\n\t\t\t\t\tfileSystemInfo.createSnapshot(\n\t\t\t\t\t\tresolveTime,\n\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\tcontextDependencies,\n\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\tsnapshotOptions,\n\t\t\t\t\t\t(err, snapshot) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst resolveResult = withYield ? yieldResult : result;\n\t\t\t\t\t\t\t// since we intercept resolve hook\n\t\t\t\t\t\t\t// we still can get result in callback\n\t\t\t\t\t\t\tif (withYield && result) yieldResult.push(result);\n\t\t\t\t\t\t\tif (!snapshot) {\n\t\t\t\t\t\t\t\tif (resolveResult) return callback(null, resolveResult);\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titemCache.store(\n\t\t\t\t\t\t\t\tnew CacheEntry(resolveResult, snapshot),\n\t\t\t\t\t\t\t\tstoreErr => {\n\t\t\t\t\t\t\t\t\tif (storeErr) return callback(storeErr);\n\t\t\t\t\t\t\t\t\tif (resolveResult) return callback(null, resolveResult);\n\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t};\n\t\tcompiler.resolverFactory.hooks.resolver.intercept({\n\t\t\tfactory(type, hook) {\n\t\t\t\t/** @type {Map<string, (function(Error=, Object=): void)[]>} */\n\t\t\t\tconst activeRequests = new Map();\n\t\t\t\t/** @type {Map<string, [function(Error=, Object=): void, function(Error=, Object=): void][]>} */\n\t\t\t\tconst activeRequestsWithYield = new Map();\n\t\t\t\thook.tap(\n\t\t\t\t\t\"ResolverCachePlugin\",\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Resolver} resolver the resolver\n\t\t\t\t\t * @param {Object} options resolve options\n\t\t\t\t\t * @param {Object} userOptions resolve options passed by the user\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\t(resolver, options, userOptions) => {\n\t\t\t\t\t\tif (options.cache !== true) return;\n\t\t\t\t\t\tconst optionsIdent = objectToString(userOptions, false);\n\t\t\t\t\t\tconst cacheWithContext =\n\t\t\t\t\t\t\toptions.cacheWithContext !== undefined\n\t\t\t\t\t\t\t\t? options.cacheWithContext\n\t\t\t\t\t\t\t\t: false;\n\t\t\t\t\t\tresolver.hooks.resolve.tapAsync(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tname: \"ResolverCachePlugin\",\n\t\t\t\t\t\t\t\tstage: -100\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t(request, resolveContext, callback) => {\n\t\t\t\t\t\t\t\tif (request._ResolverCachePluginCacheMiss || !fileSystemInfo) {\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst withYield = typeof resolveContext.yield === \"function\";\n\t\t\t\t\t\t\t\tconst identifier = `${type}${\n\t\t\t\t\t\t\t\t\twithYield ? \"|yield\" : \"|default\"\n\t\t\t\t\t\t\t\t}${optionsIdent}${objectToString(request, !cacheWithContext)}`;\n\n\t\t\t\t\t\t\t\tif (withYield) {\n\t\t\t\t\t\t\t\t\tconst activeRequest = activeRequestsWithYield.get(identifier);\n\t\t\t\t\t\t\t\t\tif (activeRequest) {\n\t\t\t\t\t\t\t\t\t\tactiveRequest[0].push(callback);\n\t\t\t\t\t\t\t\t\t\tactiveRequest[1].push(resolveContext.yield);\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst activeRequest = activeRequests.get(identifier);\n\t\t\t\t\t\t\t\t\tif (activeRequest) {\n\t\t\t\t\t\t\t\t\t\tactiveRequest.push(callback);\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst itemCache = cache.getItemCache(identifier, null);\n\t\t\t\t\t\t\t\tlet callbacks, yields;\n\t\t\t\t\t\t\t\tconst done = withYield\n\t\t\t\t\t\t\t\t\t? (err, result) => {\n\t\t\t\t\t\t\t\t\t\t\tif (callbacks === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (result)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (const r of result) resolveContext.yield(r);\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallback(null, null);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tyields = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\tcallbacks = false;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor (const cb of callbacks) cb(err);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor (let i = 0; i < callbacks.length; i++) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst cb = callbacks[i];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst yield_ = yields[i];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (result) for (const r of result) yield_(r);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcb(null, null);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tactiveRequestsWithYield.delete(identifier);\n\t\t\t\t\t\t\t\t\t\t\t\tyields = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\tcallbacks = false;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t: (err, result) => {\n\t\t\t\t\t\t\t\t\t\t\tif (callbacks === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\tcallback(err, result);\n\t\t\t\t\t\t\t\t\t\t\t\tcallbacks = false;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tfor (const callback of callbacks) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallback(err, result);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tactiveRequests.delete(identifier);\n\t\t\t\t\t\t\t\t\t\t\t\tcallbacks = false;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t  };\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @param {Error=} err error if any\n\t\t\t\t\t\t\t\t * @param {CacheEntry=} cacheEntry cache entry\n\t\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst processCacheResult = (err, cacheEntry) => {\n\t\t\t\t\t\t\t\t\tif (err) return done(err);\n\n\t\t\t\t\t\t\t\t\tif (cacheEntry) {\n\t\t\t\t\t\t\t\t\t\tconst { snapshot, result } = cacheEntry;\n\t\t\t\t\t\t\t\t\t\tfileSystemInfo.checkSnapshotValid(\n\t\t\t\t\t\t\t\t\t\t\tsnapshot,\n\t\t\t\t\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (err || !valid) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcacheInvalidResolves++;\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn doRealResolve(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\titemCache,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolver,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdone\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tcachedResolves++;\n\t\t\t\t\t\t\t\t\t\t\t\tif (resolveContext.missingDependencies) {\n\t\t\t\t\t\t\t\t\t\t\t\t\taddAllToSet(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolveContext.missingDependencies,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot.getMissingIterable()\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif (resolveContext.fileDependencies) {\n\t\t\t\t\t\t\t\t\t\t\t\t\taddAllToSet(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolveContext.fileDependencies,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot.getFileIterable()\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif (resolveContext.contextDependencies) {\n\t\t\t\t\t\t\t\t\t\t\t\t\taddAllToSet(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolveContext.contextDependencies,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot.getContextIterable()\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tdone(null, result);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tdoRealResolve(\n\t\t\t\t\t\t\t\t\t\t\titemCache,\n\t\t\t\t\t\t\t\t\t\t\tresolver,\n\t\t\t\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t\t\t\tdone\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\titemCache.get(processCacheResult);\n\t\t\t\t\t\t\t\tif (withYield && callbacks === undefined) {\n\t\t\t\t\t\t\t\t\tcallbacks = [callback];\n\t\t\t\t\t\t\t\t\tyields = [resolveContext.yield];\n\t\t\t\t\t\t\t\t\tactiveRequestsWithYield.set(\n\t\t\t\t\t\t\t\t\t\tidentifier,\n\t\t\t\t\t\t\t\t\t\t/** @type {[any, any]} */ ([callbacks, yields])\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else if (callbacks === undefined) {\n\t\t\t\t\t\t\t\t\tcallbacks = [callback];\n\t\t\t\t\t\t\t\t\tactiveRequests.set(identifier, callbacks);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\treturn hook;\n\t\t\t}\n\t\t});\n\t}\n}\n\nmodule.exports = ResolverCachePlugin;\n"]},"metadata":{},"sourceType":"script"}