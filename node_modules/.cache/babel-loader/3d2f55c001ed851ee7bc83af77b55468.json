{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  groupBy\n} = require(\"./util/ArrayHelpers\");\n\nconst createSchemaValidation = require(\"./util/create-schema-validation\");\n/** @typedef {import(\"../declarations/plugins/WatchIgnorePlugin\").WatchIgnorePluginOptions} WatchIgnorePluginOptions */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./util/fs\").WatchFileSystem} WatchFileSystem */\n\n\nconst validate = createSchemaValidation(require(\"../schemas/plugins/WatchIgnorePlugin.check.js\"), () => require(\"../schemas/plugins/WatchIgnorePlugin.json\"), {\n  name: \"Watch Ignore Plugin\",\n  baseDataPath: \"options\"\n});\nconst IGNORE_TIME_ENTRY = \"ignore\";\n\nclass IgnoringWatchFileSystem {\n  /**\n   * @param {WatchFileSystem} wfs original file system\n   * @param {(string|RegExp)[]} paths ignored paths\n   */\n  constructor(wfs, paths) {\n    this.wfs = wfs;\n    this.paths = paths;\n  }\n\n  watch(files, dirs, missing, startTime, options, callback, callbackUndelayed) {\n    files = Array.from(files);\n    dirs = Array.from(dirs);\n\n    const ignored = path => this.paths.some(p => p instanceof RegExp ? p.test(path) : path.indexOf(p) === 0);\n\n    const [ignoredFiles, notIgnoredFiles] = groupBy(files, ignored);\n    const [ignoredDirs, notIgnoredDirs] = groupBy(dirs, ignored);\n    const watcher = this.wfs.watch(notIgnoredFiles, notIgnoredDirs, missing, startTime, options, (err, fileTimestamps, dirTimestamps, changedFiles, removedFiles) => {\n      if (err) return callback(err);\n\n      for (const path of ignoredFiles) {\n        fileTimestamps.set(path, IGNORE_TIME_ENTRY);\n      }\n\n      for (const path of ignoredDirs) {\n        dirTimestamps.set(path, IGNORE_TIME_ENTRY);\n      }\n\n      callback(err, fileTimestamps, dirTimestamps, changedFiles, removedFiles);\n    }, callbackUndelayed);\n    return {\n      close: () => watcher.close(),\n      pause: () => watcher.pause(),\n      getContextTimeInfoEntries: () => {\n        const dirTimestamps = watcher.getContextTimeInfoEntries();\n\n        for (const path of ignoredDirs) {\n          dirTimestamps.set(path, IGNORE_TIME_ENTRY);\n        }\n\n        return dirTimestamps;\n      },\n      getFileTimeInfoEntries: () => {\n        const fileTimestamps = watcher.getFileTimeInfoEntries();\n\n        for (const path of ignoredFiles) {\n          fileTimestamps.set(path, IGNORE_TIME_ENTRY);\n        }\n\n        return fileTimestamps;\n      },\n      getInfo: watcher.getInfo && (() => {\n        const info = watcher.getInfo();\n        const {\n          fileTimeInfoEntries,\n          contextTimeInfoEntries\n        } = info;\n\n        for (const path of ignoredFiles) {\n          fileTimeInfoEntries.set(path, IGNORE_TIME_ENTRY);\n        }\n\n        for (const path of ignoredDirs) {\n          contextTimeInfoEntries.set(path, IGNORE_TIME_ENTRY);\n        }\n\n        return info;\n      })\n    };\n  }\n\n}\n\nclass WatchIgnorePlugin {\n  /**\n   * @param {WatchIgnorePluginOptions} options options\n   */\n  constructor(options) {\n    validate(options);\n    this.paths = options.paths;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    compiler.hooks.afterEnvironment.tap(\"WatchIgnorePlugin\", () => {\n      compiler.watchFileSystem = new IgnoringWatchFileSystem(compiler.watchFileSystem, this.paths);\n    });\n  }\n\n}\n\nmodule.exports = WatchIgnorePlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/WatchIgnorePlugin.js"],"names":["groupBy","require","createSchemaValidation","validate","name","baseDataPath","IGNORE_TIME_ENTRY","IgnoringWatchFileSystem","constructor","wfs","paths","watch","files","dirs","missing","startTime","options","callback","callbackUndelayed","Array","from","ignored","path","some","p","RegExp","test","indexOf","ignoredFiles","notIgnoredFiles","ignoredDirs","notIgnoredDirs","watcher","err","fileTimestamps","dirTimestamps","changedFiles","removedFiles","set","close","pause","getContextTimeInfoEntries","getFileTimeInfoEntries","getInfo","info","fileTimeInfoEntries","contextTimeInfoEntries","WatchIgnorePlugin","apply","compiler","hooks","afterEnvironment","tap","watchFileSystem","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { groupBy } = require(\"./util/ArrayHelpers\");\nconst createSchemaValidation = require(\"./util/create-schema-validation\");\n\n/** @typedef {import(\"../declarations/plugins/WatchIgnorePlugin\").WatchIgnorePluginOptions} WatchIgnorePluginOptions */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./util/fs\").WatchFileSystem} WatchFileSystem */\n\nconst validate = createSchemaValidation(\n\trequire(\"../schemas/plugins/WatchIgnorePlugin.check.js\"),\n\t() => require(\"../schemas/plugins/WatchIgnorePlugin.json\"),\n\t{\n\t\tname: \"Watch Ignore Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\nconst IGNORE_TIME_ENTRY = \"ignore\";\n\nclass IgnoringWatchFileSystem {\n\t/**\n\t * @param {WatchFileSystem} wfs original file system\n\t * @param {(string|RegExp)[]} paths ignored paths\n\t */\n\tconstructor(wfs, paths) {\n\t\tthis.wfs = wfs;\n\t\tthis.paths = paths;\n\t}\n\n\twatch(files, dirs, missing, startTime, options, callback, callbackUndelayed) {\n\t\tfiles = Array.from(files);\n\t\tdirs = Array.from(dirs);\n\t\tconst ignored = path =>\n\t\t\tthis.paths.some(p =>\n\t\t\t\tp instanceof RegExp ? p.test(path) : path.indexOf(p) === 0\n\t\t\t);\n\n\t\tconst [ignoredFiles, notIgnoredFiles] = groupBy(files, ignored);\n\t\tconst [ignoredDirs, notIgnoredDirs] = groupBy(dirs, ignored);\n\n\t\tconst watcher = this.wfs.watch(\n\t\t\tnotIgnoredFiles,\n\t\t\tnotIgnoredDirs,\n\t\t\tmissing,\n\t\t\tstartTime,\n\t\t\toptions,\n\t\t\t(err, fileTimestamps, dirTimestamps, changedFiles, removedFiles) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tfor (const path of ignoredFiles) {\n\t\t\t\t\tfileTimestamps.set(path, IGNORE_TIME_ENTRY);\n\t\t\t\t}\n\n\t\t\t\tfor (const path of ignoredDirs) {\n\t\t\t\t\tdirTimestamps.set(path, IGNORE_TIME_ENTRY);\n\t\t\t\t}\n\n\t\t\t\tcallback(\n\t\t\t\t\terr,\n\t\t\t\t\tfileTimestamps,\n\t\t\t\t\tdirTimestamps,\n\t\t\t\t\tchangedFiles,\n\t\t\t\t\tremovedFiles\n\t\t\t\t);\n\t\t\t},\n\t\t\tcallbackUndelayed\n\t\t);\n\n\t\treturn {\n\t\t\tclose: () => watcher.close(),\n\t\t\tpause: () => watcher.pause(),\n\t\t\tgetContextTimeInfoEntries: () => {\n\t\t\t\tconst dirTimestamps = watcher.getContextTimeInfoEntries();\n\t\t\t\tfor (const path of ignoredDirs) {\n\t\t\t\t\tdirTimestamps.set(path, IGNORE_TIME_ENTRY);\n\t\t\t\t}\n\t\t\t\treturn dirTimestamps;\n\t\t\t},\n\t\t\tgetFileTimeInfoEntries: () => {\n\t\t\t\tconst fileTimestamps = watcher.getFileTimeInfoEntries();\n\t\t\t\tfor (const path of ignoredFiles) {\n\t\t\t\t\tfileTimestamps.set(path, IGNORE_TIME_ENTRY);\n\t\t\t\t}\n\t\t\t\treturn fileTimestamps;\n\t\t\t},\n\t\t\tgetInfo:\n\t\t\t\twatcher.getInfo &&\n\t\t\t\t(() => {\n\t\t\t\t\tconst info = watcher.getInfo();\n\t\t\t\t\tconst { fileTimeInfoEntries, contextTimeInfoEntries } = info;\n\t\t\t\t\tfor (const path of ignoredFiles) {\n\t\t\t\t\t\tfileTimeInfoEntries.set(path, IGNORE_TIME_ENTRY);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const path of ignoredDirs) {\n\t\t\t\t\t\tcontextTimeInfoEntries.set(path, IGNORE_TIME_ENTRY);\n\t\t\t\t\t}\n\t\t\t\t\treturn info;\n\t\t\t\t})\n\t\t};\n\t}\n}\n\nclass WatchIgnorePlugin {\n\t/**\n\t * @param {WatchIgnorePluginOptions} options options\n\t */\n\tconstructor(options) {\n\t\tvalidate(options);\n\t\tthis.paths = options.paths;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.afterEnvironment.tap(\"WatchIgnorePlugin\", () => {\n\t\t\tcompiler.watchFileSystem = new IgnoringWatchFileSystem(\n\t\t\t\tcompiler.watchFileSystem,\n\t\t\t\tthis.paths\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = WatchIgnorePlugin;\n"]},"metadata":{},"sourceType":"script"}