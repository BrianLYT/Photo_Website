{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\n\nconst RuntimeModule = require(\"../RuntimeModule\");\n\nconst Template = require(\"../Template\");\n\nconst {\n  first\n} = require(\"../util/SetHelpers\");\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n\n/** @typedef {import(\"../Compilation\").PathData} PathData */\n\n/** @typedef {function(PathData, AssetInfo=): string} FilenameFunction */\n\n\nclass GetChunkFilenameRuntimeModule extends RuntimeModule {\n  /**\n   * @param {string} contentType the contentType to use the content hash for\n   * @param {string} name kind of filename\n   * @param {string} global function name to be assigned\n   * @param {function(Chunk): string | FilenameFunction} getFilenameForChunk functor to get the filename or function\n   * @param {boolean} allChunks when false, only async chunks are included\n   */\n  constructor(contentType, name, global, getFilenameForChunk, allChunks) {\n    super(`get ${name} chunk filename`);\n    this.contentType = contentType;\n    this.global = global;\n    this.getFilenameForChunk = getFilenameForChunk;\n    this.allChunks = allChunks;\n    this.dependentHash = true;\n  }\n  /**\n   * @returns {string} runtime code\n   */\n\n\n  generate() {\n    const {\n      global,\n      chunk,\n      chunkGraph,\n      contentType,\n      getFilenameForChunk,\n      allChunks,\n      compilation\n    } = this;\n    const {\n      runtimeTemplate\n    } = compilation;\n    /** @type {Map<string | FilenameFunction, Set<Chunk>>} */\n\n    const chunkFilenames = new Map();\n    let maxChunks = 0;\n    /** @type {string} */\n\n    let dynamicFilename;\n    /**\n     * @param {Chunk} c the chunk\n     * @returns {void}\n     */\n\n    const addChunk = c => {\n      const chunkFilename = getFilenameForChunk(c);\n\n      if (chunkFilename) {\n        let set = chunkFilenames.get(chunkFilename);\n\n        if (set === undefined) {\n          chunkFilenames.set(chunkFilename, set = new Set());\n        }\n\n        set.add(c);\n\n        if (typeof chunkFilename === \"string\") {\n          if (set.size < maxChunks) return;\n\n          if (set.size === maxChunks) {\n            if (chunkFilename.length < dynamicFilename.length) return;\n\n            if (chunkFilename.length === dynamicFilename.length) {\n              if (chunkFilename < dynamicFilename) return;\n            }\n          }\n\n          maxChunks = set.size;\n          dynamicFilename = chunkFilename;\n        }\n      }\n    };\n    /** @type {string[]} */\n\n\n    const includedChunksMessages = [];\n\n    if (allChunks) {\n      includedChunksMessages.push(\"all chunks\");\n\n      for (const c of chunk.getAllReferencedChunks()) {\n        addChunk(c);\n      }\n    } else {\n      includedChunksMessages.push(\"async chunks\");\n\n      for (const c of chunk.getAllAsyncChunks()) {\n        addChunk(c);\n      }\n\n      const includeEntries = chunkGraph.getTreeRuntimeRequirements(chunk).has(RuntimeGlobals.ensureChunkIncludeEntries);\n\n      if (includeEntries) {\n        includedChunksMessages.push(\"sibling chunks for the entrypoint\");\n\n        for (const c of chunkGraph.getChunkEntryDependentChunksIterable(chunk)) {\n          addChunk(c);\n        }\n      }\n    }\n\n    for (const entrypoint of chunk.getAllReferencedAsyncEntrypoints()) {\n      addChunk(entrypoint.chunks[entrypoint.chunks.length - 1]);\n    }\n    /** @type {Map<string, Set<string | number>>} */\n\n\n    const staticUrls = new Map();\n    /** @type {Set<Chunk>} */\n\n    const dynamicUrlChunks = new Set();\n    /**\n     * @param {Chunk} c the chunk\n     * @param {string | FilenameFunction} chunkFilename the filename template for the chunk\n     * @returns {void}\n     */\n\n    const addStaticUrl = (c, chunkFilename) => {\n      /**\n       * @param {string | number} value a value\n       * @returns {string} string to put in quotes\n       */\n      const unquotedStringify = value => {\n        const str = `${value}`;\n\n        if (str.length >= 5 && str === `${c.id}`) {\n          // This is shorter and generates the same result\n          return '\" + chunkId + \"';\n        }\n\n        const s = JSON.stringify(str);\n        return s.slice(1, s.length - 1);\n      };\n\n      const unquotedStringifyWithLength = value => length => unquotedStringify(`${value}`.slice(0, length));\n\n      const chunkFilenameValue = typeof chunkFilename === \"function\" ? JSON.stringify(chunkFilename({\n        chunk: c,\n        contentHashType: contentType\n      })) : JSON.stringify(chunkFilename);\n      const staticChunkFilename = compilation.getPath(chunkFilenameValue, {\n        hash: `\" + ${RuntimeGlobals.getFullHash}() + \"`,\n        hashWithLength: length => `\" + ${RuntimeGlobals.getFullHash}().slice(0, ${length}) + \"`,\n        chunk: {\n          id: unquotedStringify(c.id),\n          hash: unquotedStringify(c.renderedHash),\n          hashWithLength: unquotedStringifyWithLength(c.renderedHash),\n          name: unquotedStringify(c.name || c.id),\n          contentHash: {\n            [contentType]: unquotedStringify(c.contentHash[contentType])\n          },\n          contentHashWithLength: {\n            [contentType]: unquotedStringifyWithLength(c.contentHash[contentType])\n          }\n        },\n        contentHashType: contentType\n      });\n      let set = staticUrls.get(staticChunkFilename);\n\n      if (set === undefined) {\n        staticUrls.set(staticChunkFilename, set = new Set());\n      }\n\n      set.add(c.id);\n    };\n\n    for (const [filename, chunks] of chunkFilenames) {\n      if (filename !== dynamicFilename) {\n        for (const c of chunks) addStaticUrl(c, filename);\n      } else {\n        for (const c of chunks) dynamicUrlChunks.add(c);\n      }\n    }\n    /**\n     * @param {function(Chunk): string | number} fn function from chunk to value\n     * @returns {string} code with static mapping of results of fn\n     */\n\n\n    const createMap = fn => {\n      const obj = {};\n      let useId = false;\n      let lastKey;\n      let entries = 0;\n\n      for (const c of dynamicUrlChunks) {\n        const value = fn(c);\n\n        if (value === c.id) {\n          useId = true;\n        } else {\n          obj[c.id] = value;\n          lastKey = c.id;\n          entries++;\n        }\n      }\n\n      if (entries === 0) return \"chunkId\";\n\n      if (entries === 1) {\n        return useId ? `(chunkId === ${JSON.stringify(lastKey)} ? ${JSON.stringify(obj[lastKey])} : chunkId)` : JSON.stringify(obj[lastKey]);\n      }\n\n      return useId ? `(${JSON.stringify(obj)}[chunkId] || chunkId)` : `${JSON.stringify(obj)}[chunkId]`;\n    };\n    /**\n     * @param {function(Chunk): string | number} fn function from chunk to value\n     * @returns {string} code with static mapping of results of fn for including in quoted string\n     */\n\n\n    const mapExpr = fn => {\n      return `\" + ${createMap(fn)} + \"`;\n    };\n    /**\n     * @param {function(Chunk): string | number} fn function from chunk to value\n     * @returns {function(number): string} function which generates code with static mapping of results of fn for including in quoted string for specific length\n     */\n\n\n    const mapExprWithLength = fn => length => {\n      return `\" + ${createMap(c => `${fn(c)}`.slice(0, length))} + \"`;\n    };\n\n    const url = dynamicFilename && compilation.getPath(JSON.stringify(dynamicFilename), {\n      hash: `\" + ${RuntimeGlobals.getFullHash}() + \"`,\n      hashWithLength: length => `\" + ${RuntimeGlobals.getFullHash}().slice(0, ${length}) + \"`,\n      chunk: {\n        id: `\" + chunkId + \"`,\n        hash: mapExpr(c => c.renderedHash),\n        hashWithLength: mapExprWithLength(c => c.renderedHash),\n        name: mapExpr(c => c.name || c.id),\n        contentHash: {\n          [contentType]: mapExpr(c => c.contentHash[contentType])\n        },\n        contentHashWithLength: {\n          [contentType]: mapExprWithLength(c => c.contentHash[contentType])\n        }\n      },\n      contentHashType: contentType\n    });\n    return Template.asString([`// This function allow to reference ${includedChunksMessages.join(\" and \")}`, `${global} = ${runtimeTemplate.basicFunction(\"chunkId\", staticUrls.size > 0 ? [\"// return url for filenames not based on template\", // it minimizes to `x===1?\"...\":x===2?\"...\":\"...\"`\n    Template.asString(Array.from(staticUrls, _ref => {\n      let [url, ids] = _ref;\n      const condition = ids.size === 1 ? `chunkId === ${JSON.stringify(first(ids))}` : `{${Array.from(ids, id => `${JSON.stringify(id)}:1`).join(\",\")}}[chunkId]`;\n      return `if (${condition}) return ${url};`;\n    })), \"// return url for filenames based on template\", `return ${url};`] : [\"// return url for filenames based on template\", `return ${url};`])};`]);\n  }\n\n}\n\nmodule.exports = GetChunkFilenameRuntimeModule;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/runtime/GetChunkFilenameRuntimeModule.js"],"names":["RuntimeGlobals","require","RuntimeModule","Template","first","GetChunkFilenameRuntimeModule","constructor","contentType","name","global","getFilenameForChunk","allChunks","dependentHash","generate","chunk","chunkGraph","compilation","runtimeTemplate","chunkFilenames","Map","maxChunks","dynamicFilename","addChunk","c","chunkFilename","set","get","undefined","Set","add","size","length","includedChunksMessages","push","getAllReferencedChunks","getAllAsyncChunks","includeEntries","getTreeRuntimeRequirements","has","ensureChunkIncludeEntries","getChunkEntryDependentChunksIterable","entrypoint","getAllReferencedAsyncEntrypoints","chunks","staticUrls","dynamicUrlChunks","addStaticUrl","unquotedStringify","value","str","id","s","JSON","stringify","slice","unquotedStringifyWithLength","chunkFilenameValue","contentHashType","staticChunkFilename","getPath","hash","getFullHash","hashWithLength","renderedHash","contentHash","contentHashWithLength","filename","createMap","fn","obj","useId","lastKey","entries","mapExpr","mapExprWithLength","url","asString","join","basicFunction","Array","from","ids","condition","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst RuntimeModule = require(\"../RuntimeModule\");\nconst Template = require(\"../Template\");\nconst { first } = require(\"../util/SetHelpers\");\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compilation\").PathData} PathData */\n\n/** @typedef {function(PathData, AssetInfo=): string} FilenameFunction */\n\nclass GetChunkFilenameRuntimeModule extends RuntimeModule {\n\t/**\n\t * @param {string} contentType the contentType to use the content hash for\n\t * @param {string} name kind of filename\n\t * @param {string} global function name to be assigned\n\t * @param {function(Chunk): string | FilenameFunction} getFilenameForChunk functor to get the filename or function\n\t * @param {boolean} allChunks when false, only async chunks are included\n\t */\n\tconstructor(contentType, name, global, getFilenameForChunk, allChunks) {\n\t\tsuper(`get ${name} chunk filename`);\n\t\tthis.contentType = contentType;\n\t\tthis.global = global;\n\t\tthis.getFilenameForChunk = getFilenameForChunk;\n\t\tthis.allChunks = allChunks;\n\t\tthis.dependentHash = true;\n\t}\n\n\t/**\n\t * @returns {string} runtime code\n\t */\n\tgenerate() {\n\t\tconst {\n\t\t\tglobal,\n\t\t\tchunk,\n\t\t\tchunkGraph,\n\t\t\tcontentType,\n\t\t\tgetFilenameForChunk,\n\t\t\tallChunks,\n\t\t\tcompilation\n\t\t} = this;\n\t\tconst { runtimeTemplate } = compilation;\n\n\t\t/** @type {Map<string | FilenameFunction, Set<Chunk>>} */\n\t\tconst chunkFilenames = new Map();\n\t\tlet maxChunks = 0;\n\t\t/** @type {string} */\n\t\tlet dynamicFilename;\n\n\t\t/**\n\t\t * @param {Chunk} c the chunk\n\t\t * @returns {void}\n\t\t */\n\t\tconst addChunk = c => {\n\t\t\tconst chunkFilename = getFilenameForChunk(c);\n\t\t\tif (chunkFilename) {\n\t\t\t\tlet set = chunkFilenames.get(chunkFilename);\n\t\t\t\tif (set === undefined) {\n\t\t\t\t\tchunkFilenames.set(chunkFilename, (set = new Set()));\n\t\t\t\t}\n\t\t\t\tset.add(c);\n\t\t\t\tif (typeof chunkFilename === \"string\") {\n\t\t\t\t\tif (set.size < maxChunks) return;\n\t\t\t\t\tif (set.size === maxChunks) {\n\t\t\t\t\t\tif (chunkFilename.length < dynamicFilename.length) return;\n\t\t\t\t\t\tif (chunkFilename.length === dynamicFilename.length) {\n\t\t\t\t\t\t\tif (chunkFilename < dynamicFilename) return;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmaxChunks = set.size;\n\t\t\t\t\tdynamicFilename = chunkFilename;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/** @type {string[]} */\n\t\tconst includedChunksMessages = [];\n\t\tif (allChunks) {\n\t\t\tincludedChunksMessages.push(\"all chunks\");\n\t\t\tfor (const c of chunk.getAllReferencedChunks()) {\n\t\t\t\taddChunk(c);\n\t\t\t}\n\t\t} else {\n\t\t\tincludedChunksMessages.push(\"async chunks\");\n\t\t\tfor (const c of chunk.getAllAsyncChunks()) {\n\t\t\t\taddChunk(c);\n\t\t\t}\n\t\t\tconst includeEntries = chunkGraph\n\t\t\t\t.getTreeRuntimeRequirements(chunk)\n\t\t\t\t.has(RuntimeGlobals.ensureChunkIncludeEntries);\n\t\t\tif (includeEntries) {\n\t\t\t\tincludedChunksMessages.push(\"sibling chunks for the entrypoint\");\n\t\t\t\tfor (const c of chunkGraph.getChunkEntryDependentChunksIterable(\n\t\t\t\t\tchunk\n\t\t\t\t)) {\n\t\t\t\t\taddChunk(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const entrypoint of chunk.getAllReferencedAsyncEntrypoints()) {\n\t\t\taddChunk(entrypoint.chunks[entrypoint.chunks.length - 1]);\n\t\t}\n\n\t\t/** @type {Map<string, Set<string | number>>} */\n\t\tconst staticUrls = new Map();\n\t\t/** @type {Set<Chunk>} */\n\t\tconst dynamicUrlChunks = new Set();\n\n\t\t/**\n\t\t * @param {Chunk} c the chunk\n\t\t * @param {string | FilenameFunction} chunkFilename the filename template for the chunk\n\t\t * @returns {void}\n\t\t */\n\t\tconst addStaticUrl = (c, chunkFilename) => {\n\t\t\t/**\n\t\t\t * @param {string | number} value a value\n\t\t\t * @returns {string} string to put in quotes\n\t\t\t */\n\t\t\tconst unquotedStringify = value => {\n\t\t\t\tconst str = `${value}`;\n\t\t\t\tif (str.length >= 5 && str === `${c.id}`) {\n\t\t\t\t\t// This is shorter and generates the same result\n\t\t\t\t\treturn '\" + chunkId + \"';\n\t\t\t\t}\n\t\t\t\tconst s = JSON.stringify(str);\n\t\t\t\treturn s.slice(1, s.length - 1);\n\t\t\t};\n\t\t\tconst unquotedStringifyWithLength = value => length =>\n\t\t\t\tunquotedStringify(`${value}`.slice(0, length));\n\t\t\tconst chunkFilenameValue =\n\t\t\t\ttypeof chunkFilename === \"function\"\n\t\t\t\t\t? JSON.stringify(\n\t\t\t\t\t\t\tchunkFilename({\n\t\t\t\t\t\t\t\tchunk: c,\n\t\t\t\t\t\t\t\tcontentHashType: contentType\n\t\t\t\t\t\t\t})\n\t\t\t\t\t  )\n\t\t\t\t\t: JSON.stringify(chunkFilename);\n\t\t\tconst staticChunkFilename = compilation.getPath(chunkFilenameValue, {\n\t\t\t\thash: `\" + ${RuntimeGlobals.getFullHash}() + \"`,\n\t\t\t\thashWithLength: length =>\n\t\t\t\t\t`\" + ${RuntimeGlobals.getFullHash}().slice(0, ${length}) + \"`,\n\t\t\t\tchunk: {\n\t\t\t\t\tid: unquotedStringify(c.id),\n\t\t\t\t\thash: unquotedStringify(c.renderedHash),\n\t\t\t\t\thashWithLength: unquotedStringifyWithLength(c.renderedHash),\n\t\t\t\t\tname: unquotedStringify(c.name || c.id),\n\t\t\t\t\tcontentHash: {\n\t\t\t\t\t\t[contentType]: unquotedStringify(c.contentHash[contentType])\n\t\t\t\t\t},\n\t\t\t\t\tcontentHashWithLength: {\n\t\t\t\t\t\t[contentType]: unquotedStringifyWithLength(\n\t\t\t\t\t\t\tc.contentHash[contentType]\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tcontentHashType: contentType\n\t\t\t});\n\t\t\tlet set = staticUrls.get(staticChunkFilename);\n\t\t\tif (set === undefined) {\n\t\t\t\tstaticUrls.set(staticChunkFilename, (set = new Set()));\n\t\t\t}\n\t\t\tset.add(c.id);\n\t\t};\n\n\t\tfor (const [filename, chunks] of chunkFilenames) {\n\t\t\tif (filename !== dynamicFilename) {\n\t\t\t\tfor (const c of chunks) addStaticUrl(c, filename);\n\t\t\t} else {\n\t\t\t\tfor (const c of chunks) dynamicUrlChunks.add(c);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {function(Chunk): string | number} fn function from chunk to value\n\t\t * @returns {string} code with static mapping of results of fn\n\t\t */\n\t\tconst createMap = fn => {\n\t\t\tconst obj = {};\n\t\t\tlet useId = false;\n\t\t\tlet lastKey;\n\t\t\tlet entries = 0;\n\t\t\tfor (const c of dynamicUrlChunks) {\n\t\t\t\tconst value = fn(c);\n\t\t\t\tif (value === c.id) {\n\t\t\t\t\tuseId = true;\n\t\t\t\t} else {\n\t\t\t\t\tobj[c.id] = value;\n\t\t\t\t\tlastKey = c.id;\n\t\t\t\t\tentries++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (entries === 0) return \"chunkId\";\n\t\t\tif (entries === 1) {\n\t\t\t\treturn useId\n\t\t\t\t\t? `(chunkId === ${JSON.stringify(lastKey)} ? ${JSON.stringify(\n\t\t\t\t\t\t\tobj[lastKey]\n\t\t\t\t\t  )} : chunkId)`\n\t\t\t\t\t: JSON.stringify(obj[lastKey]);\n\t\t\t}\n\t\t\treturn useId\n\t\t\t\t? `(${JSON.stringify(obj)}[chunkId] || chunkId)`\n\t\t\t\t: `${JSON.stringify(obj)}[chunkId]`;\n\t\t};\n\n\t\t/**\n\t\t * @param {function(Chunk): string | number} fn function from chunk to value\n\t\t * @returns {string} code with static mapping of results of fn for including in quoted string\n\t\t */\n\t\tconst mapExpr = fn => {\n\t\t\treturn `\" + ${createMap(fn)} + \"`;\n\t\t};\n\n\t\t/**\n\t\t * @param {function(Chunk): string | number} fn function from chunk to value\n\t\t * @returns {function(number): string} function which generates code with static mapping of results of fn for including in quoted string for specific length\n\t\t */\n\t\tconst mapExprWithLength = fn => length => {\n\t\t\treturn `\" + ${createMap(c => `${fn(c)}`.slice(0, length))} + \"`;\n\t\t};\n\n\t\tconst url =\n\t\t\tdynamicFilename &&\n\t\t\tcompilation.getPath(JSON.stringify(dynamicFilename), {\n\t\t\t\thash: `\" + ${RuntimeGlobals.getFullHash}() + \"`,\n\t\t\t\thashWithLength: length =>\n\t\t\t\t\t`\" + ${RuntimeGlobals.getFullHash}().slice(0, ${length}) + \"`,\n\t\t\t\tchunk: {\n\t\t\t\t\tid: `\" + chunkId + \"`,\n\t\t\t\t\thash: mapExpr(c => c.renderedHash),\n\t\t\t\t\thashWithLength: mapExprWithLength(c => c.renderedHash),\n\t\t\t\t\tname: mapExpr(c => c.name || c.id),\n\t\t\t\t\tcontentHash: {\n\t\t\t\t\t\t[contentType]: mapExpr(c => c.contentHash[contentType])\n\t\t\t\t\t},\n\t\t\t\t\tcontentHashWithLength: {\n\t\t\t\t\t\t[contentType]: mapExprWithLength(c => c.contentHash[contentType])\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tcontentHashType: contentType\n\t\t\t});\n\n\t\treturn Template.asString([\n\t\t\t`// This function allow to reference ${includedChunksMessages.join(\n\t\t\t\t\" and \"\n\t\t\t)}`,\n\t\t\t`${global} = ${runtimeTemplate.basicFunction(\n\t\t\t\t\"chunkId\",\n\n\t\t\t\tstaticUrls.size > 0\n\t\t\t\t\t? [\n\t\t\t\t\t\t\t\"// return url for filenames not based on template\",\n\t\t\t\t\t\t\t// it minimizes to `x===1?\"...\":x===2?\"...\":\"...\"`\n\t\t\t\t\t\t\tTemplate.asString(\n\t\t\t\t\t\t\t\tArray.from(staticUrls, ([url, ids]) => {\n\t\t\t\t\t\t\t\t\tconst condition =\n\t\t\t\t\t\t\t\t\t\tids.size === 1\n\t\t\t\t\t\t\t\t\t\t\t? `chunkId === ${JSON.stringify(first(ids))}`\n\t\t\t\t\t\t\t\t\t\t\t: `{${Array.from(\n\t\t\t\t\t\t\t\t\t\t\t\t\tids,\n\t\t\t\t\t\t\t\t\t\t\t\t\tid => `${JSON.stringify(id)}:1`\n\t\t\t\t\t\t\t\t\t\t\t  ).join(\",\")}}[chunkId]`;\n\t\t\t\t\t\t\t\t\treturn `if (${condition}) return ${url};`;\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\"// return url for filenames based on template\",\n\t\t\t\t\t\t\t`return ${url};`\n\t\t\t\t\t  ]\n\t\t\t\t\t: [\"// return url for filenames based on template\", `return ${url};`]\n\t\t\t)};`\n\t\t]);\n\t}\n}\n\nmodule.exports = GetChunkFilenameRuntimeModule;\n"]},"metadata":{},"sourceType":"script"}