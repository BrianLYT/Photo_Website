{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst createHash = require(\"../util/createHash\");\n/** @typedef {import(\"../util/Hash\")} Hash */\n\n/** @typedef {typeof import(\"../util/Hash\")} HashConstructor */\n\n/**\n * @typedef {Object} HashableObject\n * @property {function(Hash): void} updateHash\n */\n\n\nclass LazyHashedEtag {\n  /**\n   * @param {HashableObject} obj object with updateHash method\n   * @param {string | HashConstructor} hashFunction the hash function to use\n   */\n  constructor(obj) {\n    let hashFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"md4\";\n    this._obj = obj;\n    this._hash = undefined;\n    this._hashFunction = hashFunction;\n  }\n  /**\n   * @returns {string} hash of object\n   */\n\n\n  toString() {\n    if (this._hash === undefined) {\n      const hash = createHash(this._hashFunction);\n\n      this._obj.updateHash(hash);\n\n      this._hash =\n      /** @type {string} */\n      hash.digest(\"base64\");\n    }\n\n    return this._hash;\n  }\n\n}\n/** @type {Map<string | HashConstructor, WeakMap<HashableObject, LazyHashedEtag>>} */\n\n\nconst mapStrings = new Map();\n/** @type {WeakMap<HashConstructor, WeakMap<HashableObject, LazyHashedEtag>>} */\n\nconst mapObjects = new WeakMap();\n/**\n * @param {HashableObject} obj object with updateHash method\n * @param {string | HashConstructor} hashFunction the hash function to use\n * @returns {LazyHashedEtag} etag\n */\n\nconst getter = function (obj) {\n  let hashFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"md4\";\n  let innerMap;\n\n  if (typeof hashFunction === \"string\") {\n    innerMap = mapStrings.get(hashFunction);\n\n    if (innerMap === undefined) {\n      const newHash = new LazyHashedEtag(obj, hashFunction);\n      innerMap = new WeakMap();\n      innerMap.set(obj, newHash);\n      mapStrings.set(hashFunction, innerMap);\n      return newHash;\n    }\n  } else {\n    innerMap = mapObjects.get(hashFunction);\n\n    if (innerMap === undefined) {\n      const newHash = new LazyHashedEtag(obj, hashFunction);\n      innerMap = new WeakMap();\n      innerMap.set(obj, newHash);\n      mapObjects.set(hashFunction, innerMap);\n      return newHash;\n    }\n  }\n\n  const hash = innerMap.get(obj);\n  if (hash !== undefined) return hash;\n  const newHash = new LazyHashedEtag(obj, hashFunction);\n  innerMap.set(obj, newHash);\n  return newHash;\n};\n\nmodule.exports = getter;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/cache/getLazyHashedEtag.js"],"names":["createHash","require","LazyHashedEtag","constructor","obj","hashFunction","_obj","_hash","undefined","_hashFunction","toString","hash","updateHash","digest","mapStrings","Map","mapObjects","WeakMap","getter","innerMap","get","newHash","set","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,UAAU,GAAGC,OAAO,CAAC,oBAAD,CAA1B;AAEA;;AACA;;AAEA;AACA;AACA;AACA;;;AAEA,MAAMC,cAAN,CAAqB;AACpB;AACD;AACA;AACA;AACCC,EAAAA,WAAW,CAACC,GAAD,EAA4B;AAAA,QAAtBC,YAAsB,uEAAP,KAAO;AACtC,SAAKC,IAAL,GAAYF,GAAZ;AACA,SAAKG,KAAL,GAAaC,SAAb;AACA,SAAKC,aAAL,GAAqBJ,YAArB;AACA;AAED;AACD;AACA;;;AACCK,EAAAA,QAAQ,GAAG;AACV,QAAI,KAAKH,KAAL,KAAeC,SAAnB,EAA8B;AAC7B,YAAMG,IAAI,GAAGX,UAAU,CAAC,KAAKS,aAAN,CAAvB;;AACA,WAAKH,IAAL,CAAUM,UAAV,CAAqBD,IAArB;;AACA,WAAKJ,KAAL;AAAa;AAAuBI,MAAAA,IAAI,CAACE,MAAL,CAAY,QAAZ,CAApC;AACA;;AACD,WAAO,KAAKN,KAAZ;AACA;;AArBmB;AAwBrB;;;AACA,MAAMO,UAAU,GAAG,IAAIC,GAAJ,EAAnB;AAEA;;AACA,MAAMC,UAAU,GAAG,IAAIC,OAAJ,EAAnB;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAMC,MAAM,GAAG,UAACd,GAAD,EAA+B;AAAA,MAAzBC,YAAyB,uEAAV,KAAU;AAC7C,MAAIc,QAAJ;;AACA,MAAI,OAAOd,YAAP,KAAwB,QAA5B,EAAsC;AACrCc,IAAAA,QAAQ,GAAGL,UAAU,CAACM,GAAX,CAAef,YAAf,CAAX;;AACA,QAAIc,QAAQ,KAAKX,SAAjB,EAA4B;AAC3B,YAAMa,OAAO,GAAG,IAAInB,cAAJ,CAAmBE,GAAnB,EAAwBC,YAAxB,CAAhB;AACAc,MAAAA,QAAQ,GAAG,IAAIF,OAAJ,EAAX;AACAE,MAAAA,QAAQ,CAACG,GAAT,CAAalB,GAAb,EAAkBiB,OAAlB;AACAP,MAAAA,UAAU,CAACQ,GAAX,CAAejB,YAAf,EAA6Bc,QAA7B;AACA,aAAOE,OAAP;AACA;AACD,GATD,MASO;AACNF,IAAAA,QAAQ,GAAGH,UAAU,CAACI,GAAX,CAAef,YAAf,CAAX;;AACA,QAAIc,QAAQ,KAAKX,SAAjB,EAA4B;AAC3B,YAAMa,OAAO,GAAG,IAAInB,cAAJ,CAAmBE,GAAnB,EAAwBC,YAAxB,CAAhB;AACAc,MAAAA,QAAQ,GAAG,IAAIF,OAAJ,EAAX;AACAE,MAAAA,QAAQ,CAACG,GAAT,CAAalB,GAAb,EAAkBiB,OAAlB;AACAL,MAAAA,UAAU,CAACM,GAAX,CAAejB,YAAf,EAA6Bc,QAA7B;AACA,aAAOE,OAAP;AACA;AACD;;AACD,QAAMV,IAAI,GAAGQ,QAAQ,CAACC,GAAT,CAAahB,GAAb,CAAb;AACA,MAAIO,IAAI,KAAKH,SAAb,EAAwB,OAAOG,IAAP;AACxB,QAAMU,OAAO,GAAG,IAAInB,cAAJ,CAAmBE,GAAnB,EAAwBC,YAAxB,CAAhB;AACAc,EAAAA,QAAQ,CAACG,GAAT,CAAalB,GAAb,EAAkBiB,OAAlB;AACA,SAAOA,OAAP;AACA,CA1BD;;AA4BAE,MAAM,CAACC,OAAP,GAAiBN,MAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst createHash = require(\"../util/createHash\");\n\n/** @typedef {import(\"../util/Hash\")} Hash */\n/** @typedef {typeof import(\"../util/Hash\")} HashConstructor */\n\n/**\n * @typedef {Object} HashableObject\n * @property {function(Hash): void} updateHash\n */\n\nclass LazyHashedEtag {\n\t/**\n\t * @param {HashableObject} obj object with updateHash method\n\t * @param {string | HashConstructor} hashFunction the hash function to use\n\t */\n\tconstructor(obj, hashFunction = \"md4\") {\n\t\tthis._obj = obj;\n\t\tthis._hash = undefined;\n\t\tthis._hashFunction = hashFunction;\n\t}\n\n\t/**\n\t * @returns {string} hash of object\n\t */\n\ttoString() {\n\t\tif (this._hash === undefined) {\n\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\tthis._obj.updateHash(hash);\n\t\t\tthis._hash = /** @type {string} */ (hash.digest(\"base64\"));\n\t\t}\n\t\treturn this._hash;\n\t}\n}\n\n/** @type {Map<string | HashConstructor, WeakMap<HashableObject, LazyHashedEtag>>} */\nconst mapStrings = new Map();\n\n/** @type {WeakMap<HashConstructor, WeakMap<HashableObject, LazyHashedEtag>>} */\nconst mapObjects = new WeakMap();\n\n/**\n * @param {HashableObject} obj object with updateHash method\n * @param {string | HashConstructor} hashFunction the hash function to use\n * @returns {LazyHashedEtag} etag\n */\nconst getter = (obj, hashFunction = \"md4\") => {\n\tlet innerMap;\n\tif (typeof hashFunction === \"string\") {\n\t\tinnerMap = mapStrings.get(hashFunction);\n\t\tif (innerMap === undefined) {\n\t\t\tconst newHash = new LazyHashedEtag(obj, hashFunction);\n\t\t\tinnerMap = new WeakMap();\n\t\t\tinnerMap.set(obj, newHash);\n\t\t\tmapStrings.set(hashFunction, innerMap);\n\t\t\treturn newHash;\n\t\t}\n\t} else {\n\t\tinnerMap = mapObjects.get(hashFunction);\n\t\tif (innerMap === undefined) {\n\t\t\tconst newHash = new LazyHashedEtag(obj, hashFunction);\n\t\t\tinnerMap = new WeakMap();\n\t\t\tinnerMap.set(obj, newHash);\n\t\t\tmapObjects.set(hashFunction, innerMap);\n\t\t\treturn newHash;\n\t\t}\n\t}\n\tconst hash = innerMap.get(obj);\n\tif (hash !== undefined) return hash;\n\tconst newHash = new LazyHashedEtag(obj, hashFunction);\n\tinnerMap.set(obj, newHash);\n\treturn newHash;\n};\n\nmodule.exports = getter;\n"]},"metadata":{},"sourceType":"script"}