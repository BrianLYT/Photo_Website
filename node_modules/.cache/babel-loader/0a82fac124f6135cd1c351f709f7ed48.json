{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst getGeneratedSourceInfo = require(\"./getGeneratedSourceInfo\");\n\nconst getSource = require(\"./getSource\");\n\nconst readMappings = require(\"./readMappings\");\n\nconst splitIntoLines = require(\"./splitIntoLines\");\n\nconst streamChunksOfSourceMapFull = (source, sourceMap, onChunk, onSource, onName) => {\n  const lines = splitIntoLines(source);\n\n  if (lines.length === 0) {\n    return {\n      generatedLine: 1,\n      generatedColumn: 0\n    };\n  }\n\n  const {\n    sources,\n    sourcesContent,\n    names,\n    mappings\n  } = sourceMap;\n\n  for (let i = 0; i < sources.length; i++) {\n    onSource(i, getSource(sourceMap, i), sourcesContent && sourcesContent[i] || undefined);\n  }\n\n  if (names) {\n    for (let i = 0; i < names.length; i++) {\n      onName(i, names[i]);\n    }\n  }\n\n  const lastLine = lines[lines.length - 1];\n  const lastNewLine = lastLine.endsWith(\"\\n\");\n  const finalLine = lastNewLine ? lines.length + 1 : lines.length;\n  const finalColumn = lastNewLine ? 0 : lastLine.length;\n  let currentGeneratedLine = 1;\n  let currentGeneratedColumn = 0;\n  let mappingActive = false;\n  let activeMappingSourceIndex = -1;\n  let activeMappingOriginalLine = -1;\n  let activeMappingOriginalColumn = -1;\n  let activeMappingNameIndex = -1;\n\n  const onMapping = (generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {\n    if (mappingActive && currentGeneratedLine <= lines.length) {\n      let chunk;\n      const mappingLine = currentGeneratedLine;\n      const mappingColumn = currentGeneratedColumn;\n      const line = lines[currentGeneratedLine - 1];\n\n      if (generatedLine !== currentGeneratedLine) {\n        chunk = line.slice(currentGeneratedColumn);\n        currentGeneratedLine++;\n        currentGeneratedColumn = 0;\n      } else {\n        chunk = line.slice(currentGeneratedColumn, generatedColumn);\n        currentGeneratedColumn = generatedColumn;\n      }\n\n      if (chunk) {\n        onChunk(chunk, mappingLine, mappingColumn, activeMappingSourceIndex, activeMappingOriginalLine, activeMappingOriginalColumn, activeMappingNameIndex);\n      }\n\n      mappingActive = false;\n    }\n\n    if (generatedLine > currentGeneratedLine && currentGeneratedColumn > 0) {\n      if (currentGeneratedLine <= lines.length) {\n        const chunk = lines[currentGeneratedLine - 1].slice(currentGeneratedColumn);\n        onChunk(chunk, currentGeneratedLine, currentGeneratedColumn, -1, -1, -1, -1);\n      }\n\n      currentGeneratedLine++;\n      currentGeneratedColumn = 0;\n    }\n\n    while (generatedLine > currentGeneratedLine) {\n      if (currentGeneratedLine <= lines.length) {\n        onChunk(lines[currentGeneratedLine - 1], currentGeneratedLine, 0, -1, -1, -1, -1);\n      }\n\n      currentGeneratedLine++;\n    }\n\n    if (generatedColumn > currentGeneratedColumn) {\n      if (currentGeneratedLine <= lines.length) {\n        const chunk = lines[currentGeneratedLine - 1].slice(currentGeneratedColumn, generatedColumn);\n        onChunk(chunk, currentGeneratedLine, currentGeneratedColumn, -1, -1, -1, -1);\n      }\n\n      currentGeneratedColumn = generatedColumn;\n    }\n\n    if (sourceIndex >= 0 && (generatedLine < finalLine || generatedLine === finalLine && generatedColumn < finalColumn)) {\n      mappingActive = true;\n      activeMappingSourceIndex = sourceIndex;\n      activeMappingOriginalLine = originalLine;\n      activeMappingOriginalColumn = originalColumn;\n      activeMappingNameIndex = nameIndex;\n    }\n  };\n\n  readMappings(mappings, onMapping);\n  onMapping(finalLine, finalColumn, -1, -1, -1, -1);\n  return {\n    generatedLine: finalLine,\n    generatedColumn: finalColumn\n  };\n};\n\nconst streamChunksOfSourceMapLinesFull = (source, sourceMap, onChunk, onSource, _onName) => {\n  const lines = splitIntoLines(source);\n\n  if (lines.length === 0) {\n    return {\n      generatedLine: 1,\n      generatedColumn: 0\n    };\n  }\n\n  const {\n    sources,\n    sourcesContent,\n    mappings\n  } = sourceMap;\n\n  for (let i = 0; i < sources.length; i++) {\n    onSource(i, getSource(sourceMap, i), sourcesContent && sourcesContent[i] || undefined);\n  }\n\n  let currentGeneratedLine = 1;\n\n  const onMapping = (generatedLine, _generatedColumn, sourceIndex, originalLine, originalColumn, _nameIndex) => {\n    if (sourceIndex < 0 || generatedLine < currentGeneratedLine || generatedLine > lines.length) {\n      return;\n    }\n\n    while (generatedLine > currentGeneratedLine) {\n      if (currentGeneratedLine <= lines.length) {\n        onChunk(lines[currentGeneratedLine - 1], currentGeneratedLine, 0, -1, -1, -1, -1);\n      }\n\n      currentGeneratedLine++;\n    }\n\n    if (generatedLine <= lines.length) {\n      onChunk(lines[generatedLine - 1], generatedLine, 0, sourceIndex, originalLine, originalColumn, -1);\n      currentGeneratedLine++;\n    }\n  };\n\n  readMappings(mappings, onMapping);\n\n  for (; currentGeneratedLine <= lines.length; currentGeneratedLine++) {\n    onChunk(lines[currentGeneratedLine - 1], currentGeneratedLine, 0, -1, -1, -1, -1);\n  }\n\n  const lastLine = lines[lines.length - 1];\n  const lastNewLine = lastLine.endsWith(\"\\n\");\n  const finalLine = lastNewLine ? lines.length + 1 : lines.length;\n  const finalColumn = lastNewLine ? 0 : lastLine.length;\n  return {\n    generatedLine: finalLine,\n    generatedColumn: finalColumn\n  };\n};\n\nconst streamChunksOfSourceMapFinal = (source, sourceMap, onChunk, onSource, onName) => {\n  const result = getGeneratedSourceInfo(source);\n  const {\n    generatedLine: finalLine,\n    generatedColumn: finalColumn\n  } = result;\n  if (finalLine === 1 && finalColumn === 0) return result;\n  const {\n    sources,\n    sourcesContent,\n    names,\n    mappings\n  } = sourceMap;\n\n  for (let i = 0; i < sources.length; i++) {\n    onSource(i, getSource(sourceMap, i), sourcesContent && sourcesContent[i] || undefined);\n  }\n\n  if (names) {\n    for (let i = 0; i < names.length; i++) {\n      onName(i, names[i]);\n    }\n  }\n\n  let mappingActiveLine = 0;\n\n  const onMapping = (generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {\n    if (generatedLine >= finalLine && (generatedColumn >= finalColumn || generatedLine > finalLine)) {\n      return;\n    }\n\n    if (sourceIndex >= 0) {\n      onChunk(undefined, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex);\n      mappingActiveLine = generatedLine;\n    } else if (mappingActiveLine === generatedLine) {\n      onChunk(undefined, generatedLine, generatedColumn, -1, -1, -1, -1);\n      mappingActiveLine = 0;\n    }\n  };\n\n  readMappings(mappings, onMapping);\n  return result;\n};\n\nconst streamChunksOfSourceMapLinesFinal = (source, sourceMap, onChunk, onSource, _onName) => {\n  const result = getGeneratedSourceInfo(source);\n  const {\n    generatedLine,\n    generatedColumn\n  } = result;\n\n  if (generatedLine === 1 && generatedColumn === 0) {\n    return {\n      generatedLine: 1,\n      generatedColumn: 0\n    };\n  }\n\n  const {\n    sources,\n    sourcesContent,\n    mappings\n  } = sourceMap;\n\n  for (let i = 0; i < sources.length; i++) {\n    onSource(i, getSource(sourceMap, i), sourcesContent && sourcesContent[i] || undefined);\n  }\n\n  const finalLine = generatedColumn === 0 ? generatedLine - 1 : generatedLine;\n  let currentGeneratedLine = 1;\n\n  const onMapping = (generatedLine, _generatedColumn, sourceIndex, originalLine, originalColumn, _nameIndex) => {\n    if (sourceIndex >= 0 && currentGeneratedLine <= generatedLine && generatedLine <= finalLine) {\n      onChunk(undefined, generatedLine, 0, sourceIndex, originalLine, originalColumn, -1);\n      currentGeneratedLine = generatedLine + 1;\n    }\n  };\n\n  readMappings(mappings, onMapping);\n  return result;\n};\n\nmodule.exports = (source, sourceMap, onChunk, onSource, onName, finalSource, columns) => {\n  if (columns) {\n    return finalSource ? streamChunksOfSourceMapFinal(source, sourceMap, onChunk, onSource, onName) : streamChunksOfSourceMapFull(source, sourceMap, onChunk, onSource, onName);\n  } else {\n    return finalSource ? streamChunksOfSourceMapLinesFinal(source, sourceMap, onChunk, onSource, onName) : streamChunksOfSourceMapLinesFull(source, sourceMap, onChunk, onSource, onName);\n  }\n};","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack-sources/lib/helpers/streamChunksOfSourceMap.js"],"names":["getGeneratedSourceInfo","require","getSource","readMappings","splitIntoLines","streamChunksOfSourceMapFull","source","sourceMap","onChunk","onSource","onName","lines","length","generatedLine","generatedColumn","sources","sourcesContent","names","mappings","i","undefined","lastLine","lastNewLine","endsWith","finalLine","finalColumn","currentGeneratedLine","currentGeneratedColumn","mappingActive","activeMappingSourceIndex","activeMappingOriginalLine","activeMappingOriginalColumn","activeMappingNameIndex","onMapping","sourceIndex","originalLine","originalColumn","nameIndex","chunk","mappingLine","mappingColumn","line","slice","streamChunksOfSourceMapLinesFull","_onName","_generatedColumn","_nameIndex","streamChunksOfSourceMapFinal","result","mappingActiveLine","streamChunksOfSourceMapLinesFinal","module","exports","finalSource","columns"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst getGeneratedSourceInfo = require(\"./getGeneratedSourceInfo\");\nconst getSource = require(\"./getSource\");\nconst readMappings = require(\"./readMappings\");\nconst splitIntoLines = require(\"./splitIntoLines\");\n\nconst streamChunksOfSourceMapFull = (\n\tsource,\n\tsourceMap,\n\tonChunk,\n\tonSource,\n\tonName\n) => {\n\tconst lines = splitIntoLines(source);\n\tif (lines.length === 0) {\n\t\treturn {\n\t\t\tgeneratedLine: 1,\n\t\t\tgeneratedColumn: 0\n\t\t};\n\t}\n\tconst { sources, sourcesContent, names, mappings } = sourceMap;\n\tfor (let i = 0; i < sources.length; i++) {\n\t\tonSource(\n\t\t\ti,\n\t\t\tgetSource(sourceMap, i),\n\t\t\t(sourcesContent && sourcesContent[i]) || undefined\n\t\t);\n\t}\n\tif (names) {\n\t\tfor (let i = 0; i < names.length; i++) {\n\t\t\tonName(i, names[i]);\n\t\t}\n\t}\n\n\tconst lastLine = lines[lines.length - 1];\n\tconst lastNewLine = lastLine.endsWith(\"\\n\");\n\tconst finalLine = lastNewLine ? lines.length + 1 : lines.length;\n\tconst finalColumn = lastNewLine ? 0 : lastLine.length;\n\n\tlet currentGeneratedLine = 1;\n\tlet currentGeneratedColumn = 0;\n\n\tlet mappingActive = false;\n\tlet activeMappingSourceIndex = -1;\n\tlet activeMappingOriginalLine = -1;\n\tlet activeMappingOriginalColumn = -1;\n\tlet activeMappingNameIndex = -1;\n\n\tconst onMapping = (\n\t\tgeneratedLine,\n\t\tgeneratedColumn,\n\t\tsourceIndex,\n\t\toriginalLine,\n\t\toriginalColumn,\n\t\tnameIndex\n\t) => {\n\t\tif (mappingActive && currentGeneratedLine <= lines.length) {\n\t\t\tlet chunk;\n\t\t\tconst mappingLine = currentGeneratedLine;\n\t\t\tconst mappingColumn = currentGeneratedColumn;\n\t\t\tconst line = lines[currentGeneratedLine - 1];\n\t\t\tif (generatedLine !== currentGeneratedLine) {\n\t\t\t\tchunk = line.slice(currentGeneratedColumn);\n\t\t\t\tcurrentGeneratedLine++;\n\t\t\t\tcurrentGeneratedColumn = 0;\n\t\t\t} else {\n\t\t\t\tchunk = line.slice(currentGeneratedColumn, generatedColumn);\n\t\t\t\tcurrentGeneratedColumn = generatedColumn;\n\t\t\t}\n\t\t\tif (chunk) {\n\t\t\t\tonChunk(\n\t\t\t\t\tchunk,\n\t\t\t\t\tmappingLine,\n\t\t\t\t\tmappingColumn,\n\t\t\t\t\tactiveMappingSourceIndex,\n\t\t\t\t\tactiveMappingOriginalLine,\n\t\t\t\t\tactiveMappingOriginalColumn,\n\t\t\t\t\tactiveMappingNameIndex\n\t\t\t\t);\n\t\t\t}\n\t\t\tmappingActive = false;\n\t\t}\n\t\tif (generatedLine > currentGeneratedLine && currentGeneratedColumn > 0) {\n\t\t\tif (currentGeneratedLine <= lines.length) {\n\t\t\t\tconst chunk = lines[currentGeneratedLine - 1].slice(\n\t\t\t\t\tcurrentGeneratedColumn\n\t\t\t\t);\n\t\t\t\tonChunk(\n\t\t\t\t\tchunk,\n\t\t\t\t\tcurrentGeneratedLine,\n\t\t\t\t\tcurrentGeneratedColumn,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1\n\t\t\t\t);\n\t\t\t}\n\t\t\tcurrentGeneratedLine++;\n\t\t\tcurrentGeneratedColumn = 0;\n\t\t}\n\t\twhile (generatedLine > currentGeneratedLine) {\n\t\t\tif (currentGeneratedLine <= lines.length) {\n\t\t\t\tonChunk(\n\t\t\t\t\tlines[currentGeneratedLine - 1],\n\t\t\t\t\tcurrentGeneratedLine,\n\t\t\t\t\t0,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1\n\t\t\t\t);\n\t\t\t}\n\t\t\tcurrentGeneratedLine++;\n\t\t}\n\t\tif (generatedColumn > currentGeneratedColumn) {\n\t\t\tif (currentGeneratedLine <= lines.length) {\n\t\t\t\tconst chunk = lines[currentGeneratedLine - 1].slice(\n\t\t\t\t\tcurrentGeneratedColumn,\n\t\t\t\t\tgeneratedColumn\n\t\t\t\t);\n\t\t\t\tonChunk(\n\t\t\t\t\tchunk,\n\t\t\t\t\tcurrentGeneratedLine,\n\t\t\t\t\tcurrentGeneratedColumn,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1\n\t\t\t\t);\n\t\t\t}\n\t\t\tcurrentGeneratedColumn = generatedColumn;\n\t\t}\n\t\tif (\n\t\t\tsourceIndex >= 0 &&\n\t\t\t(generatedLine < finalLine ||\n\t\t\t\t(generatedLine === finalLine && generatedColumn < finalColumn))\n\t\t) {\n\t\t\tmappingActive = true;\n\t\t\tactiveMappingSourceIndex = sourceIndex;\n\t\t\tactiveMappingOriginalLine = originalLine;\n\t\t\tactiveMappingOriginalColumn = originalColumn;\n\t\t\tactiveMappingNameIndex = nameIndex;\n\t\t}\n\t};\n\treadMappings(mappings, onMapping);\n\tonMapping(finalLine, finalColumn, -1, -1, -1, -1);\n\treturn {\n\t\tgeneratedLine: finalLine,\n\t\tgeneratedColumn: finalColumn\n\t};\n};\n\nconst streamChunksOfSourceMapLinesFull = (\n\tsource,\n\tsourceMap,\n\tonChunk,\n\tonSource,\n\t_onName\n) => {\n\tconst lines = splitIntoLines(source);\n\tif (lines.length === 0) {\n\t\treturn {\n\t\t\tgeneratedLine: 1,\n\t\t\tgeneratedColumn: 0\n\t\t};\n\t}\n\tconst { sources, sourcesContent, mappings } = sourceMap;\n\tfor (let i = 0; i < sources.length; i++) {\n\t\tonSource(\n\t\t\ti,\n\t\t\tgetSource(sourceMap, i),\n\t\t\t(sourcesContent && sourcesContent[i]) || undefined\n\t\t);\n\t}\n\n\tlet currentGeneratedLine = 1;\n\n\tconst onMapping = (\n\t\tgeneratedLine,\n\t\t_generatedColumn,\n\t\tsourceIndex,\n\t\toriginalLine,\n\t\toriginalColumn,\n\t\t_nameIndex\n\t) => {\n\t\tif (\n\t\t\tsourceIndex < 0 ||\n\t\t\tgeneratedLine < currentGeneratedLine ||\n\t\t\tgeneratedLine > lines.length\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\twhile (generatedLine > currentGeneratedLine) {\n\t\t\tif (currentGeneratedLine <= lines.length) {\n\t\t\t\tonChunk(\n\t\t\t\t\tlines[currentGeneratedLine - 1],\n\t\t\t\t\tcurrentGeneratedLine,\n\t\t\t\t\t0,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1\n\t\t\t\t);\n\t\t\t}\n\t\t\tcurrentGeneratedLine++;\n\t\t}\n\t\tif (generatedLine <= lines.length) {\n\t\t\tonChunk(\n\t\t\t\tlines[generatedLine - 1],\n\t\t\t\tgeneratedLine,\n\t\t\t\t0,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\t-1\n\t\t\t);\n\t\t\tcurrentGeneratedLine++;\n\t\t}\n\t};\n\treadMappings(mappings, onMapping);\n\tfor (; currentGeneratedLine <= lines.length; currentGeneratedLine++) {\n\t\tonChunk(\n\t\t\tlines[currentGeneratedLine - 1],\n\t\t\tcurrentGeneratedLine,\n\t\t\t0,\n\t\t\t-1,\n\t\t\t-1,\n\t\t\t-1,\n\t\t\t-1\n\t\t);\n\t}\n\n\tconst lastLine = lines[lines.length - 1];\n\tconst lastNewLine = lastLine.endsWith(\"\\n\");\n\n\tconst finalLine = lastNewLine ? lines.length + 1 : lines.length;\n\tconst finalColumn = lastNewLine ? 0 : lastLine.length;\n\n\treturn {\n\t\tgeneratedLine: finalLine,\n\t\tgeneratedColumn: finalColumn\n\t};\n};\n\nconst streamChunksOfSourceMapFinal = (\n\tsource,\n\tsourceMap,\n\tonChunk,\n\tonSource,\n\tonName\n) => {\n\tconst result = getGeneratedSourceInfo(source);\n\tconst { generatedLine: finalLine, generatedColumn: finalColumn } = result;\n\n\tif (finalLine === 1 && finalColumn === 0) return result;\n\tconst { sources, sourcesContent, names, mappings } = sourceMap;\n\tfor (let i = 0; i < sources.length; i++) {\n\t\tonSource(\n\t\t\ti,\n\t\t\tgetSource(sourceMap, i),\n\t\t\t(sourcesContent && sourcesContent[i]) || undefined\n\t\t);\n\t}\n\tif (names) {\n\t\tfor (let i = 0; i < names.length; i++) {\n\t\t\tonName(i, names[i]);\n\t\t}\n\t}\n\n\tlet mappingActiveLine = 0;\n\n\tconst onMapping = (\n\t\tgeneratedLine,\n\t\tgeneratedColumn,\n\t\tsourceIndex,\n\t\toriginalLine,\n\t\toriginalColumn,\n\t\tnameIndex\n\t) => {\n\t\tif (\n\t\t\tgeneratedLine >= finalLine &&\n\t\t\t(generatedColumn >= finalColumn || generatedLine > finalLine)\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\tif (sourceIndex >= 0) {\n\t\t\tonChunk(\n\t\t\t\tundefined,\n\t\t\t\tgeneratedLine,\n\t\t\t\tgeneratedColumn,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\tnameIndex\n\t\t\t);\n\t\t\tmappingActiveLine = generatedLine;\n\t\t} else if (mappingActiveLine === generatedLine) {\n\t\t\tonChunk(undefined, generatedLine, generatedColumn, -1, -1, -1, -1);\n\t\t\tmappingActiveLine = 0;\n\t\t}\n\t};\n\treadMappings(mappings, onMapping);\n\treturn result;\n};\n\nconst streamChunksOfSourceMapLinesFinal = (\n\tsource,\n\tsourceMap,\n\tonChunk,\n\tonSource,\n\t_onName\n) => {\n\tconst result = getGeneratedSourceInfo(source);\n\tconst { generatedLine, generatedColumn } = result;\n\tif (generatedLine === 1 && generatedColumn === 0) {\n\t\treturn {\n\t\t\tgeneratedLine: 1,\n\t\t\tgeneratedColumn: 0\n\t\t};\n\t}\n\n\tconst { sources, sourcesContent, mappings } = sourceMap;\n\tfor (let i = 0; i < sources.length; i++) {\n\t\tonSource(\n\t\t\ti,\n\t\t\tgetSource(sourceMap, i),\n\t\t\t(sourcesContent && sourcesContent[i]) || undefined\n\t\t);\n\t}\n\n\tconst finalLine = generatedColumn === 0 ? generatedLine - 1 : generatedLine;\n\n\tlet currentGeneratedLine = 1;\n\n\tconst onMapping = (\n\t\tgeneratedLine,\n\t\t_generatedColumn,\n\t\tsourceIndex,\n\t\toriginalLine,\n\t\toriginalColumn,\n\t\t_nameIndex\n\t) => {\n\t\tif (\n\t\t\tsourceIndex >= 0 &&\n\t\t\tcurrentGeneratedLine <= generatedLine &&\n\t\t\tgeneratedLine <= finalLine\n\t\t) {\n\t\t\tonChunk(\n\t\t\t\tundefined,\n\t\t\t\tgeneratedLine,\n\t\t\t\t0,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\t-1\n\t\t\t);\n\t\t\tcurrentGeneratedLine = generatedLine + 1;\n\t\t}\n\t};\n\treadMappings(mappings, onMapping);\n\treturn result;\n};\n\nmodule.exports = (\n\tsource,\n\tsourceMap,\n\tonChunk,\n\tonSource,\n\tonName,\n\tfinalSource,\n\tcolumns\n) => {\n\tif (columns) {\n\t\treturn finalSource\n\t\t\t? streamChunksOfSourceMapFinal(\n\t\t\t\t\tsource,\n\t\t\t\t\tsourceMap,\n\t\t\t\t\tonChunk,\n\t\t\t\t\tonSource,\n\t\t\t\t\tonName\n\t\t\t  )\n\t\t\t: streamChunksOfSourceMapFull(\n\t\t\t\t\tsource,\n\t\t\t\t\tsourceMap,\n\t\t\t\t\tonChunk,\n\t\t\t\t\tonSource,\n\t\t\t\t\tonName\n\t\t\t  );\n\t} else {\n\t\treturn finalSource\n\t\t\t? streamChunksOfSourceMapLinesFinal(\n\t\t\t\t\tsource,\n\t\t\t\t\tsourceMap,\n\t\t\t\t\tonChunk,\n\t\t\t\t\tonSource,\n\t\t\t\t\tonName\n\t\t\t  )\n\t\t\t: streamChunksOfSourceMapLinesFull(\n\t\t\t\t\tsource,\n\t\t\t\t\tsourceMap,\n\t\t\t\t\tonChunk,\n\t\t\t\t\tonSource,\n\t\t\t\t\tonName\n\t\t\t  );\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}