{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst createHash = require(\"../util/createHash\");\n\nconst {\n  makePathsRelative\n} = require(\"../util/identifier\");\n\nconst numberHash = require(\"../util/numberHash\");\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n\n/**\n * @param {string} str string to hash\n * @param {number} len max length of the hash\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} hash\n */\n\n\nconst getHash = (str, len, hashFunction) => {\n  const hash = createHash(hashFunction);\n  hash.update(str);\n  const digest =\n  /** @type {string} */\n  hash.digest(\"hex\");\n  return digest.substr(0, len);\n};\n/**\n * @param {string} str the string\n * @returns {string} string prefixed by an underscore if it is a number\n */\n\n\nconst avoidNumber = str => {\n  // max length of a number is 21 chars, bigger numbers a written as \"...e+xx\"\n  if (str.length > 21) return str;\n  const firstChar = str.charCodeAt(0); // skip everything that doesn't look like a number\n  // charCodes: \"-\": 45, \"1\": 49, \"9\": 57\n\n  if (firstChar < 49) {\n    if (firstChar !== 45) return str;\n  } else if (firstChar > 57) {\n    return str;\n  }\n\n  if (str === +str + \"\") {\n    return `_${str}`;\n  }\n\n  return str;\n};\n/**\n * @param {string} request the request\n * @returns {string} id representation\n */\n\n\nconst requestToId = request => {\n  return request.replace(/^(\\.\\.?\\/)+/, \"\").replace(/(^[.-]|[^a-zA-Z0-9_-])+/g, \"_\");\n};\n\nexports.requestToId = requestToId;\n/**\n * @param {string} string the string\n * @param {string} delimiter separator for string and hash\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} string with limited max length to 100 chars\n */\n\nconst shortenLongString = (string, delimiter, hashFunction) => {\n  if (string.length < 100) return string;\n  return string.slice(0, 100 - 6 - delimiter.length) + delimiter + getHash(string, 6, hashFunction);\n};\n/**\n * @param {Module} module the module\n * @param {string} context context directory\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} short module name\n */\n\n\nconst getShortModuleName = (module, context, associatedObjectForCache) => {\n  const libIdent = module.libIdent({\n    context,\n    associatedObjectForCache\n  });\n  if (libIdent) return avoidNumber(libIdent);\n  const nameForCondition = module.nameForCondition();\n  if (nameForCondition) return avoidNumber(makePathsRelative(context, nameForCondition, associatedObjectForCache));\n  return \"\";\n};\n\nexports.getShortModuleName = getShortModuleName;\n/**\n * @param {string} shortName the short name\n * @param {Module} module the module\n * @param {string} context context directory\n * @param {string | Hash} hashFunction hash function to use\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} long module name\n */\n\nconst getLongModuleName = (shortName, module, context, hashFunction, associatedObjectForCache) => {\n  const fullName = getFullModuleName(module, context, associatedObjectForCache);\n  return `${shortName}?${getHash(fullName, 4, hashFunction)}`;\n};\n\nexports.getLongModuleName = getLongModuleName;\n/**\n * @param {Module} module the module\n * @param {string} context context directory\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} full module name\n */\n\nconst getFullModuleName = (module, context, associatedObjectForCache) => {\n  return makePathsRelative(context, module.identifier(), associatedObjectForCache);\n};\n\nexports.getFullModuleName = getFullModuleName;\n/**\n * @param {Chunk} chunk the chunk\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {string} context context directory\n * @param {string} delimiter delimiter for names\n * @param {string | Hash} hashFunction hash function to use\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} short chunk name\n */\n\nconst getShortChunkName = (chunk, chunkGraph, context, delimiter, hashFunction, associatedObjectForCache) => {\n  const modules = chunkGraph.getChunkRootModules(chunk);\n  const shortModuleNames = modules.map(m => requestToId(getShortModuleName(m, context, associatedObjectForCache)));\n  chunk.idNameHints.sort();\n  const chunkName = Array.from(chunk.idNameHints).concat(shortModuleNames).filter(Boolean).join(delimiter);\n  return shortenLongString(chunkName, delimiter, hashFunction);\n};\n\nexports.getShortChunkName = getShortChunkName;\n/**\n * @param {Chunk} chunk the chunk\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {string} context context directory\n * @param {string} delimiter delimiter for names\n * @param {string | Hash} hashFunction hash function to use\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} short chunk name\n */\n\nconst getLongChunkName = (chunk, chunkGraph, context, delimiter, hashFunction, associatedObjectForCache) => {\n  const modules = chunkGraph.getChunkRootModules(chunk);\n  const shortModuleNames = modules.map(m => requestToId(getShortModuleName(m, context, associatedObjectForCache)));\n  const longModuleNames = modules.map(m => requestToId(getLongModuleName(\"\", m, context, hashFunction, associatedObjectForCache)));\n  chunk.idNameHints.sort();\n  const chunkName = Array.from(chunk.idNameHints).concat(shortModuleNames, longModuleNames).filter(Boolean).join(delimiter);\n  return shortenLongString(chunkName, delimiter, hashFunction);\n};\n\nexports.getLongChunkName = getLongChunkName;\n/**\n * @param {Chunk} chunk the chunk\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {string} context context directory\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} full chunk name\n */\n\nconst getFullChunkName = (chunk, chunkGraph, context, associatedObjectForCache) => {\n  if (chunk.name) return chunk.name;\n  const modules = chunkGraph.getChunkRootModules(chunk);\n  const fullModuleNames = modules.map(m => makePathsRelative(context, m.identifier(), associatedObjectForCache));\n  return fullModuleNames.join();\n};\n\nexports.getFullChunkName = getFullChunkName;\n/**\n * @template K\n * @template V\n * @param {Map<K, V[]>} map a map from key to values\n * @param {K} key key\n * @param {V} value value\n * @returns {void}\n */\n\nconst addToMapOfItems = (map, key, value) => {\n  let array = map.get(key);\n\n  if (array === undefined) {\n    array = [];\n    map.set(key, array);\n  }\n\n  array.push(value);\n};\n/**\n * @param {Compilation} compilation the compilation\n * @param {function(Module): boolean=} filter filter modules\n * @returns {[Set<string>, Module[]]} used module ids as strings and modules without id matching the filter\n */\n\n\nconst getUsedModuleIdsAndModules = (compilation, filter) => {\n  const chunkGraph = compilation.chunkGraph;\n  const modules = [];\n  /** @type {Set<string>} */\n\n  const usedIds = new Set();\n\n  if (compilation.usedModuleIds) {\n    for (const id of compilation.usedModuleIds) {\n      usedIds.add(id + \"\");\n    }\n  }\n\n  for (const module of compilation.modules) {\n    if (!module.needId) continue;\n    const moduleId = chunkGraph.getModuleId(module);\n\n    if (moduleId !== null) {\n      usedIds.add(moduleId + \"\");\n    } else {\n      if ((!filter || filter(module)) && chunkGraph.getNumberOfModuleChunks(module) !== 0) {\n        modules.push(module);\n      }\n    }\n  }\n\n  return [usedIds, modules];\n};\n\nexports.getUsedModuleIdsAndModules = getUsedModuleIdsAndModules;\n/**\n * @param {Compilation} compilation the compilation\n * @returns {Set<string>} used chunk ids as strings\n */\n\nconst getUsedChunkIds = compilation => {\n  /** @type {Set<string>} */\n  const usedIds = new Set();\n\n  if (compilation.usedChunkIds) {\n    for (const id of compilation.usedChunkIds) {\n      usedIds.add(id + \"\");\n    }\n  }\n\n  for (const chunk of compilation.chunks) {\n    const chunkId = chunk.id;\n\n    if (chunkId !== null) {\n      usedIds.add(chunkId + \"\");\n    }\n  }\n\n  return usedIds;\n};\n\nexports.getUsedChunkIds = getUsedChunkIds;\n/**\n * @template T\n * @param {Iterable<T>} items list of items to be named\n * @param {function(T): string} getShortName get a short name for an item\n * @param {function(T, string): string} getLongName get a long name for an item\n * @param {function(T, T): -1|0|1} comparator order of items\n * @param {Set<string>} usedIds already used ids, will not be assigned\n * @param {function(T, string): void} assignName assign a name to an item\n * @returns {T[]} list of items without a name\n */\n\nconst assignNames = (items, getShortName, getLongName, comparator, usedIds, assignName) => {\n  /** @type {Map<string, T[]>} */\n  const nameToItems = new Map();\n\n  for (const item of items) {\n    const name = getShortName(item);\n    addToMapOfItems(nameToItems, name, item);\n  }\n  /** @type {Map<string, T[]>} */\n\n\n  const nameToItems2 = new Map();\n\n  for (const [name, items] of nameToItems) {\n    if (items.length > 1 || !name) {\n      for (const item of items) {\n        const longName = getLongName(item, name);\n        addToMapOfItems(nameToItems2, longName, item);\n      }\n    } else {\n      addToMapOfItems(nameToItems2, name, items[0]);\n    }\n  }\n  /** @type {T[]} */\n\n\n  const unnamedItems = [];\n\n  for (const [name, items] of nameToItems2) {\n    if (!name) {\n      for (const item of items) {\n        unnamedItems.push(item);\n      }\n    } else if (items.length === 1 && !usedIds.has(name)) {\n      assignName(items[0], name);\n      usedIds.add(name);\n    } else {\n      items.sort(comparator);\n      let i = 0;\n\n      for (const item of items) {\n        while (nameToItems2.has(name + i) && usedIds.has(name + i)) i++;\n\n        assignName(item, name + i);\n        usedIds.add(name + i);\n        i++;\n      }\n    }\n  }\n\n  unnamedItems.sort(comparator);\n  return unnamedItems;\n};\n\nexports.assignNames = assignNames;\n/**\n * @template T\n * @param {T[]} items list of items to be named\n * @param {function(T): string} getName get a name for an item\n * @param {function(T, T): -1|0|1} comparator order of items\n * @param {function(T, number): boolean} assignId assign an id to an item\n * @param {number[]} ranges usable ranges for ids\n * @param {number} expandFactor factor to create more ranges\n * @param {number} extraSpace extra space to allocate, i. e. when some ids are already used\n * @param {number} salt salting number to initialize hashing\n * @returns {void}\n */\n\nconst assignDeterministicIds = function (items, getName, comparator, assignId) {\n  let ranges = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [10];\n  let expandFactor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 10;\n  let extraSpace = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  let salt = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n  items.sort(comparator); // max 5% fill rate\n\n  const optimalRange = Math.min(Math.ceil(items.length * 20) + extraSpace, Number.MAX_SAFE_INTEGER);\n  let i = 0;\n  let range = ranges[i];\n\n  while (range < optimalRange) {\n    i++;\n\n    if (i < ranges.length) {\n      range = Math.min(ranges[i], Number.MAX_SAFE_INTEGER);\n    } else if (expandFactor) {\n      range = Math.min(range * expandFactor, Number.MAX_SAFE_INTEGER);\n    } else {\n      break;\n    }\n  }\n\n  for (const item of items) {\n    const ident = getName(item);\n    let id;\n    let i = salt;\n\n    do {\n      id = numberHash(ident + i++, range);\n    } while (!assignId(item, id));\n  }\n};\n\nexports.assignDeterministicIds = assignDeterministicIds;\n/**\n * @param {Set<string>} usedIds used ids\n * @param {Iterable<Module>} modules the modules\n * @param {Compilation} compilation the compilation\n * @returns {void}\n */\n\nconst assignAscendingModuleIds = (usedIds, modules, compilation) => {\n  const chunkGraph = compilation.chunkGraph;\n  let nextId = 0;\n  let assignId;\n\n  if (usedIds.size > 0) {\n    assignId = module => {\n      if (chunkGraph.getModuleId(module) === null) {\n        while (usedIds.has(nextId + \"\")) nextId++;\n\n        chunkGraph.setModuleId(module, nextId++);\n      }\n    };\n  } else {\n    assignId = module => {\n      if (chunkGraph.getModuleId(module) === null) {\n        chunkGraph.setModuleId(module, nextId++);\n      }\n    };\n  }\n\n  for (const module of modules) {\n    assignId(module);\n  }\n};\n\nexports.assignAscendingModuleIds = assignAscendingModuleIds;\n/**\n * @param {Iterable<Chunk>} chunks the chunks\n * @param {Compilation} compilation the compilation\n * @returns {void}\n */\n\nconst assignAscendingChunkIds = (chunks, compilation) => {\n  const usedIds = getUsedChunkIds(compilation);\n  let nextId = 0;\n\n  if (usedIds.size > 0) {\n    for (const chunk of chunks) {\n      if (chunk.id === null) {\n        while (usedIds.has(nextId + \"\")) nextId++;\n\n        chunk.id = nextId;\n        chunk.ids = [nextId];\n        nextId++;\n      }\n    }\n  } else {\n    for (const chunk of chunks) {\n      if (chunk.id === null) {\n        chunk.id = nextId;\n        chunk.ids = [nextId];\n        nextId++;\n      }\n    }\n  }\n};\n\nexports.assignAscendingChunkIds = assignAscendingChunkIds;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/ids/IdHelpers.js"],"names":["createHash","require","makePathsRelative","numberHash","getHash","str","len","hashFunction","hash","update","digest","substr","avoidNumber","length","firstChar","charCodeAt","requestToId","request","replace","exports","shortenLongString","string","delimiter","slice","getShortModuleName","module","context","associatedObjectForCache","libIdent","nameForCondition","getLongModuleName","shortName","fullName","getFullModuleName","identifier","getShortChunkName","chunk","chunkGraph","modules","getChunkRootModules","shortModuleNames","map","m","idNameHints","sort","chunkName","Array","from","concat","filter","Boolean","join","getLongChunkName","longModuleNames","getFullChunkName","name","fullModuleNames","addToMapOfItems","key","value","array","get","undefined","set","push","getUsedModuleIdsAndModules","compilation","usedIds","Set","usedModuleIds","id","add","needId","moduleId","getModuleId","getNumberOfModuleChunks","getUsedChunkIds","usedChunkIds","chunks","chunkId","assignNames","items","getShortName","getLongName","comparator","assignName","nameToItems","Map","item","nameToItems2","longName","unnamedItems","has","i","assignDeterministicIds","getName","assignId","ranges","expandFactor","extraSpace","salt","optimalRange","Math","min","ceil","Number","MAX_SAFE_INTEGER","range","ident","assignAscendingModuleIds","nextId","size","setModuleId","assignAscendingChunkIds","ids"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,UAAU,GAAGC,OAAO,CAAC,oBAAD,CAA1B;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAwBD,OAAO,CAAC,oBAAD,CAArC;;AACA,MAAME,UAAU,GAAGF,OAAO,CAAC,oBAAD,CAA1B;AAEA;;AACA;;AACA;;AACA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMG,OAAO,GAAG,CAACC,GAAD,EAAMC,GAAN,EAAWC,YAAX,KAA4B;AAC3C,QAAMC,IAAI,GAAGR,UAAU,CAACO,YAAD,CAAvB;AACAC,EAAAA,IAAI,CAACC,MAAL,CAAYJ,GAAZ;AACA,QAAMK,MAAM;AAAG;AAAuBF,EAAAA,IAAI,CAACE,MAAL,CAAY,KAAZ,CAAtC;AACA,SAAOA,MAAM,CAACC,MAAP,CAAc,CAAd,EAAiBL,GAAjB,CAAP;AACA,CALD;AAOA;AACA;AACA;AACA;;;AACA,MAAMM,WAAW,GAAGP,GAAG,IAAI;AAC1B;AACA,MAAIA,GAAG,CAACQ,MAAJ,GAAa,EAAjB,EAAqB,OAAOR,GAAP;AACrB,QAAMS,SAAS,GAAGT,GAAG,CAACU,UAAJ,CAAe,CAAf,CAAlB,CAH0B,CAI1B;AACA;;AACA,MAAID,SAAS,GAAG,EAAhB,EAAoB;AACnB,QAAIA,SAAS,KAAK,EAAlB,EAAsB,OAAOT,GAAP;AACtB,GAFD,MAEO,IAAIS,SAAS,GAAG,EAAhB,EAAoB;AAC1B,WAAOT,GAAP;AACA;;AACD,MAAIA,GAAG,KAAK,CAACA,GAAD,GAAO,EAAnB,EAAuB;AACtB,WAAQ,IAAGA,GAAI,EAAf;AACA;;AACD,SAAOA,GAAP;AACA,CAfD;AAiBA;AACA;AACA;AACA;;;AACA,MAAMW,WAAW,GAAGC,OAAO,IAAI;AAC9B,SAAOA,OAAO,CACZC,OADK,CACG,aADH,EACkB,EADlB,EAELA,OAFK,CAEG,0BAFH,EAE+B,GAF/B,CAAP;AAGA,CAJD;;AAKAC,OAAO,CAACH,WAAR,GAAsBA,WAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMI,iBAAiB,GAAG,CAACC,MAAD,EAASC,SAAT,EAAoBf,YAApB,KAAqC;AAC9D,MAAIc,MAAM,CAACR,MAAP,GAAgB,GAApB,EAAyB,OAAOQ,MAAP;AACzB,SACCA,MAAM,CAACE,KAAP,CAAa,CAAb,EAAgB,MAAM,CAAN,GAAUD,SAAS,CAACT,MAApC,IACAS,SADA,GAEAlB,OAAO,CAACiB,MAAD,EAAS,CAAT,EAAYd,YAAZ,CAHR;AAKA,CAPD;AASA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMiB,kBAAkB,GAAG,CAACC,MAAD,EAASC,OAAT,EAAkBC,wBAAlB,KAA+C;AACzE,QAAMC,QAAQ,GAAGH,MAAM,CAACG,QAAP,CAAgB;AAAEF,IAAAA,OAAF;AAAWC,IAAAA;AAAX,GAAhB,CAAjB;AACA,MAAIC,QAAJ,EAAc,OAAOhB,WAAW,CAACgB,QAAD,CAAlB;AACd,QAAMC,gBAAgB,GAAGJ,MAAM,CAACI,gBAAP,EAAzB;AACA,MAAIA,gBAAJ,EACC,OAAOjB,WAAW,CACjBV,iBAAiB,CAACwB,OAAD,EAAUG,gBAAV,EAA4BF,wBAA5B,CADA,CAAlB;AAGD,SAAO,EAAP;AACA,CATD;;AAUAR,OAAO,CAACK,kBAAR,GAA6BA,kBAA7B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMM,iBAAiB,GAAG,CACzBC,SADyB,EAEzBN,MAFyB,EAGzBC,OAHyB,EAIzBnB,YAJyB,EAKzBoB,wBALyB,KAMrB;AACJ,QAAMK,QAAQ,GAAGC,iBAAiB,CAACR,MAAD,EAASC,OAAT,EAAkBC,wBAAlB,CAAlC;AACA,SAAQ,GAAEI,SAAU,IAAG3B,OAAO,CAAC4B,QAAD,EAAW,CAAX,EAAczB,YAAd,CAA4B,EAA1D;AACA,CATD;;AAUAY,OAAO,CAACW,iBAAR,GAA4BA,iBAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMG,iBAAiB,GAAG,CAACR,MAAD,EAASC,OAAT,EAAkBC,wBAAlB,KAA+C;AACxE,SAAOzB,iBAAiB,CACvBwB,OADuB,EAEvBD,MAAM,CAACS,UAAP,EAFuB,EAGvBP,wBAHuB,CAAxB;AAKA,CAND;;AAOAR,OAAO,CAACc,iBAAR,GAA4BA,iBAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAME,iBAAiB,GAAG,CACzBC,KADyB,EAEzBC,UAFyB,EAGzBX,OAHyB,EAIzBJ,SAJyB,EAKzBf,YALyB,EAMzBoB,wBANyB,KAOrB;AACJ,QAAMW,OAAO,GAAGD,UAAU,CAACE,mBAAX,CAA+BH,KAA/B,CAAhB;AACA,QAAMI,gBAAgB,GAAGF,OAAO,CAACG,GAAR,CAAYC,CAAC,IACrC1B,WAAW,CAACQ,kBAAkB,CAACkB,CAAD,EAAIhB,OAAJ,EAAaC,wBAAb,CAAnB,CADa,CAAzB;AAGAS,EAAAA,KAAK,CAACO,WAAN,CAAkBC,IAAlB;AACA,QAAMC,SAAS,GAAGC,KAAK,CAACC,IAAN,CAAWX,KAAK,CAACO,WAAjB,EAChBK,MADgB,CACTR,gBADS,EAEhBS,MAFgB,CAETC,OAFS,EAGhBC,IAHgB,CAGX7B,SAHW,CAAlB;AAIA,SAAOF,iBAAiB,CAACyB,SAAD,EAAYvB,SAAZ,EAAuBf,YAAvB,CAAxB;AACA,CAlBD;;AAmBAY,OAAO,CAACgB,iBAAR,GAA4BA,iBAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMiB,gBAAgB,GAAG,CACxBhB,KADwB,EAExBC,UAFwB,EAGxBX,OAHwB,EAIxBJ,SAJwB,EAKxBf,YALwB,EAMxBoB,wBANwB,KAOpB;AACJ,QAAMW,OAAO,GAAGD,UAAU,CAACE,mBAAX,CAA+BH,KAA/B,CAAhB;AACA,QAAMI,gBAAgB,GAAGF,OAAO,CAACG,GAAR,CAAYC,CAAC,IACrC1B,WAAW,CAACQ,kBAAkB,CAACkB,CAAD,EAAIhB,OAAJ,EAAaC,wBAAb,CAAnB,CADa,CAAzB;AAGA,QAAM0B,eAAe,GAAGf,OAAO,CAACG,GAAR,CAAYC,CAAC,IACpC1B,WAAW,CACVc,iBAAiB,CAAC,EAAD,EAAKY,CAAL,EAAQhB,OAAR,EAAiBnB,YAAjB,EAA+BoB,wBAA/B,CADP,CADY,CAAxB;AAKAS,EAAAA,KAAK,CAACO,WAAN,CAAkBC,IAAlB;AACA,QAAMC,SAAS,GAAGC,KAAK,CAACC,IAAN,CAAWX,KAAK,CAACO,WAAjB,EAChBK,MADgB,CACTR,gBADS,EACSa,eADT,EAEhBJ,MAFgB,CAETC,OAFS,EAGhBC,IAHgB,CAGX7B,SAHW,CAAlB;AAIA,SAAOF,iBAAiB,CAACyB,SAAD,EAAYvB,SAAZ,EAAuBf,YAAvB,CAAxB;AACA,CAvBD;;AAwBAY,OAAO,CAACiC,gBAAR,GAA2BA,gBAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAME,gBAAgB,GAAG,CACxBlB,KADwB,EAExBC,UAFwB,EAGxBX,OAHwB,EAIxBC,wBAJwB,KAKpB;AACJ,MAAIS,KAAK,CAACmB,IAAV,EAAgB,OAAOnB,KAAK,CAACmB,IAAb;AAChB,QAAMjB,OAAO,GAAGD,UAAU,CAACE,mBAAX,CAA+BH,KAA/B,CAAhB;AACA,QAAMoB,eAAe,GAAGlB,OAAO,CAACG,GAAR,CAAYC,CAAC,IACpCxC,iBAAiB,CAACwB,OAAD,EAAUgB,CAAC,CAACR,UAAF,EAAV,EAA0BP,wBAA1B,CADM,CAAxB;AAGA,SAAO6B,eAAe,CAACL,IAAhB,EAAP;AACA,CAZD;;AAaAhC,OAAO,CAACmC,gBAAR,GAA2BA,gBAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMG,eAAe,GAAG,CAAChB,GAAD,EAAMiB,GAAN,EAAWC,KAAX,KAAqB;AAC5C,MAAIC,KAAK,GAAGnB,GAAG,CAACoB,GAAJ,CAAQH,GAAR,CAAZ;;AACA,MAAIE,KAAK,KAAKE,SAAd,EAAyB;AACxBF,IAAAA,KAAK,GAAG,EAAR;AACAnB,IAAAA,GAAG,CAACsB,GAAJ,CAAQL,GAAR,EAAaE,KAAb;AACA;;AACDA,EAAAA,KAAK,CAACI,IAAN,CAAWL,KAAX;AACA,CAPD;AASA;AACA;AACA;AACA;AACA;;;AACA,MAAMM,0BAA0B,GAAG,CAACC,WAAD,EAAcjB,MAAd,KAAyB;AAC3D,QAAMZ,UAAU,GAAG6B,WAAW,CAAC7B,UAA/B;AAEA,QAAMC,OAAO,GAAG,EAAhB;AAEA;;AACA,QAAM6B,OAAO,GAAG,IAAIC,GAAJ,EAAhB;;AACA,MAAIF,WAAW,CAACG,aAAhB,EAA+B;AAC9B,SAAK,MAAMC,EAAX,IAAiBJ,WAAW,CAACG,aAA7B,EAA4C;AAC3CF,MAAAA,OAAO,CAACI,GAAR,CAAYD,EAAE,GAAG,EAAjB;AACA;AACD;;AAED,OAAK,MAAM7C,MAAX,IAAqByC,WAAW,CAAC5B,OAAjC,EAA0C;AACzC,QAAI,CAACb,MAAM,CAAC+C,MAAZ,EAAoB;AACpB,UAAMC,QAAQ,GAAGpC,UAAU,CAACqC,WAAX,CAAuBjD,MAAvB,CAAjB;;AACA,QAAIgD,QAAQ,KAAK,IAAjB,EAAuB;AACtBN,MAAAA,OAAO,CAACI,GAAR,CAAYE,QAAQ,GAAG,EAAvB;AACA,KAFD,MAEO;AACN,UACC,CAAC,CAACxB,MAAD,IAAWA,MAAM,CAACxB,MAAD,CAAlB,KACAY,UAAU,CAACsC,uBAAX,CAAmClD,MAAnC,MAA+C,CAFhD,EAGE;AACDa,QAAAA,OAAO,CAAC0B,IAAR,CAAavC,MAAb;AACA;AACD;AACD;;AAED,SAAO,CAAC0C,OAAD,EAAU7B,OAAV,CAAP;AACA,CA7BD;;AA8BAnB,OAAO,CAAC8C,0BAAR,GAAqCA,0BAArC;AAEA;AACA;AACA;AACA;;AACA,MAAMW,eAAe,GAAGV,WAAW,IAAI;AACtC;AACA,QAAMC,OAAO,GAAG,IAAIC,GAAJ,EAAhB;;AACA,MAAIF,WAAW,CAACW,YAAhB,EAA8B;AAC7B,SAAK,MAAMP,EAAX,IAAiBJ,WAAW,CAACW,YAA7B,EAA2C;AAC1CV,MAAAA,OAAO,CAACI,GAAR,CAAYD,EAAE,GAAG,EAAjB;AACA;AACD;;AAED,OAAK,MAAMlC,KAAX,IAAoB8B,WAAW,CAACY,MAAhC,EAAwC;AACvC,UAAMC,OAAO,GAAG3C,KAAK,CAACkC,EAAtB;;AACA,QAAIS,OAAO,KAAK,IAAhB,EAAsB;AACrBZ,MAAAA,OAAO,CAACI,GAAR,CAAYQ,OAAO,GAAG,EAAtB;AACA;AACD;;AAED,SAAOZ,OAAP;AACA,CAjBD;;AAkBAhD,OAAO,CAACyD,eAAR,GAA0BA,eAA1B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMI,WAAW,GAAG,CACnBC,KADmB,EAEnBC,YAFmB,EAGnBC,WAHmB,EAInBC,UAJmB,EAKnBjB,OALmB,EAMnBkB,UANmB,KAOf;AACJ;AACA,QAAMC,WAAW,GAAG,IAAIC,GAAJ,EAApB;;AAEA,OAAK,MAAMC,IAAX,IAAmBP,KAAnB,EAA0B;AACzB,UAAM1B,IAAI,GAAG2B,YAAY,CAACM,IAAD,CAAzB;AACA/B,IAAAA,eAAe,CAAC6B,WAAD,EAAc/B,IAAd,EAAoBiC,IAApB,CAAf;AACA;AAED;;;AACA,QAAMC,YAAY,GAAG,IAAIF,GAAJ,EAArB;;AAEA,OAAK,MAAM,CAAChC,IAAD,EAAO0B,KAAP,CAAX,IAA4BK,WAA5B,EAAyC;AACxC,QAAIL,KAAK,CAACpE,MAAN,GAAe,CAAf,IAAoB,CAAC0C,IAAzB,EAA+B;AAC9B,WAAK,MAAMiC,IAAX,IAAmBP,KAAnB,EAA0B;AACzB,cAAMS,QAAQ,GAAGP,WAAW,CAACK,IAAD,EAAOjC,IAAP,CAA5B;AACAE,QAAAA,eAAe,CAACgC,YAAD,EAAeC,QAAf,EAAyBF,IAAzB,CAAf;AACA;AACD,KALD,MAKO;AACN/B,MAAAA,eAAe,CAACgC,YAAD,EAAelC,IAAf,EAAqB0B,KAAK,CAAC,CAAD,CAA1B,CAAf;AACA;AACD;AAED;;;AACA,QAAMU,YAAY,GAAG,EAArB;;AAEA,OAAK,MAAM,CAACpC,IAAD,EAAO0B,KAAP,CAAX,IAA4BQ,YAA5B,EAA0C;AACzC,QAAI,CAAClC,IAAL,EAAW;AACV,WAAK,MAAMiC,IAAX,IAAmBP,KAAnB,EAA0B;AACzBU,QAAAA,YAAY,CAAC3B,IAAb,CAAkBwB,IAAlB;AACA;AACD,KAJD,MAIO,IAAIP,KAAK,CAACpE,MAAN,KAAiB,CAAjB,IAAsB,CAACsD,OAAO,CAACyB,GAAR,CAAYrC,IAAZ,CAA3B,EAA8C;AACpD8B,MAAAA,UAAU,CAACJ,KAAK,CAAC,CAAD,CAAN,EAAW1B,IAAX,CAAV;AACAY,MAAAA,OAAO,CAACI,GAAR,CAAYhB,IAAZ;AACA,KAHM,MAGA;AACN0B,MAAAA,KAAK,CAACrC,IAAN,CAAWwC,UAAX;AACA,UAAIS,CAAC,GAAG,CAAR;;AACA,WAAK,MAAML,IAAX,IAAmBP,KAAnB,EAA0B;AACzB,eAAOQ,YAAY,CAACG,GAAb,CAAiBrC,IAAI,GAAGsC,CAAxB,KAA8B1B,OAAO,CAACyB,GAAR,CAAYrC,IAAI,GAAGsC,CAAnB,CAArC,EAA4DA,CAAC;;AAC7DR,QAAAA,UAAU,CAACG,IAAD,EAAOjC,IAAI,GAAGsC,CAAd,CAAV;AACA1B,QAAAA,OAAO,CAACI,GAAR,CAAYhB,IAAI,GAAGsC,CAAnB;AACAA,QAAAA,CAAC;AACD;AACD;AACD;;AAEDF,EAAAA,YAAY,CAAC/C,IAAb,CAAkBwC,UAAlB;AACA,SAAOO,YAAP;AACA,CAvDD;;AAwDAxE,OAAO,CAAC6D,WAAR,GAAsBA,WAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMc,sBAAsB,GAAG,UAC9Bb,KAD8B,EAE9Bc,OAF8B,EAG9BX,UAH8B,EAI9BY,QAJ8B,EAS1B;AAAA,MAJJC,MAII,uEAJK,CAAC,EAAD,CAIL;AAAA,MAHJC,YAGI,uEAHW,EAGX;AAAA,MAFJC,UAEI,uEAFS,CAET;AAAA,MADJC,IACI,uEADG,CACH;AACJnB,EAAAA,KAAK,CAACrC,IAAN,CAAWwC,UAAX,EADI,CAGJ;;AACA,QAAMiB,YAAY,GAAGC,IAAI,CAACC,GAAL,CACpBD,IAAI,CAACE,IAAL,CAAUvB,KAAK,CAACpE,MAAN,GAAe,EAAzB,IAA+BsF,UADX,EAEpBM,MAAM,CAACC,gBAFa,CAArB;AAKA,MAAIb,CAAC,GAAG,CAAR;AACA,MAAIc,KAAK,GAAGV,MAAM,CAACJ,CAAD,CAAlB;;AACA,SAAOc,KAAK,GAAGN,YAAf,EAA6B;AAC5BR,IAAAA,CAAC;;AACD,QAAIA,CAAC,GAAGI,MAAM,CAACpF,MAAf,EAAuB;AACtB8F,MAAAA,KAAK,GAAGL,IAAI,CAACC,GAAL,CAASN,MAAM,CAACJ,CAAD,CAAf,EAAoBY,MAAM,CAACC,gBAA3B,CAAR;AACA,KAFD,MAEO,IAAIR,YAAJ,EAAkB;AACxBS,MAAAA,KAAK,GAAGL,IAAI,CAACC,GAAL,CAASI,KAAK,GAAGT,YAAjB,EAA+BO,MAAM,CAACC,gBAAtC,CAAR;AACA,KAFM,MAEA;AACN;AACA;AACD;;AAED,OAAK,MAAMlB,IAAX,IAAmBP,KAAnB,EAA0B;AACzB,UAAM2B,KAAK,GAAGb,OAAO,CAACP,IAAD,CAArB;AACA,QAAIlB,EAAJ;AACA,QAAIuB,CAAC,GAAGO,IAAR;;AACA,OAAG;AACF9B,MAAAA,EAAE,GAAGnE,UAAU,CAACyG,KAAK,GAAGf,CAAC,EAAV,EAAcc,KAAd,CAAf;AACA,KAFD,QAES,CAACX,QAAQ,CAACR,IAAD,EAAOlB,EAAP,CAFlB;AAGA;AACD,CAvCD;;AAwCAnD,OAAO,CAAC2E,sBAAR,GAAiCA,sBAAjC;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMe,wBAAwB,GAAG,CAAC1C,OAAD,EAAU7B,OAAV,EAAmB4B,WAAnB,KAAmC;AACnE,QAAM7B,UAAU,GAAG6B,WAAW,CAAC7B,UAA/B;AAEA,MAAIyE,MAAM,GAAG,CAAb;AACA,MAAId,QAAJ;;AACA,MAAI7B,OAAO,CAAC4C,IAAR,GAAe,CAAnB,EAAsB;AACrBf,IAAAA,QAAQ,GAAGvE,MAAM,IAAI;AACpB,UAAIY,UAAU,CAACqC,WAAX,CAAuBjD,MAAvB,MAAmC,IAAvC,EAA6C;AAC5C,eAAO0C,OAAO,CAACyB,GAAR,CAAYkB,MAAM,GAAG,EAArB,CAAP,EAAiCA,MAAM;;AACvCzE,QAAAA,UAAU,CAAC2E,WAAX,CAAuBvF,MAAvB,EAA+BqF,MAAM,EAArC;AACA;AACD,KALD;AAMA,GAPD,MAOO;AACNd,IAAAA,QAAQ,GAAGvE,MAAM,IAAI;AACpB,UAAIY,UAAU,CAACqC,WAAX,CAAuBjD,MAAvB,MAAmC,IAAvC,EAA6C;AAC5CY,QAAAA,UAAU,CAAC2E,WAAX,CAAuBvF,MAAvB,EAA+BqF,MAAM,EAArC;AACA;AACD,KAJD;AAKA;;AACD,OAAK,MAAMrF,MAAX,IAAqBa,OAArB,EAA8B;AAC7B0D,IAAAA,QAAQ,CAACvE,MAAD,CAAR;AACA;AACD,CAtBD;;AAuBAN,OAAO,CAAC0F,wBAAR,GAAmCA,wBAAnC;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAMI,uBAAuB,GAAG,CAACnC,MAAD,EAASZ,WAAT,KAAyB;AACxD,QAAMC,OAAO,GAAGS,eAAe,CAACV,WAAD,CAA/B;AAEA,MAAI4C,MAAM,GAAG,CAAb;;AACA,MAAI3C,OAAO,CAAC4C,IAAR,GAAe,CAAnB,EAAsB;AACrB,SAAK,MAAM3E,KAAX,IAAoB0C,MAApB,EAA4B;AAC3B,UAAI1C,KAAK,CAACkC,EAAN,KAAa,IAAjB,EAAuB;AACtB,eAAOH,OAAO,CAACyB,GAAR,CAAYkB,MAAM,GAAG,EAArB,CAAP,EAAiCA,MAAM;;AACvC1E,QAAAA,KAAK,CAACkC,EAAN,GAAWwC,MAAX;AACA1E,QAAAA,KAAK,CAAC8E,GAAN,GAAY,CAACJ,MAAD,CAAZ;AACAA,QAAAA,MAAM;AACN;AACD;AACD,GATD,MASO;AACN,SAAK,MAAM1E,KAAX,IAAoB0C,MAApB,EAA4B;AAC3B,UAAI1C,KAAK,CAACkC,EAAN,KAAa,IAAjB,EAAuB;AACtBlC,QAAAA,KAAK,CAACkC,EAAN,GAAWwC,MAAX;AACA1E,QAAAA,KAAK,CAAC8E,GAAN,GAAY,CAACJ,MAAD,CAAZ;AACAA,QAAAA,MAAM;AACN;AACD;AACD;AACD,CAtBD;;AAuBA3F,OAAO,CAAC8F,uBAAR,GAAkCA,uBAAlC","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst createHash = require(\"../util/createHash\");\nconst { makePathsRelative } = require(\"../util/identifier\");\nconst numberHash = require(\"../util/numberHash\");\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n\n/**\n * @param {string} str string to hash\n * @param {number} len max length of the hash\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} hash\n */\nconst getHash = (str, len, hashFunction) => {\n\tconst hash = createHash(hashFunction);\n\thash.update(str);\n\tconst digest = /** @type {string} */ (hash.digest(\"hex\"));\n\treturn digest.substr(0, len);\n};\n\n/**\n * @param {string} str the string\n * @returns {string} string prefixed by an underscore if it is a number\n */\nconst avoidNumber = str => {\n\t// max length of a number is 21 chars, bigger numbers a written as \"...e+xx\"\n\tif (str.length > 21) return str;\n\tconst firstChar = str.charCodeAt(0);\n\t// skip everything that doesn't look like a number\n\t// charCodes: \"-\": 45, \"1\": 49, \"9\": 57\n\tif (firstChar < 49) {\n\t\tif (firstChar !== 45) return str;\n\t} else if (firstChar > 57) {\n\t\treturn str;\n\t}\n\tif (str === +str + \"\") {\n\t\treturn `_${str}`;\n\t}\n\treturn str;\n};\n\n/**\n * @param {string} request the request\n * @returns {string} id representation\n */\nconst requestToId = request => {\n\treturn request\n\t\t.replace(/^(\\.\\.?\\/)+/, \"\")\n\t\t.replace(/(^[.-]|[^a-zA-Z0-9_-])+/g, \"_\");\n};\nexports.requestToId = requestToId;\n\n/**\n * @param {string} string the string\n * @param {string} delimiter separator for string and hash\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} string with limited max length to 100 chars\n */\nconst shortenLongString = (string, delimiter, hashFunction) => {\n\tif (string.length < 100) return string;\n\treturn (\n\t\tstring.slice(0, 100 - 6 - delimiter.length) +\n\t\tdelimiter +\n\t\tgetHash(string, 6, hashFunction)\n\t);\n};\n\n/**\n * @param {Module} module the module\n * @param {string} context context directory\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} short module name\n */\nconst getShortModuleName = (module, context, associatedObjectForCache) => {\n\tconst libIdent = module.libIdent({ context, associatedObjectForCache });\n\tif (libIdent) return avoidNumber(libIdent);\n\tconst nameForCondition = module.nameForCondition();\n\tif (nameForCondition)\n\t\treturn avoidNumber(\n\t\t\tmakePathsRelative(context, nameForCondition, associatedObjectForCache)\n\t\t);\n\treturn \"\";\n};\nexports.getShortModuleName = getShortModuleName;\n\n/**\n * @param {string} shortName the short name\n * @param {Module} module the module\n * @param {string} context context directory\n * @param {string | Hash} hashFunction hash function to use\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} long module name\n */\nconst getLongModuleName = (\n\tshortName,\n\tmodule,\n\tcontext,\n\thashFunction,\n\tassociatedObjectForCache\n) => {\n\tconst fullName = getFullModuleName(module, context, associatedObjectForCache);\n\treturn `${shortName}?${getHash(fullName, 4, hashFunction)}`;\n};\nexports.getLongModuleName = getLongModuleName;\n\n/**\n * @param {Module} module the module\n * @param {string} context context directory\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} full module name\n */\nconst getFullModuleName = (module, context, associatedObjectForCache) => {\n\treturn makePathsRelative(\n\t\tcontext,\n\t\tmodule.identifier(),\n\t\tassociatedObjectForCache\n\t);\n};\nexports.getFullModuleName = getFullModuleName;\n\n/**\n * @param {Chunk} chunk the chunk\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {string} context context directory\n * @param {string} delimiter delimiter for names\n * @param {string | Hash} hashFunction hash function to use\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} short chunk name\n */\nconst getShortChunkName = (\n\tchunk,\n\tchunkGraph,\n\tcontext,\n\tdelimiter,\n\thashFunction,\n\tassociatedObjectForCache\n) => {\n\tconst modules = chunkGraph.getChunkRootModules(chunk);\n\tconst shortModuleNames = modules.map(m =>\n\t\trequestToId(getShortModuleName(m, context, associatedObjectForCache))\n\t);\n\tchunk.idNameHints.sort();\n\tconst chunkName = Array.from(chunk.idNameHints)\n\t\t.concat(shortModuleNames)\n\t\t.filter(Boolean)\n\t\t.join(delimiter);\n\treturn shortenLongString(chunkName, delimiter, hashFunction);\n};\nexports.getShortChunkName = getShortChunkName;\n\n/**\n * @param {Chunk} chunk the chunk\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {string} context context directory\n * @param {string} delimiter delimiter for names\n * @param {string | Hash} hashFunction hash function to use\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} short chunk name\n */\nconst getLongChunkName = (\n\tchunk,\n\tchunkGraph,\n\tcontext,\n\tdelimiter,\n\thashFunction,\n\tassociatedObjectForCache\n) => {\n\tconst modules = chunkGraph.getChunkRootModules(chunk);\n\tconst shortModuleNames = modules.map(m =>\n\t\trequestToId(getShortModuleName(m, context, associatedObjectForCache))\n\t);\n\tconst longModuleNames = modules.map(m =>\n\t\trequestToId(\n\t\t\tgetLongModuleName(\"\", m, context, hashFunction, associatedObjectForCache)\n\t\t)\n\t);\n\tchunk.idNameHints.sort();\n\tconst chunkName = Array.from(chunk.idNameHints)\n\t\t.concat(shortModuleNames, longModuleNames)\n\t\t.filter(Boolean)\n\t\t.join(delimiter);\n\treturn shortenLongString(chunkName, delimiter, hashFunction);\n};\nexports.getLongChunkName = getLongChunkName;\n\n/**\n * @param {Chunk} chunk the chunk\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {string} context context directory\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} full chunk name\n */\nconst getFullChunkName = (\n\tchunk,\n\tchunkGraph,\n\tcontext,\n\tassociatedObjectForCache\n) => {\n\tif (chunk.name) return chunk.name;\n\tconst modules = chunkGraph.getChunkRootModules(chunk);\n\tconst fullModuleNames = modules.map(m =>\n\t\tmakePathsRelative(context, m.identifier(), associatedObjectForCache)\n\t);\n\treturn fullModuleNames.join();\n};\nexports.getFullChunkName = getFullChunkName;\n\n/**\n * @template K\n * @template V\n * @param {Map<K, V[]>} map a map from key to values\n * @param {K} key key\n * @param {V} value value\n * @returns {void}\n */\nconst addToMapOfItems = (map, key, value) => {\n\tlet array = map.get(key);\n\tif (array === undefined) {\n\t\tarray = [];\n\t\tmap.set(key, array);\n\t}\n\tarray.push(value);\n};\n\n/**\n * @param {Compilation} compilation the compilation\n * @param {function(Module): boolean=} filter filter modules\n * @returns {[Set<string>, Module[]]} used module ids as strings and modules without id matching the filter\n */\nconst getUsedModuleIdsAndModules = (compilation, filter) => {\n\tconst chunkGraph = compilation.chunkGraph;\n\n\tconst modules = [];\n\n\t/** @type {Set<string>} */\n\tconst usedIds = new Set();\n\tif (compilation.usedModuleIds) {\n\t\tfor (const id of compilation.usedModuleIds) {\n\t\t\tusedIds.add(id + \"\");\n\t\t}\n\t}\n\n\tfor (const module of compilation.modules) {\n\t\tif (!module.needId) continue;\n\t\tconst moduleId = chunkGraph.getModuleId(module);\n\t\tif (moduleId !== null) {\n\t\t\tusedIds.add(moduleId + \"\");\n\t\t} else {\n\t\t\tif (\n\t\t\t\t(!filter || filter(module)) &&\n\t\t\t\tchunkGraph.getNumberOfModuleChunks(module) !== 0\n\t\t\t) {\n\t\t\t\tmodules.push(module);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [usedIds, modules];\n};\nexports.getUsedModuleIdsAndModules = getUsedModuleIdsAndModules;\n\n/**\n * @param {Compilation} compilation the compilation\n * @returns {Set<string>} used chunk ids as strings\n */\nconst getUsedChunkIds = compilation => {\n\t/** @type {Set<string>} */\n\tconst usedIds = new Set();\n\tif (compilation.usedChunkIds) {\n\t\tfor (const id of compilation.usedChunkIds) {\n\t\t\tusedIds.add(id + \"\");\n\t\t}\n\t}\n\n\tfor (const chunk of compilation.chunks) {\n\t\tconst chunkId = chunk.id;\n\t\tif (chunkId !== null) {\n\t\t\tusedIds.add(chunkId + \"\");\n\t\t}\n\t}\n\n\treturn usedIds;\n};\nexports.getUsedChunkIds = getUsedChunkIds;\n\n/**\n * @template T\n * @param {Iterable<T>} items list of items to be named\n * @param {function(T): string} getShortName get a short name for an item\n * @param {function(T, string): string} getLongName get a long name for an item\n * @param {function(T, T): -1|0|1} comparator order of items\n * @param {Set<string>} usedIds already used ids, will not be assigned\n * @param {function(T, string): void} assignName assign a name to an item\n * @returns {T[]} list of items without a name\n */\nconst assignNames = (\n\titems,\n\tgetShortName,\n\tgetLongName,\n\tcomparator,\n\tusedIds,\n\tassignName\n) => {\n\t/** @type {Map<string, T[]>} */\n\tconst nameToItems = new Map();\n\n\tfor (const item of items) {\n\t\tconst name = getShortName(item);\n\t\taddToMapOfItems(nameToItems, name, item);\n\t}\n\n\t/** @type {Map<string, T[]>} */\n\tconst nameToItems2 = new Map();\n\n\tfor (const [name, items] of nameToItems) {\n\t\tif (items.length > 1 || !name) {\n\t\t\tfor (const item of items) {\n\t\t\t\tconst longName = getLongName(item, name);\n\t\t\t\taddToMapOfItems(nameToItems2, longName, item);\n\t\t\t}\n\t\t} else {\n\t\t\taddToMapOfItems(nameToItems2, name, items[0]);\n\t\t}\n\t}\n\n\t/** @type {T[]} */\n\tconst unnamedItems = [];\n\n\tfor (const [name, items] of nameToItems2) {\n\t\tif (!name) {\n\t\t\tfor (const item of items) {\n\t\t\t\tunnamedItems.push(item);\n\t\t\t}\n\t\t} else if (items.length === 1 && !usedIds.has(name)) {\n\t\t\tassignName(items[0], name);\n\t\t\tusedIds.add(name);\n\t\t} else {\n\t\t\titems.sort(comparator);\n\t\t\tlet i = 0;\n\t\t\tfor (const item of items) {\n\t\t\t\twhile (nameToItems2.has(name + i) && usedIds.has(name + i)) i++;\n\t\t\t\tassignName(item, name + i);\n\t\t\t\tusedIds.add(name + i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tunnamedItems.sort(comparator);\n\treturn unnamedItems;\n};\nexports.assignNames = assignNames;\n\n/**\n * @template T\n * @param {T[]} items list of items to be named\n * @param {function(T): string} getName get a name for an item\n * @param {function(T, T): -1|0|1} comparator order of items\n * @param {function(T, number): boolean} assignId assign an id to an item\n * @param {number[]} ranges usable ranges for ids\n * @param {number} expandFactor factor to create more ranges\n * @param {number} extraSpace extra space to allocate, i. e. when some ids are already used\n * @param {number} salt salting number to initialize hashing\n * @returns {void}\n */\nconst assignDeterministicIds = (\n\titems,\n\tgetName,\n\tcomparator,\n\tassignId,\n\tranges = [10],\n\texpandFactor = 10,\n\textraSpace = 0,\n\tsalt = 0\n) => {\n\titems.sort(comparator);\n\n\t// max 5% fill rate\n\tconst optimalRange = Math.min(\n\t\tMath.ceil(items.length * 20) + extraSpace,\n\t\tNumber.MAX_SAFE_INTEGER\n\t);\n\n\tlet i = 0;\n\tlet range = ranges[i];\n\twhile (range < optimalRange) {\n\t\ti++;\n\t\tif (i < ranges.length) {\n\t\t\trange = Math.min(ranges[i], Number.MAX_SAFE_INTEGER);\n\t\t} else if (expandFactor) {\n\t\t\trange = Math.min(range * expandFactor, Number.MAX_SAFE_INTEGER);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (const item of items) {\n\t\tconst ident = getName(item);\n\t\tlet id;\n\t\tlet i = salt;\n\t\tdo {\n\t\t\tid = numberHash(ident + i++, range);\n\t\t} while (!assignId(item, id));\n\t}\n};\nexports.assignDeterministicIds = assignDeterministicIds;\n\n/**\n * @param {Set<string>} usedIds used ids\n * @param {Iterable<Module>} modules the modules\n * @param {Compilation} compilation the compilation\n * @returns {void}\n */\nconst assignAscendingModuleIds = (usedIds, modules, compilation) => {\n\tconst chunkGraph = compilation.chunkGraph;\n\n\tlet nextId = 0;\n\tlet assignId;\n\tif (usedIds.size > 0) {\n\t\tassignId = module => {\n\t\t\tif (chunkGraph.getModuleId(module) === null) {\n\t\t\t\twhile (usedIds.has(nextId + \"\")) nextId++;\n\t\t\t\tchunkGraph.setModuleId(module, nextId++);\n\t\t\t}\n\t\t};\n\t} else {\n\t\tassignId = module => {\n\t\t\tif (chunkGraph.getModuleId(module) === null) {\n\t\t\t\tchunkGraph.setModuleId(module, nextId++);\n\t\t\t}\n\t\t};\n\t}\n\tfor (const module of modules) {\n\t\tassignId(module);\n\t}\n};\nexports.assignAscendingModuleIds = assignAscendingModuleIds;\n\n/**\n * @param {Iterable<Chunk>} chunks the chunks\n * @param {Compilation} compilation the compilation\n * @returns {void}\n */\nconst assignAscendingChunkIds = (chunks, compilation) => {\n\tconst usedIds = getUsedChunkIds(compilation);\n\n\tlet nextId = 0;\n\tif (usedIds.size > 0) {\n\t\tfor (const chunk of chunks) {\n\t\t\tif (chunk.id === null) {\n\t\t\t\twhile (usedIds.has(nextId + \"\")) nextId++;\n\t\t\t\tchunk.id = nextId;\n\t\t\t\tchunk.ids = [nextId];\n\t\t\t\tnextId++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (const chunk of chunks) {\n\t\t\tif (chunk.id === null) {\n\t\t\t\tchunk.id = nextId;\n\t\t\t\tchunk.ids = [nextId];\n\t\t\t\tnextId++;\n\t\t\t}\n\t\t}\n\t}\n};\nexports.assignAscendingChunkIds = assignAscendingChunkIds;\n"]},"metadata":{},"sourceType":"script"}