{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  compareModulesByIdentifier\n} = require(\"../util/comparators\");\n\nconst {\n  getShortModuleName,\n  getLongModuleName,\n  assignNames,\n  getUsedModuleIdsAndModules,\n  assignAscendingModuleIds\n} = require(\"./IdHelpers\");\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Module\")} Module */\n\n\nclass NamedModuleIdsPlugin {\n  constructor(options) {\n    this.options = options || {};\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const {\n      root\n    } = compiler;\n    compiler.hooks.compilation.tap(\"NamedModuleIdsPlugin\", compilation => {\n      const {\n        hashFunction\n      } = compilation.outputOptions;\n      compilation.hooks.moduleIds.tap(\"NamedModuleIdsPlugin\", () => {\n        const chunkGraph = compilation.chunkGraph;\n        const context = this.options.context ? this.options.context : compiler.context;\n        const [usedIds, modules] = getUsedModuleIdsAndModules(compilation);\n        const unnamedModules = assignNames(modules, m => getShortModuleName(m, context, root), (m, shortName) => getLongModuleName(shortName, m, context, hashFunction, root), compareModulesByIdentifier, usedIds, (m, name) => chunkGraph.setModuleId(m, name));\n\n        if (unnamedModules.length > 0) {\n          assignAscendingModuleIds(usedIds, unnamedModules, compilation);\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = NamedModuleIdsPlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/ids/NamedModuleIdsPlugin.js"],"names":["compareModulesByIdentifier","require","getShortModuleName","getLongModuleName","assignNames","getUsedModuleIdsAndModules","assignAscendingModuleIds","NamedModuleIdsPlugin","constructor","options","apply","compiler","root","hooks","compilation","tap","hashFunction","outputOptions","moduleIds","chunkGraph","context","usedIds","modules","unnamedModules","m","shortName","name","setModuleId","length","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAiCC,OAAO,CAAC,qBAAD,CAA9C;;AACA,MAAM;AACLC,EAAAA,kBADK;AAELC,EAAAA,iBAFK;AAGLC,EAAAA,WAHK;AAILC,EAAAA,0BAJK;AAKLC,EAAAA;AALK,IAMFL,OAAO,CAAC,aAAD,CANX;AAQA;;AACA;;;AAEA,MAAMM,oBAAN,CAA2B;AAC1BC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACpB,SAAKA,OAAL,GAAeA,OAAO,IAAI,EAA1B;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCC,EAAAA,KAAK,CAACC,QAAD,EAAW;AACf,UAAM;AAAEC,MAAAA;AAAF,QAAWD,QAAjB;AACAA,IAAAA,QAAQ,CAACE,KAAT,CAAeC,WAAf,CAA2BC,GAA3B,CAA+B,sBAA/B,EAAuDD,WAAW,IAAI;AACrE,YAAM;AAAEE,QAAAA;AAAF,UAAmBF,WAAW,CAACG,aAArC;AACAH,MAAAA,WAAW,CAACD,KAAZ,CAAkBK,SAAlB,CAA4BH,GAA5B,CAAgC,sBAAhC,EAAwD,MAAM;AAC7D,cAAMI,UAAU,GAAGL,WAAW,CAACK,UAA/B;AACA,cAAMC,OAAO,GAAG,KAAKX,OAAL,CAAaW,OAAb,GACb,KAAKX,OAAL,CAAaW,OADA,GAEbT,QAAQ,CAACS,OAFZ;AAIA,cAAM,CAACC,OAAD,EAAUC,OAAV,IAAqBjB,0BAA0B,CAACS,WAAD,CAArD;AACA,cAAMS,cAAc,GAAGnB,WAAW,CACjCkB,OADiC,EAEjCE,CAAC,IAAItB,kBAAkB,CAACsB,CAAD,EAAIJ,OAAJ,EAAaR,IAAb,CAFU,EAGjC,CAACY,CAAD,EAAIC,SAAJ,KACCtB,iBAAiB,CAACsB,SAAD,EAAYD,CAAZ,EAAeJ,OAAf,EAAwBJ,YAAxB,EAAsCJ,IAAtC,CAJe,EAKjCZ,0BALiC,EAMjCqB,OANiC,EAOjC,CAACG,CAAD,EAAIE,IAAJ,KAAaP,UAAU,CAACQ,WAAX,CAAuBH,CAAvB,EAA0BE,IAA1B,CAPoB,CAAlC;;AASA,YAAIH,cAAc,CAACK,MAAf,GAAwB,CAA5B,EAA+B;AAC9BtB,UAAAA,wBAAwB,CAACe,OAAD,EAAUE,cAAV,EAA0BT,WAA1B,CAAxB;AACA;AACD,OAnBD;AAoBA,KAtBD;AAuBA;;AAnCyB;;AAsC3Be,MAAM,CAACC,OAAP,GAAiBvB,oBAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { compareModulesByIdentifier } = require(\"../util/comparators\");\nconst {\n\tgetShortModuleName,\n\tgetLongModuleName,\n\tassignNames,\n\tgetUsedModuleIdsAndModules,\n\tassignAscendingModuleIds\n} = require(\"./IdHelpers\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\nclass NamedModuleIdsPlugin {\n\tconstructor(options) {\n\t\tthis.options = options || {};\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst { root } = compiler;\n\t\tcompiler.hooks.compilation.tap(\"NamedModuleIdsPlugin\", compilation => {\n\t\t\tconst { hashFunction } = compilation.outputOptions;\n\t\t\tcompilation.hooks.moduleIds.tap(\"NamedModuleIdsPlugin\", () => {\n\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\tconst context = this.options.context\n\t\t\t\t\t? this.options.context\n\t\t\t\t\t: compiler.context;\n\n\t\t\t\tconst [usedIds, modules] = getUsedModuleIdsAndModules(compilation);\n\t\t\t\tconst unnamedModules = assignNames(\n\t\t\t\t\tmodules,\n\t\t\t\t\tm => getShortModuleName(m, context, root),\n\t\t\t\t\t(m, shortName) =>\n\t\t\t\t\t\tgetLongModuleName(shortName, m, context, hashFunction, root),\n\t\t\t\t\tcompareModulesByIdentifier,\n\t\t\t\t\tusedIds,\n\t\t\t\t\t(m, name) => chunkGraph.setModuleId(m, name)\n\t\t\t\t);\n\t\t\t\tif (unnamedModules.length > 0) {\n\t\t\t\t\tassignAscendingModuleIds(usedIds, unnamedModules, compilation);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n\nmodule.exports = NamedModuleIdsPlugin;\n"]},"metadata":{},"sourceType":"script"}