{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  first\n} = require(\"./SetHelpers\");\n\nconst SortableSet = require(\"./SortableSet\");\n/**\n * Multi layer bucket sorted set:\n * Supports adding non-existing items (DO NOT ADD ITEM TWICE),\n * Supports removing exiting items (DO NOT REMOVE ITEM NOT IN SET),\n * Supports popping the first items according to defined order,\n * Supports iterating all items without order,\n * Supports updating an item in an efficient way,\n * Supports size property, which is the number of items,\n * Items are lazy partially sorted when needed\n * @template T\n * @template K\n */\n\n\nclass LazyBucketSortedSet {\n  /**\n   * @param {function(T): K} getKey function to get key from item\n   * @param {function(K, K): number} comparator comparator to sort keys\n   * @param  {...((function(T): any) | (function(any, any): number))} args more pairs of getKey and comparator plus optional final comparator for the last layer\n   */\n  constructor(getKey, comparator) {\n    this._getKey = getKey;\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    this._innerArgs = args;\n    this._leaf = args.length <= 1;\n    this._keys = new SortableSet(undefined, comparator);\n    /** @type {Map<K, LazyBucketSortedSet<T, any> | SortableSet<T>>} */\n\n    this._map = new Map();\n    this._unsortedItems = new Set();\n    this.size = 0;\n  }\n  /**\n   * @param {T} item an item\n   * @returns {void}\n   */\n\n\n  add(item) {\n    this.size++;\n\n    this._unsortedItems.add(item);\n  }\n  /**\n   * @param {K} key key of item\n   * @param {T} item the item\n   * @returns {void}\n   */\n\n\n  _addInternal(key, item) {\n    let entry = this._map.get(key);\n\n    if (entry === undefined) {\n      entry = this._leaf ? new SortableSet(undefined, this._innerArgs[0]) : new\n      /** @type {any} */\n      LazyBucketSortedSet(...this._innerArgs);\n\n      this._keys.add(key);\n\n      this._map.set(key, entry);\n    }\n\n    entry.add(item);\n  }\n  /**\n   * @param {T} item an item\n   * @returns {void}\n   */\n\n\n  delete(item) {\n    this.size--;\n\n    if (this._unsortedItems.has(item)) {\n      this._unsortedItems.delete(item);\n\n      return;\n    }\n\n    const key = this._getKey(item);\n\n    const entry = this._map.get(key);\n\n    entry.delete(item);\n\n    if (entry.size === 0) {\n      this._deleteKey(key);\n    }\n  }\n  /**\n   * @param {K} key key to be removed\n   * @returns {void}\n   */\n\n\n  _deleteKey(key) {\n    this._keys.delete(key);\n\n    this._map.delete(key);\n  }\n  /**\n   * @returns {T | undefined} an item\n   */\n\n\n  popFirst() {\n    if (this.size === 0) return undefined;\n    this.size--;\n\n    if (this._unsortedItems.size > 0) {\n      for (const item of this._unsortedItems) {\n        const key = this._getKey(item);\n\n        this._addInternal(key, item);\n      }\n\n      this._unsortedItems.clear();\n    }\n\n    this._keys.sort();\n\n    const key = first(this._keys);\n\n    const entry = this._map.get(key);\n\n    if (this._leaf) {\n      const leafEntry =\n      /** @type {SortableSet<T>} */\n      entry;\n      leafEntry.sort();\n      const item = first(leafEntry);\n      leafEntry.delete(item);\n\n      if (leafEntry.size === 0) {\n        this._deleteKey(key);\n      }\n\n      return item;\n    } else {\n      const nodeEntry =\n      /** @type {LazyBucketSortedSet<T, any>} */\n      entry;\n      const item = nodeEntry.popFirst();\n\n      if (nodeEntry.size === 0) {\n        this._deleteKey(key);\n      }\n\n      return item;\n    }\n  }\n  /**\n   * @param {T} item to be updated item\n   * @returns {function(true=): void} finish update\n   */\n\n\n  startUpdate(item) {\n    if (this._unsortedItems.has(item)) {\n      return remove => {\n        if (remove) {\n          this._unsortedItems.delete(item);\n\n          this.size--;\n          return;\n        }\n      };\n    }\n\n    const key = this._getKey(item);\n\n    if (this._leaf) {\n      const oldEntry =\n      /** @type {SortableSet<T>} */\n      this._map.get(key);\n\n      return remove => {\n        if (remove) {\n          this.size--;\n          oldEntry.delete(item);\n\n          if (oldEntry.size === 0) {\n            this._deleteKey(key);\n          }\n\n          return;\n        }\n\n        const newKey = this._getKey(item);\n\n        if (key === newKey) {\n          // This flags the sortable set as unordered\n          oldEntry.add(item);\n        } else {\n          oldEntry.delete(item);\n\n          if (oldEntry.size === 0) {\n            this._deleteKey(key);\n          }\n\n          this._addInternal(newKey, item);\n        }\n      };\n    } else {\n      const oldEntry =\n      /** @type {LazyBucketSortedSet<T, any>} */\n      this._map.get(key);\n\n      const finishUpdate = oldEntry.startUpdate(item);\n      return remove => {\n        if (remove) {\n          this.size--;\n          finishUpdate(true);\n\n          if (oldEntry.size === 0) {\n            this._deleteKey(key);\n          }\n\n          return;\n        }\n\n        const newKey = this._getKey(item);\n\n        if (key === newKey) {\n          finishUpdate();\n        } else {\n          finishUpdate(true);\n\n          if (oldEntry.size === 0) {\n            this._deleteKey(key);\n          }\n\n          this._addInternal(newKey, item);\n        }\n      };\n    }\n  }\n  /**\n   * @param {Iterator<T>[]} iterators list of iterators to append to\n   * @returns {void}\n   */\n\n\n  _appendIterators(iterators) {\n    if (this._unsortedItems.size > 0) iterators.push(this._unsortedItems[Symbol.iterator]());\n\n    for (const key of this._keys) {\n      const entry = this._map.get(key);\n\n      if (this._leaf) {\n        const leafEntry =\n        /** @type {SortableSet<T>} */\n        entry;\n        const iterator = leafEntry[Symbol.iterator]();\n        iterators.push(iterator);\n      } else {\n        const nodeEntry =\n        /** @type {LazyBucketSortedSet<T, any>} */\n        entry;\n\n        nodeEntry._appendIterators(iterators);\n      }\n    }\n  }\n  /**\n   * @returns {Iterator<T>} the iterator\n   */\n\n\n  [Symbol.iterator]() {\n    const iterators = [];\n\n    this._appendIterators(iterators);\n\n    iterators.reverse();\n    let currentIterator = iterators.pop();\n    return {\n      next: () => {\n        const res = currentIterator.next();\n\n        if (res.done) {\n          if (iterators.length === 0) return res;\n          currentIterator = iterators.pop();\n          return currentIterator.next();\n        }\n\n        return res;\n      }\n    };\n  }\n\n}\n\nmodule.exports = LazyBucketSortedSet;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/util/LazyBucketSortedSet.js"],"names":["first","require","SortableSet","LazyBucketSortedSet","constructor","getKey","comparator","_getKey","args","_innerArgs","_leaf","length","_keys","undefined","_map","Map","_unsortedItems","Set","size","add","item","_addInternal","key","entry","get","set","delete","has","_deleteKey","popFirst","clear","sort","leafEntry","nodeEntry","startUpdate","remove","oldEntry","newKey","finishUpdate","_appendIterators","iterators","push","Symbol","iterator","reverse","currentIterator","pop","next","res","done","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { first } = require(\"./SetHelpers\");\nconst SortableSet = require(\"./SortableSet\");\n\n/**\n * Multi layer bucket sorted set:\n * Supports adding non-existing items (DO NOT ADD ITEM TWICE),\n * Supports removing exiting items (DO NOT REMOVE ITEM NOT IN SET),\n * Supports popping the first items according to defined order,\n * Supports iterating all items without order,\n * Supports updating an item in an efficient way,\n * Supports size property, which is the number of items,\n * Items are lazy partially sorted when needed\n * @template T\n * @template K\n */\nclass LazyBucketSortedSet {\n\t/**\n\t * @param {function(T): K} getKey function to get key from item\n\t * @param {function(K, K): number} comparator comparator to sort keys\n\t * @param  {...((function(T): any) | (function(any, any): number))} args more pairs of getKey and comparator plus optional final comparator for the last layer\n\t */\n\tconstructor(getKey, comparator, ...args) {\n\t\tthis._getKey = getKey;\n\t\tthis._innerArgs = args;\n\t\tthis._leaf = args.length <= 1;\n\t\tthis._keys = new SortableSet(undefined, comparator);\n\t\t/** @type {Map<K, LazyBucketSortedSet<T, any> | SortableSet<T>>} */\n\t\tthis._map = new Map();\n\t\tthis._unsortedItems = new Set();\n\t\tthis.size = 0;\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {void}\n\t */\n\tadd(item) {\n\t\tthis.size++;\n\t\tthis._unsortedItems.add(item);\n\t}\n\n\t/**\n\t * @param {K} key key of item\n\t * @param {T} item the item\n\t * @returns {void}\n\t */\n\t_addInternal(key, item) {\n\t\tlet entry = this._map.get(key);\n\t\tif (entry === undefined) {\n\t\t\tentry = this._leaf\n\t\t\t\t? new SortableSet(undefined, this._innerArgs[0])\n\t\t\t\t: new /** @type {any} */ (LazyBucketSortedSet)(...this._innerArgs);\n\t\t\tthis._keys.add(key);\n\t\t\tthis._map.set(key, entry);\n\t\t}\n\t\tentry.add(item);\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {void}\n\t */\n\tdelete(item) {\n\t\tthis.size--;\n\t\tif (this._unsortedItems.has(item)) {\n\t\t\tthis._unsortedItems.delete(item);\n\t\t\treturn;\n\t\t}\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._map.get(key);\n\t\tentry.delete(item);\n\t\tif (entry.size === 0) {\n\t\t\tthis._deleteKey(key);\n\t\t}\n\t}\n\n\t/**\n\t * @param {K} key key to be removed\n\t * @returns {void}\n\t */\n\t_deleteKey(key) {\n\t\tthis._keys.delete(key);\n\t\tthis._map.delete(key);\n\t}\n\n\t/**\n\t * @returns {T | undefined} an item\n\t */\n\tpopFirst() {\n\t\tif (this.size === 0) return undefined;\n\t\tthis.size--;\n\t\tif (this._unsortedItems.size > 0) {\n\t\t\tfor (const item of this._unsortedItems) {\n\t\t\t\tconst key = this._getKey(item);\n\t\t\t\tthis._addInternal(key, item);\n\t\t\t}\n\t\t\tthis._unsortedItems.clear();\n\t\t}\n\t\tthis._keys.sort();\n\t\tconst key = first(this._keys);\n\t\tconst entry = this._map.get(key);\n\t\tif (this._leaf) {\n\t\t\tconst leafEntry = /** @type {SortableSet<T>} */ (entry);\n\t\t\tleafEntry.sort();\n\t\t\tconst item = first(leafEntry);\n\t\t\tleafEntry.delete(item);\n\t\t\tif (leafEntry.size === 0) {\n\t\t\t\tthis._deleteKey(key);\n\t\t\t}\n\t\t\treturn item;\n\t\t} else {\n\t\t\tconst nodeEntry = /** @type {LazyBucketSortedSet<T, any>} */ (entry);\n\t\t\tconst item = nodeEntry.popFirst();\n\t\t\tif (nodeEntry.size === 0) {\n\t\t\t\tthis._deleteKey(key);\n\t\t\t}\n\t\t\treturn item;\n\t\t}\n\t}\n\n\t/**\n\t * @param {T} item to be updated item\n\t * @returns {function(true=): void} finish update\n\t */\n\tstartUpdate(item) {\n\t\tif (this._unsortedItems.has(item)) {\n\t\t\treturn remove => {\n\t\t\t\tif (remove) {\n\t\t\t\t\tthis._unsortedItems.delete(item);\n\t\t\t\t\tthis.size--;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tconst key = this._getKey(item);\n\t\tif (this._leaf) {\n\t\t\tconst oldEntry = /** @type {SortableSet<T>} */ (this._map.get(key));\n\t\t\treturn remove => {\n\t\t\t\tif (remove) {\n\t\t\t\t\tthis.size--;\n\t\t\t\t\toldEntry.delete(item);\n\t\t\t\t\tif (oldEntry.size === 0) {\n\t\t\t\t\t\tthis._deleteKey(key);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst newKey = this._getKey(item);\n\t\t\t\tif (key === newKey) {\n\t\t\t\t\t// This flags the sortable set as unordered\n\t\t\t\t\toldEntry.add(item);\n\t\t\t\t} else {\n\t\t\t\t\toldEntry.delete(item);\n\t\t\t\t\tif (oldEntry.size === 0) {\n\t\t\t\t\t\tthis._deleteKey(key);\n\t\t\t\t\t}\n\t\t\t\t\tthis._addInternal(newKey, item);\n\t\t\t\t}\n\t\t\t};\n\t\t} else {\n\t\t\tconst oldEntry = /** @type {LazyBucketSortedSet<T, any>} */ (\n\t\t\t\tthis._map.get(key)\n\t\t\t);\n\t\t\tconst finishUpdate = oldEntry.startUpdate(item);\n\t\t\treturn remove => {\n\t\t\t\tif (remove) {\n\t\t\t\t\tthis.size--;\n\t\t\t\t\tfinishUpdate(true);\n\t\t\t\t\tif (oldEntry.size === 0) {\n\t\t\t\t\t\tthis._deleteKey(key);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst newKey = this._getKey(item);\n\t\t\t\tif (key === newKey) {\n\t\t\t\t\tfinishUpdate();\n\t\t\t\t} else {\n\t\t\t\t\tfinishUpdate(true);\n\t\t\t\t\tif (oldEntry.size === 0) {\n\t\t\t\t\t\tthis._deleteKey(key);\n\t\t\t\t\t}\n\t\t\t\t\tthis._addInternal(newKey, item);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * @param {Iterator<T>[]} iterators list of iterators to append to\n\t * @returns {void}\n\t */\n\t_appendIterators(iterators) {\n\t\tif (this._unsortedItems.size > 0)\n\t\t\titerators.push(this._unsortedItems[Symbol.iterator]());\n\t\tfor (const key of this._keys) {\n\t\t\tconst entry = this._map.get(key);\n\t\t\tif (this._leaf) {\n\t\t\t\tconst leafEntry = /** @type {SortableSet<T>} */ (entry);\n\t\t\t\tconst iterator = leafEntry[Symbol.iterator]();\n\t\t\t\titerators.push(iterator);\n\t\t\t} else {\n\t\t\t\tconst nodeEntry = /** @type {LazyBucketSortedSet<T, any>} */ (entry);\n\t\t\t\tnodeEntry._appendIterators(iterators);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @returns {Iterator<T>} the iterator\n\t */\n\t[Symbol.iterator]() {\n\t\tconst iterators = [];\n\t\tthis._appendIterators(iterators);\n\t\titerators.reverse();\n\t\tlet currentIterator = iterators.pop();\n\t\treturn {\n\t\t\tnext: () => {\n\t\t\t\tconst res = currentIterator.next();\n\t\t\t\tif (res.done) {\n\t\t\t\t\tif (iterators.length === 0) return res;\n\t\t\t\t\tcurrentIterator = iterators.pop();\n\t\t\t\t\treturn currentIterator.next();\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t}\n\t\t};\n\t}\n}\n\nmodule.exports = LazyBucketSortedSet;\n"]},"metadata":{},"sourceType":"script"}