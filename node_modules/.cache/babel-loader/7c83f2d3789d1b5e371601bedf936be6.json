{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/**\n * @typedef {Object} GroupOptions\n * @property {boolean=} groupChildren\n * @property {boolean=} force\n * @property {number=} targetGroupCount\n */\n\n/**\n * @template T\n * @template R\n * @typedef {Object} GroupConfig\n * @property {function(T): string[]} getKeys\n * @property {function(string, (R | T)[], T[]): R} createGroup\n * @property {function(string, T[]): GroupOptions=} getOptions\n */\n\n/**\n * @template T\n * @template R\n * @typedef {Object} ItemWithGroups\n * @property {T} item\n * @property {Set<Group<T, R>>} groups\n */\n\n/**\n * @template T\n * @template R\n * @typedef {{ config: GroupConfig<T, R>, name: string, alreadyGrouped: boolean, items: Set<ItemWithGroups<T, R>> | undefined }} Group\n */\n\n/**\n * @template T\n * @template R\n * @param {T[]} items the list of items\n * @param {GroupConfig<T, R>[]} groupConfigs configuration\n * @returns {(R | T)[]} grouped items\n */\n\nconst smartGrouping = (items, groupConfigs) => {\n  /** @type {Set<ItemWithGroups<T, R>>} */\n  const itemsWithGroups = new Set();\n  /** @type {Map<string, Group<T, R>>} */\n\n  const allGroups = new Map();\n\n  for (const item of items) {\n    /** @type {Set<Group<T, R>>} */\n    const groups = new Set();\n\n    for (let i = 0; i < groupConfigs.length; i++) {\n      const groupConfig = groupConfigs[i];\n      const keys = groupConfig.getKeys(item);\n\n      if (keys) {\n        for (const name of keys) {\n          const key = `${i}:${name}`;\n          let group = allGroups.get(key);\n\n          if (group === undefined) {\n            allGroups.set(key, group = {\n              config: groupConfig,\n              name,\n              alreadyGrouped: false,\n              items: undefined\n            });\n          }\n\n          groups.add(group);\n        }\n      }\n    }\n\n    itemsWithGroups.add({\n      item,\n      groups\n    });\n  }\n  /**\n   * @param {Set<ItemWithGroups<T, R>>} itemsWithGroups input items with groups\n   * @returns {(T | R)[]} groups items\n   */\n\n\n  const runGrouping = itemsWithGroups => {\n    const totalSize = itemsWithGroups.size;\n\n    for (const entry of itemsWithGroups) {\n      for (const group of entry.groups) {\n        if (group.alreadyGrouped) continue;\n        const items = group.items;\n\n        if (items === undefined) {\n          group.items = new Set([entry]);\n        } else {\n          items.add(entry);\n        }\n      }\n    }\n    /** @type {Map<Group<T, R>, { items: Set<ItemWithGroups<T, R>>, options: GroupOptions | false | undefined, used: boolean }>} */\n\n\n    const groupMap = new Map();\n\n    for (const group of allGroups.values()) {\n      if (group.items) {\n        const items = group.items;\n        group.items = undefined;\n        groupMap.set(group, {\n          items,\n          options: undefined,\n          used: false\n        });\n      }\n    }\n    /** @type {(T | R)[]} */\n\n\n    const results = [];\n\n    for (;;) {\n      /** @type {Group<T, R>} */\n      let bestGroup = undefined;\n      let bestGroupSize = -1;\n      let bestGroupItems = undefined;\n      let bestGroupOptions = undefined;\n\n      for (const [group, state] of groupMap) {\n        const {\n          items,\n          used\n        } = state;\n        let options = state.options;\n\n        if (options === undefined) {\n          const groupConfig = group.config;\n          state.options = options = groupConfig.getOptions && groupConfig.getOptions(group.name, Array.from(items, _ref => {\n            let {\n              item\n            } = _ref;\n            return item;\n          })) || false;\n        }\n\n        const force = options && options.force;\n\n        if (!force) {\n          if (bestGroupOptions && bestGroupOptions.force) continue;\n          if (used) continue;\n\n          if (items.size <= 1 || totalSize - items.size <= 1) {\n            continue;\n          }\n        }\n\n        const targetGroupCount = options && options.targetGroupCount || 4;\n        let sizeValue = force ? items.size : Math.min(items.size, totalSize * 2 / targetGroupCount + itemsWithGroups.size - items.size);\n\n        if (sizeValue > bestGroupSize || force && (!bestGroupOptions || !bestGroupOptions.force)) {\n          bestGroup = group;\n          bestGroupSize = sizeValue;\n          bestGroupItems = items;\n          bestGroupOptions = options;\n        }\n      }\n\n      if (bestGroup === undefined) {\n        break;\n      }\n\n      const items = new Set(bestGroupItems);\n      const options = bestGroupOptions;\n      const groupChildren = !options || options.groupChildren !== false;\n\n      for (const item of items) {\n        itemsWithGroups.delete(item); // Remove all groups that items have from the map to not select them again\n\n        for (const group of item.groups) {\n          const state = groupMap.get(group);\n\n          if (state !== undefined) {\n            state.items.delete(item);\n\n            if (state.items.size === 0) {\n              groupMap.delete(group);\n            } else {\n              state.options = undefined;\n\n              if (groupChildren) {\n                state.used = true;\n              }\n            }\n          }\n        }\n      }\n\n      groupMap.delete(bestGroup);\n      const key = bestGroup.name;\n      const groupConfig = bestGroup.config;\n      const allItems = Array.from(items, _ref2 => {\n        let {\n          item\n        } = _ref2;\n        return item;\n      });\n      bestGroup.alreadyGrouped = true;\n      const children = groupChildren ? runGrouping(items) : allItems;\n      bestGroup.alreadyGrouped = false;\n      results.push(groupConfig.createGroup(key, children, allItems));\n    }\n\n    for (const {\n      item\n    } of itemsWithGroups) {\n      results.push(item);\n    }\n\n    return results;\n  };\n\n  return runGrouping(itemsWithGroups);\n};\n\nmodule.exports = smartGrouping;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/util/smartGrouping.js"],"names":["smartGrouping","items","groupConfigs","itemsWithGroups","Set","allGroups","Map","item","groups","i","length","groupConfig","keys","getKeys","name","key","group","get","undefined","set","config","alreadyGrouped","add","runGrouping","totalSize","size","entry","groupMap","values","options","used","results","bestGroup","bestGroupSize","bestGroupItems","bestGroupOptions","state","getOptions","Array","from","force","targetGroupCount","sizeValue","Math","min","groupChildren","delete","allItems","children","push","createGroup","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/**\n * @typedef {Object} GroupOptions\n * @property {boolean=} groupChildren\n * @property {boolean=} force\n * @property {number=} targetGroupCount\n */\n\n/**\n * @template T\n * @template R\n * @typedef {Object} GroupConfig\n * @property {function(T): string[]} getKeys\n * @property {function(string, (R | T)[], T[]): R} createGroup\n * @property {function(string, T[]): GroupOptions=} getOptions\n */\n\n/**\n * @template T\n * @template R\n * @typedef {Object} ItemWithGroups\n * @property {T} item\n * @property {Set<Group<T, R>>} groups\n */\n\n/**\n * @template T\n * @template R\n * @typedef {{ config: GroupConfig<T, R>, name: string, alreadyGrouped: boolean, items: Set<ItemWithGroups<T, R>> | undefined }} Group\n */\n\n/**\n * @template T\n * @template R\n * @param {T[]} items the list of items\n * @param {GroupConfig<T, R>[]} groupConfigs configuration\n * @returns {(R | T)[]} grouped items\n */\nconst smartGrouping = (items, groupConfigs) => {\n\t/** @type {Set<ItemWithGroups<T, R>>} */\n\tconst itemsWithGroups = new Set();\n\t/** @type {Map<string, Group<T, R>>} */\n\tconst allGroups = new Map();\n\tfor (const item of items) {\n\t\t/** @type {Set<Group<T, R>>} */\n\t\tconst groups = new Set();\n\t\tfor (let i = 0; i < groupConfigs.length; i++) {\n\t\t\tconst groupConfig = groupConfigs[i];\n\t\t\tconst keys = groupConfig.getKeys(item);\n\t\t\tif (keys) {\n\t\t\t\tfor (const name of keys) {\n\t\t\t\t\tconst key = `${i}:${name}`;\n\t\t\t\t\tlet group = allGroups.get(key);\n\t\t\t\t\tif (group === undefined) {\n\t\t\t\t\t\tallGroups.set(\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t(group = {\n\t\t\t\t\t\t\t\tconfig: groupConfig,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\talreadyGrouped: false,\n\t\t\t\t\t\t\t\titems: undefined\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tgroups.add(group);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\titemsWithGroups.add({\n\t\t\titem,\n\t\t\tgroups\n\t\t});\n\t}\n\t/**\n\t * @param {Set<ItemWithGroups<T, R>>} itemsWithGroups input items with groups\n\t * @returns {(T | R)[]} groups items\n\t */\n\tconst runGrouping = itemsWithGroups => {\n\t\tconst totalSize = itemsWithGroups.size;\n\t\tfor (const entry of itemsWithGroups) {\n\t\t\tfor (const group of entry.groups) {\n\t\t\t\tif (group.alreadyGrouped) continue;\n\t\t\t\tconst items = group.items;\n\t\t\t\tif (items === undefined) {\n\t\t\t\t\tgroup.items = new Set([entry]);\n\t\t\t\t} else {\n\t\t\t\t\titems.add(entry);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/** @type {Map<Group<T, R>, { items: Set<ItemWithGroups<T, R>>, options: GroupOptions | false | undefined, used: boolean }>} */\n\t\tconst groupMap = new Map();\n\t\tfor (const group of allGroups.values()) {\n\t\t\tif (group.items) {\n\t\t\t\tconst items = group.items;\n\t\t\t\tgroup.items = undefined;\n\t\t\t\tgroupMap.set(group, {\n\t\t\t\t\titems,\n\t\t\t\t\toptions: undefined,\n\t\t\t\t\tused: false\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t/** @type {(T | R)[]} */\n\t\tconst results = [];\n\t\tfor (;;) {\n\t\t\t/** @type {Group<T, R>} */\n\t\t\tlet bestGroup = undefined;\n\t\t\tlet bestGroupSize = -1;\n\t\t\tlet bestGroupItems = undefined;\n\t\t\tlet bestGroupOptions = undefined;\n\t\t\tfor (const [group, state] of groupMap) {\n\t\t\t\tconst { items, used } = state;\n\t\t\t\tlet options = state.options;\n\t\t\t\tif (options === undefined) {\n\t\t\t\t\tconst groupConfig = group.config;\n\t\t\t\t\tstate.options = options =\n\t\t\t\t\t\t(groupConfig.getOptions &&\n\t\t\t\t\t\t\tgroupConfig.getOptions(\n\t\t\t\t\t\t\t\tgroup.name,\n\t\t\t\t\t\t\t\tArray.from(items, ({ item }) => item)\n\t\t\t\t\t\t\t)) ||\n\t\t\t\t\t\tfalse;\n\t\t\t\t}\n\n\t\t\t\tconst force = options && options.force;\n\t\t\t\tif (!force) {\n\t\t\t\t\tif (bestGroupOptions && bestGroupOptions.force) continue;\n\t\t\t\t\tif (used) continue;\n\t\t\t\t\tif (items.size <= 1 || totalSize - items.size <= 1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst targetGroupCount = (options && options.targetGroupCount) || 4;\n\t\t\t\tlet sizeValue = force\n\t\t\t\t\t? items.size\n\t\t\t\t\t: Math.min(\n\t\t\t\t\t\t\titems.size,\n\t\t\t\t\t\t\t(totalSize * 2) / targetGroupCount +\n\t\t\t\t\t\t\t\titemsWithGroups.size -\n\t\t\t\t\t\t\t\titems.size\n\t\t\t\t\t  );\n\t\t\t\tif (\n\t\t\t\t\tsizeValue > bestGroupSize ||\n\t\t\t\t\t(force && (!bestGroupOptions || !bestGroupOptions.force))\n\t\t\t\t) {\n\t\t\t\t\tbestGroup = group;\n\t\t\t\t\tbestGroupSize = sizeValue;\n\t\t\t\t\tbestGroupItems = items;\n\t\t\t\t\tbestGroupOptions = options;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bestGroup === undefined) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst items = new Set(bestGroupItems);\n\t\t\tconst options = bestGroupOptions;\n\n\t\t\tconst groupChildren = !options || options.groupChildren !== false;\n\n\t\t\tfor (const item of items) {\n\t\t\t\titemsWithGroups.delete(item);\n\t\t\t\t// Remove all groups that items have from the map to not select them again\n\t\t\t\tfor (const group of item.groups) {\n\t\t\t\t\tconst state = groupMap.get(group);\n\t\t\t\t\tif (state !== undefined) {\n\t\t\t\t\t\tstate.items.delete(item);\n\t\t\t\t\t\tif (state.items.size === 0) {\n\t\t\t\t\t\t\tgroupMap.delete(group);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstate.options = undefined;\n\t\t\t\t\t\t\tif (groupChildren) {\n\t\t\t\t\t\t\t\tstate.used = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgroupMap.delete(bestGroup);\n\n\t\t\tconst key = bestGroup.name;\n\t\t\tconst groupConfig = bestGroup.config;\n\n\t\t\tconst allItems = Array.from(items, ({ item }) => item);\n\n\t\t\tbestGroup.alreadyGrouped = true;\n\t\t\tconst children = groupChildren ? runGrouping(items) : allItems;\n\t\t\tbestGroup.alreadyGrouped = false;\n\n\t\t\tresults.push(groupConfig.createGroup(key, children, allItems));\n\t\t}\n\t\tfor (const { item } of itemsWithGroups) {\n\t\t\tresults.push(item);\n\t\t}\n\t\treturn results;\n\t};\n\treturn runGrouping(itemsWithGroups);\n};\n\nmodule.exports = smartGrouping;\n"]},"metadata":{},"sourceType":"script"}