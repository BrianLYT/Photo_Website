{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst eslintScope = require(\"eslint-scope\");\n\nconst Referencer = require(\"eslint-scope/lib/referencer\");\n\nconst {\n  CachedSource,\n  ConcatSource,\n  ReplaceSource\n} = require(\"webpack-sources\");\n\nconst ConcatenationScope = require(\"../ConcatenationScope\");\n\nconst {\n  UsageState\n} = require(\"../ExportsInfo\");\n\nconst Module = require(\"../Module\");\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\n\nconst Template = require(\"../Template\");\n\nconst HarmonyImportDependency = require(\"../dependencies/HarmonyImportDependency\");\n\nconst JavascriptParser = require(\"../javascript/JavascriptParser\");\n\nconst {\n  equals\n} = require(\"../util/ArrayHelpers\");\n\nconst LazySet = require(\"../util/LazySet\");\n\nconst {\n  concatComparators,\n  keepOriginalOrder\n} = require(\"../util/comparators\");\n\nconst createHash = require(\"../util/createHash\");\n\nconst {\n  makePathsRelative\n} = require(\"../util/identifier\");\n\nconst makeSerializable = require(\"../util/makeSerializable\");\n\nconst propertyAccess = require(\"../util/propertyAccess\");\n\nconst {\n  filterRuntime,\n  intersectRuntime,\n  mergeRuntimeCondition,\n  mergeRuntimeConditionNonFalse,\n  runtimeConditionToString,\n  subtractRuntimeCondition\n} = require(\"../util/runtime\");\n/** @typedef {import(\"eslint-scope\").Scope} Scope */\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").WebpackOptionsNormalized} WebpackOptions */\n\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n\n/** @typedef {import(\"../CodeGenerationResults\")} CodeGenerationResults */\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n\n/** @typedef {import(\"../Dependency\")} Dependency */\n\n/** @typedef {import(\"../Dependency\").UpdateHashContext} UpdateHashContext */\n\n/** @typedef {import(\"../DependencyTemplate\").DependencyTemplateContext} DependencyTemplateContext */\n\n/** @typedef {import(\"../DependencyTemplates\")} DependencyTemplates */\n\n/** @typedef {import(\"../ExportsInfo\").ExportInfo} ExportInfo */\n\n/** @template T @typedef {import(\"../InitFragment\")<T>} InitFragment */\n\n/** @typedef {import(\"../Module\").CodeGenerationContext} CodeGenerationContext */\n\n/** @typedef {import(\"../Module\").CodeGenerationResult} CodeGenerationResult */\n\n/** @typedef {import(\"../Module\").LibIdentOptions} LibIdentOptions */\n\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n\n/** @typedef {import(\"../ModuleGraphConnection\").ConnectionState} ConnectionState */\n\n/** @typedef {import(\"../RequestShortener\")} RequestShortener */\n\n/** @typedef {import(\"../ResolverFactory\").ResolverWithOptions} ResolverWithOptions */\n\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n\n/** @typedef {import(\"../WebpackError\")} WebpackError */\n\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").ChunkRenderContext} ChunkRenderContext */\n\n/** @typedef {import(\"../util/Hash\")} Hash */\n\n/** @typedef {typeof import(\"../util/Hash\")} HashConstructor */\n\n/** @typedef {import(\"../util/fs\").InputFileSystem} InputFileSystem */\n\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n// fix eslint-scope to support class properties correctly\n// cspell:word Referencer\n\n\nconst ReferencerClass = Referencer;\n\nif (!ReferencerClass.prototype.PropertyDefinition) {\n  ReferencerClass.prototype.PropertyDefinition = ReferencerClass.prototype.Property;\n}\n/**\n * @typedef {Object} ReexportInfo\n * @property {Module} module\n * @property {string[]} export\n */\n\n/** @typedef {RawBinding | SymbolBinding} Binding */\n\n/**\n * @typedef {Object} RawBinding\n * @property {ModuleInfo} info\n * @property {string} rawName\n * @property {string=} comment\n * @property {string[]} ids\n * @property {string[]} exportName\n */\n\n/**\n * @typedef {Object} SymbolBinding\n * @property {ConcatenatedModuleInfo} info\n * @property {string} name\n * @property {string=} comment\n * @property {string[]} ids\n * @property {string[]} exportName\n */\n\n/** @typedef {ConcatenatedModuleInfo | ExternalModuleInfo } ModuleInfo */\n\n/** @typedef {ConcatenatedModuleInfo | ExternalModuleInfo | ReferenceToModuleInfo } ModuleInfoOrReference */\n\n/**\n * @typedef {Object} ConcatenatedModuleInfo\n * @property {\"concatenated\"} type\n * @property {Module} module\n * @property {number} index\n * @property {Object} ast\n * @property {Source} internalSource\n * @property {ReplaceSource} source\n * @property {InitFragment<ChunkRenderContext>[]=} chunkInitFragments\n * @property {Iterable<string>} runtimeRequirements\n * @property {Scope} globalScope\n * @property {Scope} moduleScope\n * @property {Map<string, string>} internalNames\n * @property {Map<string, string>} exportMap\n * @property {Map<string, string>} rawExportMap\n * @property {string=} namespaceExportSymbol\n * @property {string} namespaceObjectName\n * @property {boolean} interopNamespaceObjectUsed\n * @property {string} interopNamespaceObjectName\n * @property {boolean} interopNamespaceObject2Used\n * @property {string} interopNamespaceObject2Name\n * @property {boolean} interopDefaultAccessUsed\n * @property {string} interopDefaultAccessName\n */\n\n/**\n * @typedef {Object} ExternalModuleInfo\n * @property {\"external\"} type\n * @property {Module} module\n * @property {RuntimeSpec | boolean} runtimeCondition\n * @property {number} index\n * @property {string} name\n * @property {boolean} interopNamespaceObjectUsed\n * @property {string} interopNamespaceObjectName\n * @property {boolean} interopNamespaceObject2Used\n * @property {string} interopNamespaceObject2Name\n * @property {boolean} interopDefaultAccessUsed\n * @property {string} interopDefaultAccessName\n */\n\n/**\n * @typedef {Object} ReferenceToModuleInfo\n * @property {\"reference\"} type\n * @property {RuntimeSpec | boolean} runtimeCondition\n * @property {ConcatenatedModuleInfo | ExternalModuleInfo} target\n */\n\n\nconst RESERVED_NAMES = new Set([// internal names (should always be renamed)\nConcatenationScope.DEFAULT_EXPORT, ConcatenationScope.NAMESPACE_OBJECT_EXPORT, // keywords\n\"abstract,arguments,async,await,boolean,break,byte,case,catch,char,class,const,continue\", \"debugger,default,delete,do,double,else,enum,eval,export,extends,false,final,finally,float\", \"for,function,goto,if,implements,import,in,instanceof,int,interface,let,long,native,new,null\", \"package,private,protected,public,return,short,static,super,switch,synchronized,this,throw\", \"throws,transient,true,try,typeof,var,void,volatile,while,with,yield\", // commonjs/amd\n\"module,__dirname,__filename,exports,require,define\", // js globals\n\"Array,Date,eval,function,hasOwnProperty,Infinity,isFinite,isNaN,isPrototypeOf,length,Math\", \"NaN,name,Number,Object,prototype,String,toString,undefined,valueOf\", // browser globals\n\"alert,all,anchor,anchors,area,assign,blur,button,checkbox,clearInterval,clearTimeout\", \"clientInformation,close,closed,confirm,constructor,crypto,decodeURI,decodeURIComponent\", \"defaultStatus,document,element,elements,embed,embeds,encodeURI,encodeURIComponent,escape\", \"event,fileUpload,focus,form,forms,frame,innerHeight,innerWidth,layer,layers,link,location\", \"mimeTypes,navigate,navigator,frames,frameRate,hidden,history,image,images,offscreenBuffering\", \"open,opener,option,outerHeight,outerWidth,packages,pageXOffset,pageYOffset,parent,parseFloat\", \"parseInt,password,pkcs11,plugin,prompt,propertyIsEnum,radio,reset,screenX,screenY,scroll\", \"secure,select,self,setInterval,setTimeout,status,submit,taint,text,textarea,top,unescape\", \"untaint,window\", // window events\n\"onblur,onclick,onerror,onfocus,onkeydown,onkeypress,onkeyup,onmouseover,onload,onmouseup,onmousedown,onsubmit\"].join(\",\").split(\",\"));\n\nconst bySourceOrder = (a, b) => {\n  const aOrder = a.sourceOrder;\n  const bOrder = b.sourceOrder;\n\n  if (isNaN(aOrder)) {\n    if (!isNaN(bOrder)) {\n      return 1;\n    }\n  } else {\n    if (isNaN(bOrder)) {\n      return -1;\n    }\n\n    if (aOrder !== bOrder) {\n      return aOrder < bOrder ? -1 : 1;\n    }\n  }\n\n  return 0;\n};\n\nconst joinIterableWithComma = iterable => {\n  // This is more performant than Array.from().join(\", \")\n  // as it doesn't create an array\n  let str = \"\";\n  let first = true;\n\n  for (const item of iterable) {\n    if (first) {\n      first = false;\n    } else {\n      str += \", \";\n    }\n\n    str += item;\n  }\n\n  return str;\n};\n/**\n * @typedef {Object} ConcatenationEntry\n * @property {\"concatenated\" | \"external\"} type\n * @property {Module} module\n * @property {RuntimeSpec | boolean} runtimeCondition\n */\n\n/**\n * @param {ModuleGraph} moduleGraph the module graph\n * @param {ModuleInfo} info module info\n * @param {string[]} exportName exportName\n * @param {Map<Module, ModuleInfo>} moduleToInfoMap moduleToInfoMap\n * @param {RuntimeSpec} runtime for which runtime\n * @param {RequestShortener} requestShortener the request shortener\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {Set<ConcatenatedModuleInfo>} neededNamespaceObjects modules for which a namespace object should be generated\n * @param {boolean} asCall asCall\n * @param {boolean} strictHarmonyModule strictHarmonyModule\n * @param {boolean | undefined} asiSafe asiSafe\n * @param {Set<ExportInfo>} alreadyVisited alreadyVisited\n * @returns {Binding} the final variable\n */\n\n\nconst getFinalBinding = function (moduleGraph, info, exportName, moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, asCall, strictHarmonyModule, asiSafe) {\n  let alreadyVisited = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : new Set();\n  const exportsType = info.module.getExportsType(moduleGraph, strictHarmonyModule);\n\n  if (exportName.length === 0) {\n    switch (exportsType) {\n      case \"default-only\":\n        info.interopNamespaceObject2Used = true;\n        return {\n          info,\n          rawName: info.interopNamespaceObject2Name,\n          ids: exportName,\n          exportName\n        };\n\n      case \"default-with-named\":\n        info.interopNamespaceObjectUsed = true;\n        return {\n          info,\n          rawName: info.interopNamespaceObjectName,\n          ids: exportName,\n          exportName\n        };\n\n      case \"namespace\":\n      case \"dynamic\":\n        break;\n\n      default:\n        throw new Error(`Unexpected exportsType ${exportsType}`);\n    }\n  } else {\n    switch (exportsType) {\n      case \"namespace\":\n        break;\n\n      case \"default-with-named\":\n        switch (exportName[0]) {\n          case \"default\":\n            exportName = exportName.slice(1);\n            break;\n\n          case \"__esModule\":\n            return {\n              info,\n              rawName: \"/* __esModule */true\",\n              ids: exportName.slice(1),\n              exportName\n            };\n        }\n\n        break;\n\n      case \"default-only\":\n        {\n          const exportId = exportName[0];\n\n          if (exportId === \"__esModule\") {\n            return {\n              info,\n              rawName: \"/* __esModule */true\",\n              ids: exportName.slice(1),\n              exportName\n            };\n          }\n\n          exportName = exportName.slice(1);\n\n          if (exportId !== \"default\") {\n            return {\n              info,\n              rawName: \"/* non-default import from default-exporting module */undefined\",\n              ids: exportName,\n              exportName\n            };\n          }\n\n          break;\n        }\n\n      case \"dynamic\":\n        switch (exportName[0]) {\n          case \"default\":\n            {\n              exportName = exportName.slice(1);\n              info.interopDefaultAccessUsed = true;\n              const defaultExport = asCall ? `${info.interopDefaultAccessName}()` : asiSafe ? `(${info.interopDefaultAccessName}())` : asiSafe === false ? `;(${info.interopDefaultAccessName}())` : `${info.interopDefaultAccessName}.a`;\n              return {\n                info,\n                rawName: defaultExport,\n                ids: exportName,\n                exportName\n              };\n            }\n\n          case \"__esModule\":\n            return {\n              info,\n              rawName: \"/* __esModule */true\",\n              ids: exportName.slice(1),\n              exportName\n            };\n        }\n\n        break;\n\n      default:\n        throw new Error(`Unexpected exportsType ${exportsType}`);\n    }\n  }\n\n  if (exportName.length === 0) {\n    switch (info.type) {\n      case \"concatenated\":\n        neededNamespaceObjects.add(info);\n        return {\n          info,\n          rawName: info.namespaceObjectName,\n          ids: exportName,\n          exportName\n        };\n\n      case \"external\":\n        return {\n          info,\n          rawName: info.name,\n          ids: exportName,\n          exportName\n        };\n    }\n  }\n\n  const exportsInfo = moduleGraph.getExportsInfo(info.module);\n  const exportInfo = exportsInfo.getExportInfo(exportName[0]);\n\n  if (alreadyVisited.has(exportInfo)) {\n    return {\n      info,\n      rawName: \"/* circular reexport */ Object(function x() { x() }())\",\n      ids: [],\n      exportName\n    };\n  }\n\n  alreadyVisited.add(exportInfo);\n\n  switch (info.type) {\n    case \"concatenated\":\n      {\n        const exportId = exportName[0];\n\n        if (exportInfo.provided === false) {\n          // It's not provided, but it could be on the prototype\n          neededNamespaceObjects.add(info);\n          return {\n            info,\n            rawName: info.namespaceObjectName,\n            ids: exportName,\n            exportName\n          };\n        }\n\n        const directExport = info.exportMap && info.exportMap.get(exportId);\n\n        if (directExport) {\n          const usedName =\n          /** @type {string[]} */\n          exportsInfo.getUsedName(exportName, runtime);\n\n          if (!usedName) {\n            return {\n              info,\n              rawName: \"/* unused export */ undefined\",\n              ids: exportName.slice(1),\n              exportName\n            };\n          }\n\n          return {\n            info,\n            name: directExport,\n            ids: usedName.slice(1),\n            exportName\n          };\n        }\n\n        const rawExport = info.rawExportMap && info.rawExportMap.get(exportId);\n\n        if (rawExport) {\n          return {\n            info,\n            rawName: rawExport,\n            ids: exportName.slice(1),\n            exportName\n          };\n        }\n\n        const reexport = exportInfo.findTarget(moduleGraph, module => moduleToInfoMap.has(module));\n\n        if (reexport === false) {\n          throw new Error(`Target module of reexport from '${info.module.readableIdentifier(requestShortener)}' is not part of the concatenation (export '${exportId}')\\nModules in the concatenation:\\n${Array.from(moduleToInfoMap, _ref => {\n            let [m, info] = _ref;\n            return ` * ${info.type} ${m.readableIdentifier(requestShortener)}`;\n          }).join(\"\\n\")}`);\n        }\n\n        if (reexport) {\n          const refInfo = moduleToInfoMap.get(reexport.module);\n          return getFinalBinding(moduleGraph, refInfo, reexport.export ? [...reexport.export, ...exportName.slice(1)] : exportName.slice(1), moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, asCall, info.module.buildMeta.strictHarmonyModule, asiSafe, alreadyVisited);\n        }\n\n        if (info.namespaceExportSymbol) {\n          const usedName =\n          /** @type {string[]} */\n          exportsInfo.getUsedName(exportName, runtime);\n          return {\n            info,\n            rawName: info.namespaceObjectName,\n            ids: usedName,\n            exportName\n          };\n        }\n\n        throw new Error(`Cannot get final name for export '${exportName.join(\".\")}' of ${info.module.readableIdentifier(requestShortener)}`);\n      }\n\n    case \"external\":\n      {\n        const used =\n        /** @type {string[]} */\n        exportsInfo.getUsedName(exportName, runtime);\n\n        if (!used) {\n          return {\n            info,\n            rawName: \"/* unused export */ undefined\",\n            ids: exportName.slice(1),\n            exportName\n          };\n        }\n\n        const comment = equals(used, exportName) ? \"\" : Template.toNormalComment(`${exportName.join(\".\")}`);\n        return {\n          info,\n          rawName: info.name + comment,\n          ids: used,\n          exportName\n        };\n      }\n  }\n};\n/**\n * @param {ModuleGraph} moduleGraph the module graph\n * @param {ModuleInfo} info module info\n * @param {string[]} exportName exportName\n * @param {Map<Module, ModuleInfo>} moduleToInfoMap moduleToInfoMap\n * @param {RuntimeSpec} runtime for which runtime\n * @param {RequestShortener} requestShortener the request shortener\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {Set<ConcatenatedModuleInfo>} neededNamespaceObjects modules for which a namespace object should be generated\n * @param {boolean} asCall asCall\n * @param {boolean} callContext callContext\n * @param {boolean} strictHarmonyModule strictHarmonyModule\n * @param {boolean | undefined} asiSafe asiSafe\n * @returns {string} the final name\n */\n\n\nconst getFinalName = (moduleGraph, info, exportName, moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, asCall, callContext, strictHarmonyModule, asiSafe) => {\n  const binding = getFinalBinding(moduleGraph, info, exportName, moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, asCall, strictHarmonyModule, asiSafe);\n  {\n    const {\n      ids,\n      comment\n    } = binding;\n    let reference;\n    let isPropertyAccess;\n\n    if (\"rawName\" in binding) {\n      reference = `${binding.rawName}${comment || \"\"}${propertyAccess(ids)}`;\n      isPropertyAccess = ids.length > 0;\n    } else {\n      const {\n        info,\n        name: exportId\n      } = binding;\n      const name = info.internalNames.get(exportId);\n\n      if (!name) {\n        throw new Error(`The export \"${exportId}\" in \"${info.module.readableIdentifier(requestShortener)}\" has no internal name (existing names: ${Array.from(info.internalNames, _ref2 => {\n          let [name, symbol] = _ref2;\n          return `${name}: ${symbol}`;\n        }).join(\", \") || \"none\"})`);\n      }\n\n      reference = `${name}${comment || \"\"}${propertyAccess(ids)}`;\n      isPropertyAccess = ids.length > 1;\n    }\n\n    if (isPropertyAccess && asCall && callContext === false) {\n      return asiSafe ? `(0,${reference})` : asiSafe === false ? `;(0,${reference})` : `/*#__PURE__*/Object(${reference})`;\n    }\n\n    return reference;\n  }\n};\n\nconst addScopeSymbols = (s, nameSet, scopeSet1, scopeSet2) => {\n  let scope = s;\n\n  while (scope) {\n    if (scopeSet1.has(scope)) break;\n    if (scopeSet2.has(scope)) break;\n    scopeSet1.add(scope);\n\n    for (const variable of scope.variables) {\n      nameSet.add(variable.name);\n    }\n\n    scope = scope.upper;\n  }\n};\n\nconst getAllReferences = variable => {\n  let set = variable.references; // Look for inner scope variables too (like in class Foo { t() { Foo } })\n\n  const identifiers = new Set(variable.identifiers);\n\n  for (const scope of variable.scope.childScopes) {\n    for (const innerVar of scope.variables) {\n      if (innerVar.identifiers.some(id => identifiers.has(id))) {\n        set = set.concat(innerVar.references);\n        break;\n      }\n    }\n  }\n\n  return set;\n};\n\nconst getPathInAst = (ast, node) => {\n  if (ast === node) {\n    return [];\n  }\n\n  const nr = node.range;\n\n  const enterNode = n => {\n    if (!n) return undefined;\n    const r = n.range;\n\n    if (r) {\n      if (r[0] <= nr[0] && r[1] >= nr[1]) {\n        const path = getPathInAst(n, node);\n\n        if (path) {\n          path.push(n);\n          return path;\n        }\n      }\n    }\n\n    return undefined;\n  };\n\n  if (Array.isArray(ast)) {\n    for (let i = 0; i < ast.length; i++) {\n      const enterResult = enterNode(ast[i]);\n      if (enterResult !== undefined) return enterResult;\n    }\n  } else if (ast && typeof ast === \"object\") {\n    const keys = Object.keys(ast);\n\n    for (let i = 0; i < keys.length; i++) {\n      const value = ast[keys[i]];\n\n      if (Array.isArray(value)) {\n        const pathResult = getPathInAst(value, node);\n        if (pathResult !== undefined) return pathResult;\n      } else if (value && typeof value === \"object\") {\n        const enterResult = enterNode(value);\n        if (enterResult !== undefined) return enterResult;\n      }\n    }\n  }\n};\n\nconst TYPES = new Set([\"javascript\"]);\n\nclass ConcatenatedModule extends Module {\n  /**\n   * @param {Module} rootModule the root module of the concatenation\n   * @param {Set<Module>} modules all modules in the concatenation (including the root module)\n   * @param {RuntimeSpec} runtime the runtime\n   * @param {Object=} associatedObjectForCache object for caching\n   * @param {string | HashConstructor=} hashFunction hash function to use\n   * @returns {ConcatenatedModule} the module\n   */\n  static create(rootModule, modules, runtime, associatedObjectForCache) {\n    let hashFunction = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"md4\";\n\n    const identifier = ConcatenatedModule._createIdentifier(rootModule, modules, associatedObjectForCache, hashFunction);\n\n    return new ConcatenatedModule({\n      identifier,\n      rootModule,\n      modules,\n      runtime\n    });\n  }\n  /**\n   * @param {Object} options options\n   * @param {string} options.identifier the identifier of the module\n   * @param {Module=} options.rootModule the root module of the concatenation\n   * @param {RuntimeSpec} options.runtime the selected runtime\n   * @param {Set<Module>=} options.modules all concatenated modules\n   */\n\n\n  constructor(_ref3) {\n    let {\n      identifier,\n      rootModule,\n      modules,\n      runtime\n    } = _ref3;\n    super(\"javascript/esm\", null, rootModule && rootModule.layer); // Info from Factory\n\n    /** @type {string} */\n\n    this._identifier = identifier;\n    /** @type {Module} */\n\n    this.rootModule = rootModule;\n    /** @type {Set<Module>} */\n\n    this._modules = modules;\n    this._runtime = runtime;\n    this.factoryMeta = rootModule && rootModule.factoryMeta;\n  }\n  /**\n   * Assuming this module is in the cache. Update the (cached) module with\n   * the fresh module from the factory. Usually updates internal references\n   * and properties.\n   * @param {Module} module fresh module\n   * @returns {void}\n   */\n\n\n  updateCacheModule(module) {\n    throw new Error(\"Must not be called\");\n  }\n  /**\n   * @returns {Set<string>} types available (do not mutate)\n   */\n\n\n  getSourceTypes() {\n    return TYPES;\n  }\n\n  get modules() {\n    return Array.from(this._modules);\n  }\n  /**\n   * @returns {string} a unique identifier of the module\n   */\n\n\n  identifier() {\n    return this._identifier;\n  }\n  /**\n   * @param {RequestShortener} requestShortener the request shortener\n   * @returns {string} a user readable identifier of the module\n   */\n\n\n  readableIdentifier(requestShortener) {\n    return this.rootModule.readableIdentifier(requestShortener) + ` + ${this._modules.size - 1} modules`;\n  }\n  /**\n   * @param {LibIdentOptions} options options\n   * @returns {string | null} an identifier for library inclusion\n   */\n\n\n  libIdent(options) {\n    return this.rootModule.libIdent(options);\n  }\n  /**\n   * @returns {string | null} absolute path which should be used for condition matching (usually the resource path)\n   */\n\n\n  nameForCondition() {\n    return this.rootModule.nameForCondition();\n  }\n  /**\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @returns {ConnectionState} how this module should be connected to referencing modules when consumed for side-effects only\n   */\n\n\n  getSideEffectsConnectionState(moduleGraph) {\n    return this.rootModule.getSideEffectsConnectionState(moduleGraph);\n  }\n  /**\n   * @param {WebpackOptions} options webpack options\n   * @param {Compilation} compilation the compilation\n   * @param {ResolverWithOptions} resolver the resolver\n   * @param {InputFileSystem} fs the file system\n   * @param {function(WebpackError=): void} callback callback function\n   * @returns {void}\n   */\n\n\n  build(options, compilation, resolver, fs, callback) {\n    const {\n      rootModule\n    } = this;\n    this.buildInfo = {\n      strict: true,\n      cacheable: true,\n      moduleArgument: rootModule.buildInfo.moduleArgument,\n      exportsArgument: rootModule.buildInfo.exportsArgument,\n      fileDependencies: new LazySet(),\n      contextDependencies: new LazySet(),\n      missingDependencies: new LazySet(),\n      topLevelDeclarations: new Set(),\n      assets: undefined\n    };\n    this.buildMeta = rootModule.buildMeta;\n    this.clearDependenciesAndBlocks();\n    this.clearWarningsAndErrors();\n\n    for (const m of this._modules) {\n      // populate cacheable\n      if (!m.buildInfo.cacheable) {\n        this.buildInfo.cacheable = false;\n      } // populate dependencies\n\n\n      for (const d of m.dependencies.filter(dep => !(dep instanceof HarmonyImportDependency) || !this._modules.has(compilation.moduleGraph.getModule(dep)))) {\n        this.dependencies.push(d);\n      } // populate blocks\n\n\n      for (const d of m.blocks) {\n        this.blocks.push(d);\n      } // populate warnings\n\n\n      const warnings = m.getWarnings();\n\n      if (warnings !== undefined) {\n        for (const warning of warnings) {\n          this.addWarning(warning);\n        }\n      } // populate errors\n\n\n      const errors = m.getErrors();\n\n      if (errors !== undefined) {\n        for (const error of errors) {\n          this.addError(error);\n        }\n      } // populate topLevelDeclarations\n\n\n      if (m.buildInfo.topLevelDeclarations) {\n        const topLevelDeclarations = this.buildInfo.topLevelDeclarations;\n\n        if (topLevelDeclarations !== undefined) {\n          for (const decl of m.buildInfo.topLevelDeclarations) {\n            topLevelDeclarations.add(decl);\n          }\n        }\n      } else {\n        this.buildInfo.topLevelDeclarations = undefined;\n      } // populate assets\n\n\n      if (m.buildInfo.assets) {\n        if (this.buildInfo.assets === undefined) {\n          this.buildInfo.assets = Object.create(null);\n        }\n\n        Object.assign(this.buildInfo.assets, m.buildInfo.assets);\n      }\n\n      if (m.buildInfo.assetsInfo) {\n        if (this.buildInfo.assetsInfo === undefined) {\n          this.buildInfo.assetsInfo = new Map();\n        }\n\n        for (const [key, value] of m.buildInfo.assetsInfo) {\n          this.buildInfo.assetsInfo.set(key, value);\n        }\n      }\n    }\n\n    callback();\n  }\n  /**\n   * @param {string=} type the source type for which the size should be estimated\n   * @returns {number} the estimated size of the module (must be non-zero)\n   */\n\n\n  size(type) {\n    // Guess size from embedded modules\n    let size = 0;\n\n    for (const module of this._modules) {\n      size += module.size(type);\n    }\n\n    return size;\n  }\n  /**\n   * @private\n   * @param {Module} rootModule the root of the concatenation\n   * @param {Set<Module>} modulesSet a set of modules which should be concatenated\n   * @param {RuntimeSpec} runtime for this runtime\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @returns {ConcatenationEntry[]} concatenation list\n   */\n\n\n  _createConcatenationList(rootModule, modulesSet, runtime, moduleGraph) {\n    /** @type {ConcatenationEntry[]} */\n    const list = [];\n    /** @type {Map<Module, RuntimeSpec | true>} */\n\n    const existingEntries = new Map();\n    /**\n     * @param {Module} module a module\n     * @returns {Iterable<{ connection: ModuleGraphConnection, runtimeCondition: RuntimeSpec | true }>} imported modules in order\n     */\n\n    const getConcatenatedImports = module => {\n      let connections = Array.from(moduleGraph.getOutgoingConnections(module));\n\n      if (module === rootModule) {\n        for (const c of moduleGraph.getOutgoingConnections(this)) connections.push(c);\n      }\n\n      const references = connections.filter(connection => {\n        if (!(connection.dependency instanceof HarmonyImportDependency)) return false;\n        return connection && connection.resolvedOriginModule === module && connection.module && connection.isTargetActive(runtime);\n      }).map(connection => ({\n        connection,\n        sourceOrder:\n        /** @type {HarmonyImportDependency} */\n        connection.dependency.sourceOrder\n      }));\n      references.sort(concatComparators(bySourceOrder, keepOriginalOrder(references)));\n      /** @type {Map<Module, { connection: ModuleGraphConnection, runtimeCondition: RuntimeSpec | true }>} */\n\n      const referencesMap = new Map();\n\n      for (const {\n        connection\n      } of references) {\n        const runtimeCondition = filterRuntime(runtime, r => connection.isTargetActive(r));\n        if (runtimeCondition === false) continue;\n        const module = connection.module;\n        const entry = referencesMap.get(module);\n\n        if (entry === undefined) {\n          referencesMap.set(module, {\n            connection,\n            runtimeCondition\n          });\n          continue;\n        }\n\n        entry.runtimeCondition = mergeRuntimeConditionNonFalse(entry.runtimeCondition, runtimeCondition, runtime);\n      }\n\n      return referencesMap.values();\n    };\n    /**\n     * @param {ModuleGraphConnection} connection graph connection\n     * @param {RuntimeSpec | true} runtimeCondition runtime condition\n     * @returns {void}\n     */\n\n\n    const enterModule = (connection, runtimeCondition) => {\n      const module = connection.module;\n      if (!module) return;\n      const existingEntry = existingEntries.get(module);\n\n      if (existingEntry === true) {\n        return;\n      }\n\n      if (modulesSet.has(module)) {\n        existingEntries.set(module, true);\n\n        if (runtimeCondition !== true) {\n          throw new Error(`Cannot runtime-conditional concatenate a module (${module.identifier()} in ${this.rootModule.identifier()}, ${runtimeConditionToString(runtimeCondition)}). This should not happen.`);\n        }\n\n        const imports = getConcatenatedImports(module);\n\n        for (const {\n          connection,\n          runtimeCondition\n        } of imports) enterModule(connection, runtimeCondition);\n\n        list.push({\n          type: \"concatenated\",\n          module: connection.module,\n          runtimeCondition\n        });\n      } else {\n        if (existingEntry !== undefined) {\n          const reducedRuntimeCondition = subtractRuntimeCondition(runtimeCondition, existingEntry, runtime);\n          if (reducedRuntimeCondition === false) return;\n          runtimeCondition = reducedRuntimeCondition;\n          existingEntries.set(connection.module, mergeRuntimeConditionNonFalse(existingEntry, runtimeCondition, runtime));\n        } else {\n          existingEntries.set(connection.module, runtimeCondition);\n        }\n\n        if (list.length > 0) {\n          const lastItem = list[list.length - 1];\n\n          if (lastItem.type === \"external\" && lastItem.module === connection.module) {\n            lastItem.runtimeCondition = mergeRuntimeCondition(lastItem.runtimeCondition, runtimeCondition, runtime);\n            return;\n          }\n        }\n\n        list.push({\n          type: \"external\",\n\n          get module() {\n            // We need to use a getter here, because the module in the dependency\n            // could be replaced by some other process (i. e. also replaced with a\n            // concatenated module)\n            return connection.module;\n          },\n\n          runtimeCondition\n        });\n      }\n    };\n\n    existingEntries.set(rootModule, true);\n    const imports = getConcatenatedImports(rootModule);\n\n    for (const {\n      connection,\n      runtimeCondition\n    } of imports) enterModule(connection, runtimeCondition);\n\n    list.push({\n      type: \"concatenated\",\n      module: rootModule,\n      runtimeCondition: true\n    });\n    return list;\n  }\n  /**\n   * @param {Module} rootModule the root module of the concatenation\n   * @param {Set<Module>} modules all modules in the concatenation (including the root module)\n   * @param {Object=} associatedObjectForCache object for caching\n   * @param {string | HashConstructor=} hashFunction hash function to use\n   * @returns {string} the identifier\n   */\n\n\n  static _createIdentifier(rootModule, modules, associatedObjectForCache) {\n    let hashFunction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"md4\";\n    const cachedMakePathsRelative = makePathsRelative.bindContextCache(rootModule.context, associatedObjectForCache);\n    let identifiers = [];\n\n    for (const module of modules) {\n      identifiers.push(cachedMakePathsRelative(module.identifier()));\n    }\n\n    identifiers.sort();\n    const hash = createHash(hashFunction);\n    hash.update(identifiers.join(\" \"));\n    return rootModule.identifier() + \"|\" + hash.digest(\"hex\");\n  }\n  /**\n   * @param {LazySet<string>} fileDependencies set where file dependencies are added to\n   * @param {LazySet<string>} contextDependencies set where context dependencies are added to\n   * @param {LazySet<string>} missingDependencies set where missing dependencies are added to\n   * @param {LazySet<string>} buildDependencies set where build dependencies are added to\n   */\n\n\n  addCacheDependencies(fileDependencies, contextDependencies, missingDependencies, buildDependencies) {\n    for (const module of this._modules) {\n      module.addCacheDependencies(fileDependencies, contextDependencies, missingDependencies, buildDependencies);\n    }\n  }\n  /**\n   * @param {CodeGenerationContext} context context for code generation\n   * @returns {CodeGenerationResult} result\n   */\n\n\n  codeGeneration(_ref4) {\n    let {\n      dependencyTemplates,\n      runtimeTemplate,\n      moduleGraph,\n      chunkGraph,\n      runtime: generationRuntime,\n      codeGenerationResults\n    } = _ref4;\n\n    /** @type {Set<string>} */\n    const runtimeRequirements = new Set();\n    const runtime = intersectRuntime(generationRuntime, this._runtime);\n    const requestShortener = runtimeTemplate.requestShortener; // Meta info for each module\n\n    const [modulesWithInfo, moduleToInfoMap] = this._getModulesWithInfo(moduleGraph, runtime); // Set with modules that need a generated namespace object\n\n    /** @type {Set<ConcatenatedModuleInfo>} */\n\n\n    const neededNamespaceObjects = new Set(); // Generate source code and analyse scopes\n    // Prepare a ReplaceSource for the final source\n\n    for (const info of moduleToInfoMap.values()) {\n      this._analyseModule(moduleToInfoMap, info, dependencyTemplates, runtimeTemplate, moduleGraph, chunkGraph, runtime, codeGenerationResults);\n    } // List of all used names to avoid conflicts\n\n\n    const allUsedNames = new Set(RESERVED_NAMES); // Updated Top level declarations are created by renaming\n\n    const topLevelDeclarations = new Set(); // List of additional names in scope for module references\n\n    /** @type {Map<string, { usedNames: Set<string>, alreadyCheckedScopes: Set<TODO> }>} */\n\n    const usedNamesInScopeInfo = new Map();\n    /**\n     * @param {string} module module identifier\n     * @param {string} id export id\n     * @returns {{ usedNames: Set<string>, alreadyCheckedScopes: Set<TODO> }} info\n     */\n\n    const getUsedNamesInScopeInfo = (module, id) => {\n      const key = `${module}-${id}`;\n      let info = usedNamesInScopeInfo.get(key);\n\n      if (info === undefined) {\n        info = {\n          usedNames: new Set(),\n          alreadyCheckedScopes: new Set()\n        };\n        usedNamesInScopeInfo.set(key, info);\n      }\n\n      return info;\n    }; // Set of already checked scopes\n\n\n    const ignoredScopes = new Set(); // get all global names\n\n    for (const info of modulesWithInfo) {\n      if (info.type === \"concatenated\") {\n        // ignore symbols from moduleScope\n        if (info.moduleScope) {\n          ignoredScopes.add(info.moduleScope);\n        } // The super class expression in class scopes behaves weird\n        // We get ranges of all super class expressions to make\n        // renaming to work correctly\n\n\n        const superClassCache = new WeakMap();\n\n        const getSuperClassExpressions = scope => {\n          const cacheEntry = superClassCache.get(scope);\n          if (cacheEntry !== undefined) return cacheEntry;\n          const superClassExpressions = [];\n\n          for (const childScope of scope.childScopes) {\n            if (childScope.type !== \"class\") continue;\n            const block = childScope.block;\n\n            if ((block.type === \"ClassDeclaration\" || block.type === \"ClassExpression\") && block.superClass) {\n              superClassExpressions.push({\n                range: block.superClass.range,\n                variables: childScope.variables\n              });\n            }\n          }\n\n          superClassCache.set(scope, superClassExpressions);\n          return superClassExpressions;\n        }; // add global symbols\n\n\n        if (info.globalScope) {\n          for (const reference of info.globalScope.through) {\n            const name = reference.identifier.name;\n\n            if (ConcatenationScope.isModuleReference(name)) {\n              const match = ConcatenationScope.matchModuleReference(name);\n              if (!match) continue;\n              const referencedInfo = modulesWithInfo[match.index];\n              if (referencedInfo.type === \"reference\") throw new Error(\"Module reference can't point to a reference\");\n              const binding = getFinalBinding(moduleGraph, referencedInfo, match.ids, moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, false, info.module.buildMeta.strictHarmonyModule, true);\n              if (!binding.ids) continue;\n              const {\n                usedNames,\n                alreadyCheckedScopes\n              } = getUsedNamesInScopeInfo(binding.info.module.identifier(), \"name\" in binding ? binding.name : \"\");\n\n              for (const expr of getSuperClassExpressions(reference.from)) {\n                if (expr.range[0] <= reference.identifier.range[0] && expr.range[1] >= reference.identifier.range[1]) {\n                  for (const variable of expr.variables) {\n                    usedNames.add(variable.name);\n                  }\n                }\n              }\n\n              addScopeSymbols(reference.from, usedNames, alreadyCheckedScopes, ignoredScopes);\n            } else {\n              allUsedNames.add(name);\n            }\n          }\n        }\n      }\n    } // generate names for symbols\n\n\n    for (const info of moduleToInfoMap.values()) {\n      const {\n        usedNames: namespaceObjectUsedNames\n      } = getUsedNamesInScopeInfo(info.module.identifier(), \"\");\n\n      switch (info.type) {\n        case \"concatenated\":\n          {\n            for (const variable of info.moduleScope.variables) {\n              const name = variable.name;\n              const {\n                usedNames,\n                alreadyCheckedScopes\n              } = getUsedNamesInScopeInfo(info.module.identifier(), name);\n\n              if (allUsedNames.has(name) || usedNames.has(name)) {\n                const references = getAllReferences(variable);\n\n                for (const ref of references) {\n                  addScopeSymbols(ref.from, usedNames, alreadyCheckedScopes, ignoredScopes);\n                }\n\n                const newName = this.findNewName(name, allUsedNames, usedNames, info.module.readableIdentifier(requestShortener));\n                allUsedNames.add(newName);\n                info.internalNames.set(name, newName);\n                topLevelDeclarations.add(newName);\n                const source = info.source;\n                const allIdentifiers = new Set(references.map(r => r.identifier).concat(variable.identifiers));\n\n                for (const identifier of allIdentifiers) {\n                  const r = identifier.range;\n                  const path = getPathInAst(info.ast, identifier);\n\n                  if (path && path.length > 1) {\n                    const maybeProperty = path[1].type === \"AssignmentPattern\" && path[1].left === path[0] ? path[2] : path[1];\n\n                    if (maybeProperty.type === \"Property\" && maybeProperty.shorthand) {\n                      source.insert(r[1], `: ${newName}`);\n                      continue;\n                    }\n                  }\n\n                  source.replace(r[0], r[1] - 1, newName);\n                }\n              } else {\n                allUsedNames.add(name);\n                info.internalNames.set(name, name);\n                topLevelDeclarations.add(name);\n              }\n            }\n\n            let namespaceObjectName;\n\n            if (info.namespaceExportSymbol) {\n              namespaceObjectName = info.internalNames.get(info.namespaceExportSymbol);\n            } else {\n              namespaceObjectName = this.findNewName(\"namespaceObject\", allUsedNames, namespaceObjectUsedNames, info.module.readableIdentifier(requestShortener));\n              allUsedNames.add(namespaceObjectName);\n            }\n\n            info.namespaceObjectName = namespaceObjectName;\n            topLevelDeclarations.add(namespaceObjectName);\n            break;\n          }\n\n        case \"external\":\n          {\n            const externalName = this.findNewName(\"\", allUsedNames, namespaceObjectUsedNames, info.module.readableIdentifier(requestShortener));\n            allUsedNames.add(externalName);\n            info.name = externalName;\n            topLevelDeclarations.add(externalName);\n            break;\n          }\n      }\n\n      if (info.module.buildMeta.exportsType !== \"namespace\") {\n        const externalNameInterop = this.findNewName(\"namespaceObject\", allUsedNames, namespaceObjectUsedNames, info.module.readableIdentifier(requestShortener));\n        allUsedNames.add(externalNameInterop);\n        info.interopNamespaceObjectName = externalNameInterop;\n        topLevelDeclarations.add(externalNameInterop);\n      }\n\n      if (info.module.buildMeta.exportsType === \"default\" && info.module.buildMeta.defaultObject !== \"redirect\") {\n        const externalNameInterop = this.findNewName(\"namespaceObject2\", allUsedNames, namespaceObjectUsedNames, info.module.readableIdentifier(requestShortener));\n        allUsedNames.add(externalNameInterop);\n        info.interopNamespaceObject2Name = externalNameInterop;\n        topLevelDeclarations.add(externalNameInterop);\n      }\n\n      if (info.module.buildMeta.exportsType === \"dynamic\" || !info.module.buildMeta.exportsType) {\n        const externalNameInterop = this.findNewName(\"default\", allUsedNames, namespaceObjectUsedNames, info.module.readableIdentifier(requestShortener));\n        allUsedNames.add(externalNameInterop);\n        info.interopDefaultAccessName = externalNameInterop;\n        topLevelDeclarations.add(externalNameInterop);\n      }\n    } // Find and replace references to modules\n\n\n    for (const info of moduleToInfoMap.values()) {\n      if (info.type === \"concatenated\") {\n        for (const reference of info.globalScope.through) {\n          const name = reference.identifier.name;\n          const match = ConcatenationScope.matchModuleReference(name);\n\n          if (match) {\n            const referencedInfo = modulesWithInfo[match.index];\n            if (referencedInfo.type === \"reference\") throw new Error(\"Module reference can't point to a reference\");\n            const finalName = getFinalName(moduleGraph, referencedInfo, match.ids, moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, match.call, !match.directImport, info.module.buildMeta.strictHarmonyModule, match.asiSafe);\n            const r = reference.identifier.range;\n            const source = info.source; // range is extended by 2 chars to cover the appended \"._\"\n\n            source.replace(r[0], r[1] + 1, finalName);\n          }\n        }\n      }\n    } // Map with all root exposed used exports\n\n    /** @type {Map<string, function(RequestShortener): string>} */\n\n\n    const exportsMap = new Map(); // Set with all root exposed unused exports\n\n    /** @type {Set<string>} */\n\n    const unusedExports = new Set();\n    const rootInfo =\n    /** @type {ConcatenatedModuleInfo} */\n    moduleToInfoMap.get(this.rootModule);\n    const strictHarmonyModule = rootInfo.module.buildMeta.strictHarmonyModule;\n    const exportsInfo = moduleGraph.getExportsInfo(rootInfo.module);\n\n    for (const exportInfo of exportsInfo.orderedExports) {\n      const name = exportInfo.name;\n      if (exportInfo.provided === false) continue;\n      const used = exportInfo.getUsedName(undefined, runtime);\n\n      if (!used) {\n        unusedExports.add(name);\n        continue;\n      }\n\n      exportsMap.set(used, requestShortener => {\n        try {\n          const finalName = getFinalName(moduleGraph, rootInfo, [name], moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, false, false, strictHarmonyModule, true);\n          return `/* ${exportInfo.isReexport() ? \"reexport\" : \"binding\"} */ ${finalName}`;\n        } catch (e) {\n          e.message += `\\nwhile generating the root export '${name}' (used name: '${used}')`;\n          throw e;\n        }\n      });\n    }\n\n    const result = new ConcatSource(); // add harmony compatibility flag (must be first because of possible circular dependencies)\n\n    if (moduleGraph.getExportsInfo(this).otherExportsInfo.getUsed(runtime) !== UsageState.Unused) {\n      result.add(`// ESM COMPAT FLAG\\n`);\n      result.add(runtimeTemplate.defineEsModuleFlagStatement({\n        exportsArgument: this.exportsArgument,\n        runtimeRequirements\n      }));\n    } // define exports\n\n\n    if (exportsMap.size > 0) {\n      runtimeRequirements.add(RuntimeGlobals.exports);\n      runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);\n      const definitions = [];\n\n      for (const [key, value] of exportsMap) {\n        definitions.push(`\\n  ${JSON.stringify(key)}: ${runtimeTemplate.returningFunction(value(requestShortener))}`);\n      }\n\n      result.add(`\\n// EXPORTS\\n`);\n      result.add(`${RuntimeGlobals.definePropertyGetters}(${this.exportsArgument}, {${definitions.join(\",\")}\\n});\\n`);\n    } // list unused exports\n\n\n    if (unusedExports.size > 0) {\n      result.add(`\\n// UNUSED EXPORTS: ${joinIterableWithComma(unusedExports)}\\n`);\n    } // generate namespace objects\n\n\n    const namespaceObjectSources = new Map();\n\n    for (const info of neededNamespaceObjects) {\n      if (info.namespaceExportSymbol) continue;\n      const nsObj = [];\n      const exportsInfo = moduleGraph.getExportsInfo(info.module);\n\n      for (const exportInfo of exportsInfo.orderedExports) {\n        if (exportInfo.provided === false) continue;\n        const usedName = exportInfo.getUsedName(undefined, runtime);\n\n        if (usedName) {\n          const finalName = getFinalName(moduleGraph, info, [exportInfo.name], moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, false, undefined, info.module.buildMeta.strictHarmonyModule, true);\n          nsObj.push(`\\n  ${JSON.stringify(usedName)}: ${runtimeTemplate.returningFunction(finalName)}`);\n        }\n      }\n\n      const name = info.namespaceObjectName;\n      const defineGetters = nsObj.length > 0 ? `${RuntimeGlobals.definePropertyGetters}(${name}, {${nsObj.join(\",\")}\\n});\\n` : \"\";\n      if (nsObj.length > 0) runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);\n      namespaceObjectSources.set(info, `\n// NAMESPACE OBJECT: ${info.module.readableIdentifier(requestShortener)}\nvar ${name} = {};\n${RuntimeGlobals.makeNamespaceObject}(${name});\n${defineGetters}`);\n      runtimeRequirements.add(RuntimeGlobals.makeNamespaceObject);\n    } // define required namespace objects (must be before evaluation modules)\n\n\n    for (const info of modulesWithInfo) {\n      if (info.type === \"concatenated\") {\n        const source = namespaceObjectSources.get(info);\n        if (!source) continue;\n        result.add(source);\n      }\n    }\n\n    const chunkInitFragments = []; // evaluate modules in order\n\n    for (const rawInfo of modulesWithInfo) {\n      let name;\n      let isConditional = false;\n      const info = rawInfo.type === \"reference\" ? rawInfo.target : rawInfo;\n\n      switch (info.type) {\n        case \"concatenated\":\n          {\n            result.add(`\\n;// CONCATENATED MODULE: ${info.module.readableIdentifier(requestShortener)}\\n`);\n            result.add(info.source);\n\n            if (info.chunkInitFragments) {\n              for (const f of info.chunkInitFragments) chunkInitFragments.push(f);\n            }\n\n            if (info.runtimeRequirements) {\n              for (const r of info.runtimeRequirements) {\n                runtimeRequirements.add(r);\n              }\n            }\n\n            name = info.namespaceObjectName;\n            break;\n          }\n\n        case \"external\":\n          {\n            result.add(`\\n// EXTERNAL MODULE: ${info.module.readableIdentifier(requestShortener)}\\n`);\n            runtimeRequirements.add(RuntimeGlobals.require);\n            const {\n              runtimeCondition\n            } =\n            /** @type {ExternalModuleInfo | ReferenceToModuleInfo} */\n            rawInfo;\n            const condition = runtimeTemplate.runtimeConditionExpression({\n              chunkGraph,\n              runtimeCondition,\n              runtime,\n              runtimeRequirements\n            });\n\n            if (condition !== \"true\") {\n              isConditional = true;\n              result.add(`if (${condition}) {\\n`);\n            }\n\n            result.add(`var ${info.name} = __webpack_require__(${JSON.stringify(chunkGraph.getModuleId(info.module))});`);\n            name = info.name;\n            break;\n          }\n\n        default:\n          // @ts-expect-error never is expected here\n          throw new Error(`Unsupported concatenation entry type ${info.type}`);\n      }\n\n      if (info.interopNamespaceObjectUsed) {\n        runtimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject);\n        result.add(`\\nvar ${info.interopNamespaceObjectName} = /*#__PURE__*/${RuntimeGlobals.createFakeNamespaceObject}(${name}, 2);`);\n      }\n\n      if (info.interopNamespaceObject2Used) {\n        runtimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject);\n        result.add(`\\nvar ${info.interopNamespaceObject2Name} = /*#__PURE__*/${RuntimeGlobals.createFakeNamespaceObject}(${name});`);\n      }\n\n      if (info.interopDefaultAccessUsed) {\n        runtimeRequirements.add(RuntimeGlobals.compatGetDefaultExport);\n        result.add(`\\nvar ${info.interopDefaultAccessName} = /*#__PURE__*/${RuntimeGlobals.compatGetDefaultExport}(${name});`);\n      }\n\n      if (isConditional) {\n        result.add(\"\\n}\");\n      }\n    }\n\n    const data = new Map();\n    if (chunkInitFragments.length > 0) data.set(\"chunkInitFragments\", chunkInitFragments);\n    data.set(\"topLevelDeclarations\", topLevelDeclarations);\n    /** @type {CodeGenerationResult} */\n\n    const resultEntry = {\n      sources: new Map([[\"javascript\", new CachedSource(result)]]),\n      data,\n      runtimeRequirements\n    };\n    return resultEntry;\n  }\n  /**\n   * @param {Map<Module, ModuleInfo>} modulesMap modulesMap\n   * @param {ModuleInfo} info info\n   * @param {DependencyTemplates} dependencyTemplates dependencyTemplates\n   * @param {RuntimeTemplate} runtimeTemplate runtimeTemplate\n   * @param {ModuleGraph} moduleGraph moduleGraph\n   * @param {ChunkGraph} chunkGraph chunkGraph\n   * @param {RuntimeSpec} runtime runtime\n   * @param {CodeGenerationResults} codeGenerationResults codeGenerationResults\n   */\n\n\n  _analyseModule(modulesMap, info, dependencyTemplates, runtimeTemplate, moduleGraph, chunkGraph, runtime, codeGenerationResults) {\n    if (info.type === \"concatenated\") {\n      const m = info.module;\n\n      try {\n        // Create a concatenation scope to track and capture information\n        const concatenationScope = new ConcatenationScope(modulesMap, info); // TODO cache codeGeneration results\n\n        const codeGenResult = m.codeGeneration({\n          dependencyTemplates,\n          runtimeTemplate,\n          moduleGraph,\n          chunkGraph,\n          runtime,\n          concatenationScope,\n          codeGenerationResults\n        });\n        const source = codeGenResult.sources.get(\"javascript\");\n        const data = codeGenResult.data;\n        const chunkInitFragments = data && data.get(\"chunkInitFragments\");\n        const code = source.source().toString();\n        let ast;\n\n        try {\n          ast = JavascriptParser._parse(code, {\n            sourceType: \"module\"\n          });\n        } catch (err) {\n          if (err.loc && typeof err.loc === \"object\" && typeof err.loc.line === \"number\") {\n            const lineNumber = err.loc.line;\n            const lines = code.split(\"\\n\");\n            err.message += \"\\n| \" + lines.slice(Math.max(0, lineNumber - 3), lineNumber + 2).join(\"\\n| \");\n          }\n\n          throw err;\n        }\n\n        const scopeManager = eslintScope.analyze(ast, {\n          ecmaVersion: 6,\n          sourceType: \"module\",\n          optimistic: true,\n          ignoreEval: true,\n          impliedStrict: true\n        });\n        const globalScope = scopeManager.acquire(ast);\n        const moduleScope = globalScope.childScopes[0];\n        const resultSource = new ReplaceSource(source);\n        info.runtimeRequirements = codeGenResult.runtimeRequirements;\n        info.ast = ast;\n        info.internalSource = source;\n        info.source = resultSource;\n        info.chunkInitFragments = chunkInitFragments;\n        info.globalScope = globalScope;\n        info.moduleScope = moduleScope;\n      } catch (err) {\n        err.message += `\\nwhile analyzing module ${m.identifier()} for concatenation`;\n        throw err;\n      }\n    }\n  }\n  /**\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {[ModuleInfoOrReference[], Map<Module, ModuleInfo>]} module info items\n   */\n\n\n  _getModulesWithInfo(moduleGraph, runtime) {\n    const orderedConcatenationList = this._createConcatenationList(this.rootModule, this._modules, runtime, moduleGraph);\n    /** @type {Map<Module, ModuleInfo>} */\n\n\n    const map = new Map();\n    const list = orderedConcatenationList.map((info, index) => {\n      let item = map.get(info.module);\n\n      if (item === undefined) {\n        switch (info.type) {\n          case \"concatenated\":\n            item = {\n              type: \"concatenated\",\n              module: info.module,\n              index,\n              ast: undefined,\n              internalSource: undefined,\n              runtimeRequirements: undefined,\n              source: undefined,\n              globalScope: undefined,\n              moduleScope: undefined,\n              internalNames: new Map(),\n              exportMap: undefined,\n              rawExportMap: undefined,\n              namespaceExportSymbol: undefined,\n              namespaceObjectName: undefined,\n              interopNamespaceObjectUsed: false,\n              interopNamespaceObjectName: undefined,\n              interopNamespaceObject2Used: false,\n              interopNamespaceObject2Name: undefined,\n              interopDefaultAccessUsed: false,\n              interopDefaultAccessName: undefined\n            };\n            break;\n\n          case \"external\":\n            item = {\n              type: \"external\",\n              module: info.module,\n              runtimeCondition: info.runtimeCondition,\n              index,\n              name: undefined,\n              interopNamespaceObjectUsed: false,\n              interopNamespaceObjectName: undefined,\n              interopNamespaceObject2Used: false,\n              interopNamespaceObject2Name: undefined,\n              interopDefaultAccessUsed: false,\n              interopDefaultAccessName: undefined\n            };\n            break;\n\n          default:\n            throw new Error(`Unsupported concatenation entry type ${info.type}`);\n        }\n\n        map.set(item.module, item);\n        return item;\n      } else {\n        /** @type {ReferenceToModuleInfo} */\n        const ref = {\n          type: \"reference\",\n          runtimeCondition: info.runtimeCondition,\n          target: item\n        };\n        return ref;\n      }\n    });\n    return [list, map];\n  }\n\n  findNewName(oldName, usedNamed1, usedNamed2, extraInfo) {\n    let name = oldName;\n\n    if (name === ConcatenationScope.DEFAULT_EXPORT) {\n      name = \"\";\n    }\n\n    if (name === ConcatenationScope.NAMESPACE_OBJECT_EXPORT) {\n      name = \"namespaceObject\";\n    } // Remove uncool stuff\n\n\n    extraInfo = extraInfo.replace(/\\.+\\/|(\\/index)?\\.([a-zA-Z0-9]{1,4})($|\\s|\\?)|\\s*\\+\\s*\\d+\\s*modules/g, \"\");\n    const splittedInfo = extraInfo.split(\"/\");\n\n    while (splittedInfo.length) {\n      name = splittedInfo.pop() + (name ? \"_\" + name : \"\");\n      const nameIdent = Template.toIdentifier(name);\n      if (!usedNamed1.has(nameIdent) && (!usedNamed2 || !usedNamed2.has(nameIdent))) return nameIdent;\n    }\n\n    let i = 0;\n    let nameWithNumber = Template.toIdentifier(`${name}_${i}`);\n\n    while (usedNamed1.has(nameWithNumber) || usedNamed2 && usedNamed2.has(nameWithNumber)) {\n      i++;\n      nameWithNumber = Template.toIdentifier(`${name}_${i}`);\n    }\n\n    return nameWithNumber;\n  }\n  /**\n   * @param {Hash} hash the hash used to track dependencies\n   * @param {UpdateHashContext} context context\n   * @returns {void}\n   */\n\n\n  updateHash(hash, context) {\n    const {\n      chunkGraph,\n      runtime\n    } = context;\n\n    for (const info of this._createConcatenationList(this.rootModule, this._modules, intersectRuntime(runtime, this._runtime), chunkGraph.moduleGraph)) {\n      switch (info.type) {\n        case \"concatenated\":\n          info.module.updateHash(hash, context);\n          break;\n\n        case \"external\":\n          hash.update(`${chunkGraph.getModuleId(info.module)}`); // TODO runtimeCondition\n\n          break;\n      }\n    }\n\n    super.updateHash(hash, context);\n  }\n\n  static deserialize(context) {\n    const obj = new ConcatenatedModule({\n      identifier: undefined,\n      rootModule: undefined,\n      modules: undefined,\n      runtime: undefined\n    });\n    obj.deserialize(context);\n    return obj;\n  }\n\n}\n\nmakeSerializable(ConcatenatedModule, \"webpack/lib/optimize/ConcatenatedModule\");\nmodule.exports = ConcatenatedModule;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/optimize/ConcatenatedModule.js"],"names":["eslintScope","require","Referencer","CachedSource","ConcatSource","ReplaceSource","ConcatenationScope","UsageState","Module","RuntimeGlobals","Template","HarmonyImportDependency","JavascriptParser","equals","LazySet","concatComparators","keepOriginalOrder","createHash","makePathsRelative","makeSerializable","propertyAccess","filterRuntime","intersectRuntime","mergeRuntimeCondition","mergeRuntimeConditionNonFalse","runtimeConditionToString","subtractRuntimeCondition","ReferencerClass","prototype","PropertyDefinition","Property","RESERVED_NAMES","Set","DEFAULT_EXPORT","NAMESPACE_OBJECT_EXPORT","join","split","bySourceOrder","a","b","aOrder","sourceOrder","bOrder","isNaN","joinIterableWithComma","iterable","str","first","item","getFinalBinding","moduleGraph","info","exportName","moduleToInfoMap","runtime","requestShortener","runtimeTemplate","neededNamespaceObjects","asCall","strictHarmonyModule","asiSafe","alreadyVisited","exportsType","module","getExportsType","length","interopNamespaceObject2Used","rawName","interopNamespaceObject2Name","ids","interopNamespaceObjectUsed","interopNamespaceObjectName","Error","slice","exportId","interopDefaultAccessUsed","defaultExport","interopDefaultAccessName","type","add","namespaceObjectName","name","exportsInfo","getExportsInfo","exportInfo","getExportInfo","has","provided","directExport","exportMap","get","usedName","getUsedName","rawExport","rawExportMap","reexport","findTarget","readableIdentifier","Array","from","m","refInfo","export","buildMeta","namespaceExportSymbol","used","comment","toNormalComment","getFinalName","callContext","binding","reference","isPropertyAccess","internalNames","symbol","addScopeSymbols","s","nameSet","scopeSet1","scopeSet2","scope","variable","variables","upper","getAllReferences","set","references","identifiers","childScopes","innerVar","some","id","concat","getPathInAst","ast","node","nr","range","enterNode","n","undefined","r","path","push","isArray","i","enterResult","keys","Object","value","pathResult","TYPES","ConcatenatedModule","create","rootModule","modules","associatedObjectForCache","hashFunction","identifier","_createIdentifier","constructor","layer","_identifier","_modules","_runtime","factoryMeta","updateCacheModule","getSourceTypes","size","libIdent","options","nameForCondition","getSideEffectsConnectionState","build","compilation","resolver","fs","callback","buildInfo","strict","cacheable","moduleArgument","exportsArgument","fileDependencies","contextDependencies","missingDependencies","topLevelDeclarations","assets","clearDependenciesAndBlocks","clearWarningsAndErrors","d","dependencies","filter","dep","getModule","blocks","warnings","getWarnings","warning","addWarning","errors","getErrors","error","addError","decl","assign","assetsInfo","Map","key","_createConcatenationList","modulesSet","list","existingEntries","getConcatenatedImports","connections","getOutgoingConnections","c","connection","dependency","resolvedOriginModule","isTargetActive","map","sort","referencesMap","runtimeCondition","entry","values","enterModule","existingEntry","imports","reducedRuntimeCondition","lastItem","cachedMakePathsRelative","bindContextCache","context","hash","update","digest","addCacheDependencies","buildDependencies","codeGeneration","dependencyTemplates","chunkGraph","generationRuntime","codeGenerationResults","runtimeRequirements","modulesWithInfo","_getModulesWithInfo","_analyseModule","allUsedNames","usedNamesInScopeInfo","getUsedNamesInScopeInfo","usedNames","alreadyCheckedScopes","ignoredScopes","moduleScope","superClassCache","WeakMap","getSuperClassExpressions","cacheEntry","superClassExpressions","childScope","block","superClass","globalScope","through","isModuleReference","match","matchModuleReference","referencedInfo","index","expr","namespaceObjectUsedNames","ref","newName","findNewName","source","allIdentifiers","maybeProperty","left","shorthand","insert","replace","externalName","externalNameInterop","defaultObject","finalName","call","directImport","exportsMap","unusedExports","rootInfo","orderedExports","isReexport","e","message","result","otherExportsInfo","getUsed","Unused","defineEsModuleFlagStatement","exports","definePropertyGetters","definitions","JSON","stringify","returningFunction","namespaceObjectSources","nsObj","defineGetters","makeNamespaceObject","chunkInitFragments","rawInfo","isConditional","target","f","condition","runtimeConditionExpression","getModuleId","createFakeNamespaceObject","compatGetDefaultExport","data","resultEntry","sources","modulesMap","concatenationScope","codeGenResult","code","toString","_parse","sourceType","err","loc","line","lineNumber","lines","Math","max","scopeManager","analyze","ecmaVersion","optimistic","ignoreEval","impliedStrict","acquire","resultSource","internalSource","orderedConcatenationList","oldName","usedNamed1","usedNamed2","extraInfo","splittedInfo","pop","nameIdent","toIdentifier","nameWithNumber","updateHash","deserialize","obj"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst eslintScope = require(\"eslint-scope\");\nconst Referencer = require(\"eslint-scope/lib/referencer\");\nconst {\n\tCachedSource,\n\tConcatSource,\n\tReplaceSource\n} = require(\"webpack-sources\");\nconst ConcatenationScope = require(\"../ConcatenationScope\");\nconst { UsageState } = require(\"../ExportsInfo\");\nconst Module = require(\"../Module\");\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst Template = require(\"../Template\");\nconst HarmonyImportDependency = require(\"../dependencies/HarmonyImportDependency\");\nconst JavascriptParser = require(\"../javascript/JavascriptParser\");\nconst { equals } = require(\"../util/ArrayHelpers\");\nconst LazySet = require(\"../util/LazySet\");\nconst { concatComparators, keepOriginalOrder } = require(\"../util/comparators\");\nconst createHash = require(\"../util/createHash\");\nconst { makePathsRelative } = require(\"../util/identifier\");\nconst makeSerializable = require(\"../util/makeSerializable\");\nconst propertyAccess = require(\"../util/propertyAccess\");\nconst {\n\tfilterRuntime,\n\tintersectRuntime,\n\tmergeRuntimeCondition,\n\tmergeRuntimeConditionNonFalse,\n\truntimeConditionToString,\n\tsubtractRuntimeCondition\n} = require(\"../util/runtime\");\n\n/** @typedef {import(\"eslint-scope\").Scope} Scope */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../../declarations/WebpackOptions\").WebpackOptionsNormalized} WebpackOptions */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../CodeGenerationResults\")} CodeGenerationResults */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../Dependency\").UpdateHashContext} UpdateHashContext */\n/** @typedef {import(\"../DependencyTemplate\").DependencyTemplateContext} DependencyTemplateContext */\n/** @typedef {import(\"../DependencyTemplates\")} DependencyTemplates */\n/** @typedef {import(\"../ExportsInfo\").ExportInfo} ExportInfo */\n/** @template T @typedef {import(\"../InitFragment\")<T>} InitFragment */\n/** @typedef {import(\"../Module\").CodeGenerationContext} CodeGenerationContext */\n/** @typedef {import(\"../Module\").CodeGenerationResult} CodeGenerationResult */\n/** @typedef {import(\"../Module\").LibIdentOptions} LibIdentOptions */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n/** @typedef {import(\"../ModuleGraphConnection\").ConnectionState} ConnectionState */\n/** @typedef {import(\"../RequestShortener\")} RequestShortener */\n/** @typedef {import(\"../ResolverFactory\").ResolverWithOptions} ResolverWithOptions */\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"../WebpackError\")} WebpackError */\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").ChunkRenderContext} ChunkRenderContext */\n/** @typedef {import(\"../util/Hash\")} Hash */\n/** @typedef {typeof import(\"../util/Hash\")} HashConstructor */\n/** @typedef {import(\"../util/fs\").InputFileSystem} InputFileSystem */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n// fix eslint-scope to support class properties correctly\n// cspell:word Referencer\nconst ReferencerClass = Referencer;\nif (!ReferencerClass.prototype.PropertyDefinition) {\n\tReferencerClass.prototype.PropertyDefinition =\n\t\tReferencerClass.prototype.Property;\n}\n\n/**\n * @typedef {Object} ReexportInfo\n * @property {Module} module\n * @property {string[]} export\n */\n\n/** @typedef {RawBinding | SymbolBinding} Binding */\n\n/**\n * @typedef {Object} RawBinding\n * @property {ModuleInfo} info\n * @property {string} rawName\n * @property {string=} comment\n * @property {string[]} ids\n * @property {string[]} exportName\n */\n\n/**\n * @typedef {Object} SymbolBinding\n * @property {ConcatenatedModuleInfo} info\n * @property {string} name\n * @property {string=} comment\n * @property {string[]} ids\n * @property {string[]} exportName\n */\n\n/** @typedef {ConcatenatedModuleInfo | ExternalModuleInfo } ModuleInfo */\n/** @typedef {ConcatenatedModuleInfo | ExternalModuleInfo | ReferenceToModuleInfo } ModuleInfoOrReference */\n\n/**\n * @typedef {Object} ConcatenatedModuleInfo\n * @property {\"concatenated\"} type\n * @property {Module} module\n * @property {number} index\n * @property {Object} ast\n * @property {Source} internalSource\n * @property {ReplaceSource} source\n * @property {InitFragment<ChunkRenderContext>[]=} chunkInitFragments\n * @property {Iterable<string>} runtimeRequirements\n * @property {Scope} globalScope\n * @property {Scope} moduleScope\n * @property {Map<string, string>} internalNames\n * @property {Map<string, string>} exportMap\n * @property {Map<string, string>} rawExportMap\n * @property {string=} namespaceExportSymbol\n * @property {string} namespaceObjectName\n * @property {boolean} interopNamespaceObjectUsed\n * @property {string} interopNamespaceObjectName\n * @property {boolean} interopNamespaceObject2Used\n * @property {string} interopNamespaceObject2Name\n * @property {boolean} interopDefaultAccessUsed\n * @property {string} interopDefaultAccessName\n */\n\n/**\n * @typedef {Object} ExternalModuleInfo\n * @property {\"external\"} type\n * @property {Module} module\n * @property {RuntimeSpec | boolean} runtimeCondition\n * @property {number} index\n * @property {string} name\n * @property {boolean} interopNamespaceObjectUsed\n * @property {string} interopNamespaceObjectName\n * @property {boolean} interopNamespaceObject2Used\n * @property {string} interopNamespaceObject2Name\n * @property {boolean} interopDefaultAccessUsed\n * @property {string} interopDefaultAccessName\n */\n\n/**\n * @typedef {Object} ReferenceToModuleInfo\n * @property {\"reference\"} type\n * @property {RuntimeSpec | boolean} runtimeCondition\n * @property {ConcatenatedModuleInfo | ExternalModuleInfo} target\n */\n\nconst RESERVED_NAMES = new Set(\n\t[\n\t\t// internal names (should always be renamed)\n\t\tConcatenationScope.DEFAULT_EXPORT,\n\t\tConcatenationScope.NAMESPACE_OBJECT_EXPORT,\n\n\t\t// keywords\n\t\t\"abstract,arguments,async,await,boolean,break,byte,case,catch,char,class,const,continue\",\n\t\t\"debugger,default,delete,do,double,else,enum,eval,export,extends,false,final,finally,float\",\n\t\t\"for,function,goto,if,implements,import,in,instanceof,int,interface,let,long,native,new,null\",\n\t\t\"package,private,protected,public,return,short,static,super,switch,synchronized,this,throw\",\n\t\t\"throws,transient,true,try,typeof,var,void,volatile,while,with,yield\",\n\n\t\t// commonjs/amd\n\t\t\"module,__dirname,__filename,exports,require,define\",\n\n\t\t// js globals\n\t\t\"Array,Date,eval,function,hasOwnProperty,Infinity,isFinite,isNaN,isPrototypeOf,length,Math\",\n\t\t\"NaN,name,Number,Object,prototype,String,toString,undefined,valueOf\",\n\n\t\t// browser globals\n\t\t\"alert,all,anchor,anchors,area,assign,blur,button,checkbox,clearInterval,clearTimeout\",\n\t\t\"clientInformation,close,closed,confirm,constructor,crypto,decodeURI,decodeURIComponent\",\n\t\t\"defaultStatus,document,element,elements,embed,embeds,encodeURI,encodeURIComponent,escape\",\n\t\t\"event,fileUpload,focus,form,forms,frame,innerHeight,innerWidth,layer,layers,link,location\",\n\t\t\"mimeTypes,navigate,navigator,frames,frameRate,hidden,history,image,images,offscreenBuffering\",\n\t\t\"open,opener,option,outerHeight,outerWidth,packages,pageXOffset,pageYOffset,parent,parseFloat\",\n\t\t\"parseInt,password,pkcs11,plugin,prompt,propertyIsEnum,radio,reset,screenX,screenY,scroll\",\n\t\t\"secure,select,self,setInterval,setTimeout,status,submit,taint,text,textarea,top,unescape\",\n\t\t\"untaint,window\",\n\n\t\t// window events\n\t\t\"onblur,onclick,onerror,onfocus,onkeydown,onkeypress,onkeyup,onmouseover,onload,onmouseup,onmousedown,onsubmit\"\n\t]\n\t\t.join(\",\")\n\t\t.split(\",\")\n);\n\nconst bySourceOrder = (a, b) => {\n\tconst aOrder = a.sourceOrder;\n\tconst bOrder = b.sourceOrder;\n\tif (isNaN(aOrder)) {\n\t\tif (!isNaN(bOrder)) {\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tif (isNaN(bOrder)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (aOrder !== bOrder) {\n\t\t\treturn aOrder < bOrder ? -1 : 1;\n\t\t}\n\t}\n\treturn 0;\n};\n\nconst joinIterableWithComma = iterable => {\n\t// This is more performant than Array.from().join(\", \")\n\t// as it doesn't create an array\n\tlet str = \"\";\n\tlet first = true;\n\tfor (const item of iterable) {\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t} else {\n\t\t\tstr += \", \";\n\t\t}\n\t\tstr += item;\n\t}\n\treturn str;\n};\n\n/**\n * @typedef {Object} ConcatenationEntry\n * @property {\"concatenated\" | \"external\"} type\n * @property {Module} module\n * @property {RuntimeSpec | boolean} runtimeCondition\n */\n\n/**\n * @param {ModuleGraph} moduleGraph the module graph\n * @param {ModuleInfo} info module info\n * @param {string[]} exportName exportName\n * @param {Map<Module, ModuleInfo>} moduleToInfoMap moduleToInfoMap\n * @param {RuntimeSpec} runtime for which runtime\n * @param {RequestShortener} requestShortener the request shortener\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {Set<ConcatenatedModuleInfo>} neededNamespaceObjects modules for which a namespace object should be generated\n * @param {boolean} asCall asCall\n * @param {boolean} strictHarmonyModule strictHarmonyModule\n * @param {boolean | undefined} asiSafe asiSafe\n * @param {Set<ExportInfo>} alreadyVisited alreadyVisited\n * @returns {Binding} the final variable\n */\nconst getFinalBinding = (\n\tmoduleGraph,\n\tinfo,\n\texportName,\n\tmoduleToInfoMap,\n\truntime,\n\trequestShortener,\n\truntimeTemplate,\n\tneededNamespaceObjects,\n\tasCall,\n\tstrictHarmonyModule,\n\tasiSafe,\n\talreadyVisited = new Set()\n) => {\n\tconst exportsType = info.module.getExportsType(\n\t\tmoduleGraph,\n\t\tstrictHarmonyModule\n\t);\n\tif (exportName.length === 0) {\n\t\tswitch (exportsType) {\n\t\t\tcase \"default-only\":\n\t\t\t\tinfo.interopNamespaceObject2Used = true;\n\t\t\t\treturn {\n\t\t\t\t\tinfo,\n\t\t\t\t\trawName: info.interopNamespaceObject2Name,\n\t\t\t\t\tids: exportName,\n\t\t\t\t\texportName\n\t\t\t\t};\n\t\t\tcase \"default-with-named\":\n\t\t\t\tinfo.interopNamespaceObjectUsed = true;\n\t\t\t\treturn {\n\t\t\t\t\tinfo,\n\t\t\t\t\trawName: info.interopNamespaceObjectName,\n\t\t\t\t\tids: exportName,\n\t\t\t\t\texportName\n\t\t\t\t};\n\t\t\tcase \"namespace\":\n\t\t\tcase \"dynamic\":\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected exportsType ${exportsType}`);\n\t\t}\n\t} else {\n\t\tswitch (exportsType) {\n\t\t\tcase \"namespace\":\n\t\t\t\tbreak;\n\t\t\tcase \"default-with-named\":\n\t\t\t\tswitch (exportName[0]) {\n\t\t\t\t\tcase \"default\":\n\t\t\t\t\t\texportName = exportName.slice(1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"__esModule\":\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\trawName: \"/* __esModule */true\",\n\t\t\t\t\t\t\tids: exportName.slice(1),\n\t\t\t\t\t\t\texportName\n\t\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"default-only\": {\n\t\t\t\tconst exportId = exportName[0];\n\t\t\t\tif (exportId === \"__esModule\") {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tinfo,\n\t\t\t\t\t\trawName: \"/* __esModule */true\",\n\t\t\t\t\t\tids: exportName.slice(1),\n\t\t\t\t\t\texportName\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\texportName = exportName.slice(1);\n\t\t\t\tif (exportId !== \"default\") {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tinfo,\n\t\t\t\t\t\trawName:\n\t\t\t\t\t\t\t\"/* non-default import from default-exporting module */undefined\",\n\t\t\t\t\t\tids: exportName,\n\t\t\t\t\t\texportName\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"dynamic\":\n\t\t\t\tswitch (exportName[0]) {\n\t\t\t\t\tcase \"default\": {\n\t\t\t\t\t\texportName = exportName.slice(1);\n\t\t\t\t\t\tinfo.interopDefaultAccessUsed = true;\n\t\t\t\t\t\tconst defaultExport = asCall\n\t\t\t\t\t\t\t? `${info.interopDefaultAccessName}()`\n\t\t\t\t\t\t\t: asiSafe\n\t\t\t\t\t\t\t? `(${info.interopDefaultAccessName}())`\n\t\t\t\t\t\t\t: asiSafe === false\n\t\t\t\t\t\t\t? `;(${info.interopDefaultAccessName}())`\n\t\t\t\t\t\t\t: `${info.interopDefaultAccessName}.a`;\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\trawName: defaultExport,\n\t\t\t\t\t\t\tids: exportName,\n\t\t\t\t\t\t\texportName\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tcase \"__esModule\":\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\trawName: \"/* __esModule */true\",\n\t\t\t\t\t\t\tids: exportName.slice(1),\n\t\t\t\t\t\t\texportName\n\t\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected exportsType ${exportsType}`);\n\t\t}\n\t}\n\tif (exportName.length === 0) {\n\t\tswitch (info.type) {\n\t\t\tcase \"concatenated\":\n\t\t\t\tneededNamespaceObjects.add(info);\n\t\t\t\treturn {\n\t\t\t\t\tinfo,\n\t\t\t\t\trawName: info.namespaceObjectName,\n\t\t\t\t\tids: exportName,\n\t\t\t\t\texportName\n\t\t\t\t};\n\t\t\tcase \"external\":\n\t\t\t\treturn { info, rawName: info.name, ids: exportName, exportName };\n\t\t}\n\t}\n\tconst exportsInfo = moduleGraph.getExportsInfo(info.module);\n\tconst exportInfo = exportsInfo.getExportInfo(exportName[0]);\n\tif (alreadyVisited.has(exportInfo)) {\n\t\treturn {\n\t\t\tinfo,\n\t\t\trawName: \"/* circular reexport */ Object(function x() { x() }())\",\n\t\t\tids: [],\n\t\t\texportName\n\t\t};\n\t}\n\talreadyVisited.add(exportInfo);\n\tswitch (info.type) {\n\t\tcase \"concatenated\": {\n\t\t\tconst exportId = exportName[0];\n\t\t\tif (exportInfo.provided === false) {\n\t\t\t\t// It's not provided, but it could be on the prototype\n\t\t\t\tneededNamespaceObjects.add(info);\n\t\t\t\treturn {\n\t\t\t\t\tinfo,\n\t\t\t\t\trawName: info.namespaceObjectName,\n\t\t\t\t\tids: exportName,\n\t\t\t\t\texportName\n\t\t\t\t};\n\t\t\t}\n\t\t\tconst directExport = info.exportMap && info.exportMap.get(exportId);\n\t\t\tif (directExport) {\n\t\t\t\tconst usedName = /** @type {string[]} */ (\n\t\t\t\t\texportsInfo.getUsedName(exportName, runtime)\n\t\t\t\t);\n\t\t\t\tif (!usedName) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tinfo,\n\t\t\t\t\t\trawName: \"/* unused export */ undefined\",\n\t\t\t\t\t\tids: exportName.slice(1),\n\t\t\t\t\t\texportName\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tinfo,\n\t\t\t\t\tname: directExport,\n\t\t\t\t\tids: usedName.slice(1),\n\t\t\t\t\texportName\n\t\t\t\t};\n\t\t\t}\n\t\t\tconst rawExport = info.rawExportMap && info.rawExportMap.get(exportId);\n\t\t\tif (rawExport) {\n\t\t\t\treturn {\n\t\t\t\t\tinfo,\n\t\t\t\t\trawName: rawExport,\n\t\t\t\t\tids: exportName.slice(1),\n\t\t\t\t\texportName\n\t\t\t\t};\n\t\t\t}\n\t\t\tconst reexport = exportInfo.findTarget(moduleGraph, module =>\n\t\t\t\tmoduleToInfoMap.has(module)\n\t\t\t);\n\t\t\tif (reexport === false) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Target module of reexport from '${info.module.readableIdentifier(\n\t\t\t\t\t\trequestShortener\n\t\t\t\t\t)}' is not part of the concatenation (export '${exportId}')\\nModules in the concatenation:\\n${Array.from(\n\t\t\t\t\t\tmoduleToInfoMap,\n\t\t\t\t\t\t([m, info]) =>\n\t\t\t\t\t\t\t` * ${info.type} ${m.readableIdentifier(requestShortener)}`\n\t\t\t\t\t).join(\"\\n\")}`\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (reexport) {\n\t\t\t\tconst refInfo = moduleToInfoMap.get(reexport.module);\n\t\t\t\treturn getFinalBinding(\n\t\t\t\t\tmoduleGraph,\n\t\t\t\t\trefInfo,\n\t\t\t\t\treexport.export\n\t\t\t\t\t\t? [...reexport.export, ...exportName.slice(1)]\n\t\t\t\t\t\t: exportName.slice(1),\n\t\t\t\t\tmoduleToInfoMap,\n\t\t\t\t\truntime,\n\t\t\t\t\trequestShortener,\n\t\t\t\t\truntimeTemplate,\n\t\t\t\t\tneededNamespaceObjects,\n\t\t\t\t\tasCall,\n\t\t\t\t\tinfo.module.buildMeta.strictHarmonyModule,\n\t\t\t\t\tasiSafe,\n\t\t\t\t\talreadyVisited\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (info.namespaceExportSymbol) {\n\t\t\t\tconst usedName = /** @type {string[]} */ (\n\t\t\t\t\texportsInfo.getUsedName(exportName, runtime)\n\t\t\t\t);\n\t\t\t\treturn {\n\t\t\t\t\tinfo,\n\t\t\t\t\trawName: info.namespaceObjectName,\n\t\t\t\t\tids: usedName,\n\t\t\t\t\texportName\n\t\t\t\t};\n\t\t\t}\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot get final name for export '${exportName.join(\n\t\t\t\t\t\".\"\n\t\t\t\t)}' of ${info.module.readableIdentifier(requestShortener)}`\n\t\t\t);\n\t\t}\n\n\t\tcase \"external\": {\n\t\t\tconst used = /** @type {string[]} */ (\n\t\t\t\texportsInfo.getUsedName(exportName, runtime)\n\t\t\t);\n\t\t\tif (!used) {\n\t\t\t\treturn {\n\t\t\t\t\tinfo,\n\t\t\t\t\trawName: \"/* unused export */ undefined\",\n\t\t\t\t\tids: exportName.slice(1),\n\t\t\t\t\texportName\n\t\t\t\t};\n\t\t\t}\n\t\t\tconst comment = equals(used, exportName)\n\t\t\t\t? \"\"\n\t\t\t\t: Template.toNormalComment(`${exportName.join(\".\")}`);\n\t\t\treturn { info, rawName: info.name + comment, ids: used, exportName };\n\t\t}\n\t}\n};\n\n/**\n * @param {ModuleGraph} moduleGraph the module graph\n * @param {ModuleInfo} info module info\n * @param {string[]} exportName exportName\n * @param {Map<Module, ModuleInfo>} moduleToInfoMap moduleToInfoMap\n * @param {RuntimeSpec} runtime for which runtime\n * @param {RequestShortener} requestShortener the request shortener\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {Set<ConcatenatedModuleInfo>} neededNamespaceObjects modules for which a namespace object should be generated\n * @param {boolean} asCall asCall\n * @param {boolean} callContext callContext\n * @param {boolean} strictHarmonyModule strictHarmonyModule\n * @param {boolean | undefined} asiSafe asiSafe\n * @returns {string} the final name\n */\nconst getFinalName = (\n\tmoduleGraph,\n\tinfo,\n\texportName,\n\tmoduleToInfoMap,\n\truntime,\n\trequestShortener,\n\truntimeTemplate,\n\tneededNamespaceObjects,\n\tasCall,\n\tcallContext,\n\tstrictHarmonyModule,\n\tasiSafe\n) => {\n\tconst binding = getFinalBinding(\n\t\tmoduleGraph,\n\t\tinfo,\n\t\texportName,\n\t\tmoduleToInfoMap,\n\t\truntime,\n\t\trequestShortener,\n\t\truntimeTemplate,\n\t\tneededNamespaceObjects,\n\t\tasCall,\n\t\tstrictHarmonyModule,\n\t\tasiSafe\n\t);\n\t{\n\t\tconst { ids, comment } = binding;\n\t\tlet reference;\n\t\tlet isPropertyAccess;\n\t\tif (\"rawName\" in binding) {\n\t\t\treference = `${binding.rawName}${comment || \"\"}${propertyAccess(ids)}`;\n\t\t\tisPropertyAccess = ids.length > 0;\n\t\t} else {\n\t\t\tconst { info, name: exportId } = binding;\n\t\t\tconst name = info.internalNames.get(exportId);\n\t\t\tif (!name) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`The export \"${exportId}\" in \"${info.module.readableIdentifier(\n\t\t\t\t\t\trequestShortener\n\t\t\t\t\t)}\" has no internal name (existing names: ${\n\t\t\t\t\t\tArray.from(\n\t\t\t\t\t\t\tinfo.internalNames,\n\t\t\t\t\t\t\t([name, symbol]) => `${name}: ${symbol}`\n\t\t\t\t\t\t).join(\", \") || \"none\"\n\t\t\t\t\t})`\n\t\t\t\t);\n\t\t\t}\n\t\t\treference = `${name}${comment || \"\"}${propertyAccess(ids)}`;\n\t\t\tisPropertyAccess = ids.length > 1;\n\t\t}\n\t\tif (isPropertyAccess && asCall && callContext === false) {\n\t\t\treturn asiSafe\n\t\t\t\t? `(0,${reference})`\n\t\t\t\t: asiSafe === false\n\t\t\t\t? `;(0,${reference})`\n\t\t\t\t: `/*#__PURE__*/Object(${reference})`;\n\t\t}\n\t\treturn reference;\n\t}\n};\n\nconst addScopeSymbols = (s, nameSet, scopeSet1, scopeSet2) => {\n\tlet scope = s;\n\twhile (scope) {\n\t\tif (scopeSet1.has(scope)) break;\n\t\tif (scopeSet2.has(scope)) break;\n\t\tscopeSet1.add(scope);\n\t\tfor (const variable of scope.variables) {\n\t\t\tnameSet.add(variable.name);\n\t\t}\n\t\tscope = scope.upper;\n\t}\n};\n\nconst getAllReferences = variable => {\n\tlet set = variable.references;\n\t// Look for inner scope variables too (like in class Foo { t() { Foo } })\n\tconst identifiers = new Set(variable.identifiers);\n\tfor (const scope of variable.scope.childScopes) {\n\t\tfor (const innerVar of scope.variables) {\n\t\t\tif (innerVar.identifiers.some(id => identifiers.has(id))) {\n\t\t\t\tset = set.concat(innerVar.references);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn set;\n};\n\nconst getPathInAst = (ast, node) => {\n\tif (ast === node) {\n\t\treturn [];\n\t}\n\n\tconst nr = node.range;\n\n\tconst enterNode = n => {\n\t\tif (!n) return undefined;\n\t\tconst r = n.range;\n\t\tif (r) {\n\t\t\tif (r[0] <= nr[0] && r[1] >= nr[1]) {\n\t\t\t\tconst path = getPathInAst(n, node);\n\t\t\t\tif (path) {\n\t\t\t\t\tpath.push(n);\n\t\t\t\t\treturn path;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t};\n\n\tif (Array.isArray(ast)) {\n\t\tfor (let i = 0; i < ast.length; i++) {\n\t\t\tconst enterResult = enterNode(ast[i]);\n\t\t\tif (enterResult !== undefined) return enterResult;\n\t\t}\n\t} else if (ast && typeof ast === \"object\") {\n\t\tconst keys = Object.keys(ast);\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst value = ast[keys[i]];\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tconst pathResult = getPathInAst(value, node);\n\t\t\t\tif (pathResult !== undefined) return pathResult;\n\t\t\t} else if (value && typeof value === \"object\") {\n\t\t\t\tconst enterResult = enterNode(value);\n\t\t\t\tif (enterResult !== undefined) return enterResult;\n\t\t\t}\n\t\t}\n\t}\n};\n\nconst TYPES = new Set([\"javascript\"]);\n\nclass ConcatenatedModule extends Module {\n\t/**\n\t * @param {Module} rootModule the root module of the concatenation\n\t * @param {Set<Module>} modules all modules in the concatenation (including the root module)\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {Object=} associatedObjectForCache object for caching\n\t * @param {string | HashConstructor=} hashFunction hash function to use\n\t * @returns {ConcatenatedModule} the module\n\t */\n\tstatic create(\n\t\trootModule,\n\t\tmodules,\n\t\truntime,\n\t\tassociatedObjectForCache,\n\t\thashFunction = \"md4\"\n\t) {\n\t\tconst identifier = ConcatenatedModule._createIdentifier(\n\t\t\trootModule,\n\t\t\tmodules,\n\t\t\tassociatedObjectForCache,\n\t\t\thashFunction\n\t\t);\n\t\treturn new ConcatenatedModule({\n\t\t\tidentifier,\n\t\t\trootModule,\n\t\t\tmodules,\n\t\t\truntime\n\t\t});\n\t}\n\n\t/**\n\t * @param {Object} options options\n\t * @param {string} options.identifier the identifier of the module\n\t * @param {Module=} options.rootModule the root module of the concatenation\n\t * @param {RuntimeSpec} options.runtime the selected runtime\n\t * @param {Set<Module>=} options.modules all concatenated modules\n\t */\n\tconstructor({ identifier, rootModule, modules, runtime }) {\n\t\tsuper(\"javascript/esm\", null, rootModule && rootModule.layer);\n\n\t\t// Info from Factory\n\t\t/** @type {string} */\n\t\tthis._identifier = identifier;\n\t\t/** @type {Module} */\n\t\tthis.rootModule = rootModule;\n\t\t/** @type {Set<Module>} */\n\t\tthis._modules = modules;\n\t\tthis._runtime = runtime;\n\t\tthis.factoryMeta = rootModule && rootModule.factoryMeta;\n\t}\n\n\t/**\n\t * Assuming this module is in the cache. Update the (cached) module with\n\t * the fresh module from the factory. Usually updates internal references\n\t * and properties.\n\t * @param {Module} module fresh module\n\t * @returns {void}\n\t */\n\tupdateCacheModule(module) {\n\t\tthrow new Error(\"Must not be called\");\n\t}\n\n\t/**\n\t * @returns {Set<string>} types available (do not mutate)\n\t */\n\tgetSourceTypes() {\n\t\treturn TYPES;\n\t}\n\n\tget modules() {\n\t\treturn Array.from(this._modules);\n\t}\n\n\t/**\n\t * @returns {string} a unique identifier of the module\n\t */\n\tidentifier() {\n\t\treturn this._identifier;\n\t}\n\n\t/**\n\t * @param {RequestShortener} requestShortener the request shortener\n\t * @returns {string} a user readable identifier of the module\n\t */\n\treadableIdentifier(requestShortener) {\n\t\treturn (\n\t\t\tthis.rootModule.readableIdentifier(requestShortener) +\n\t\t\t` + ${this._modules.size - 1} modules`\n\t\t);\n\t}\n\n\t/**\n\t * @param {LibIdentOptions} options options\n\t * @returns {string | null} an identifier for library inclusion\n\t */\n\tlibIdent(options) {\n\t\treturn this.rootModule.libIdent(options);\n\t}\n\n\t/**\n\t * @returns {string | null} absolute path which should be used for condition matching (usually the resource path)\n\t */\n\tnameForCondition() {\n\t\treturn this.rootModule.nameForCondition();\n\t}\n\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @returns {ConnectionState} how this module should be connected to referencing modules when consumed for side-effects only\n\t */\n\tgetSideEffectsConnectionState(moduleGraph) {\n\t\treturn this.rootModule.getSideEffectsConnectionState(moduleGraph);\n\t}\n\n\t/**\n\t * @param {WebpackOptions} options webpack options\n\t * @param {Compilation} compilation the compilation\n\t * @param {ResolverWithOptions} resolver the resolver\n\t * @param {InputFileSystem} fs the file system\n\t * @param {function(WebpackError=): void} callback callback function\n\t * @returns {void}\n\t */\n\tbuild(options, compilation, resolver, fs, callback) {\n\t\tconst { rootModule } = this;\n\t\tthis.buildInfo = {\n\t\t\tstrict: true,\n\t\t\tcacheable: true,\n\t\t\tmoduleArgument: rootModule.buildInfo.moduleArgument,\n\t\t\texportsArgument: rootModule.buildInfo.exportsArgument,\n\t\t\tfileDependencies: new LazySet(),\n\t\t\tcontextDependencies: new LazySet(),\n\t\t\tmissingDependencies: new LazySet(),\n\t\t\ttopLevelDeclarations: new Set(),\n\t\t\tassets: undefined\n\t\t};\n\t\tthis.buildMeta = rootModule.buildMeta;\n\t\tthis.clearDependenciesAndBlocks();\n\t\tthis.clearWarningsAndErrors();\n\n\t\tfor (const m of this._modules) {\n\t\t\t// populate cacheable\n\t\t\tif (!m.buildInfo.cacheable) {\n\t\t\t\tthis.buildInfo.cacheable = false;\n\t\t\t}\n\n\t\t\t// populate dependencies\n\t\t\tfor (const d of m.dependencies.filter(\n\t\t\t\tdep =>\n\t\t\t\t\t!(dep instanceof HarmonyImportDependency) ||\n\t\t\t\t\t!this._modules.has(compilation.moduleGraph.getModule(dep))\n\t\t\t)) {\n\t\t\t\tthis.dependencies.push(d);\n\t\t\t}\n\t\t\t// populate blocks\n\t\t\tfor (const d of m.blocks) {\n\t\t\t\tthis.blocks.push(d);\n\t\t\t}\n\n\t\t\t// populate warnings\n\t\t\tconst warnings = m.getWarnings();\n\t\t\tif (warnings !== undefined) {\n\t\t\t\tfor (const warning of warnings) {\n\t\t\t\t\tthis.addWarning(warning);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// populate errors\n\t\t\tconst errors = m.getErrors();\n\t\t\tif (errors !== undefined) {\n\t\t\t\tfor (const error of errors) {\n\t\t\t\t\tthis.addError(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// populate topLevelDeclarations\n\t\t\tif (m.buildInfo.topLevelDeclarations) {\n\t\t\t\tconst topLevelDeclarations = this.buildInfo.topLevelDeclarations;\n\t\t\t\tif (topLevelDeclarations !== undefined) {\n\t\t\t\t\tfor (const decl of m.buildInfo.topLevelDeclarations) {\n\t\t\t\t\t\ttopLevelDeclarations.add(decl);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.buildInfo.topLevelDeclarations = undefined;\n\t\t\t}\n\n\t\t\t// populate assets\n\t\t\tif (m.buildInfo.assets) {\n\t\t\t\tif (this.buildInfo.assets === undefined) {\n\t\t\t\t\tthis.buildInfo.assets = Object.create(null);\n\t\t\t\t}\n\t\t\t\tObject.assign(this.buildInfo.assets, m.buildInfo.assets);\n\t\t\t}\n\t\t\tif (m.buildInfo.assetsInfo) {\n\t\t\t\tif (this.buildInfo.assetsInfo === undefined) {\n\t\t\t\t\tthis.buildInfo.assetsInfo = new Map();\n\t\t\t\t}\n\t\t\t\tfor (const [key, value] of m.buildInfo.assetsInfo) {\n\t\t\t\t\tthis.buildInfo.assetsInfo.set(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcallback();\n\t}\n\n\t/**\n\t * @param {string=} type the source type for which the size should be estimated\n\t * @returns {number} the estimated size of the module (must be non-zero)\n\t */\n\tsize(type) {\n\t\t// Guess size from embedded modules\n\t\tlet size = 0;\n\t\tfor (const module of this._modules) {\n\t\t\tsize += module.size(type);\n\t\t}\n\t\treturn size;\n\t}\n\n\t/**\n\t * @private\n\t * @param {Module} rootModule the root of the concatenation\n\t * @param {Set<Module>} modulesSet a set of modules which should be concatenated\n\t * @param {RuntimeSpec} runtime for this runtime\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @returns {ConcatenationEntry[]} concatenation list\n\t */\n\t_createConcatenationList(rootModule, modulesSet, runtime, moduleGraph) {\n\t\t/** @type {ConcatenationEntry[]} */\n\t\tconst list = [];\n\t\t/** @type {Map<Module, RuntimeSpec | true>} */\n\t\tconst existingEntries = new Map();\n\n\t\t/**\n\t\t * @param {Module} module a module\n\t\t * @returns {Iterable<{ connection: ModuleGraphConnection, runtimeCondition: RuntimeSpec | true }>} imported modules in order\n\t\t */\n\t\tconst getConcatenatedImports = module => {\n\t\t\tlet connections = Array.from(moduleGraph.getOutgoingConnections(module));\n\t\t\tif (module === rootModule) {\n\t\t\t\tfor (const c of moduleGraph.getOutgoingConnections(this))\n\t\t\t\t\tconnections.push(c);\n\t\t\t}\n\t\t\tconst references = connections\n\t\t\t\t.filter(connection => {\n\t\t\t\t\tif (!(connection.dependency instanceof HarmonyImportDependency))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\treturn (\n\t\t\t\t\t\tconnection &&\n\t\t\t\t\t\tconnection.resolvedOriginModule === module &&\n\t\t\t\t\t\tconnection.module &&\n\t\t\t\t\t\tconnection.isTargetActive(runtime)\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t\t.map(connection => ({\n\t\t\t\t\tconnection,\n\t\t\t\t\tsourceOrder: /** @type {HarmonyImportDependency} */ (\n\t\t\t\t\t\tconnection.dependency\n\t\t\t\t\t).sourceOrder\n\t\t\t\t}));\n\t\t\treferences.sort(\n\t\t\t\tconcatComparators(bySourceOrder, keepOriginalOrder(references))\n\t\t\t);\n\t\t\t/** @type {Map<Module, { connection: ModuleGraphConnection, runtimeCondition: RuntimeSpec | true }>} */\n\t\t\tconst referencesMap = new Map();\n\t\t\tfor (const { connection } of references) {\n\t\t\t\tconst runtimeCondition = filterRuntime(runtime, r =>\n\t\t\t\t\tconnection.isTargetActive(r)\n\t\t\t\t);\n\t\t\t\tif (runtimeCondition === false) continue;\n\t\t\t\tconst module = connection.module;\n\t\t\t\tconst entry = referencesMap.get(module);\n\t\t\t\tif (entry === undefined) {\n\t\t\t\t\treferencesMap.set(module, { connection, runtimeCondition });\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tentry.runtimeCondition = mergeRuntimeConditionNonFalse(\n\t\t\t\t\tentry.runtimeCondition,\n\t\t\t\t\truntimeCondition,\n\t\t\t\t\truntime\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn referencesMap.values();\n\t\t};\n\n\t\t/**\n\t\t * @param {ModuleGraphConnection} connection graph connection\n\t\t * @param {RuntimeSpec | true} runtimeCondition runtime condition\n\t\t * @returns {void}\n\t\t */\n\t\tconst enterModule = (connection, runtimeCondition) => {\n\t\t\tconst module = connection.module;\n\t\t\tif (!module) return;\n\t\t\tconst existingEntry = existingEntries.get(module);\n\t\t\tif (existingEntry === true) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (modulesSet.has(module)) {\n\t\t\t\texistingEntries.set(module, true);\n\t\t\t\tif (runtimeCondition !== true) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot runtime-conditional concatenate a module (${module.identifier()} in ${this.rootModule.identifier()}, ${runtimeConditionToString(\n\t\t\t\t\t\t\truntimeCondition\n\t\t\t\t\t\t)}). This should not happen.`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst imports = getConcatenatedImports(module);\n\t\t\t\tfor (const { connection, runtimeCondition } of imports)\n\t\t\t\t\tenterModule(connection, runtimeCondition);\n\t\t\t\tlist.push({\n\t\t\t\t\ttype: \"concatenated\",\n\t\t\t\t\tmodule: connection.module,\n\t\t\t\t\truntimeCondition\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (existingEntry !== undefined) {\n\t\t\t\t\tconst reducedRuntimeCondition = subtractRuntimeCondition(\n\t\t\t\t\t\truntimeCondition,\n\t\t\t\t\t\texistingEntry,\n\t\t\t\t\t\truntime\n\t\t\t\t\t);\n\t\t\t\t\tif (reducedRuntimeCondition === false) return;\n\t\t\t\t\truntimeCondition = reducedRuntimeCondition;\n\t\t\t\t\texistingEntries.set(\n\t\t\t\t\t\tconnection.module,\n\t\t\t\t\t\tmergeRuntimeConditionNonFalse(\n\t\t\t\t\t\t\texistingEntry,\n\t\t\t\t\t\t\truntimeCondition,\n\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\texistingEntries.set(connection.module, runtimeCondition);\n\t\t\t\t}\n\t\t\t\tif (list.length > 0) {\n\t\t\t\t\tconst lastItem = list[list.length - 1];\n\t\t\t\t\tif (\n\t\t\t\t\t\tlastItem.type === \"external\" &&\n\t\t\t\t\t\tlastItem.module === connection.module\n\t\t\t\t\t) {\n\t\t\t\t\t\tlastItem.runtimeCondition = mergeRuntimeCondition(\n\t\t\t\t\t\t\tlastItem.runtimeCondition,\n\t\t\t\t\t\t\truntimeCondition,\n\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.push({\n\t\t\t\t\ttype: \"external\",\n\t\t\t\t\tget module() {\n\t\t\t\t\t\t// We need to use a getter here, because the module in the dependency\n\t\t\t\t\t\t// could be replaced by some other process (i. e. also replaced with a\n\t\t\t\t\t\t// concatenated module)\n\t\t\t\t\t\treturn connection.module;\n\t\t\t\t\t},\n\t\t\t\t\truntimeCondition\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\texistingEntries.set(rootModule, true);\n\t\tconst imports = getConcatenatedImports(rootModule);\n\t\tfor (const { connection, runtimeCondition } of imports)\n\t\t\tenterModule(connection, runtimeCondition);\n\t\tlist.push({\n\t\t\ttype: \"concatenated\",\n\t\t\tmodule: rootModule,\n\t\t\truntimeCondition: true\n\t\t});\n\n\t\treturn list;\n\t}\n\n\t/**\n\t * @param {Module} rootModule the root module of the concatenation\n\t * @param {Set<Module>} modules all modules in the concatenation (including the root module)\n\t * @param {Object=} associatedObjectForCache object for caching\n\t * @param {string | HashConstructor=} hashFunction hash function to use\n\t * @returns {string} the identifier\n\t */\n\tstatic _createIdentifier(\n\t\trootModule,\n\t\tmodules,\n\t\tassociatedObjectForCache,\n\t\thashFunction = \"md4\"\n\t) {\n\t\tconst cachedMakePathsRelative = makePathsRelative.bindContextCache(\n\t\t\trootModule.context,\n\t\t\tassociatedObjectForCache\n\t\t);\n\t\tlet identifiers = [];\n\t\tfor (const module of modules) {\n\t\t\tidentifiers.push(cachedMakePathsRelative(module.identifier()));\n\t\t}\n\t\tidentifiers.sort();\n\t\tconst hash = createHash(hashFunction);\n\t\thash.update(identifiers.join(\" \"));\n\t\treturn rootModule.identifier() + \"|\" + hash.digest(\"hex\");\n\t}\n\n\t/**\n\t * @param {LazySet<string>} fileDependencies set where file dependencies are added to\n\t * @param {LazySet<string>} contextDependencies set where context dependencies are added to\n\t * @param {LazySet<string>} missingDependencies set where missing dependencies are added to\n\t * @param {LazySet<string>} buildDependencies set where build dependencies are added to\n\t */\n\taddCacheDependencies(\n\t\tfileDependencies,\n\t\tcontextDependencies,\n\t\tmissingDependencies,\n\t\tbuildDependencies\n\t) {\n\t\tfor (const module of this._modules) {\n\t\t\tmodule.addCacheDependencies(\n\t\t\t\tfileDependencies,\n\t\t\t\tcontextDependencies,\n\t\t\t\tmissingDependencies,\n\t\t\t\tbuildDependencies\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @param {CodeGenerationContext} context context for code generation\n\t * @returns {CodeGenerationResult} result\n\t */\n\tcodeGeneration({\n\t\tdependencyTemplates,\n\t\truntimeTemplate,\n\t\tmoduleGraph,\n\t\tchunkGraph,\n\t\truntime: generationRuntime,\n\t\tcodeGenerationResults\n\t}) {\n\t\t/** @type {Set<string>} */\n\t\tconst runtimeRequirements = new Set();\n\t\tconst runtime = intersectRuntime(generationRuntime, this._runtime);\n\n\t\tconst requestShortener = runtimeTemplate.requestShortener;\n\t\t// Meta info for each module\n\t\tconst [modulesWithInfo, moduleToInfoMap] = this._getModulesWithInfo(\n\t\t\tmoduleGraph,\n\t\t\truntime\n\t\t);\n\n\t\t// Set with modules that need a generated namespace object\n\t\t/** @type {Set<ConcatenatedModuleInfo>} */\n\t\tconst neededNamespaceObjects = new Set();\n\n\t\t// Generate source code and analyse scopes\n\t\t// Prepare a ReplaceSource for the final source\n\t\tfor (const info of moduleToInfoMap.values()) {\n\t\t\tthis._analyseModule(\n\t\t\t\tmoduleToInfoMap,\n\t\t\t\tinfo,\n\t\t\t\tdependencyTemplates,\n\t\t\t\truntimeTemplate,\n\t\t\t\tmoduleGraph,\n\t\t\t\tchunkGraph,\n\t\t\t\truntime,\n\t\t\t\tcodeGenerationResults\n\t\t\t);\n\t\t}\n\n\t\t// List of all used names to avoid conflicts\n\t\tconst allUsedNames = new Set(RESERVED_NAMES);\n\t\t// Updated Top level declarations are created by renaming\n\t\tconst topLevelDeclarations = new Set();\n\n\t\t// List of additional names in scope for module references\n\t\t/** @type {Map<string, { usedNames: Set<string>, alreadyCheckedScopes: Set<TODO> }>} */\n\t\tconst usedNamesInScopeInfo = new Map();\n\t\t/**\n\t\t * @param {string} module module identifier\n\t\t * @param {string} id export id\n\t\t * @returns {{ usedNames: Set<string>, alreadyCheckedScopes: Set<TODO> }} info\n\t\t */\n\t\tconst getUsedNamesInScopeInfo = (module, id) => {\n\t\t\tconst key = `${module}-${id}`;\n\t\t\tlet info = usedNamesInScopeInfo.get(key);\n\t\t\tif (info === undefined) {\n\t\t\t\tinfo = {\n\t\t\t\t\tusedNames: new Set(),\n\t\t\t\t\talreadyCheckedScopes: new Set()\n\t\t\t\t};\n\t\t\t\tusedNamesInScopeInfo.set(key, info);\n\t\t\t}\n\t\t\treturn info;\n\t\t};\n\n\t\t// Set of already checked scopes\n\t\tconst ignoredScopes = new Set();\n\n\t\t// get all global names\n\t\tfor (const info of modulesWithInfo) {\n\t\t\tif (info.type === \"concatenated\") {\n\t\t\t\t// ignore symbols from moduleScope\n\t\t\t\tif (info.moduleScope) {\n\t\t\t\t\tignoredScopes.add(info.moduleScope);\n\t\t\t\t}\n\n\t\t\t\t// The super class expression in class scopes behaves weird\n\t\t\t\t// We get ranges of all super class expressions to make\n\t\t\t\t// renaming to work correctly\n\t\t\t\tconst superClassCache = new WeakMap();\n\t\t\t\tconst getSuperClassExpressions = scope => {\n\t\t\t\t\tconst cacheEntry = superClassCache.get(scope);\n\t\t\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\t\t\tconst superClassExpressions = [];\n\t\t\t\t\tfor (const childScope of scope.childScopes) {\n\t\t\t\t\t\tif (childScope.type !== \"class\") continue;\n\t\t\t\t\t\tconst block = childScope.block;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t(block.type === \"ClassDeclaration\" ||\n\t\t\t\t\t\t\t\tblock.type === \"ClassExpression\") &&\n\t\t\t\t\t\t\tblock.superClass\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tsuperClassExpressions.push({\n\t\t\t\t\t\t\t\trange: block.superClass.range,\n\t\t\t\t\t\t\t\tvariables: childScope.variables\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsuperClassCache.set(scope, superClassExpressions);\n\t\t\t\t\treturn superClassExpressions;\n\t\t\t\t};\n\n\t\t\t\t// add global symbols\n\t\t\t\tif (info.globalScope) {\n\t\t\t\t\tfor (const reference of info.globalScope.through) {\n\t\t\t\t\t\tconst name = reference.identifier.name;\n\t\t\t\t\t\tif (ConcatenationScope.isModuleReference(name)) {\n\t\t\t\t\t\t\tconst match = ConcatenationScope.matchModuleReference(name);\n\t\t\t\t\t\t\tif (!match) continue;\n\t\t\t\t\t\t\tconst referencedInfo = modulesWithInfo[match.index];\n\t\t\t\t\t\t\tif (referencedInfo.type === \"reference\")\n\t\t\t\t\t\t\t\tthrow new Error(\"Module reference can't point to a reference\");\n\t\t\t\t\t\t\tconst binding = getFinalBinding(\n\t\t\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\t\t\treferencedInfo,\n\t\t\t\t\t\t\t\tmatch.ids,\n\t\t\t\t\t\t\t\tmoduleToInfoMap,\n\t\t\t\t\t\t\t\truntime,\n\t\t\t\t\t\t\t\trequestShortener,\n\t\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\t\tneededNamespaceObjects,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tinfo.module.buildMeta.strictHarmonyModule,\n\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (!binding.ids) continue;\n\t\t\t\t\t\t\tconst { usedNames, alreadyCheckedScopes } =\n\t\t\t\t\t\t\t\tgetUsedNamesInScopeInfo(\n\t\t\t\t\t\t\t\t\tbinding.info.module.identifier(),\n\t\t\t\t\t\t\t\t\t\"name\" in binding ? binding.name : \"\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tfor (const expr of getSuperClassExpressions(reference.from)) {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\texpr.range[0] <= reference.identifier.range[0] &&\n\t\t\t\t\t\t\t\t\texpr.range[1] >= reference.identifier.range[1]\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tfor (const variable of expr.variables) {\n\t\t\t\t\t\t\t\t\t\tusedNames.add(variable.name);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\taddScopeSymbols(\n\t\t\t\t\t\t\t\treference.from,\n\t\t\t\t\t\t\t\tusedNames,\n\t\t\t\t\t\t\t\talreadyCheckedScopes,\n\t\t\t\t\t\t\t\tignoredScopes\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tallUsedNames.add(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// generate names for symbols\n\t\tfor (const info of moduleToInfoMap.values()) {\n\t\t\tconst { usedNames: namespaceObjectUsedNames } = getUsedNamesInScopeInfo(\n\t\t\t\tinfo.module.identifier(),\n\t\t\t\t\"\"\n\t\t\t);\n\t\t\tswitch (info.type) {\n\t\t\t\tcase \"concatenated\": {\n\t\t\t\t\tfor (const variable of info.moduleScope.variables) {\n\t\t\t\t\t\tconst name = variable.name;\n\t\t\t\t\t\tconst { usedNames, alreadyCheckedScopes } = getUsedNamesInScopeInfo(\n\t\t\t\t\t\t\tinfo.module.identifier(),\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (allUsedNames.has(name) || usedNames.has(name)) {\n\t\t\t\t\t\t\tconst references = getAllReferences(variable);\n\t\t\t\t\t\t\tfor (const ref of references) {\n\t\t\t\t\t\t\t\taddScopeSymbols(\n\t\t\t\t\t\t\t\t\tref.from,\n\t\t\t\t\t\t\t\t\tusedNames,\n\t\t\t\t\t\t\t\t\talreadyCheckedScopes,\n\t\t\t\t\t\t\t\t\tignoredScopes\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst newName = this.findNewName(\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tallUsedNames,\n\t\t\t\t\t\t\t\tusedNames,\n\t\t\t\t\t\t\t\tinfo.module.readableIdentifier(requestShortener)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tallUsedNames.add(newName);\n\t\t\t\t\t\t\tinfo.internalNames.set(name, newName);\n\t\t\t\t\t\t\ttopLevelDeclarations.add(newName);\n\t\t\t\t\t\t\tconst source = info.source;\n\t\t\t\t\t\t\tconst allIdentifiers = new Set(\n\t\t\t\t\t\t\t\treferences.map(r => r.identifier).concat(variable.identifiers)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tfor (const identifier of allIdentifiers) {\n\t\t\t\t\t\t\t\tconst r = identifier.range;\n\t\t\t\t\t\t\t\tconst path = getPathInAst(info.ast, identifier);\n\t\t\t\t\t\t\t\tif (path && path.length > 1) {\n\t\t\t\t\t\t\t\t\tconst maybeProperty =\n\t\t\t\t\t\t\t\t\t\tpath[1].type === \"AssignmentPattern\" &&\n\t\t\t\t\t\t\t\t\t\tpath[1].left === path[0]\n\t\t\t\t\t\t\t\t\t\t\t? path[2]\n\t\t\t\t\t\t\t\t\t\t\t: path[1];\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tmaybeProperty.type === \"Property\" &&\n\t\t\t\t\t\t\t\t\t\tmaybeProperty.shorthand\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tsource.insert(r[1], `: ${newName}`);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsource.replace(r[0], r[1] - 1, newName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tallUsedNames.add(name);\n\t\t\t\t\t\t\tinfo.internalNames.set(name, name);\n\t\t\t\t\t\t\ttopLevelDeclarations.add(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlet namespaceObjectName;\n\t\t\t\t\tif (info.namespaceExportSymbol) {\n\t\t\t\t\t\tnamespaceObjectName = info.internalNames.get(\n\t\t\t\t\t\t\tinfo.namespaceExportSymbol\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnamespaceObjectName = this.findNewName(\n\t\t\t\t\t\t\t\"namespaceObject\",\n\t\t\t\t\t\t\tallUsedNames,\n\t\t\t\t\t\t\tnamespaceObjectUsedNames,\n\t\t\t\t\t\t\tinfo.module.readableIdentifier(requestShortener)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tallUsedNames.add(namespaceObjectName);\n\t\t\t\t\t}\n\t\t\t\t\tinfo.namespaceObjectName = namespaceObjectName;\n\t\t\t\t\ttopLevelDeclarations.add(namespaceObjectName);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"external\": {\n\t\t\t\t\tconst externalName = this.findNewName(\n\t\t\t\t\t\t\"\",\n\t\t\t\t\t\tallUsedNames,\n\t\t\t\t\t\tnamespaceObjectUsedNames,\n\t\t\t\t\t\tinfo.module.readableIdentifier(requestShortener)\n\t\t\t\t\t);\n\t\t\t\t\tallUsedNames.add(externalName);\n\t\t\t\t\tinfo.name = externalName;\n\t\t\t\t\ttopLevelDeclarations.add(externalName);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (info.module.buildMeta.exportsType !== \"namespace\") {\n\t\t\t\tconst externalNameInterop = this.findNewName(\n\t\t\t\t\t\"namespaceObject\",\n\t\t\t\t\tallUsedNames,\n\t\t\t\t\tnamespaceObjectUsedNames,\n\t\t\t\t\tinfo.module.readableIdentifier(requestShortener)\n\t\t\t\t);\n\t\t\t\tallUsedNames.add(externalNameInterop);\n\t\t\t\tinfo.interopNamespaceObjectName = externalNameInterop;\n\t\t\t\ttopLevelDeclarations.add(externalNameInterop);\n\t\t\t}\n\t\t\tif (\n\t\t\t\tinfo.module.buildMeta.exportsType === \"default\" &&\n\t\t\t\tinfo.module.buildMeta.defaultObject !== \"redirect\"\n\t\t\t) {\n\t\t\t\tconst externalNameInterop = this.findNewName(\n\t\t\t\t\t\"namespaceObject2\",\n\t\t\t\t\tallUsedNames,\n\t\t\t\t\tnamespaceObjectUsedNames,\n\t\t\t\t\tinfo.module.readableIdentifier(requestShortener)\n\t\t\t\t);\n\t\t\t\tallUsedNames.add(externalNameInterop);\n\t\t\t\tinfo.interopNamespaceObject2Name = externalNameInterop;\n\t\t\t\ttopLevelDeclarations.add(externalNameInterop);\n\t\t\t}\n\t\t\tif (\n\t\t\t\tinfo.module.buildMeta.exportsType === \"dynamic\" ||\n\t\t\t\t!info.module.buildMeta.exportsType\n\t\t\t) {\n\t\t\t\tconst externalNameInterop = this.findNewName(\n\t\t\t\t\t\"default\",\n\t\t\t\t\tallUsedNames,\n\t\t\t\t\tnamespaceObjectUsedNames,\n\t\t\t\t\tinfo.module.readableIdentifier(requestShortener)\n\t\t\t\t);\n\t\t\t\tallUsedNames.add(externalNameInterop);\n\t\t\t\tinfo.interopDefaultAccessName = externalNameInterop;\n\t\t\t\ttopLevelDeclarations.add(externalNameInterop);\n\t\t\t}\n\t\t}\n\n\t\t// Find and replace references to modules\n\t\tfor (const info of moduleToInfoMap.values()) {\n\t\t\tif (info.type === \"concatenated\") {\n\t\t\t\tfor (const reference of info.globalScope.through) {\n\t\t\t\t\tconst name = reference.identifier.name;\n\t\t\t\t\tconst match = ConcatenationScope.matchModuleReference(name);\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tconst referencedInfo = modulesWithInfo[match.index];\n\t\t\t\t\t\tif (referencedInfo.type === \"reference\")\n\t\t\t\t\t\t\tthrow new Error(\"Module reference can't point to a reference\");\n\t\t\t\t\t\tconst finalName = getFinalName(\n\t\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\t\treferencedInfo,\n\t\t\t\t\t\t\tmatch.ids,\n\t\t\t\t\t\t\tmoduleToInfoMap,\n\t\t\t\t\t\t\truntime,\n\t\t\t\t\t\t\trequestShortener,\n\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\tneededNamespaceObjects,\n\t\t\t\t\t\t\tmatch.call,\n\t\t\t\t\t\t\t!match.directImport,\n\t\t\t\t\t\t\tinfo.module.buildMeta.strictHarmonyModule,\n\t\t\t\t\t\t\tmatch.asiSafe\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst r = reference.identifier.range;\n\t\t\t\t\t\tconst source = info.source;\n\t\t\t\t\t\t// range is extended by 2 chars to cover the appended \"._\"\n\t\t\t\t\t\tsource.replace(r[0], r[1] + 1, finalName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Map with all root exposed used exports\n\t\t/** @type {Map<string, function(RequestShortener): string>} */\n\t\tconst exportsMap = new Map();\n\n\t\t// Set with all root exposed unused exports\n\t\t/** @type {Set<string>} */\n\t\tconst unusedExports = new Set();\n\n\t\tconst rootInfo = /** @type {ConcatenatedModuleInfo} */ (\n\t\t\tmoduleToInfoMap.get(this.rootModule)\n\t\t);\n\t\tconst strictHarmonyModule = rootInfo.module.buildMeta.strictHarmonyModule;\n\t\tconst exportsInfo = moduleGraph.getExportsInfo(rootInfo.module);\n\t\tfor (const exportInfo of exportsInfo.orderedExports) {\n\t\t\tconst name = exportInfo.name;\n\t\t\tif (exportInfo.provided === false) continue;\n\t\t\tconst used = exportInfo.getUsedName(undefined, runtime);\n\t\t\tif (!used) {\n\t\t\t\tunusedExports.add(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\texportsMap.set(used, requestShortener => {\n\t\t\t\ttry {\n\t\t\t\t\tconst finalName = getFinalName(\n\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\trootInfo,\n\t\t\t\t\t\t[name],\n\t\t\t\t\t\tmoduleToInfoMap,\n\t\t\t\t\t\truntime,\n\t\t\t\t\t\trequestShortener,\n\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\tneededNamespaceObjects,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tstrictHarmonyModule,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t);\n\t\t\t\t\treturn `/* ${\n\t\t\t\t\t\texportInfo.isReexport() ? \"reexport\" : \"binding\"\n\t\t\t\t\t} */ ${finalName}`;\n\t\t\t\t} catch (e) {\n\t\t\t\t\te.message += `\\nwhile generating the root export '${name}' (used name: '${used}')`;\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tconst result = new ConcatSource();\n\n\t\t// add harmony compatibility flag (must be first because of possible circular dependencies)\n\t\tif (\n\t\t\tmoduleGraph.getExportsInfo(this).otherExportsInfo.getUsed(runtime) !==\n\t\t\tUsageState.Unused\n\t\t) {\n\t\t\tresult.add(`// ESM COMPAT FLAG\\n`);\n\t\t\tresult.add(\n\t\t\t\truntimeTemplate.defineEsModuleFlagStatement({\n\t\t\t\t\texportsArgument: this.exportsArgument,\n\t\t\t\t\truntimeRequirements\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\t// define exports\n\t\tif (exportsMap.size > 0) {\n\t\t\truntimeRequirements.add(RuntimeGlobals.exports);\n\t\t\truntimeRequirements.add(RuntimeGlobals.definePropertyGetters);\n\t\t\tconst definitions = [];\n\t\t\tfor (const [key, value] of exportsMap) {\n\t\t\t\tdefinitions.push(\n\t\t\t\t\t`\\n  ${JSON.stringify(key)}: ${runtimeTemplate.returningFunction(\n\t\t\t\t\t\tvalue(requestShortener)\n\t\t\t\t\t)}`\n\t\t\t\t);\n\t\t\t}\n\t\t\tresult.add(`\\n// EXPORTS\\n`);\n\t\t\tresult.add(\n\t\t\t\t`${RuntimeGlobals.definePropertyGetters}(${\n\t\t\t\t\tthis.exportsArgument\n\t\t\t\t}, {${definitions.join(\",\")}\\n});\\n`\n\t\t\t);\n\t\t}\n\n\t\t// list unused exports\n\t\tif (unusedExports.size > 0) {\n\t\t\tresult.add(\n\t\t\t\t`\\n// UNUSED EXPORTS: ${joinIterableWithComma(unusedExports)}\\n`\n\t\t\t);\n\t\t}\n\n\t\t// generate namespace objects\n\t\tconst namespaceObjectSources = new Map();\n\t\tfor (const info of neededNamespaceObjects) {\n\t\t\tif (info.namespaceExportSymbol) continue;\n\t\t\tconst nsObj = [];\n\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(info.module);\n\t\t\tfor (const exportInfo of exportsInfo.orderedExports) {\n\t\t\t\tif (exportInfo.provided === false) continue;\n\t\t\t\tconst usedName = exportInfo.getUsedName(undefined, runtime);\n\t\t\t\tif (usedName) {\n\t\t\t\t\tconst finalName = getFinalName(\n\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t[exportInfo.name],\n\t\t\t\t\t\tmoduleToInfoMap,\n\t\t\t\t\t\truntime,\n\t\t\t\t\t\trequestShortener,\n\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\tneededNamespaceObjects,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tinfo.module.buildMeta.strictHarmonyModule,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t);\n\t\t\t\t\tnsObj.push(\n\t\t\t\t\t\t`\\n  ${JSON.stringify(\n\t\t\t\t\t\t\tusedName\n\t\t\t\t\t\t)}: ${runtimeTemplate.returningFunction(finalName)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst name = info.namespaceObjectName;\n\t\t\tconst defineGetters =\n\t\t\t\tnsObj.length > 0\n\t\t\t\t\t? `${RuntimeGlobals.definePropertyGetters}(${name}, {${nsObj.join(\n\t\t\t\t\t\t\t\",\"\n\t\t\t\t\t  )}\\n});\\n`\n\t\t\t\t\t: \"\";\n\t\t\tif (nsObj.length > 0)\n\t\t\t\truntimeRequirements.add(RuntimeGlobals.definePropertyGetters);\n\t\t\tnamespaceObjectSources.set(\n\t\t\t\tinfo,\n\t\t\t\t`\n// NAMESPACE OBJECT: ${info.module.readableIdentifier(requestShortener)}\nvar ${name} = {};\n${RuntimeGlobals.makeNamespaceObject}(${name});\n${defineGetters}`\n\t\t\t);\n\t\t\truntimeRequirements.add(RuntimeGlobals.makeNamespaceObject);\n\t\t}\n\n\t\t// define required namespace objects (must be before evaluation modules)\n\t\tfor (const info of modulesWithInfo) {\n\t\t\tif (info.type === \"concatenated\") {\n\t\t\t\tconst source = namespaceObjectSources.get(info);\n\t\t\t\tif (!source) continue;\n\t\t\t\tresult.add(source);\n\t\t\t}\n\t\t}\n\n\t\tconst chunkInitFragments = [];\n\n\t\t// evaluate modules in order\n\t\tfor (const rawInfo of modulesWithInfo) {\n\t\t\tlet name;\n\t\t\tlet isConditional = false;\n\t\t\tconst info = rawInfo.type === \"reference\" ? rawInfo.target : rawInfo;\n\t\t\tswitch (info.type) {\n\t\t\t\tcase \"concatenated\": {\n\t\t\t\t\tresult.add(\n\t\t\t\t\t\t`\\n;// CONCATENATED MODULE: ${info.module.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)}\\n`\n\t\t\t\t\t);\n\t\t\t\t\tresult.add(info.source);\n\t\t\t\t\tif (info.chunkInitFragments) {\n\t\t\t\t\t\tfor (const f of info.chunkInitFragments) chunkInitFragments.push(f);\n\t\t\t\t\t}\n\t\t\t\t\tif (info.runtimeRequirements) {\n\t\t\t\t\t\tfor (const r of info.runtimeRequirements) {\n\t\t\t\t\t\t\truntimeRequirements.add(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tname = info.namespaceObjectName;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"external\": {\n\t\t\t\t\tresult.add(\n\t\t\t\t\t\t`\\n// EXTERNAL MODULE: ${info.module.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)}\\n`\n\t\t\t\t\t);\n\t\t\t\t\truntimeRequirements.add(RuntimeGlobals.require);\n\t\t\t\t\tconst { runtimeCondition } =\n\t\t\t\t\t\t/** @type {ExternalModuleInfo | ReferenceToModuleInfo} */ (rawInfo);\n\t\t\t\t\tconst condition = runtimeTemplate.runtimeConditionExpression({\n\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\truntimeCondition,\n\t\t\t\t\t\truntime,\n\t\t\t\t\t\truntimeRequirements\n\t\t\t\t\t});\n\t\t\t\t\tif (condition !== \"true\") {\n\t\t\t\t\t\tisConditional = true;\n\t\t\t\t\t\tresult.add(`if (${condition}) {\\n`);\n\t\t\t\t\t}\n\t\t\t\t\tresult.add(\n\t\t\t\t\t\t`var ${info.name} = __webpack_require__(${JSON.stringify(\n\t\t\t\t\t\t\tchunkGraph.getModuleId(info.module)\n\t\t\t\t\t\t)});`\n\t\t\t\t\t);\n\t\t\t\t\tname = info.name;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\t// @ts-expect-error never is expected here\n\t\t\t\t\tthrow new Error(`Unsupported concatenation entry type ${info.type}`);\n\t\t\t}\n\t\t\tif (info.interopNamespaceObjectUsed) {\n\t\t\t\truntimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject);\n\t\t\t\tresult.add(\n\t\t\t\t\t`\\nvar ${info.interopNamespaceObjectName} = /*#__PURE__*/${RuntimeGlobals.createFakeNamespaceObject}(${name}, 2);`\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (info.interopNamespaceObject2Used) {\n\t\t\t\truntimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject);\n\t\t\t\tresult.add(\n\t\t\t\t\t`\\nvar ${info.interopNamespaceObject2Name} = /*#__PURE__*/${RuntimeGlobals.createFakeNamespaceObject}(${name});`\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (info.interopDefaultAccessUsed) {\n\t\t\t\truntimeRequirements.add(RuntimeGlobals.compatGetDefaultExport);\n\t\t\t\tresult.add(\n\t\t\t\t\t`\\nvar ${info.interopDefaultAccessName} = /*#__PURE__*/${RuntimeGlobals.compatGetDefaultExport}(${name});`\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (isConditional) {\n\t\t\t\tresult.add(\"\\n}\");\n\t\t\t}\n\t\t}\n\n\t\tconst data = new Map();\n\t\tif (chunkInitFragments.length > 0)\n\t\t\tdata.set(\"chunkInitFragments\", chunkInitFragments);\n\t\tdata.set(\"topLevelDeclarations\", topLevelDeclarations);\n\n\t\t/** @type {CodeGenerationResult} */\n\t\tconst resultEntry = {\n\t\t\tsources: new Map([[\"javascript\", new CachedSource(result)]]),\n\t\t\tdata,\n\t\t\truntimeRequirements\n\t\t};\n\n\t\treturn resultEntry;\n\t}\n\n\t/**\n\t * @param {Map<Module, ModuleInfo>} modulesMap modulesMap\n\t * @param {ModuleInfo} info info\n\t * @param {DependencyTemplates} dependencyTemplates dependencyTemplates\n\t * @param {RuntimeTemplate} runtimeTemplate runtimeTemplate\n\t * @param {ModuleGraph} moduleGraph moduleGraph\n\t * @param {ChunkGraph} chunkGraph chunkGraph\n\t * @param {RuntimeSpec} runtime runtime\n\t * @param {CodeGenerationResults} codeGenerationResults codeGenerationResults\n\t */\n\t_analyseModule(\n\t\tmodulesMap,\n\t\tinfo,\n\t\tdependencyTemplates,\n\t\truntimeTemplate,\n\t\tmoduleGraph,\n\t\tchunkGraph,\n\t\truntime,\n\t\tcodeGenerationResults\n\t) {\n\t\tif (info.type === \"concatenated\") {\n\t\t\tconst m = info.module;\n\t\t\ttry {\n\t\t\t\t// Create a concatenation scope to track and capture information\n\t\t\t\tconst concatenationScope = new ConcatenationScope(modulesMap, info);\n\n\t\t\t\t// TODO cache codeGeneration results\n\t\t\t\tconst codeGenResult = m.codeGeneration({\n\t\t\t\t\tdependencyTemplates,\n\t\t\t\t\truntimeTemplate,\n\t\t\t\t\tmoduleGraph,\n\t\t\t\t\tchunkGraph,\n\t\t\t\t\truntime,\n\t\t\t\t\tconcatenationScope,\n\t\t\t\t\tcodeGenerationResults\n\t\t\t\t});\n\t\t\t\tconst source = codeGenResult.sources.get(\"javascript\");\n\t\t\t\tconst data = codeGenResult.data;\n\t\t\t\tconst chunkInitFragments = data && data.get(\"chunkInitFragments\");\n\t\t\t\tconst code = source.source().toString();\n\t\t\t\tlet ast;\n\t\t\t\ttry {\n\t\t\t\t\tast = JavascriptParser._parse(code, {\n\t\t\t\t\t\tsourceType: \"module\"\n\t\t\t\t\t});\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (\n\t\t\t\t\t\terr.loc &&\n\t\t\t\t\t\ttypeof err.loc === \"object\" &&\n\t\t\t\t\t\ttypeof err.loc.line === \"number\"\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst lineNumber = err.loc.line;\n\t\t\t\t\t\tconst lines = code.split(\"\\n\");\n\t\t\t\t\t\terr.message +=\n\t\t\t\t\t\t\t\"\\n| \" +\n\t\t\t\t\t\t\tlines\n\t\t\t\t\t\t\t\t.slice(Math.max(0, lineNumber - 3), lineNumber + 2)\n\t\t\t\t\t\t\t\t.join(\"\\n| \");\n\t\t\t\t\t}\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\t\t\t\tconst scopeManager = eslintScope.analyze(ast, {\n\t\t\t\t\tecmaVersion: 6,\n\t\t\t\t\tsourceType: \"module\",\n\t\t\t\t\toptimistic: true,\n\t\t\t\t\tignoreEval: true,\n\t\t\t\t\timpliedStrict: true\n\t\t\t\t});\n\t\t\t\tconst globalScope = scopeManager.acquire(ast);\n\t\t\t\tconst moduleScope = globalScope.childScopes[0];\n\t\t\t\tconst resultSource = new ReplaceSource(source);\n\t\t\t\tinfo.runtimeRequirements = codeGenResult.runtimeRequirements;\n\t\t\t\tinfo.ast = ast;\n\t\t\t\tinfo.internalSource = source;\n\t\t\t\tinfo.source = resultSource;\n\t\t\t\tinfo.chunkInitFragments = chunkInitFragments;\n\t\t\t\tinfo.globalScope = globalScope;\n\t\t\t\tinfo.moduleScope = moduleScope;\n\t\t\t} catch (err) {\n\t\t\t\terr.message += `\\nwhile analyzing module ${m.identifier()} for concatenation`;\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {[ModuleInfoOrReference[], Map<Module, ModuleInfo>]} module info items\n\t */\n\t_getModulesWithInfo(moduleGraph, runtime) {\n\t\tconst orderedConcatenationList = this._createConcatenationList(\n\t\t\tthis.rootModule,\n\t\t\tthis._modules,\n\t\t\truntime,\n\t\t\tmoduleGraph\n\t\t);\n\t\t/** @type {Map<Module, ModuleInfo>} */\n\t\tconst map = new Map();\n\t\tconst list = orderedConcatenationList.map((info, index) => {\n\t\t\tlet item = map.get(info.module);\n\t\t\tif (item === undefined) {\n\t\t\t\tswitch (info.type) {\n\t\t\t\t\tcase \"concatenated\":\n\t\t\t\t\t\titem = {\n\t\t\t\t\t\t\ttype: \"concatenated\",\n\t\t\t\t\t\t\tmodule: info.module,\n\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\tast: undefined,\n\t\t\t\t\t\t\tinternalSource: undefined,\n\t\t\t\t\t\t\truntimeRequirements: undefined,\n\t\t\t\t\t\t\tsource: undefined,\n\t\t\t\t\t\t\tglobalScope: undefined,\n\t\t\t\t\t\t\tmoduleScope: undefined,\n\t\t\t\t\t\t\tinternalNames: new Map(),\n\t\t\t\t\t\t\texportMap: undefined,\n\t\t\t\t\t\t\trawExportMap: undefined,\n\t\t\t\t\t\t\tnamespaceExportSymbol: undefined,\n\t\t\t\t\t\t\tnamespaceObjectName: undefined,\n\t\t\t\t\t\t\tinteropNamespaceObjectUsed: false,\n\t\t\t\t\t\t\tinteropNamespaceObjectName: undefined,\n\t\t\t\t\t\t\tinteropNamespaceObject2Used: false,\n\t\t\t\t\t\t\tinteropNamespaceObject2Name: undefined,\n\t\t\t\t\t\t\tinteropDefaultAccessUsed: false,\n\t\t\t\t\t\t\tinteropDefaultAccessName: undefined\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"external\":\n\t\t\t\t\t\titem = {\n\t\t\t\t\t\t\ttype: \"external\",\n\t\t\t\t\t\t\tmodule: info.module,\n\t\t\t\t\t\t\truntimeCondition: info.runtimeCondition,\n\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\tname: undefined,\n\t\t\t\t\t\t\tinteropNamespaceObjectUsed: false,\n\t\t\t\t\t\t\tinteropNamespaceObjectName: undefined,\n\t\t\t\t\t\t\tinteropNamespaceObject2Used: false,\n\t\t\t\t\t\t\tinteropNamespaceObject2Name: undefined,\n\t\t\t\t\t\t\tinteropDefaultAccessUsed: false,\n\t\t\t\t\t\t\tinteropDefaultAccessName: undefined\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unsupported concatenation entry type ${info.type}`\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tmap.set(item.module, item);\n\t\t\t\treturn item;\n\t\t\t} else {\n\t\t\t\t/** @type {ReferenceToModuleInfo} */\n\t\t\t\tconst ref = {\n\t\t\t\t\ttype: \"reference\",\n\t\t\t\t\truntimeCondition: info.runtimeCondition,\n\t\t\t\t\ttarget: item\n\t\t\t\t};\n\t\t\t\treturn ref;\n\t\t\t}\n\t\t});\n\t\treturn [list, map];\n\t}\n\n\tfindNewName(oldName, usedNamed1, usedNamed2, extraInfo) {\n\t\tlet name = oldName;\n\n\t\tif (name === ConcatenationScope.DEFAULT_EXPORT) {\n\t\t\tname = \"\";\n\t\t}\n\t\tif (name === ConcatenationScope.NAMESPACE_OBJECT_EXPORT) {\n\t\t\tname = \"namespaceObject\";\n\t\t}\n\n\t\t// Remove uncool stuff\n\t\textraInfo = extraInfo.replace(\n\t\t\t/\\.+\\/|(\\/index)?\\.([a-zA-Z0-9]{1,4})($|\\s|\\?)|\\s*\\+\\s*\\d+\\s*modules/g,\n\t\t\t\"\"\n\t\t);\n\n\t\tconst splittedInfo = extraInfo.split(\"/\");\n\t\twhile (splittedInfo.length) {\n\t\t\tname = splittedInfo.pop() + (name ? \"_\" + name : \"\");\n\t\t\tconst nameIdent = Template.toIdentifier(name);\n\t\t\tif (\n\t\t\t\t!usedNamed1.has(nameIdent) &&\n\t\t\t\t(!usedNamed2 || !usedNamed2.has(nameIdent))\n\t\t\t)\n\t\t\t\treturn nameIdent;\n\t\t}\n\n\t\tlet i = 0;\n\t\tlet nameWithNumber = Template.toIdentifier(`${name}_${i}`);\n\t\twhile (\n\t\t\tusedNamed1.has(nameWithNumber) ||\n\t\t\t(usedNamed2 && usedNamed2.has(nameWithNumber))\n\t\t) {\n\t\t\ti++;\n\t\t\tnameWithNumber = Template.toIdentifier(`${name}_${i}`);\n\t\t}\n\t\treturn nameWithNumber;\n\t}\n\n\t/**\n\t * @param {Hash} hash the hash used to track dependencies\n\t * @param {UpdateHashContext} context context\n\t * @returns {void}\n\t */\n\tupdateHash(hash, context) {\n\t\tconst { chunkGraph, runtime } = context;\n\t\tfor (const info of this._createConcatenationList(\n\t\t\tthis.rootModule,\n\t\t\tthis._modules,\n\t\t\tintersectRuntime(runtime, this._runtime),\n\t\t\tchunkGraph.moduleGraph\n\t\t)) {\n\t\t\tswitch (info.type) {\n\t\t\t\tcase \"concatenated\":\n\t\t\t\t\tinfo.module.updateHash(hash, context);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"external\":\n\t\t\t\t\thash.update(`${chunkGraph.getModuleId(info.module)}`);\n\t\t\t\t\t// TODO runtimeCondition\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsuper.updateHash(hash, context);\n\t}\n\n\tstatic deserialize(context) {\n\t\tconst obj = new ConcatenatedModule({\n\t\t\tidentifier: undefined,\n\t\t\trootModule: undefined,\n\t\t\tmodules: undefined,\n\t\t\truntime: undefined\n\t\t});\n\t\tobj.deserialize(context);\n\t\treturn obj;\n\t}\n}\n\nmakeSerializable(ConcatenatedModule, \"webpack/lib/optimize/ConcatenatedModule\");\n\nmodule.exports = ConcatenatedModule;\n"]},"metadata":{},"sourceType":"script"}