{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  STAGE_ADVANCED\n} = require(\"../OptimizationStages\");\n\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\n/** @typedef {import(\"../../declarations/plugins/optimize/MinChunkSizePlugin\").MinChunkSizePluginOptions} MinChunkSizePluginOptions */\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n\nconst validate = createSchemaValidation(require(\"../../schemas/plugins/optimize/MinChunkSizePlugin.check.js\"), () => require(\"../../schemas/plugins/optimize/MinChunkSizePlugin.json\"), {\n  name: \"Min Chunk Size Plugin\",\n  baseDataPath: \"options\"\n});\n\nclass MinChunkSizePlugin {\n  /**\n   * @param {MinChunkSizePluginOptions} options options object\n   */\n  constructor(options) {\n    validate(options);\n    this.options = options;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const options = this.options;\n    const minChunkSize = options.minChunkSize;\n    compiler.hooks.compilation.tap(\"MinChunkSizePlugin\", compilation => {\n      compilation.hooks.optimizeChunks.tap({\n        name: \"MinChunkSizePlugin\",\n        stage: STAGE_ADVANCED\n      }, chunks => {\n        const chunkGraph = compilation.chunkGraph;\n        const equalOptions = {\n          chunkOverhead: 1,\n          entryChunkMultiplicator: 1\n        };\n        const chunkSizesMap = new Map();\n        /** @type {[Chunk, Chunk][]} */\n\n        const combinations = [];\n        /** @type {Chunk[]} */\n\n        const smallChunks = [];\n        const visitedChunks = [];\n\n        for (const a of chunks) {\n          // check if one of the chunks sizes is smaller than the minChunkSize\n          // and filter pairs that can NOT be integrated!\n          if (chunkGraph.getChunkSize(a, equalOptions) < minChunkSize) {\n            smallChunks.push(a);\n\n            for (const b of visitedChunks) {\n              if (chunkGraph.canChunksBeIntegrated(b, a)) combinations.push([b, a]);\n            }\n          } else {\n            for (const b of smallChunks) {\n              if (chunkGraph.canChunksBeIntegrated(b, a)) combinations.push([b, a]);\n            }\n          }\n\n          chunkSizesMap.set(a, chunkGraph.getChunkSize(a, options));\n          visitedChunks.push(a);\n        }\n\n        const sortedSizeFilteredExtendedPairCombinations = combinations.map(pair => {\n          // extend combination pairs with size and integrated size\n          const a = chunkSizesMap.get(pair[0]);\n          const b = chunkSizesMap.get(pair[1]);\n          const ab = chunkGraph.getIntegratedChunksSize(pair[0], pair[1], options);\n          /** @type {[number, number, Chunk, Chunk]} */\n\n          const extendedPair = [a + b - ab, ab, pair[0], pair[1]];\n          return extendedPair;\n        }).sort((a, b) => {\n          // sadly javascript does an in place sort here\n          // sort by size\n          const diff = b[0] - a[0];\n          if (diff !== 0) return diff;\n          return a[1] - b[1];\n        });\n        if (sortedSizeFilteredExtendedPairCombinations.length === 0) return;\n        const pair = sortedSizeFilteredExtendedPairCombinations[0];\n        chunkGraph.integrateChunks(pair[2], pair[3]);\n        compilation.chunks.delete(pair[3]);\n        return true;\n      });\n    });\n  }\n\n}\n\nmodule.exports = MinChunkSizePlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/optimize/MinChunkSizePlugin.js"],"names":["STAGE_ADVANCED","require","createSchemaValidation","validate","name","baseDataPath","MinChunkSizePlugin","constructor","options","apply","compiler","minChunkSize","hooks","compilation","tap","optimizeChunks","stage","chunks","chunkGraph","equalOptions","chunkOverhead","entryChunkMultiplicator","chunkSizesMap","Map","combinations","smallChunks","visitedChunks","a","getChunkSize","push","b","canChunksBeIntegrated","set","sortedSizeFilteredExtendedPairCombinations","map","pair","get","ab","getIntegratedChunksSize","extendedPair","sort","diff","length","integrateChunks","delete","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { STAGE_ADVANCED } = require(\"../OptimizationStages\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/MinChunkSizePlugin\").MinChunkSizePluginOptions} MinChunkSizePluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/optimize/MinChunkSizePlugin.check.js\"),\n\t() => require(\"../../schemas/plugins/optimize/MinChunkSizePlugin.json\"),\n\t{\n\t\tname: \"Min Chunk Size Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\nclass MinChunkSizePlugin {\n\t/**\n\t * @param {MinChunkSizePluginOptions} options options object\n\t */\n\tconstructor(options) {\n\t\tvalidate(options);\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst options = this.options;\n\t\tconst minChunkSize = options.minChunkSize;\n\t\tcompiler.hooks.compilation.tap(\"MinChunkSizePlugin\", compilation => {\n\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t{\n\t\t\t\t\tname: \"MinChunkSizePlugin\",\n\t\t\t\t\tstage: STAGE_ADVANCED\n\t\t\t\t},\n\t\t\t\tchunks => {\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\tconst equalOptions = {\n\t\t\t\t\t\tchunkOverhead: 1,\n\t\t\t\t\t\tentryChunkMultiplicator: 1\n\t\t\t\t\t};\n\n\t\t\t\t\tconst chunkSizesMap = new Map();\n\t\t\t\t\t/** @type {[Chunk, Chunk][]} */\n\t\t\t\t\tconst combinations = [];\n\t\t\t\t\t/** @type {Chunk[]} */\n\t\t\t\t\tconst smallChunks = [];\n\t\t\t\t\tconst visitedChunks = [];\n\t\t\t\t\tfor (const a of chunks) {\n\t\t\t\t\t\t// check if one of the chunks sizes is smaller than the minChunkSize\n\t\t\t\t\t\t// and filter pairs that can NOT be integrated!\n\t\t\t\t\t\tif (chunkGraph.getChunkSize(a, equalOptions) < minChunkSize) {\n\t\t\t\t\t\t\tsmallChunks.push(a);\n\t\t\t\t\t\t\tfor (const b of visitedChunks) {\n\t\t\t\t\t\t\t\tif (chunkGraph.canChunksBeIntegrated(b, a))\n\t\t\t\t\t\t\t\t\tcombinations.push([b, a]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (const b of smallChunks) {\n\t\t\t\t\t\t\t\tif (chunkGraph.canChunksBeIntegrated(b, a))\n\t\t\t\t\t\t\t\t\tcombinations.push([b, a]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchunkSizesMap.set(a, chunkGraph.getChunkSize(a, options));\n\t\t\t\t\t\tvisitedChunks.push(a);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst sortedSizeFilteredExtendedPairCombinations = combinations\n\t\t\t\t\t\t.map(pair => {\n\t\t\t\t\t\t\t// extend combination pairs with size and integrated size\n\t\t\t\t\t\t\tconst a = chunkSizesMap.get(pair[0]);\n\t\t\t\t\t\t\tconst b = chunkSizesMap.get(pair[1]);\n\t\t\t\t\t\t\tconst ab = chunkGraph.getIntegratedChunksSize(\n\t\t\t\t\t\t\t\tpair[0],\n\t\t\t\t\t\t\t\tpair[1],\n\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t/** @type {[number, number, Chunk, Chunk]} */\n\t\t\t\t\t\t\tconst extendedPair = [a + b - ab, ab, pair[0], pair[1]];\n\t\t\t\t\t\t\treturn extendedPair;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.sort((a, b) => {\n\t\t\t\t\t\t\t// sadly javascript does an in place sort here\n\t\t\t\t\t\t\t// sort by size\n\t\t\t\t\t\t\tconst diff = b[0] - a[0];\n\t\t\t\t\t\t\tif (diff !== 0) return diff;\n\t\t\t\t\t\t\treturn a[1] - b[1];\n\t\t\t\t\t\t});\n\n\t\t\t\t\tif (sortedSizeFilteredExtendedPairCombinations.length === 0) return;\n\n\t\t\t\t\tconst pair = sortedSizeFilteredExtendedPairCombinations[0];\n\n\t\t\t\t\tchunkGraph.integrateChunks(pair[2], pair[3]);\n\t\t\t\t\tcompilation.chunks.delete(pair[3]);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = MinChunkSizePlugin;\n"]},"metadata":{},"sourceType":"script"}