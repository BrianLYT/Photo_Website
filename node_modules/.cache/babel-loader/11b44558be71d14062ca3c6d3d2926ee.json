{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Source = require(\"./Source\");\n\nconst RawSource = require(\"./RawSource\");\n\nconst streamChunks = require(\"./helpers/streamChunks\");\n\nconst {\n  getMap,\n  getSourceAndMap\n} = require(\"./helpers/getFromStreamChunks\");\n\nconst stringsAsRawSources = new WeakSet();\n\nclass ConcatSource extends Source {\n  constructor() {\n    super();\n    this._children = [];\n\n    for (let i = 0; i < arguments.length; i++) {\n      const item = arguments[i];\n\n      if (item instanceof ConcatSource) {\n        for (const child of item._children) {\n          this._children.push(child);\n        }\n      } else {\n        this._children.push(item);\n      }\n    }\n\n    this._isOptimized = arguments.length === 0;\n  }\n\n  getChildren() {\n    if (!this._isOptimized) this._optimize();\n    return this._children;\n  }\n\n  add(item) {\n    if (item instanceof ConcatSource) {\n      for (const child of item._children) {\n        this._children.push(child);\n      }\n    } else {\n      this._children.push(item);\n    }\n\n    this._isOptimized = false;\n  }\n\n  addAllSkipOptimizing(items) {\n    for (const item of items) {\n      this._children.push(item);\n    }\n  }\n\n  buffer() {\n    if (!this._isOptimized) this._optimize();\n    const buffers = [];\n\n    for (const child of this._children) {\n      if (typeof child.buffer === \"function\") {\n        buffers.push(child.buffer());\n      } else {\n        const bufferOrString = child.source();\n\n        if (Buffer.isBuffer(bufferOrString)) {\n          buffers.push(bufferOrString);\n        } else {\n          // This will not happen\n          buffers.push(Buffer.from(bufferOrString, \"utf-8\"));\n        }\n      }\n    }\n\n    return Buffer.concat(buffers);\n  }\n\n  source() {\n    if (!this._isOptimized) this._optimize();\n    let source = \"\";\n\n    for (const child of this._children) {\n      source += child.source();\n    }\n\n    return source;\n  }\n\n  size() {\n    if (!this._isOptimized) this._optimize();\n    let size = 0;\n\n    for (const child of this._children) {\n      size += child.size();\n    }\n\n    return size;\n  }\n\n  map(options) {\n    return getMap(this, options);\n  }\n\n  sourceAndMap(options) {\n    return getSourceAndMap(this, options);\n  }\n\n  streamChunks(options, onChunk, onSource, onName) {\n    if (!this._isOptimized) this._optimize();\n    if (this._children.length === 1) return this._children[0].streamChunks(options, onChunk, onSource, onName);\n    let currentLineOffset = 0;\n    let currentColumnOffset = 0;\n    let sourceMapping = new Map();\n    let nameMapping = new Map();\n    const finalSource = !!(options && options.finalSource);\n    let code = \"\";\n    let needToCloseMapping = false;\n\n    for (const item of this._children) {\n      const sourceIndexMapping = [];\n      const nameIndexMapping = [];\n      let lastMappingLine = 0;\n      const {\n        generatedLine,\n        generatedColumn,\n        source\n      } = streamChunks(item, options, // eslint-disable-next-line no-loop-func\n      (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {\n        const line = generatedLine + currentLineOffset;\n        const column = generatedLine === 1 ? generatedColumn + currentColumnOffset : generatedColumn;\n\n        if (needToCloseMapping) {\n          if (generatedLine !== 1 || generatedColumn !== 0) {\n            onChunk(undefined, currentLineOffset + 1, currentColumnOffset, -1, -1, -1, -1);\n          }\n\n          needToCloseMapping = false;\n        }\n\n        const resultSourceIndex = sourceIndex < 0 || sourceIndex >= sourceIndexMapping.length ? -1 : sourceIndexMapping[sourceIndex];\n        const resultNameIndex = nameIndex < 0 || nameIndex >= nameIndexMapping.length ? -1 : nameIndexMapping[nameIndex];\n        lastMappingLine = resultSourceIndex < 0 ? 0 : generatedLine;\n\n        if (finalSource) {\n          if (chunk !== undefined) code += chunk;\n\n          if (resultSourceIndex >= 0) {\n            onChunk(undefined, line, column, resultSourceIndex, originalLine, originalColumn, resultNameIndex);\n          }\n        } else {\n          if (resultSourceIndex < 0) {\n            onChunk(chunk, line, column, -1, -1, -1, -1);\n          } else {\n            onChunk(chunk, line, column, resultSourceIndex, originalLine, originalColumn, resultNameIndex);\n          }\n        }\n      }, (i, source, sourceContent) => {\n        let globalIndex = sourceMapping.get(source);\n\n        if (globalIndex === undefined) {\n          sourceMapping.set(source, globalIndex = sourceMapping.size);\n          onSource(globalIndex, source, sourceContent);\n        }\n\n        sourceIndexMapping[i] = globalIndex;\n      }, (i, name) => {\n        let globalIndex = nameMapping.get(name);\n\n        if (globalIndex === undefined) {\n          nameMapping.set(name, globalIndex = nameMapping.size);\n          onName(globalIndex, name);\n        }\n\n        nameIndexMapping[i] = globalIndex;\n      });\n      if (source !== undefined) code += source;\n\n      if (needToCloseMapping) {\n        if (generatedLine !== 1 || generatedColumn !== 0) {\n          onChunk(undefined, currentLineOffset + 1, currentColumnOffset, -1, -1, -1, -1);\n          needToCloseMapping = false;\n        }\n      }\n\n      if (generatedLine > 1) {\n        currentColumnOffset = generatedColumn;\n      } else {\n        currentColumnOffset += generatedColumn;\n      }\n\n      needToCloseMapping = needToCloseMapping || finalSource && lastMappingLine === generatedLine;\n      currentLineOffset += generatedLine - 1;\n    }\n\n    return {\n      generatedLine: currentLineOffset + 1,\n      generatedColumn: currentColumnOffset,\n      source: finalSource ? code : undefined\n    };\n  }\n\n  updateHash(hash) {\n    if (!this._isOptimized) this._optimize();\n    hash.update(\"ConcatSource\");\n\n    for (const item of this._children) {\n      item.updateHash(hash);\n    }\n  }\n\n  _optimize() {\n    const newChildren = [];\n    let currentString = undefined;\n    let currentRawSources = undefined;\n\n    const addStringToRawSources = string => {\n      if (currentRawSources === undefined) {\n        currentRawSources = string;\n      } else if (Array.isArray(currentRawSources)) {\n        currentRawSources.push(string);\n      } else {\n        currentRawSources = [typeof currentRawSources === \"string\" ? currentRawSources : currentRawSources.source(), string];\n      }\n    };\n\n    const addSourceToRawSources = source => {\n      if (currentRawSources === undefined) {\n        currentRawSources = source;\n      } else if (Array.isArray(currentRawSources)) {\n        currentRawSources.push(source.source());\n      } else {\n        currentRawSources = [typeof currentRawSources === \"string\" ? currentRawSources : currentRawSources.source(), source.source()];\n      }\n    };\n\n    const mergeRawSources = () => {\n      if (Array.isArray(currentRawSources)) {\n        const rawSource = new RawSource(currentRawSources.join(\"\"));\n        stringsAsRawSources.add(rawSource);\n        newChildren.push(rawSource);\n      } else if (typeof currentRawSources === \"string\") {\n        const rawSource = new RawSource(currentRawSources);\n        stringsAsRawSources.add(rawSource);\n        newChildren.push(rawSource);\n      } else {\n        newChildren.push(currentRawSources);\n      }\n    };\n\n    for (const child of this._children) {\n      if (typeof child === \"string\") {\n        if (currentString === undefined) {\n          currentString = child;\n        } else {\n          currentString += child;\n        }\n      } else {\n        if (currentString !== undefined) {\n          addStringToRawSources(currentString);\n          currentString = undefined;\n        }\n\n        if (stringsAsRawSources.has(child)) {\n          addSourceToRawSources(child);\n        } else {\n          if (currentRawSources !== undefined) {\n            mergeRawSources();\n            currentRawSources = undefined;\n          }\n\n          newChildren.push(child);\n        }\n      }\n    }\n\n    if (currentString !== undefined) {\n      addStringToRawSources(currentString);\n    }\n\n    if (currentRawSources !== undefined) {\n      mergeRawSources();\n    }\n\n    this._children = newChildren;\n    this._isOptimized = true;\n  }\n\n}\n\nmodule.exports = ConcatSource;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack-sources/lib/ConcatSource.js"],"names":["Source","require","RawSource","streamChunks","getMap","getSourceAndMap","stringsAsRawSources","WeakSet","ConcatSource","constructor","_children","i","arguments","length","item","child","push","_isOptimized","getChildren","_optimize","add","addAllSkipOptimizing","items","buffer","buffers","bufferOrString","source","Buffer","isBuffer","from","concat","size","map","options","sourceAndMap","onChunk","onSource","onName","currentLineOffset","currentColumnOffset","sourceMapping","Map","nameMapping","finalSource","code","needToCloseMapping","sourceIndexMapping","nameIndexMapping","lastMappingLine","generatedLine","generatedColumn","chunk","sourceIndex","originalLine","originalColumn","nameIndex","line","column","undefined","resultSourceIndex","resultNameIndex","sourceContent","globalIndex","get","set","name","updateHash","hash","update","newChildren","currentString","currentRawSources","addStringToRawSources","string","Array","isArray","addSourceToRawSources","mergeRawSources","rawSource","join","has","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Source = require(\"./Source\");\nconst RawSource = require(\"./RawSource\");\nconst streamChunks = require(\"./helpers/streamChunks\");\nconst { getMap, getSourceAndMap } = require(\"./helpers/getFromStreamChunks\");\n\nconst stringsAsRawSources = new WeakSet();\n\nclass ConcatSource extends Source {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._children = [];\n\t\tfor (let i = 0; i < arguments.length; i++) {\n\t\t\tconst item = arguments[i];\n\t\t\tif (item instanceof ConcatSource) {\n\t\t\t\tfor (const child of item._children) {\n\t\t\t\t\tthis._children.push(child);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._children.push(item);\n\t\t\t}\n\t\t}\n\t\tthis._isOptimized = arguments.length === 0;\n\t}\n\n\tgetChildren() {\n\t\tif (!this._isOptimized) this._optimize();\n\t\treturn this._children;\n\t}\n\n\tadd(item) {\n\t\tif (item instanceof ConcatSource) {\n\t\t\tfor (const child of item._children) {\n\t\t\t\tthis._children.push(child);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._children.push(item);\n\t\t}\n\t\tthis._isOptimized = false;\n\t}\n\n\taddAllSkipOptimizing(items) {\n\t\tfor (const item of items) {\n\t\t\tthis._children.push(item);\n\t\t}\n\t}\n\n\tbuffer() {\n\t\tif (!this._isOptimized) this._optimize();\n\t\tconst buffers = [];\n\t\tfor (const child of this._children) {\n\t\t\tif (typeof child.buffer === \"function\") {\n\t\t\t\tbuffers.push(child.buffer());\n\t\t\t} else {\n\t\t\t\tconst bufferOrString = child.source();\n\t\t\t\tif (Buffer.isBuffer(bufferOrString)) {\n\t\t\t\t\tbuffers.push(bufferOrString);\n\t\t\t\t} else {\n\t\t\t\t\t// This will not happen\n\t\t\t\t\tbuffers.push(Buffer.from(bufferOrString, \"utf-8\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Buffer.concat(buffers);\n\t}\n\n\tsource() {\n\t\tif (!this._isOptimized) this._optimize();\n\t\tlet source = \"\";\n\t\tfor (const child of this._children) {\n\t\t\tsource += child.source();\n\t\t}\n\t\treturn source;\n\t}\n\n\tsize() {\n\t\tif (!this._isOptimized) this._optimize();\n\t\tlet size = 0;\n\t\tfor (const child of this._children) {\n\t\t\tsize += child.size();\n\t\t}\n\t\treturn size;\n\t}\n\n\tmap(options) {\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tif (!this._isOptimized) this._optimize();\n\t\tif (this._children.length === 1)\n\t\t\treturn this._children[0].streamChunks(options, onChunk, onSource, onName);\n\t\tlet currentLineOffset = 0;\n\t\tlet currentColumnOffset = 0;\n\t\tlet sourceMapping = new Map();\n\t\tlet nameMapping = new Map();\n\t\tconst finalSource = !!(options && options.finalSource);\n\t\tlet code = \"\";\n\t\tlet needToCloseMapping = false;\n\t\tfor (const item of this._children) {\n\t\t\tconst sourceIndexMapping = [];\n\t\t\tconst nameIndexMapping = [];\n\t\t\tlet lastMappingLine = 0;\n\t\t\tconst { generatedLine, generatedColumn, source } = streamChunks(\n\t\t\t\titem,\n\t\t\t\toptions,\n\t\t\t\t// eslint-disable-next-line no-loop-func\n\t\t\t\t(\n\t\t\t\t\tchunk,\n\t\t\t\t\tgeneratedLine,\n\t\t\t\t\tgeneratedColumn,\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\toriginalLine,\n\t\t\t\t\toriginalColumn,\n\t\t\t\t\tnameIndex\n\t\t\t\t) => {\n\t\t\t\t\tconst line = generatedLine + currentLineOffset;\n\t\t\t\t\tconst column =\n\t\t\t\t\t\tgeneratedLine === 1\n\t\t\t\t\t\t\t? generatedColumn + currentColumnOffset\n\t\t\t\t\t\t\t: generatedColumn;\n\t\t\t\t\tif (needToCloseMapping) {\n\t\t\t\t\t\tif (generatedLine !== 1 || generatedColumn !== 0) {\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tcurrentLineOffset + 1,\n\t\t\t\t\t\t\t\tcurrentColumnOffset,\n\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t-1\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tneedToCloseMapping = false;\n\t\t\t\t\t}\n\t\t\t\t\tconst resultSourceIndex =\n\t\t\t\t\t\tsourceIndex < 0 || sourceIndex >= sourceIndexMapping.length\n\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t: sourceIndexMapping[sourceIndex];\n\t\t\t\t\tconst resultNameIndex =\n\t\t\t\t\t\tnameIndex < 0 || nameIndex >= nameIndexMapping.length\n\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t: nameIndexMapping[nameIndex];\n\t\t\t\t\tlastMappingLine = resultSourceIndex < 0 ? 0 : generatedLine;\n\t\t\t\t\tif (finalSource) {\n\t\t\t\t\t\tif (chunk !== undefined) code += chunk;\n\t\t\t\t\t\tif (resultSourceIndex >= 0) {\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tcolumn,\n\t\t\t\t\t\t\t\tresultSourceIndex,\n\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\tresultNameIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (resultSourceIndex < 0) {\n\t\t\t\t\t\t\tonChunk(chunk, line, column, -1, -1, -1, -1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tcolumn,\n\t\t\t\t\t\t\t\tresultSourceIndex,\n\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\tresultNameIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t(i, source, sourceContent) => {\n\t\t\t\t\tlet globalIndex = sourceMapping.get(source);\n\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\tsourceMapping.set(source, (globalIndex = sourceMapping.size));\n\t\t\t\t\t\tonSource(globalIndex, source, sourceContent);\n\t\t\t\t\t}\n\t\t\t\t\tsourceIndexMapping[i] = globalIndex;\n\t\t\t\t},\n\t\t\t\t(i, name) => {\n\t\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\tnameMapping.set(name, (globalIndex = nameMapping.size));\n\t\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t\t}\n\t\t\t\t\tnameIndexMapping[i] = globalIndex;\n\t\t\t\t}\n\t\t\t);\n\t\t\tif (source !== undefined) code += source;\n\t\t\tif (needToCloseMapping) {\n\t\t\t\tif (generatedLine !== 1 || generatedColumn !== 0) {\n\t\t\t\t\tonChunk(\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tcurrentLineOffset + 1,\n\t\t\t\t\t\tcurrentColumnOffset,\n\t\t\t\t\t\t-1,\n\t\t\t\t\t\t-1,\n\t\t\t\t\t\t-1,\n\t\t\t\t\t\t-1\n\t\t\t\t\t);\n\t\t\t\t\tneedToCloseMapping = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (generatedLine > 1) {\n\t\t\t\tcurrentColumnOffset = generatedColumn;\n\t\t\t} else {\n\t\t\t\tcurrentColumnOffset += generatedColumn;\n\t\t\t}\n\t\t\tneedToCloseMapping =\n\t\t\t\tneedToCloseMapping ||\n\t\t\t\t(finalSource && lastMappingLine === generatedLine);\n\t\t\tcurrentLineOffset += generatedLine - 1;\n\t\t}\n\t\treturn {\n\t\t\tgeneratedLine: currentLineOffset + 1,\n\t\t\tgeneratedColumn: currentColumnOffset,\n\t\t\tsource: finalSource ? code : undefined\n\t\t};\n\t}\n\n\tupdateHash(hash) {\n\t\tif (!this._isOptimized) this._optimize();\n\t\thash.update(\"ConcatSource\");\n\t\tfor (const item of this._children) {\n\t\t\titem.updateHash(hash);\n\t\t}\n\t}\n\n\t_optimize() {\n\t\tconst newChildren = [];\n\t\tlet currentString = undefined;\n\t\tlet currentRawSources = undefined;\n\t\tconst addStringToRawSources = string => {\n\t\t\tif (currentRawSources === undefined) {\n\t\t\t\tcurrentRawSources = string;\n\t\t\t} else if (Array.isArray(currentRawSources)) {\n\t\t\t\tcurrentRawSources.push(string);\n\t\t\t} else {\n\t\t\t\tcurrentRawSources = [\n\t\t\t\t\ttypeof currentRawSources === \"string\"\n\t\t\t\t\t\t? currentRawSources\n\t\t\t\t\t\t: currentRawSources.source(),\n\t\t\t\t\tstring\n\t\t\t\t];\n\t\t\t}\n\t\t};\n\t\tconst addSourceToRawSources = source => {\n\t\t\tif (currentRawSources === undefined) {\n\t\t\t\tcurrentRawSources = source;\n\t\t\t} else if (Array.isArray(currentRawSources)) {\n\t\t\t\tcurrentRawSources.push(source.source());\n\t\t\t} else {\n\t\t\t\tcurrentRawSources = [\n\t\t\t\t\ttypeof currentRawSources === \"string\"\n\t\t\t\t\t\t? currentRawSources\n\t\t\t\t\t\t: currentRawSources.source(),\n\t\t\t\t\tsource.source()\n\t\t\t\t];\n\t\t\t}\n\t\t};\n\t\tconst mergeRawSources = () => {\n\t\t\tif (Array.isArray(currentRawSources)) {\n\t\t\t\tconst rawSource = new RawSource(currentRawSources.join(\"\"));\n\t\t\t\tstringsAsRawSources.add(rawSource);\n\t\t\t\tnewChildren.push(rawSource);\n\t\t\t} else if (typeof currentRawSources === \"string\") {\n\t\t\t\tconst rawSource = new RawSource(currentRawSources);\n\t\t\t\tstringsAsRawSources.add(rawSource);\n\t\t\t\tnewChildren.push(rawSource);\n\t\t\t} else {\n\t\t\t\tnewChildren.push(currentRawSources);\n\t\t\t}\n\t\t};\n\t\tfor (const child of this._children) {\n\t\t\tif (typeof child === \"string\") {\n\t\t\t\tif (currentString === undefined) {\n\t\t\t\t\tcurrentString = child;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentString += child;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (currentString !== undefined) {\n\t\t\t\t\taddStringToRawSources(currentString);\n\t\t\t\t\tcurrentString = undefined;\n\t\t\t\t}\n\t\t\t\tif (stringsAsRawSources.has(child)) {\n\t\t\t\t\taddSourceToRawSources(child);\n\t\t\t\t} else {\n\t\t\t\t\tif (currentRawSources !== undefined) {\n\t\t\t\t\t\tmergeRawSources();\n\t\t\t\t\t\tcurrentRawSources = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tnewChildren.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (currentString !== undefined) {\n\t\t\taddStringToRawSources(currentString);\n\t\t}\n\t\tif (currentRawSources !== undefined) {\n\t\t\tmergeRawSources();\n\t\t}\n\t\tthis._children = newChildren;\n\t\tthis._isOptimized = true;\n\t}\n}\n\nmodule.exports = ConcatSource;\n"]},"metadata":{},"sourceType":"script"}