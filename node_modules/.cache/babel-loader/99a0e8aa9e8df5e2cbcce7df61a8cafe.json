{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst path = require(\"path\");\n\nconst webpackSchema = require(\"../schemas/WebpackOptions.json\"); // TODO add originPath to PathItem for better errors\n\n/**\n * @typedef {Object} PathItem\n * @property {any} schema the part of the schema\n * @property {string} path the path in the config\n */\n\n/** @typedef {\"unknown-argument\" | \"unexpected-non-array-in-path\" | \"unexpected-non-object-in-path\" | \"multiple-values-unexpected\" | \"invalid-value\"} ProblemType */\n\n/**\n * @typedef {Object} Problem\n * @property {ProblemType} type\n * @property {string} path\n * @property {string} argument\n * @property {any=} value\n * @property {number=} index\n * @property {string=} expected\n */\n\n/**\n * @typedef {Object} LocalProblem\n * @property {ProblemType} type\n * @property {string} path\n * @property {string=} expected\n */\n\n/**\n * @typedef {Object} ArgumentConfig\n * @property {string} description\n * @property {string} [negatedDescription]\n * @property {string} path\n * @property {boolean} multiple\n * @property {\"enum\"|\"string\"|\"path\"|\"number\"|\"boolean\"|\"RegExp\"|\"reset\"} type\n * @property {any[]=} values\n */\n\n/**\n * @typedef {Object} Argument\n * @property {string} description\n * @property {\"string\"|\"number\"|\"boolean\"} simpleType\n * @property {boolean} multiple\n * @property {ArgumentConfig[]} configs\n */\n\n/**\n * @param {any=} schema a json schema to create arguments for (by default webpack schema is used)\n * @returns {Record<string, Argument>} object of arguments\n */\n\n\nconst getArguments = function () {\n  let schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : webpackSchema;\n\n  /** @type {Record<string, Argument>} */\n  const flags = {};\n\n  const pathToArgumentName = input => {\n    return input.replace(/\\./g, \"-\").replace(/\\[\\]/g, \"\").replace(/(\\p{Uppercase_Letter}+|\\p{Lowercase_Letter}|\\d)(\\p{Uppercase_Letter}+)/gu, \"$1-$2\").replace(/-?[^\\p{Uppercase_Letter}\\p{Lowercase_Letter}\\d]+/gu, \"-\").toLowerCase();\n  };\n\n  const getSchemaPart = path => {\n    const newPath = path.split(\"/\");\n    let schemaPart = schema;\n\n    for (let i = 1; i < newPath.length; i++) {\n      const inner = schemaPart[newPath[i]];\n\n      if (!inner) {\n        break;\n      }\n\n      schemaPart = inner;\n    }\n\n    return schemaPart;\n  };\n  /**\n   *\n   * @param {PathItem[]} path path in the schema\n   * @returns {string | undefined} description\n   */\n\n\n  const getDescription = path => {\n    for (const {\n      schema\n    } of path) {\n      if (schema.cli) {\n        if (schema.cli.helper) continue;\n        if (schema.cli.description) return schema.cli.description;\n      }\n\n      if (schema.description) return schema.description;\n    }\n  };\n  /**\n   *\n   * @param {PathItem[]} path path in the schema\n   * @returns {string | undefined} negative description\n   */\n\n\n  const getNegatedDescription = path => {\n    for (const {\n      schema\n    } of path) {\n      if (schema.cli) {\n        if (schema.cli.helper) continue;\n        if (schema.cli.negatedDescription) return schema.cli.negatedDescription;\n      }\n    }\n  };\n  /**\n   *\n   * @param {PathItem[]} path path in the schema\n   * @returns {string | undefined} reset description\n   */\n\n\n  const getResetDescription = path => {\n    for (const {\n      schema\n    } of path) {\n      if (schema.cli) {\n        if (schema.cli.helper) continue;\n        if (schema.cli.resetDescription) return schema.cli.resetDescription;\n      }\n    }\n  };\n  /**\n   *\n   * @param {any} schemaPart schema\n   * @returns {Pick<ArgumentConfig, \"type\"|\"values\">} partial argument config\n   */\n\n\n  const schemaToArgumentConfig = schemaPart => {\n    if (schemaPart.enum) {\n      return {\n        type: \"enum\",\n        values: schemaPart.enum\n      };\n    }\n\n    switch (schemaPart.type) {\n      case \"number\":\n        return {\n          type: \"number\"\n        };\n\n      case \"string\":\n        return {\n          type: schemaPart.absolutePath ? \"path\" : \"string\"\n        };\n\n      case \"boolean\":\n        return {\n          type: \"boolean\"\n        };\n    }\n\n    if (schemaPart.instanceof === \"RegExp\") {\n      return {\n        type: \"RegExp\"\n      };\n    }\n\n    return undefined;\n  };\n  /**\n   * @param {PathItem[]} path path in the schema\n   * @returns {void}\n   */\n\n\n  const addResetFlag = path => {\n    const schemaPath = path[0].path;\n    const name = pathToArgumentName(`${schemaPath}.reset`);\n    const description = getResetDescription(path) || `Clear all items provided in '${schemaPath}' configuration. ${getDescription(path)}`;\n    flags[name] = {\n      configs: [{\n        type: \"reset\",\n        multiple: false,\n        description,\n        path: schemaPath\n      }],\n      description: undefined,\n      simpleType: undefined,\n      multiple: undefined\n    };\n  };\n  /**\n   * @param {PathItem[]} path full path in schema\n   * @param {boolean} multiple inside of an array\n   * @returns {number} number of arguments added\n   */\n\n\n  const addFlag = (path, multiple) => {\n    const argConfigBase = schemaToArgumentConfig(path[0].schema);\n    if (!argConfigBase) return 0;\n    const negatedDescription = getNegatedDescription(path);\n    const name = pathToArgumentName(path[0].path);\n    /** @type {ArgumentConfig} */\n\n    const argConfig = { ...argConfigBase,\n      multiple,\n      description: getDescription(path),\n      path: path[0].path\n    };\n\n    if (negatedDescription) {\n      argConfig.negatedDescription = negatedDescription;\n    }\n\n    if (!flags[name]) {\n      flags[name] = {\n        configs: [],\n        description: undefined,\n        simpleType: undefined,\n        multiple: undefined\n      };\n    }\n\n    if (flags[name].configs.some(item => JSON.stringify(item) === JSON.stringify(argConfig))) {\n      return 0;\n    }\n\n    if (flags[name].configs.some(item => item.type === argConfig.type && item.multiple !== multiple)) {\n      if (multiple) {\n        throw new Error(`Conflicting schema for ${path[0].path} with ${argConfig.type} type (array type must be before single item type)`);\n      }\n\n      return 0;\n    }\n\n    flags[name].configs.push(argConfig);\n    return 1;\n  }; // TODO support `not` and `if/then/else`\n  // TODO support `const`, but we don't use it on our schema\n\n  /**\n   *\n   * @param {object} schemaPart the current schema\n   * @param {string} schemaPath the current path in the schema\n   * @param {{schema: object, path: string}[]} path all previous visited schemaParts\n   * @param {string | null} inArray if inside of an array, the path to the array\n   * @returns {number} added arguments\n   */\n\n\n  const traverse = function (schemaPart) {\n    let schemaPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let inArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    while (schemaPart.$ref) {\n      schemaPart = getSchemaPart(schemaPart.$ref);\n    }\n\n    const repetitions = path.filter(_ref => {\n      let {\n        schema\n      } = _ref;\n      return schema === schemaPart;\n    });\n\n    if (repetitions.length >= 2 || repetitions.some(_ref2 => {\n      let {\n        path\n      } = _ref2;\n      return path === schemaPath;\n    })) {\n      return 0;\n    }\n\n    if (schemaPart.cli && schemaPart.cli.exclude) return 0;\n    const fullPath = [{\n      schema: schemaPart,\n      path: schemaPath\n    }, ...path];\n    let addedArguments = 0;\n    addedArguments += addFlag(fullPath, !!inArray);\n\n    if (schemaPart.type === \"object\") {\n      if (schemaPart.properties) {\n        for (const property of Object.keys(schemaPart.properties)) {\n          addedArguments += traverse(schemaPart.properties[property], schemaPath ? `${schemaPath}.${property}` : property, fullPath, inArray);\n        }\n      }\n\n      return addedArguments;\n    }\n\n    if (schemaPart.type === \"array\") {\n      if (inArray) {\n        return 0;\n      }\n\n      if (Array.isArray(schemaPart.items)) {\n        let i = 0;\n\n        for (const item of schemaPart.items) {\n          addedArguments += traverse(item, `${schemaPath}.${i}`, fullPath, schemaPath);\n        }\n\n        return addedArguments;\n      }\n\n      addedArguments += traverse(schemaPart.items, `${schemaPath}[]`, fullPath, schemaPath);\n\n      if (addedArguments > 0) {\n        addResetFlag(fullPath);\n        addedArguments++;\n      }\n\n      return addedArguments;\n    }\n\n    const maybeOf = schemaPart.oneOf || schemaPart.anyOf || schemaPart.allOf;\n\n    if (maybeOf) {\n      const items = maybeOf;\n\n      for (let i = 0; i < items.length; i++) {\n        addedArguments += traverse(items[i], schemaPath, fullPath, inArray);\n      }\n\n      return addedArguments;\n    }\n\n    return addedArguments;\n  };\n\n  traverse(schema); // Summarize flags\n\n  for (const name of Object.keys(flags)) {\n    const argument = flags[name];\n    argument.description = argument.configs.reduce((desc, _ref3) => {\n      let {\n        description\n      } = _ref3;\n      if (!desc) return description;\n      if (!description) return desc;\n      if (desc.includes(description)) return desc;\n      return `${desc} ${description}`;\n    },\n    /** @type {string | undefined} */\n    undefined);\n    argument.simpleType = argument.configs.reduce((t, argConfig) => {\n      /** @type {\"string\" | \"number\" | \"boolean\"} */\n      let type = \"string\";\n\n      switch (argConfig.type) {\n        case \"number\":\n          type = \"number\";\n          break;\n\n        case \"reset\":\n        case \"boolean\":\n          type = \"boolean\";\n          break;\n\n        case \"enum\":\n          if (argConfig.values.every(v => typeof v === \"boolean\")) type = \"boolean\";\n          if (argConfig.values.every(v => typeof v === \"number\")) type = \"number\";\n          break;\n      }\n\n      if (t === undefined) return type;\n      return t === type ? t : \"string\";\n    },\n    /** @type {\"string\" | \"number\" | \"boolean\" | undefined} */\n    undefined);\n    argument.multiple = argument.configs.some(c => c.multiple);\n  }\n\n  return flags;\n};\n\nconst cliAddedItems = new WeakMap();\n/**\n * @param {any} config configuration\n * @param {string} schemaPath path in the config\n * @param {number | undefined} index index of value when multiple values are provided, otherwise undefined\n * @returns {{ problem?: LocalProblem, object?: any, property?: string | number, value?: any }} problem or object with property and value\n */\n\nconst getObjectAndProperty = function (config, schemaPath) {\n  let index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  if (!schemaPath) return {\n    value: config\n  };\n  const parts = schemaPath.split(\".\");\n  let property = parts.pop();\n  let current = config;\n  let i = 0;\n\n  for (const part of parts) {\n    const isArray = part.endsWith(\"[]\");\n    const name = isArray ? part.slice(0, -2) : part;\n    let value = current[name];\n\n    if (isArray) {\n      if (value === undefined) {\n        value = {};\n        current[name] = [...Array.from({\n          length: index\n        }), value];\n        cliAddedItems.set(current[name], index + 1);\n      } else if (!Array.isArray(value)) {\n        return {\n          problem: {\n            type: \"unexpected-non-array-in-path\",\n            path: parts.slice(0, i).join(\".\")\n          }\n        };\n      } else {\n        let addedItems = cliAddedItems.get(value) || 0;\n\n        while (addedItems <= index) {\n          value.push(undefined);\n          addedItems++;\n        }\n\n        cliAddedItems.set(value, addedItems);\n        const x = value.length - addedItems + index;\n\n        if (value[x] === undefined) {\n          value[x] = {};\n        } else if (value[x] === null || typeof value[x] !== \"object\") {\n          return {\n            problem: {\n              type: \"unexpected-non-object-in-path\",\n              path: parts.slice(0, i).join(\".\")\n            }\n          };\n        }\n\n        value = value[x];\n      }\n    } else {\n      if (value === undefined) {\n        value = current[name] = {};\n      } else if (value === null || typeof value !== \"object\") {\n        return {\n          problem: {\n            type: \"unexpected-non-object-in-path\",\n            path: parts.slice(0, i).join(\".\")\n          }\n        };\n      }\n    }\n\n    current = value;\n    i++;\n  }\n\n  let value = current[property];\n\n  if (property.endsWith(\"[]\")) {\n    const name = property.slice(0, -2);\n    const value = current[name];\n\n    if (value === undefined) {\n      current[name] = [...Array.from({\n        length: index\n      }), undefined];\n      cliAddedItems.set(current[name], index + 1);\n      return {\n        object: current[name],\n        property: index,\n        value: undefined\n      };\n    } else if (!Array.isArray(value)) {\n      current[name] = [value, ...Array.from({\n        length: index\n      }), undefined];\n      cliAddedItems.set(current[name], index + 1);\n      return {\n        object: current[name],\n        property: index + 1,\n        value: undefined\n      };\n    } else {\n      let addedItems = cliAddedItems.get(value) || 0;\n\n      while (addedItems <= index) {\n        value.push(undefined);\n        addedItems++;\n      }\n\n      cliAddedItems.set(value, addedItems);\n      const x = value.length - addedItems + index;\n\n      if (value[x] === undefined) {\n        value[x] = {};\n      } else if (value[x] === null || typeof value[x] !== \"object\") {\n        return {\n          problem: {\n            type: \"unexpected-non-object-in-path\",\n            path: schemaPath\n          }\n        };\n      }\n\n      return {\n        object: value,\n        property: x,\n        value: value[x]\n      };\n    }\n  }\n\n  return {\n    object: current,\n    property,\n    value\n  };\n};\n/**\n * @param {any} config configuration\n * @param {string} schemaPath path in the config\n * @param {any} value parsed value\n * @param {number | undefined} index index of value when multiple values are provided, otherwise undefined\n * @returns {LocalProblem | null} problem or null for success\n */\n\n\nconst setValue = (config, schemaPath, value, index) => {\n  const {\n    problem,\n    object,\n    property\n  } = getObjectAndProperty(config, schemaPath, index);\n  if (problem) return problem;\n  object[property] = value;\n  return null;\n};\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @param {any} config configuration\n * @param {any} value the value\n * @param {number | undefined} index the index if multiple values provided\n * @returns {LocalProblem | null} a problem if any\n */\n\n\nconst processArgumentConfig = (argConfig, config, value, index) => {\n  if (index !== undefined && !argConfig.multiple) {\n    return {\n      type: \"multiple-values-unexpected\",\n      path: argConfig.path\n    };\n  }\n\n  const parsed = parseValueForArgumentConfig(argConfig, value);\n\n  if (parsed === undefined) {\n    return {\n      type: \"invalid-value\",\n      path: argConfig.path,\n      expected: getExpectedValue(argConfig)\n    };\n  }\n\n  const problem = setValue(config, argConfig.path, parsed, index);\n  if (problem) return problem;\n  return null;\n};\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @returns {string | undefined} expected message\n */\n\n\nconst getExpectedValue = argConfig => {\n  switch (argConfig.type) {\n    default:\n      return argConfig.type;\n\n    case \"boolean\":\n      return \"true | false\";\n\n    case \"RegExp\":\n      return \"regular expression (example: /ab?c*/)\";\n\n    case \"enum\":\n      return argConfig.values.map(v => `${v}`).join(\" | \");\n\n    case \"reset\":\n      return \"true (will reset the previous value to an empty array)\";\n  }\n};\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @param {any} value the value\n * @returns {any | undefined} parsed value\n */\n\n\nconst parseValueForArgumentConfig = (argConfig, value) => {\n  switch (argConfig.type) {\n    case \"string\":\n      if (typeof value === \"string\") {\n        return value;\n      }\n\n      break;\n\n    case \"path\":\n      if (typeof value === \"string\") {\n        return path.resolve(value);\n      }\n\n      break;\n\n    case \"number\":\n      if (typeof value === \"number\") return value;\n\n      if (typeof value === \"string\" && /^[+-]?\\d*(\\.\\d*)[eE]\\d+$/) {\n        const n = +value;\n        if (!isNaN(n)) return n;\n      }\n\n      break;\n\n    case \"boolean\":\n      if (typeof value === \"boolean\") return value;\n      if (value === \"true\") return true;\n      if (value === \"false\") return false;\n      break;\n\n    case \"RegExp\":\n      if (value instanceof RegExp) return value;\n\n      if (typeof value === \"string\") {\n        // cspell:word yugi\n        const match = /^\\/(.*)\\/([yugi]*)$/.exec(value);\n        if (match && !/[^\\\\]\\//.test(match[1])) return new RegExp(match[1], match[2]);\n      }\n\n      break;\n\n    case \"enum\":\n      if (argConfig.values.includes(value)) return value;\n\n      for (const item of argConfig.values) {\n        if (`${item}` === value) return item;\n      }\n\n      break;\n\n    case \"reset\":\n      if (value === true) return [];\n      break;\n  }\n};\n/**\n * @param {Record<string, Argument>} args object of arguments\n * @param {any} config configuration\n * @param {Record<string, string | number | boolean | RegExp | (string | number | boolean | RegExp)[]>} values object with values\n * @returns {Problem[] | null} problems or null for success\n */\n\n\nconst processArguments = (args, config, values) => {\n  /** @type {Problem[]} */\n  const problems = [];\n\n  for (const key of Object.keys(values)) {\n    const arg = args[key];\n\n    if (!arg) {\n      problems.push({\n        type: \"unknown-argument\",\n        path: \"\",\n        argument: key\n      });\n      continue;\n    }\n\n    const processValue = (value, i) => {\n      const currentProblems = [];\n\n      for (const argConfig of arg.configs) {\n        const problem = processArgumentConfig(argConfig, config, value, i);\n\n        if (!problem) {\n          return;\n        }\n\n        currentProblems.push({ ...problem,\n          argument: key,\n          value: value,\n          index: i\n        });\n      }\n\n      problems.push(...currentProblems);\n    };\n\n    let value = values[key];\n\n    if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        processValue(value[i], i);\n      }\n    } else {\n      processValue(value, undefined);\n    }\n  }\n\n  if (problems.length === 0) return null;\n  return problems;\n};\n\nexports.getArguments = getArguments;\nexports.processArguments = processArguments;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/cli.js"],"names":["path","require","webpackSchema","getArguments","schema","flags","pathToArgumentName","input","replace","toLowerCase","getSchemaPart","newPath","split","schemaPart","i","length","inner","getDescription","cli","helper","description","getNegatedDescription","negatedDescription","getResetDescription","resetDescription","schemaToArgumentConfig","enum","type","values","absolutePath","instanceof","undefined","addResetFlag","schemaPath","name","configs","multiple","simpleType","addFlag","argConfigBase","argConfig","some","item","JSON","stringify","Error","push","traverse","inArray","$ref","repetitions","filter","exclude","fullPath","addedArguments","properties","property","Object","keys","Array","isArray","items","maybeOf","oneOf","anyOf","allOf","argument","reduce","desc","includes","t","every","v","c","cliAddedItems","WeakMap","getObjectAndProperty","config","index","value","parts","pop","current","part","endsWith","slice","from","set","problem","join","addedItems","get","x","object","setValue","processArgumentConfig","parsed","parseValueForArgumentConfig","expected","getExpectedValue","map","resolve","n","isNaN","RegExp","match","exec","test","processArguments","args","problems","key","arg","processValue","currentProblems","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\nconst webpackSchema = require(\"../schemas/WebpackOptions.json\");\n\n// TODO add originPath to PathItem for better errors\n/**\n * @typedef {Object} PathItem\n * @property {any} schema the part of the schema\n * @property {string} path the path in the config\n */\n\n/** @typedef {\"unknown-argument\" | \"unexpected-non-array-in-path\" | \"unexpected-non-object-in-path\" | \"multiple-values-unexpected\" | \"invalid-value\"} ProblemType */\n\n/**\n * @typedef {Object} Problem\n * @property {ProblemType} type\n * @property {string} path\n * @property {string} argument\n * @property {any=} value\n * @property {number=} index\n * @property {string=} expected\n */\n\n/**\n * @typedef {Object} LocalProblem\n * @property {ProblemType} type\n * @property {string} path\n * @property {string=} expected\n */\n\n/**\n * @typedef {Object} ArgumentConfig\n * @property {string} description\n * @property {string} [negatedDescription]\n * @property {string} path\n * @property {boolean} multiple\n * @property {\"enum\"|\"string\"|\"path\"|\"number\"|\"boolean\"|\"RegExp\"|\"reset\"} type\n * @property {any[]=} values\n */\n\n/**\n * @typedef {Object} Argument\n * @property {string} description\n * @property {\"string\"|\"number\"|\"boolean\"} simpleType\n * @property {boolean} multiple\n * @property {ArgumentConfig[]} configs\n */\n\n/**\n * @param {any=} schema a json schema to create arguments for (by default webpack schema is used)\n * @returns {Record<string, Argument>} object of arguments\n */\nconst getArguments = (schema = webpackSchema) => {\n\t/** @type {Record<string, Argument>} */\n\tconst flags = {};\n\n\tconst pathToArgumentName = input => {\n\t\treturn input\n\t\t\t.replace(/\\./g, \"-\")\n\t\t\t.replace(/\\[\\]/g, \"\")\n\t\t\t.replace(\n\t\t\t\t/(\\p{Uppercase_Letter}+|\\p{Lowercase_Letter}|\\d)(\\p{Uppercase_Letter}+)/gu,\n\t\t\t\t\"$1-$2\"\n\t\t\t)\n\t\t\t.replace(/-?[^\\p{Uppercase_Letter}\\p{Lowercase_Letter}\\d]+/gu, \"-\")\n\t\t\t.toLowerCase();\n\t};\n\n\tconst getSchemaPart = path => {\n\t\tconst newPath = path.split(\"/\");\n\n\t\tlet schemaPart = schema;\n\n\t\tfor (let i = 1; i < newPath.length; i++) {\n\t\t\tconst inner = schemaPart[newPath[i]];\n\n\t\t\tif (!inner) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tschemaPart = inner;\n\t\t}\n\n\t\treturn schemaPart;\n\t};\n\n\t/**\n\t *\n\t * @param {PathItem[]} path path in the schema\n\t * @returns {string | undefined} description\n\t */\n\tconst getDescription = path => {\n\t\tfor (const { schema } of path) {\n\t\t\tif (schema.cli) {\n\t\t\t\tif (schema.cli.helper) continue;\n\t\t\t\tif (schema.cli.description) return schema.cli.description;\n\t\t\t}\n\t\t\tif (schema.description) return schema.description;\n\t\t}\n\t};\n\n\t/**\n\t *\n\t * @param {PathItem[]} path path in the schema\n\t * @returns {string | undefined} negative description\n\t */\n\tconst getNegatedDescription = path => {\n\t\tfor (const { schema } of path) {\n\t\t\tif (schema.cli) {\n\t\t\t\tif (schema.cli.helper) continue;\n\t\t\t\tif (schema.cli.negatedDescription) return schema.cli.negatedDescription;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t *\n\t * @param {PathItem[]} path path in the schema\n\t * @returns {string | undefined} reset description\n\t */\n\tconst getResetDescription = path => {\n\t\tfor (const { schema } of path) {\n\t\t\tif (schema.cli) {\n\t\t\t\tif (schema.cli.helper) continue;\n\t\t\t\tif (schema.cli.resetDescription) return schema.cli.resetDescription;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t *\n\t * @param {any} schemaPart schema\n\t * @returns {Pick<ArgumentConfig, \"type\"|\"values\">} partial argument config\n\t */\n\tconst schemaToArgumentConfig = schemaPart => {\n\t\tif (schemaPart.enum) {\n\t\t\treturn {\n\t\t\t\ttype: \"enum\",\n\t\t\t\tvalues: schemaPart.enum\n\t\t\t};\n\t\t}\n\t\tswitch (schemaPart.type) {\n\t\t\tcase \"number\":\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"number\"\n\t\t\t\t};\n\t\t\tcase \"string\":\n\t\t\t\treturn {\n\t\t\t\t\ttype: schemaPart.absolutePath ? \"path\" : \"string\"\n\t\t\t\t};\n\t\t\tcase \"boolean\":\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"boolean\"\n\t\t\t\t};\n\t\t}\n\t\tif (schemaPart.instanceof === \"RegExp\") {\n\t\t\treturn {\n\t\t\t\ttype: \"RegExp\"\n\t\t\t};\n\t\t}\n\t\treturn undefined;\n\t};\n\n\t/**\n\t * @param {PathItem[]} path path in the schema\n\t * @returns {void}\n\t */\n\tconst addResetFlag = path => {\n\t\tconst schemaPath = path[0].path;\n\t\tconst name = pathToArgumentName(`${schemaPath}.reset`);\n\t\tconst description =\n\t\t\tgetResetDescription(path) ||\n\t\t\t`Clear all items provided in '${schemaPath}' configuration. ${getDescription(\n\t\t\t\tpath\n\t\t\t)}`;\n\t\tflags[name] = {\n\t\t\tconfigs: [\n\t\t\t\t{\n\t\t\t\t\ttype: \"reset\",\n\t\t\t\t\tmultiple: false,\n\t\t\t\t\tdescription,\n\t\t\t\t\tpath: schemaPath\n\t\t\t\t}\n\t\t\t],\n\t\t\tdescription: undefined,\n\t\t\tsimpleType: undefined,\n\t\t\tmultiple: undefined\n\t\t};\n\t};\n\n\t/**\n\t * @param {PathItem[]} path full path in schema\n\t * @param {boolean} multiple inside of an array\n\t * @returns {number} number of arguments added\n\t */\n\tconst addFlag = (path, multiple) => {\n\t\tconst argConfigBase = schemaToArgumentConfig(path[0].schema);\n\t\tif (!argConfigBase) return 0;\n\n\t\tconst negatedDescription = getNegatedDescription(path);\n\t\tconst name = pathToArgumentName(path[0].path);\n\t\t/** @type {ArgumentConfig} */\n\t\tconst argConfig = {\n\t\t\t...argConfigBase,\n\t\t\tmultiple,\n\t\t\tdescription: getDescription(path),\n\t\t\tpath: path[0].path\n\t\t};\n\n\t\tif (negatedDescription) {\n\t\t\targConfig.negatedDescription = negatedDescription;\n\t\t}\n\n\t\tif (!flags[name]) {\n\t\t\tflags[name] = {\n\t\t\t\tconfigs: [],\n\t\t\t\tdescription: undefined,\n\t\t\t\tsimpleType: undefined,\n\t\t\t\tmultiple: undefined\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tflags[name].configs.some(\n\t\t\t\titem => JSON.stringify(item) === JSON.stringify(argConfig)\n\t\t\t)\n\t\t) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (\n\t\t\tflags[name].configs.some(\n\t\t\t\titem => item.type === argConfig.type && item.multiple !== multiple\n\t\t\t)\n\t\t) {\n\t\t\tif (multiple) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Conflicting schema for ${path[0].path} with ${argConfig.type} type (array type must be before single item type)`\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tflags[name].configs.push(argConfig);\n\n\t\treturn 1;\n\t};\n\n\t// TODO support `not` and `if/then/else`\n\t// TODO support `const`, but we don't use it on our schema\n\t/**\n\t *\n\t * @param {object} schemaPart the current schema\n\t * @param {string} schemaPath the current path in the schema\n\t * @param {{schema: object, path: string}[]} path all previous visited schemaParts\n\t * @param {string | null} inArray if inside of an array, the path to the array\n\t * @returns {number} added arguments\n\t */\n\tconst traverse = (schemaPart, schemaPath = \"\", path = [], inArray = null) => {\n\t\twhile (schemaPart.$ref) {\n\t\t\tschemaPart = getSchemaPart(schemaPart.$ref);\n\t\t}\n\n\t\tconst repetitions = path.filter(({ schema }) => schema === schemaPart);\n\t\tif (\n\t\t\trepetitions.length >= 2 ||\n\t\t\trepetitions.some(({ path }) => path === schemaPath)\n\t\t) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (schemaPart.cli && schemaPart.cli.exclude) return 0;\n\n\t\tconst fullPath = [{ schema: schemaPart, path: schemaPath }, ...path];\n\n\t\tlet addedArguments = 0;\n\n\t\taddedArguments += addFlag(fullPath, !!inArray);\n\n\t\tif (schemaPart.type === \"object\") {\n\t\t\tif (schemaPart.properties) {\n\t\t\t\tfor (const property of Object.keys(schemaPart.properties)) {\n\t\t\t\t\taddedArguments += traverse(\n\t\t\t\t\t\tschemaPart.properties[property],\n\t\t\t\t\t\tschemaPath ? `${schemaPath}.${property}` : property,\n\t\t\t\t\t\tfullPath,\n\t\t\t\t\t\tinArray\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn addedArguments;\n\t\t}\n\n\t\tif (schemaPart.type === \"array\") {\n\t\t\tif (inArray) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (Array.isArray(schemaPart.items)) {\n\t\t\t\tlet i = 0;\n\t\t\t\tfor (const item of schemaPart.items) {\n\t\t\t\t\taddedArguments += traverse(\n\t\t\t\t\t\titem,\n\t\t\t\t\t\t`${schemaPath}.${i}`,\n\t\t\t\t\t\tfullPath,\n\t\t\t\t\t\tschemaPath\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn addedArguments;\n\t\t\t}\n\n\t\t\taddedArguments += traverse(\n\t\t\t\tschemaPart.items,\n\t\t\t\t`${schemaPath}[]`,\n\t\t\t\tfullPath,\n\t\t\t\tschemaPath\n\t\t\t);\n\n\t\t\tif (addedArguments > 0) {\n\t\t\t\taddResetFlag(fullPath);\n\t\t\t\taddedArguments++;\n\t\t\t}\n\n\t\t\treturn addedArguments;\n\t\t}\n\n\t\tconst maybeOf = schemaPart.oneOf || schemaPart.anyOf || schemaPart.allOf;\n\n\t\tif (maybeOf) {\n\t\t\tconst items = maybeOf;\n\n\t\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\t\taddedArguments += traverse(items[i], schemaPath, fullPath, inArray);\n\t\t\t}\n\n\t\t\treturn addedArguments;\n\t\t}\n\n\t\treturn addedArguments;\n\t};\n\n\ttraverse(schema);\n\n\t// Summarize flags\n\tfor (const name of Object.keys(flags)) {\n\t\tconst argument = flags[name];\n\t\targument.description = argument.configs.reduce((desc, { description }) => {\n\t\t\tif (!desc) return description;\n\t\t\tif (!description) return desc;\n\t\t\tif (desc.includes(description)) return desc;\n\t\t\treturn `${desc} ${description}`;\n\t\t}, /** @type {string | undefined} */ (undefined));\n\t\targument.simpleType = argument.configs.reduce((t, argConfig) => {\n\t\t\t/** @type {\"string\" | \"number\" | \"boolean\"} */\n\t\t\tlet type = \"string\";\n\t\t\tswitch (argConfig.type) {\n\t\t\t\tcase \"number\":\n\t\t\t\t\ttype = \"number\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"reset\":\n\t\t\t\tcase \"boolean\":\n\t\t\t\t\ttype = \"boolean\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"enum\":\n\t\t\t\t\tif (argConfig.values.every(v => typeof v === \"boolean\"))\n\t\t\t\t\t\ttype = \"boolean\";\n\t\t\t\t\tif (argConfig.values.every(v => typeof v === \"number\"))\n\t\t\t\t\t\ttype = \"number\";\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t === undefined) return type;\n\t\t\treturn t === type ? t : \"string\";\n\t\t}, /** @type {\"string\" | \"number\" | \"boolean\" | undefined} */ (undefined));\n\t\targument.multiple = argument.configs.some(c => c.multiple);\n\t}\n\n\treturn flags;\n};\n\nconst cliAddedItems = new WeakMap();\n\n/**\n * @param {any} config configuration\n * @param {string} schemaPath path in the config\n * @param {number | undefined} index index of value when multiple values are provided, otherwise undefined\n * @returns {{ problem?: LocalProblem, object?: any, property?: string | number, value?: any }} problem or object with property and value\n */\nconst getObjectAndProperty = (config, schemaPath, index = 0) => {\n\tif (!schemaPath) return { value: config };\n\tconst parts = schemaPath.split(\".\");\n\tlet property = parts.pop();\n\tlet current = config;\n\tlet i = 0;\n\tfor (const part of parts) {\n\t\tconst isArray = part.endsWith(\"[]\");\n\t\tconst name = isArray ? part.slice(0, -2) : part;\n\t\tlet value = current[name];\n\t\tif (isArray) {\n\t\t\tif (value === undefined) {\n\t\t\t\tvalue = {};\n\t\t\t\tcurrent[name] = [...Array.from({ length: index }), value];\n\t\t\t\tcliAddedItems.set(current[name], index + 1);\n\t\t\t} else if (!Array.isArray(value)) {\n\t\t\t\treturn {\n\t\t\t\t\tproblem: {\n\t\t\t\t\t\ttype: \"unexpected-non-array-in-path\",\n\t\t\t\t\t\tpath: parts.slice(0, i).join(\".\")\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tlet addedItems = cliAddedItems.get(value) || 0;\n\t\t\t\twhile (addedItems <= index) {\n\t\t\t\t\tvalue.push(undefined);\n\t\t\t\t\taddedItems++;\n\t\t\t\t}\n\t\t\t\tcliAddedItems.set(value, addedItems);\n\t\t\t\tconst x = value.length - addedItems + index;\n\t\t\t\tif (value[x] === undefined) {\n\t\t\t\t\tvalue[x] = {};\n\t\t\t\t} else if (value[x] === null || typeof value[x] !== \"object\") {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tproblem: {\n\t\t\t\t\t\t\ttype: \"unexpected-non-object-in-path\",\n\t\t\t\t\t\t\tpath: parts.slice(0, i).join(\".\")\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tvalue = value[x];\n\t\t\t}\n\t\t} else {\n\t\t\tif (value === undefined) {\n\t\t\t\tvalue = current[name] = {};\n\t\t\t} else if (value === null || typeof value !== \"object\") {\n\t\t\t\treturn {\n\t\t\t\t\tproblem: {\n\t\t\t\t\t\ttype: \"unexpected-non-object-in-path\",\n\t\t\t\t\t\tpath: parts.slice(0, i).join(\".\")\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tcurrent = value;\n\t\ti++;\n\t}\n\tlet value = current[property];\n\tif (property.endsWith(\"[]\")) {\n\t\tconst name = property.slice(0, -2);\n\t\tconst value = current[name];\n\t\tif (value === undefined) {\n\t\t\tcurrent[name] = [...Array.from({ length: index }), undefined];\n\t\t\tcliAddedItems.set(current[name], index + 1);\n\t\t\treturn { object: current[name], property: index, value: undefined };\n\t\t} else if (!Array.isArray(value)) {\n\t\t\tcurrent[name] = [value, ...Array.from({ length: index }), undefined];\n\t\t\tcliAddedItems.set(current[name], index + 1);\n\t\t\treturn { object: current[name], property: index + 1, value: undefined };\n\t\t} else {\n\t\t\tlet addedItems = cliAddedItems.get(value) || 0;\n\t\t\twhile (addedItems <= index) {\n\t\t\t\tvalue.push(undefined);\n\t\t\t\taddedItems++;\n\t\t\t}\n\t\t\tcliAddedItems.set(value, addedItems);\n\t\t\tconst x = value.length - addedItems + index;\n\t\t\tif (value[x] === undefined) {\n\t\t\t\tvalue[x] = {};\n\t\t\t} else if (value[x] === null || typeof value[x] !== \"object\") {\n\t\t\t\treturn {\n\t\t\t\t\tproblem: {\n\t\t\t\t\t\ttype: \"unexpected-non-object-in-path\",\n\t\t\t\t\t\tpath: schemaPath\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tobject: value,\n\t\t\t\tproperty: x,\n\t\t\t\tvalue: value[x]\n\t\t\t};\n\t\t}\n\t}\n\treturn { object: current, property, value };\n};\n\n/**\n * @param {any} config configuration\n * @param {string} schemaPath path in the config\n * @param {any} value parsed value\n * @param {number | undefined} index index of value when multiple values are provided, otherwise undefined\n * @returns {LocalProblem | null} problem or null for success\n */\nconst setValue = (config, schemaPath, value, index) => {\n\tconst { problem, object, property } = getObjectAndProperty(\n\t\tconfig,\n\t\tschemaPath,\n\t\tindex\n\t);\n\tif (problem) return problem;\n\tobject[property] = value;\n\treturn null;\n};\n\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @param {any} config configuration\n * @param {any} value the value\n * @param {number | undefined} index the index if multiple values provided\n * @returns {LocalProblem | null} a problem if any\n */\nconst processArgumentConfig = (argConfig, config, value, index) => {\n\tif (index !== undefined && !argConfig.multiple) {\n\t\treturn {\n\t\t\ttype: \"multiple-values-unexpected\",\n\t\t\tpath: argConfig.path\n\t\t};\n\t}\n\tconst parsed = parseValueForArgumentConfig(argConfig, value);\n\tif (parsed === undefined) {\n\t\treturn {\n\t\t\ttype: \"invalid-value\",\n\t\t\tpath: argConfig.path,\n\t\t\texpected: getExpectedValue(argConfig)\n\t\t};\n\t}\n\tconst problem = setValue(config, argConfig.path, parsed, index);\n\tif (problem) return problem;\n\treturn null;\n};\n\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @returns {string | undefined} expected message\n */\nconst getExpectedValue = argConfig => {\n\tswitch (argConfig.type) {\n\t\tdefault:\n\t\t\treturn argConfig.type;\n\t\tcase \"boolean\":\n\t\t\treturn \"true | false\";\n\t\tcase \"RegExp\":\n\t\t\treturn \"regular expression (example: /ab?c*/)\";\n\t\tcase \"enum\":\n\t\t\treturn argConfig.values.map(v => `${v}`).join(\" | \");\n\t\tcase \"reset\":\n\t\t\treturn \"true (will reset the previous value to an empty array)\";\n\t}\n};\n\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @param {any} value the value\n * @returns {any | undefined} parsed value\n */\nconst parseValueForArgumentConfig = (argConfig, value) => {\n\tswitch (argConfig.type) {\n\t\tcase \"string\":\n\t\t\tif (typeof value === \"string\") {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"path\":\n\t\t\tif (typeof value === \"string\") {\n\t\t\t\treturn path.resolve(value);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"number\":\n\t\t\tif (typeof value === \"number\") return value;\n\t\t\tif (typeof value === \"string\" && /^[+-]?\\d*(\\.\\d*)[eE]\\d+$/) {\n\t\t\t\tconst n = +value;\n\t\t\t\tif (!isNaN(n)) return n;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"boolean\":\n\t\t\tif (typeof value === \"boolean\") return value;\n\t\t\tif (value === \"true\") return true;\n\t\t\tif (value === \"false\") return false;\n\t\t\tbreak;\n\t\tcase \"RegExp\":\n\t\t\tif (value instanceof RegExp) return value;\n\t\t\tif (typeof value === \"string\") {\n\t\t\t\t// cspell:word yugi\n\t\t\t\tconst match = /^\\/(.*)\\/([yugi]*)$/.exec(value);\n\t\t\t\tif (match && !/[^\\\\]\\//.test(match[1]))\n\t\t\t\t\treturn new RegExp(match[1], match[2]);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"enum\":\n\t\t\tif (argConfig.values.includes(value)) return value;\n\t\t\tfor (const item of argConfig.values) {\n\t\t\t\tif (`${item}` === value) return item;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"reset\":\n\t\t\tif (value === true) return [];\n\t\t\tbreak;\n\t}\n};\n\n/**\n * @param {Record<string, Argument>} args object of arguments\n * @param {any} config configuration\n * @param {Record<string, string | number | boolean | RegExp | (string | number | boolean | RegExp)[]>} values object with values\n * @returns {Problem[] | null} problems or null for success\n */\nconst processArguments = (args, config, values) => {\n\t/** @type {Problem[]} */\n\tconst problems = [];\n\tfor (const key of Object.keys(values)) {\n\t\tconst arg = args[key];\n\t\tif (!arg) {\n\t\t\tproblems.push({\n\t\t\t\ttype: \"unknown-argument\",\n\t\t\t\tpath: \"\",\n\t\t\t\targument: key\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\t\tconst processValue = (value, i) => {\n\t\t\tconst currentProblems = [];\n\t\t\tfor (const argConfig of arg.configs) {\n\t\t\t\tconst problem = processArgumentConfig(argConfig, config, value, i);\n\t\t\t\tif (!problem) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentProblems.push({\n\t\t\t\t\t...problem,\n\t\t\t\t\targument: key,\n\t\t\t\t\tvalue: value,\n\t\t\t\t\tindex: i\n\t\t\t\t});\n\t\t\t}\n\t\t\tproblems.push(...currentProblems);\n\t\t};\n\t\tlet value = values[key];\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\tprocessValue(value[i], i);\n\t\t\t}\n\t\t} else {\n\t\t\tprocessValue(value, undefined);\n\t\t}\n\t}\n\tif (problems.length === 0) return null;\n\treturn problems;\n};\n\nexports.getArguments = getArguments;\nexports.processArguments = processArguments;\n"]},"metadata":{},"sourceType":"script"}