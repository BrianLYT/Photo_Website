{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst util = require(\"util\");\n\nconst Entrypoint = require(\"./Entrypoint\");\n\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\n\nconst {\n  first\n} = require(\"./util/SetHelpers\");\n\nconst SortableSet = require(\"./util/SortableSet\");\n\nconst {\n  compareModulesById,\n  compareIterables,\n  compareModulesByIdentifier,\n  concatComparators,\n  compareSelect,\n  compareIds\n} = require(\"./util/comparators\");\n\nconst createHash = require(\"./util/createHash\");\n\nconst findGraphRoots = require(\"./util/findGraphRoots\");\n\nconst {\n  RuntimeSpecMap,\n  RuntimeSpecSet,\n  runtimeToString,\n  mergeRuntime,\n  forEachRuntime\n} = require(\"./util/runtime\");\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n\n/** @typedef {import(\"./RuntimeModule\")} RuntimeModule */\n\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @type {ReadonlySet<string>} */\n\n\nconst EMPTY_SET = new Set();\nconst ZERO_BIG_INT = BigInt(0);\nconst compareModuleIterables = compareIterables(compareModulesByIdentifier);\n/** @typedef {(c: Chunk, chunkGraph: ChunkGraph) => boolean} ChunkFilterPredicate */\n\n/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */\n\n/** @typedef {[Module, Entrypoint | undefined]} EntryModuleWithChunkGroup */\n\n/**\n * @typedef {Object} ChunkSizeOptions\n * @property {number=} chunkOverhead constant overhead for a chunk\n * @property {number=} entryChunkMultiplicator multiplicator for initial chunks\n */\n\nclass ModuleHashInfo {\n  constructor(hash, renderedHash) {\n    this.hash = hash;\n    this.renderedHash = renderedHash;\n  }\n\n}\n/** @template T @typedef {(set: SortableSet<T>) => T[]} SetToArrayFunction<T> */\n\n/**\n * @template T\n * @param {SortableSet<T>} set the set\n * @returns {T[]} set as array\n */\n\n\nconst getArray = set => {\n  return Array.from(set);\n};\n/**\n * @param {SortableSet<Chunk>} chunks the chunks\n * @returns {RuntimeSpecSet} runtimes\n */\n\n\nconst getModuleRuntimes = chunks => {\n  const runtimes = new RuntimeSpecSet();\n\n  for (const chunk of chunks) {\n    runtimes.add(chunk.runtime);\n  }\n\n  return runtimes;\n};\n/**\n * @param {SortableSet<Module>} set the set\n * @returns {Map<string, SortableSet<Module>>} modules by source type\n */\n\n\nconst modulesBySourceType = set => {\n  /** @type {Map<string, SortableSet<Module>>} */\n  const map = new Map();\n\n  for (const module of set) {\n    for (const sourceType of module.getSourceTypes()) {\n      let innerSet = map.get(sourceType);\n\n      if (innerSet === undefined) {\n        innerSet = new SortableSet();\n        map.set(sourceType, innerSet);\n      }\n\n      innerSet.add(module);\n    }\n  }\n\n  for (const [key, innerSet] of map) {\n    // When all modules have the source type, we reuse the original SortableSet\n    // to benefit from the shared cache (especially for sorting)\n    if (innerSet.size === set.size) {\n      map.set(key, set);\n    }\n  }\n\n  return map;\n};\n/** @type {WeakMap<Function, any>} */\n\n\nconst createOrderedArrayFunctionMap = new WeakMap();\n/**\n * @template T\n * @param {function(T, T): -1|0|1} comparator comparator function\n * @returns {SetToArrayFunction<T>} set as ordered array\n */\n\nconst createOrderedArrayFunction = comparator => {\n  /** @type {SetToArrayFunction<T>} */\n  let fn = createOrderedArrayFunctionMap.get(comparator);\n  if (fn !== undefined) return fn;\n\n  fn = set => {\n    set.sortWith(comparator);\n    return Array.from(set);\n  };\n\n  createOrderedArrayFunctionMap.set(comparator, fn);\n  return fn;\n};\n/**\n * @param {Iterable<Module>} modules the modules to get the count/size of\n * @returns {number} the size of the modules\n */\n\n\nconst getModulesSize = modules => {\n  let size = 0;\n\n  for (const module of modules) {\n    for (const type of module.getSourceTypes()) {\n      size += module.size(type);\n    }\n  }\n\n  return size;\n};\n/**\n * @param {Iterable<Module>} modules the sortable Set to get the size of\n * @returns {Record<string, number>} the sizes of the modules\n */\n\n\nconst getModulesSizes = modules => {\n  let sizes = Object.create(null);\n\n  for (const module of modules) {\n    for (const type of module.getSourceTypes()) {\n      sizes[type] = (sizes[type] || 0) + module.size(type);\n    }\n  }\n\n  return sizes;\n};\n/**\n * @param {Chunk} a chunk\n * @param {Chunk} b chunk\n * @returns {boolean} true, if a is always a parent of b\n */\n\n\nconst isAvailableChunk = (a, b) => {\n  const queue = new Set(b.groupsIterable);\n\n  for (const chunkGroup of queue) {\n    if (a.isInGroup(chunkGroup)) continue;\n    if (chunkGroup.isInitial()) return false;\n\n    for (const parent of chunkGroup.parentsIterable) {\n      queue.add(parent);\n    }\n  }\n\n  return true;\n};\n\nclass ChunkGraphModule {\n  constructor() {\n    /** @type {SortableSet<Chunk>} */\n    this.chunks = new SortableSet();\n    /** @type {Set<Chunk> | undefined} */\n\n    this.entryInChunks = undefined;\n    /** @type {Set<Chunk> | undefined} */\n\n    this.runtimeInChunks = undefined;\n    /** @type {RuntimeSpecMap<ModuleHashInfo>} */\n\n    this.hashes = undefined;\n    /** @type {string | number} */\n\n    this.id = null;\n    /** @type {RuntimeSpecMap<Set<string>> | undefined} */\n\n    this.runtimeRequirements = undefined;\n    /** @type {RuntimeSpecMap<string>} */\n\n    this.graphHashes = undefined;\n    /** @type {RuntimeSpecMap<string>} */\n\n    this.graphHashesWithConnections = undefined;\n  }\n\n}\n\nclass ChunkGraphChunk {\n  constructor() {\n    /** @type {SortableSet<Module>} */\n    this.modules = new SortableSet();\n    /** @type {Map<Module, Entrypoint>} */\n\n    this.entryModules = new Map();\n    /** @type {SortableSet<RuntimeModule>} */\n\n    this.runtimeModules = new SortableSet();\n    /** @type {Set<RuntimeModule> | undefined} */\n\n    this.fullHashModules = undefined;\n    /** @type {Set<RuntimeModule> | undefined} */\n\n    this.dependentHashModules = undefined;\n    /** @type {Set<string> | undefined} */\n\n    this.runtimeRequirements = undefined;\n    /** @type {Set<string>} */\n\n    this.runtimeRequirementsInTree = new Set();\n  }\n\n}\n\nclass ChunkGraph {\n  /**\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @param {string | Hash} hashFunction the hash function to use\n   */\n  constructor(moduleGraph) {\n    let hashFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"md4\";\n\n    /** @private @type {WeakMap<Module, ChunkGraphModule>} */\n    this._modules = new WeakMap();\n    /** @private @type {WeakMap<Chunk, ChunkGraphChunk>} */\n\n    this._chunks = new WeakMap();\n    /** @private @type {WeakMap<AsyncDependenciesBlock, ChunkGroup>} */\n\n    this._blockChunkGroups = new WeakMap();\n    /** @private @type {Map<string, string | number>} */\n\n    this._runtimeIds = new Map();\n    /** @type {ModuleGraph} */\n\n    this.moduleGraph = moduleGraph;\n    this._hashFunction = hashFunction;\n    this._getGraphRoots = this._getGraphRoots.bind(this);\n  }\n  /**\n   * @private\n   * @param {Module} module the module\n   * @returns {ChunkGraphModule} internal module\n   */\n\n\n  _getChunkGraphModule(module) {\n    let cgm = this._modules.get(module);\n\n    if (cgm === undefined) {\n      cgm = new ChunkGraphModule();\n\n      this._modules.set(module, cgm);\n    }\n\n    return cgm;\n  }\n  /**\n   * @private\n   * @param {Chunk} chunk the chunk\n   * @returns {ChunkGraphChunk} internal chunk\n   */\n\n\n  _getChunkGraphChunk(chunk) {\n    let cgc = this._chunks.get(chunk);\n\n    if (cgc === undefined) {\n      cgc = new ChunkGraphChunk();\n\n      this._chunks.set(chunk, cgc);\n    }\n\n    return cgc;\n  }\n  /**\n   * @param {SortableSet<Module>} set the sortable Set to get the roots of\n   * @returns {Module[]} the graph roots\n   */\n\n\n  _getGraphRoots(set) {\n    const {\n      moduleGraph\n    } = this;\n    return Array.from(findGraphRoots(set, module => {\n      /** @type {Set<Module>} */\n      const set = new Set();\n\n      const addDependencies = module => {\n        for (const connection of moduleGraph.getOutgoingConnections(module)) {\n          if (!connection.module) continue;\n          const activeState = connection.getActiveState(undefined);\n          if (activeState === false) continue;\n\n          if (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\n            addDependencies(connection.module);\n            continue;\n          }\n\n          set.add(connection.module);\n        }\n      };\n\n      addDependencies(module);\n      return set;\n    })).sort(compareModulesByIdentifier);\n  }\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {Module} module the module\n   * @returns {void}\n   */\n\n\n  connectChunkAndModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    cgm.chunks.add(chunk);\n    cgc.modules.add(module);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Module} module the module\n   * @returns {void}\n   */\n\n\n  disconnectChunkAndModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    cgc.modules.delete(module);\n    cgm.chunks.delete(chunk);\n  }\n  /**\n   * @param {Chunk} chunk the chunk which will be disconnected\n   * @returns {void}\n   */\n\n\n  disconnectChunk(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    for (const module of cgc.modules) {\n      const cgm = this._getChunkGraphModule(module);\n\n      cgm.chunks.delete(chunk);\n    }\n\n    cgc.modules.clear();\n    chunk.disconnectFromGroups();\n    ChunkGraph.clearChunkGraphForChunk(chunk);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Iterable<Module>} modules the modules\n   * @returns {void}\n   */\n\n\n  attachModules(chunk, modules) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    for (const module of modules) {\n      cgc.modules.add(module);\n    }\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Iterable<RuntimeModule>} modules the runtime modules\n   * @returns {void}\n   */\n\n\n  attachRuntimeModules(chunk, modules) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    for (const module of modules) {\n      cgc.runtimeModules.add(module);\n    }\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n   * @returns {void}\n   */\n\n\n  attachFullHashModules(chunk, modules) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n\n    for (const module of modules) {\n      cgc.fullHashModules.add(module);\n    }\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n   * @returns {void}\n   */\n\n\n  attachDependentHashModules(chunk, modules) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgc.dependentHashModules === undefined) cgc.dependentHashModules = new Set();\n\n    for (const module of modules) {\n      cgc.dependentHashModules.add(module);\n    }\n  }\n  /**\n   * @param {Module} oldModule the replaced module\n   * @param {Module} newModule the replacing module\n   * @returns {void}\n   */\n\n\n  replaceModule(oldModule, newModule) {\n    const oldCgm = this._getChunkGraphModule(oldModule);\n\n    const newCgm = this._getChunkGraphModule(newModule);\n\n    for (const chunk of oldCgm.chunks) {\n      const cgc = this._getChunkGraphChunk(chunk);\n\n      cgc.modules.delete(oldModule);\n      cgc.modules.add(newModule);\n      newCgm.chunks.add(chunk);\n    }\n\n    oldCgm.chunks.clear();\n\n    if (oldCgm.entryInChunks !== undefined) {\n      if (newCgm.entryInChunks === undefined) {\n        newCgm.entryInChunks = new Set();\n      }\n\n      for (const chunk of oldCgm.entryInChunks) {\n        const cgc = this._getChunkGraphChunk(chunk);\n\n        const old = cgc.entryModules.get(oldModule);\n        /** @type {Map<Module, Entrypoint>} */\n\n        const newEntryModules = new Map();\n\n        for (const [m, cg] of cgc.entryModules) {\n          if (m === oldModule) {\n            newEntryModules.set(newModule, old);\n          } else {\n            newEntryModules.set(m, cg);\n          }\n        }\n\n        cgc.entryModules = newEntryModules;\n        newCgm.entryInChunks.add(chunk);\n      }\n\n      oldCgm.entryInChunks = undefined;\n    }\n\n    if (oldCgm.runtimeInChunks !== undefined) {\n      if (newCgm.runtimeInChunks === undefined) {\n        newCgm.runtimeInChunks = new Set();\n      }\n\n      for (const chunk of oldCgm.runtimeInChunks) {\n        const cgc = this._getChunkGraphChunk(chunk);\n\n        cgc.runtimeModules.delete(\n        /** @type {RuntimeModule} */\n        oldModule);\n        cgc.runtimeModules.add(\n        /** @type {RuntimeModule} */\n        newModule);\n        newCgm.runtimeInChunks.add(chunk);\n\n        if (cgc.fullHashModules !== undefined && cgc.fullHashModules.has(\n        /** @type {RuntimeModule} */\n        oldModule)) {\n          cgc.fullHashModules.delete(\n          /** @type {RuntimeModule} */\n          oldModule);\n          cgc.fullHashModules.add(\n          /** @type {RuntimeModule} */\n          newModule);\n        }\n\n        if (cgc.dependentHashModules !== undefined && cgc.dependentHashModules.has(\n        /** @type {RuntimeModule} */\n        oldModule)) {\n          cgc.dependentHashModules.delete(\n          /** @type {RuntimeModule} */\n          oldModule);\n          cgc.dependentHashModules.add(\n          /** @type {RuntimeModule} */\n          newModule);\n        }\n      }\n\n      oldCgm.runtimeInChunks = undefined;\n    }\n  }\n  /**\n   * @param {Module} module the checked module\n   * @param {Chunk} chunk the checked chunk\n   * @returns {boolean} true, if the chunk contains the module\n   */\n\n\n  isModuleInChunk(module, chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.modules.has(module);\n  }\n  /**\n   * @param {Module} module the checked module\n   * @param {ChunkGroup} chunkGroup the checked chunk group\n   * @returns {boolean} true, if the chunk contains the module\n   */\n\n\n  isModuleInChunkGroup(module, chunkGroup) {\n    for (const chunk of chunkGroup.chunks) {\n      if (this.isModuleInChunk(module, chunk)) return true;\n    }\n\n    return false;\n  }\n  /**\n   * @param {Module} module the checked module\n   * @returns {boolean} true, if the module is entry of any chunk\n   */\n\n\n  isEntryModule(module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    return cgm.entryInChunks !== undefined;\n  }\n  /**\n   * @param {Module} module the module\n   * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n   */\n\n\n  getModuleChunksIterable(module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    return cgm.chunks;\n  }\n  /**\n   * @param {Module} module the module\n   * @param {function(Chunk, Chunk): -1|0|1} sortFn sort function\n   * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n   */\n\n\n  getOrderedModuleChunksIterable(module, sortFn) {\n    const cgm = this._getChunkGraphModule(module);\n\n    cgm.chunks.sortWith(sortFn);\n    return cgm.chunks;\n  }\n  /**\n   * @param {Module} module the module\n   * @returns {Chunk[]} array of chunks (cached, do not modify)\n   */\n\n\n  getModuleChunks(module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    return cgm.chunks.getFromCache(getArray);\n  }\n  /**\n   * @param {Module} module the module\n   * @returns {number} the number of chunk which contain the module\n   */\n\n\n  getNumberOfModuleChunks(module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    return cgm.chunks.size;\n  }\n  /**\n   * @param {Module} module the module\n   * @returns {RuntimeSpecSet} runtimes\n   */\n\n\n  getModuleRuntimes(module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    return cgm.chunks.getFromUnorderedCache(getModuleRuntimes);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {number} the number of modules which are contained in this chunk\n   */\n\n\n  getNumberOfChunkModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.modules.size;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {number} the number of full hash modules which are contained in this chunk\n   */\n\n\n  getNumberOfChunkFullHashModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.fullHashModules === undefined ? 0 : cgc.fullHashModules.size;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<Module>} return the modules for this chunk\n   */\n\n\n  getChunkModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.modules;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {string} sourceType source type\n   * @returns {Iterable<Module> | undefined} return the modules for this chunk\n   */\n\n\n  getChunkModulesIterableBySourceType(chunk, sourceType) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const modulesWithSourceType = cgc.modules.getFromUnorderedCache(modulesBySourceType).get(sourceType);\n    return modulesWithSourceType;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {function(Module, Module): -1|0|1} comparator comparator function\n   * @returns {Iterable<Module>} return the modules for this chunk\n   */\n\n\n  getOrderedChunkModulesIterable(chunk, comparator) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    cgc.modules.sortWith(comparator);\n    return cgc.modules;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {string} sourceType source type\n   * @param {function(Module, Module): -1|0|1} comparator comparator function\n   * @returns {Iterable<Module> | undefined} return the modules for this chunk\n   */\n\n\n  getOrderedChunkModulesIterableBySourceType(chunk, sourceType, comparator) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const modulesWithSourceType = cgc.modules.getFromUnorderedCache(modulesBySourceType).get(sourceType);\n    if (modulesWithSourceType === undefined) return undefined;\n    modulesWithSourceType.sortWith(comparator);\n    return modulesWithSourceType;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n   */\n\n\n  getChunkModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.modules.getFromUnorderedCache(getArray);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {function(Module, Module): -1|0|1} comparator comparator function\n   * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n   */\n\n\n  getOrderedChunkModules(chunk, comparator) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const arrayFunction = createOrderedArrayFunction(comparator);\n    return cgc.modules.getFromUnorderedCache(arrayFunction);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ModuleFilterPredicate} filterFn function used to filter modules\n   * @param {boolean} includeAllChunks all chunks or only async chunks\n   * @returns {Record<string|number, (string|number)[]>} chunk to module ids object\n   */\n\n\n  getChunkModuleIdMap(chunk, filterFn) {\n    let includeAllChunks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    /** @type {Record<string|number, (string|number)[]>} */\n    const chunkModuleIdMap = Object.create(null);\n\n    for (const asyncChunk of includeAllChunks ? chunk.getAllReferencedChunks() : chunk.getAllAsyncChunks()) {\n      /** @type {(string|number)[]} */\n      let array;\n\n      for (const module of this.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(this))) {\n        if (filterFn(module)) {\n          if (array === undefined) {\n            array = [];\n            chunkModuleIdMap[asyncChunk.id] = array;\n          }\n\n          const moduleId = this.getModuleId(module);\n          array.push(moduleId);\n        }\n      }\n    }\n\n    return chunkModuleIdMap;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ModuleFilterPredicate} filterFn function used to filter modules\n   * @param {number} hashLength length of the hash\n   * @param {boolean} includeAllChunks all chunks or only async chunks\n   * @returns {Record<string|number, Record<string|number, string>>} chunk to module id to module hash object\n   */\n\n\n  getChunkModuleRenderedHashMap(chunk, filterFn) {\n    let hashLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let includeAllChunks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    /** @type {Record<string|number, Record<string|number, string>>} */\n    const chunkModuleHashMap = Object.create(null);\n\n    for (const asyncChunk of includeAllChunks ? chunk.getAllReferencedChunks() : chunk.getAllAsyncChunks()) {\n      /** @type {Record<string|number, string>} */\n      let idToHashMap;\n\n      for (const module of this.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(this))) {\n        if (filterFn(module)) {\n          if (idToHashMap === undefined) {\n            idToHashMap = Object.create(null);\n            chunkModuleHashMap[asyncChunk.id] = idToHashMap;\n          }\n\n          const moduleId = this.getModuleId(module);\n          const hash = this.getRenderedModuleHash(module, asyncChunk.runtime);\n          idToHashMap[moduleId] = hashLength ? hash.slice(0, hashLength) : hash;\n        }\n      }\n    }\n\n    return chunkModuleHashMap;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ChunkFilterPredicate} filterFn function used to filter chunks\n   * @returns {Record<string|number, boolean>} chunk map\n   */\n\n\n  getChunkConditionMap(chunk, filterFn) {\n    const map = Object.create(null);\n\n    for (const c of chunk.getAllReferencedChunks()) {\n      map[c.id] = filterFn(c, this);\n    }\n\n    return map;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\n   * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\n   * @returns {boolean} return true if module exists in graph\n   */\n\n\n  hasModuleInGraph(chunk, filterFn, filterChunkFn) {\n    const queue = new Set(chunk.groupsIterable);\n    const chunksProcessed = new Set();\n\n    for (const chunkGroup of queue) {\n      for (const innerChunk of chunkGroup.chunks) {\n        if (!chunksProcessed.has(innerChunk)) {\n          chunksProcessed.add(innerChunk);\n\n          if (!filterChunkFn || filterChunkFn(innerChunk, this)) {\n            for (const module of this.getChunkModulesIterable(innerChunk)) {\n              if (filterFn(module)) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n\n    return false;\n  }\n  /**\n   * @param {Chunk} chunkA first chunk\n   * @param {Chunk} chunkB second chunk\n   * @returns {-1|0|1} this is a comparator function like sort and returns -1, 0, or 1 based on sort order\n   */\n\n\n  compareChunks(chunkA, chunkB) {\n    const cgcA = this._getChunkGraphChunk(chunkA);\n\n    const cgcB = this._getChunkGraphChunk(chunkB);\n\n    if (cgcA.modules.size > cgcB.modules.size) return -1;\n    if (cgcA.modules.size < cgcB.modules.size) return 1;\n    cgcA.modules.sortWith(compareModulesByIdentifier);\n    cgcB.modules.sortWith(compareModulesByIdentifier);\n    return compareModuleIterables(cgcA.modules, cgcB.modules);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {number} total size of all modules in the chunk\n   */\n\n\n  getChunkModulesSize(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.modules.getFromUnorderedCache(getModulesSize);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Record<string, number>} total sizes of all modules in the chunk by source type\n   */\n\n\n  getChunkModulesSizes(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.modules.getFromUnorderedCache(getModulesSizes);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Module[]} root modules of the chunks (ordered by identifier)\n   */\n\n\n  getChunkRootModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.modules.getFromUnorderedCache(this._getGraphRoots);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ChunkSizeOptions} options options object\n   * @returns {number} total size of the chunk\n   */\n\n\n  getChunkSize(chunk) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const modulesSize = cgc.modules.getFromUnorderedCache(getModulesSize);\n    const chunkOverhead = typeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n    const entryChunkMultiplicator = typeof options.entryChunkMultiplicator === \"number\" ? options.entryChunkMultiplicator : 10;\n    return chunkOverhead + modulesSize * (chunk.canBeInitial() ? entryChunkMultiplicator : 1);\n  }\n  /**\n   * @param {Chunk} chunkA chunk\n   * @param {Chunk} chunkB chunk\n   * @param {ChunkSizeOptions} options options object\n   * @returns {number} total size of the chunk or false if chunks can't be integrated\n   */\n\n\n  getIntegratedChunksSize(chunkA, chunkB) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    const cgcA = this._getChunkGraphChunk(chunkA);\n\n    const cgcB = this._getChunkGraphChunk(chunkB);\n\n    const allModules = new Set(cgcA.modules);\n\n    for (const m of cgcB.modules) allModules.add(m);\n\n    let modulesSize = getModulesSize(allModules);\n    const chunkOverhead = typeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n    const entryChunkMultiplicator = typeof options.entryChunkMultiplicator === \"number\" ? options.entryChunkMultiplicator : 10;\n    return chunkOverhead + modulesSize * (chunkA.canBeInitial() || chunkB.canBeInitial() ? entryChunkMultiplicator : 1);\n  }\n  /**\n   * @param {Chunk} chunkA chunk\n   * @param {Chunk} chunkB chunk\n   * @returns {boolean} true, if chunks could be integrated\n   */\n\n\n  canChunksBeIntegrated(chunkA, chunkB) {\n    if (chunkA.preventIntegration || chunkB.preventIntegration) {\n      return false;\n    }\n\n    const hasRuntimeA = chunkA.hasRuntime();\n    const hasRuntimeB = chunkB.hasRuntime();\n\n    if (hasRuntimeA !== hasRuntimeB) {\n      if (hasRuntimeA) {\n        return isAvailableChunk(chunkA, chunkB);\n      } else if (hasRuntimeB) {\n        return isAvailableChunk(chunkB, chunkA);\n      } else {\n        return false;\n      }\n    }\n\n    if (this.getNumberOfEntryModules(chunkA) > 0 || this.getNumberOfEntryModules(chunkB) > 0) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * @param {Chunk} chunkA the target chunk\n   * @param {Chunk} chunkB the chunk to integrate\n   * @returns {void}\n   */\n\n\n  integrateChunks(chunkA, chunkB) {\n    // Decide for one name (deterministic)\n    if (chunkA.name && chunkB.name) {\n      if (this.getNumberOfEntryModules(chunkA) > 0 === this.getNumberOfEntryModules(chunkB) > 0) {\n        // When both chunks have entry modules or none have one, use\n        // shortest name\n        if (chunkA.name.length !== chunkB.name.length) {\n          chunkA.name = chunkA.name.length < chunkB.name.length ? chunkA.name : chunkB.name;\n        } else {\n          chunkA.name = chunkA.name < chunkB.name ? chunkA.name : chunkB.name;\n        }\n      } else if (this.getNumberOfEntryModules(chunkB) > 0) {\n        // Pick the name of the chunk with the entry module\n        chunkA.name = chunkB.name;\n      }\n    } else if (chunkB.name) {\n      chunkA.name = chunkB.name;\n    } // Merge id name hints\n\n\n    for (const hint of chunkB.idNameHints) {\n      chunkA.idNameHints.add(hint);\n    } // Merge runtime\n\n\n    chunkA.runtime = mergeRuntime(chunkA.runtime, chunkB.runtime); // getChunkModules is used here to create a clone, because disconnectChunkAndModule modifies\n\n    for (const module of this.getChunkModules(chunkB)) {\n      this.disconnectChunkAndModule(chunkB, module);\n      this.connectChunkAndModule(chunkA, module);\n    }\n\n    for (const [module, chunkGroup] of Array.from(this.getChunkEntryModulesWithChunkGroupIterable(chunkB))) {\n      this.disconnectChunkAndEntryModule(chunkB, module);\n      this.connectChunkAndEntryModule(chunkA, module, chunkGroup);\n    }\n\n    for (const chunkGroup of chunkB.groupsIterable) {\n      chunkGroup.replaceChunk(chunkB, chunkA);\n      chunkA.addGroup(chunkGroup);\n      chunkB.removeGroup(chunkGroup);\n    }\n\n    ChunkGraph.clearChunkGraphForChunk(chunkB);\n  }\n  /**\n   * @param {Chunk} chunk the chunk to upgrade\n   * @returns {void}\n   */\n\n\n  upgradeDependentToFullHashModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgc.dependentHashModules === undefined) return;\n\n    if (cgc.fullHashModules === undefined) {\n      cgc.fullHashModules = cgc.dependentHashModules;\n    } else {\n      for (const m of cgc.dependentHashModules) {\n        cgc.fullHashModules.add(m);\n      }\n\n      cgc.dependentHashModules = undefined;\n    }\n  }\n  /**\n   * @param {Module} module the checked module\n   * @param {Chunk} chunk the checked chunk\n   * @returns {boolean} true, if the chunk contains the module as entry\n   */\n\n\n  isEntryModuleInChunk(module, chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.entryModules.has(module);\n  }\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {Module} module the entry module\n   * @param {Entrypoint=} entrypoint the chunk group which must be loaded before the module is executed\n   * @returns {void}\n   */\n\n\n  connectChunkAndEntryModule(chunk, module, entrypoint) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgm.entryInChunks === undefined) {\n      cgm.entryInChunks = new Set();\n    }\n\n    cgm.entryInChunks.add(chunk);\n    cgc.entryModules.set(module, entrypoint);\n  }\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {RuntimeModule} module the runtime module\n   * @returns {void}\n   */\n\n\n  connectChunkAndRuntimeModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgm.runtimeInChunks === undefined) {\n      cgm.runtimeInChunks = new Set();\n    }\n\n    cgm.runtimeInChunks.add(chunk);\n    cgc.runtimeModules.add(module);\n  }\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {RuntimeModule} module the module that require a full hash\n   * @returns {void}\n   */\n\n\n  addFullHashModuleToChunk(chunk, module) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n    cgc.fullHashModules.add(module);\n  }\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {RuntimeModule} module the module that require a full hash\n   * @returns {void}\n   */\n\n\n  addDependentHashModuleToChunk(chunk, module) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgc.dependentHashModules === undefined) cgc.dependentHashModules = new Set();\n    cgc.dependentHashModules.add(module);\n  }\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {Module} module the entry module\n   * @returns {void}\n   */\n\n\n  disconnectChunkAndEntryModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    cgm.entryInChunks.delete(chunk);\n\n    if (cgm.entryInChunks.size === 0) {\n      cgm.entryInChunks = undefined;\n    }\n\n    cgc.entryModules.delete(module);\n  }\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {RuntimeModule} module the runtime module\n   * @returns {void}\n   */\n\n\n  disconnectChunkAndRuntimeModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    cgm.runtimeInChunks.delete(chunk);\n\n    if (cgm.runtimeInChunks.size === 0) {\n      cgm.runtimeInChunks = undefined;\n    }\n\n    cgc.runtimeModules.delete(module);\n  }\n  /**\n   * @param {Module} module the entry module, it will no longer be entry\n   * @returns {void}\n   */\n\n\n  disconnectEntryModule(module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    for (const chunk of cgm.entryInChunks) {\n      const cgc = this._getChunkGraphChunk(chunk);\n\n      cgc.entryModules.delete(module);\n    }\n\n    cgm.entryInChunks = undefined;\n  }\n  /**\n   * @param {Chunk} chunk the chunk, for which all entries will be removed\n   * @returns {void}\n   */\n\n\n  disconnectEntries(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    for (const module of cgc.entryModules.keys()) {\n      const cgm = this._getChunkGraphModule(module);\n\n      cgm.entryInChunks.delete(chunk);\n\n      if (cgm.entryInChunks.size === 0) {\n        cgm.entryInChunks = undefined;\n      }\n    }\n\n    cgc.entryModules.clear();\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {number} the amount of entry modules in chunk\n   */\n\n\n  getNumberOfEntryModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.entryModules.size;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {number} the amount of entry modules in chunk\n   */\n\n\n  getNumberOfRuntimeModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.runtimeModules.size;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<Module>} iterable of modules (do not modify)\n   */\n\n\n  getChunkEntryModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.entryModules.keys();\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<Chunk>} iterable of chunks\n   */\n\n\n  getChunkEntryDependentChunksIterable(chunk) {\n    /** @type {Set<Chunk>} */\n    const set = new Set();\n\n    for (const chunkGroup of chunk.groupsIterable) {\n      if (chunkGroup instanceof Entrypoint) {\n        const entrypointChunk = chunkGroup.getEntrypointChunk();\n\n        const cgc = this._getChunkGraphChunk(entrypointChunk);\n\n        for (const chunkGroup of cgc.entryModules.values()) {\n          for (const c of chunkGroup.chunks) {\n            if (c !== chunk && c !== entrypointChunk && !c.hasRuntime()) {\n              set.add(c);\n            }\n          }\n        }\n      }\n    }\n\n    return set;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {boolean} true, when it has dependent chunks\n   */\n\n\n  hasChunkEntryDependentChunks(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    for (const chunkGroup of cgc.entryModules.values()) {\n      for (const c of chunkGroup.chunks) {\n        if (c !== chunk) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<RuntimeModule>} iterable of modules (do not modify)\n   */\n\n\n  getChunkRuntimeModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.runtimeModules;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {RuntimeModule[]} array of modules in order of execution\n   */\n\n\n  getChunkRuntimeModulesInOrder(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const array = Array.from(cgc.runtimeModules);\n    array.sort(concatComparators(compareSelect(\n    /**\n     * @param {RuntimeModule} r runtime module\n     * @returns {number=} stage\n     */\n    r => r.stage, compareIds), compareModulesByIdentifier));\n    return array;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n   */\n\n\n  getChunkFullHashModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.fullHashModules;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {ReadonlySet<RuntimeModule> | undefined} set of modules (do not modify)\n   */\n\n\n  getChunkFullHashModulesSet(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.fullHashModules;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n   */\n\n\n  getChunkDependentHashModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.dependentHashModules;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<EntryModuleWithChunkGroup>} iterable of modules (do not modify)\n   */\n\n\n  getChunkEntryModulesWithChunkGroupIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.entryModules;\n  }\n  /**\n   * @param {AsyncDependenciesBlock} depBlock the async block\n   * @returns {ChunkGroup} the chunk group\n   */\n\n\n  getBlockChunkGroup(depBlock) {\n    return this._blockChunkGroups.get(depBlock);\n  }\n  /**\n   * @param {AsyncDependenciesBlock} depBlock the async block\n   * @param {ChunkGroup} chunkGroup the chunk group\n   * @returns {void}\n   */\n\n\n  connectBlockAndChunkGroup(depBlock, chunkGroup) {\n    this._blockChunkGroups.set(depBlock, chunkGroup);\n\n    chunkGroup.addBlock(depBlock);\n  }\n  /**\n   * @param {ChunkGroup} chunkGroup the chunk group\n   * @returns {void}\n   */\n\n\n  disconnectChunkGroup(chunkGroup) {\n    for (const block of chunkGroup.blocksIterable) {\n      this._blockChunkGroups.delete(block);\n    } // TODO refactor by moving blocks list into ChunkGraph\n\n\n    chunkGroup._blocks.clear();\n  }\n  /**\n   * @param {Module} module the module\n   * @returns {string | number} the id of the module\n   */\n\n\n  getModuleId(module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    return cgm.id;\n  }\n  /**\n   * @param {Module} module the module\n   * @param {string | number} id the id of the module\n   * @returns {void}\n   */\n\n\n  setModuleId(module, id) {\n    const cgm = this._getChunkGraphModule(module);\n\n    cgm.id = id;\n  }\n  /**\n   * @param {string} runtime runtime\n   * @returns {string | number} the id of the runtime\n   */\n\n\n  getRuntimeId(runtime) {\n    return this._runtimeIds.get(runtime);\n  }\n  /**\n   * @param {string} runtime runtime\n   * @param {string | number} id the id of the runtime\n   * @returns {void}\n   */\n\n\n  setRuntimeId(runtime, id) {\n    this._runtimeIds.set(runtime, id);\n  }\n  /**\n   * @template T\n   * @param {Module} module the module\n   * @param {RuntimeSpecMap<T>} hashes hashes data\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {T} hash\n   */\n\n\n  _getModuleHashInfo(module, hashes, runtime) {\n    if (!hashes) {\n      throw new Error(`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(runtime)} (hashes not set at all)`);\n    } else if (runtime === undefined) {\n      const hashInfoItems = new Set(hashes.values());\n\n      if (hashInfoItems.size !== 1) {\n        throw new Error(`No unique hash info entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(hashes.keys(), r => runtimeToString(r)).join(\", \")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \"global\").`);\n      }\n\n      return first(hashInfoItems);\n    } else {\n      const hashInfo = hashes.get(runtime);\n\n      if (!hashInfo) {\n        throw new Error(`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(runtime)} (available runtimes ${Array.from(hashes.keys(), runtimeToString).join(\", \")})`);\n      }\n\n      return hashInfo;\n    }\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {boolean} true, if the module has hashes for this runtime\n   */\n\n\n  hasModuleHashes(module, runtime) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const hashes = cgm.hashes;\n    return hashes && hashes.has(runtime);\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {string} hash\n   */\n\n\n  getModuleHash(module, runtime) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const hashes = cgm.hashes;\n    return this._getModuleHashInfo(module, hashes, runtime).hash;\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {string} hash\n   */\n\n\n  getRenderedModuleHash(module, runtime) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const hashes = cgm.hashes;\n    return this._getModuleHashInfo(module, hashes, runtime).renderedHash;\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @param {string} hash the full hash\n   * @param {string} renderedHash the shortened hash for rendering\n   * @returns {void}\n   */\n\n\n  setModuleHashes(module, runtime, hash, renderedHash) {\n    const cgm = this._getChunkGraphModule(module);\n\n    if (cgm.hashes === undefined) {\n      cgm.hashes = new RuntimeSpecMap();\n    }\n\n    cgm.hashes.set(runtime, new ModuleHashInfo(hash, renderedHash));\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph when transferOwnership not false)\n   * @param {boolean} transferOwnership true: transfer ownership of the items object, false: items is immutable and shared and won't be modified\n   * @returns {void}\n   */\n\n\n  addModuleRuntimeRequirements(module, runtime, items) {\n    let transferOwnership = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    const cgm = this._getChunkGraphModule(module);\n\n    const runtimeRequirementsMap = cgm.runtimeRequirements;\n\n    if (runtimeRequirementsMap === undefined) {\n      const map = new RuntimeSpecMap(); // TODO avoid cloning item and track ownership instead\n\n      map.set(runtime, transferOwnership ? items : new Set(items));\n      cgm.runtimeRequirements = map;\n      return;\n    }\n\n    runtimeRequirementsMap.update(runtime, runtimeRequirements => {\n      if (runtimeRequirements === undefined) {\n        return transferOwnership ? items : new Set(items);\n      } else if (!transferOwnership || runtimeRequirements.size >= items.size) {\n        for (const item of items) runtimeRequirements.add(item);\n\n        return runtimeRequirements;\n      } else {\n        for (const item of runtimeRequirements) items.add(item);\n\n        return items;\n      }\n    });\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph)\n   * @returns {void}\n   */\n\n\n  addChunkRuntimeRequirements(chunk, items) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const runtimeRequirements = cgc.runtimeRequirements;\n\n    if (runtimeRequirements === undefined) {\n      cgc.runtimeRequirements = items;\n    } else if (runtimeRequirements.size >= items.size) {\n      for (const item of items) runtimeRequirements.add(item);\n    } else {\n      for (const item of runtimeRequirements) items.add(item);\n\n      cgc.runtimeRequirements = items;\n    }\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Iterable<string>} items runtime requirements to be added\n   * @returns {void}\n   */\n\n\n  addTreeRuntimeRequirements(chunk, items) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const runtimeRequirements = cgc.runtimeRequirementsInTree;\n\n    for (const item of items) runtimeRequirements.add(item);\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {ReadonlySet<string>} runtime requirements\n   */\n\n\n  getModuleRuntimeRequirements(module, runtime) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const runtimeRequirements = cgm.runtimeRequirements && cgm.runtimeRequirements.get(runtime);\n    return runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {ReadonlySet<string>} runtime requirements\n   */\n\n\n  getChunkRuntimeRequirements(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const runtimeRequirements = cgc.runtimeRequirements;\n    return runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @param {boolean} withConnections include connections\n   * @returns {string} hash\n   */\n\n\n  getModuleGraphHash(module, runtime) {\n    let withConnections = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    const cgm = this._getChunkGraphModule(module);\n\n    return withConnections ? this._getModuleGraphHashWithConnections(cgm, module, runtime) : this._getModuleGraphHashBigInt(cgm, module, runtime).toString(16);\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @param {boolean} withConnections include connections\n   * @returns {bigint} hash\n   */\n\n\n  getModuleGraphHashBigInt(module, runtime) {\n    let withConnections = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    const cgm = this._getChunkGraphModule(module);\n\n    return withConnections ? BigInt(`0x${this._getModuleGraphHashWithConnections(cgm, module, runtime)}`) : this._getModuleGraphHashBigInt(cgm, module, runtime);\n  }\n  /**\n   * @param {ChunkGraphModule} cgm the ChunkGraphModule\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {bigint} hash as big int\n   */\n\n\n  _getModuleGraphHashBigInt(cgm, module, runtime) {\n    if (cgm.graphHashes === undefined) {\n      cgm.graphHashes = new RuntimeSpecMap();\n    }\n\n    const graphHash = cgm.graphHashes.provide(runtime, () => {\n      const hash = createHash(this._hashFunction);\n      hash.update(`${cgm.id}${this.moduleGraph.isAsync(module)}`);\n      this.moduleGraph.getExportsInfo(module).updateHash(hash, runtime);\n      return BigInt(`0x${\n      /** @type {string} */\n      hash.digest(\"hex\")}`);\n    });\n    return graphHash;\n  }\n  /**\n   * @param {ChunkGraphModule} cgm the ChunkGraphModule\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {string} hash\n   */\n\n\n  _getModuleGraphHashWithConnections(cgm, module, runtime) {\n    if (cgm.graphHashesWithConnections === undefined) {\n      cgm.graphHashesWithConnections = new RuntimeSpecMap();\n    }\n\n    const activeStateToString = state => {\n      if (state === false) return \"F\";\n      if (state === true) return \"T\";\n      if (state === ModuleGraphConnection.TRANSITIVE_ONLY) return \"O\";\n      throw new Error(\"Not implemented active state\");\n    };\n\n    const strict = module.buildMeta && module.buildMeta.strictHarmonyModule;\n    return cgm.graphHashesWithConnections.provide(runtime, () => {\n      const graphHash = this._getModuleGraphHashBigInt(cgm, module, runtime).toString(16);\n\n      const connections = this.moduleGraph.getOutgoingConnections(module);\n      /** @type {Set<Module>} */\n\n      const activeNamespaceModules = new Set();\n      /** @type {Map<string, Module | Set<Module>>} */\n\n      const connectedModules = new Map();\n\n      const processConnection = (connection, stateInfo) => {\n        const module = connection.module;\n        stateInfo += module.getExportsType(this.moduleGraph, strict); // cspell:word Tnamespace\n\n        if (stateInfo === \"Tnamespace\") activeNamespaceModules.add(module);else {\n          const oldModule = connectedModules.get(stateInfo);\n\n          if (oldModule === undefined) {\n            connectedModules.set(stateInfo, module);\n          } else if (oldModule instanceof Set) {\n            oldModule.add(module);\n          } else if (oldModule !== module) {\n            connectedModules.set(stateInfo, new Set([oldModule, module]));\n          }\n        }\n      };\n\n      if (runtime === undefined || typeof runtime === \"string\") {\n        for (const connection of connections) {\n          const state = connection.getActiveState(runtime);\n          if (state === false) continue;\n          processConnection(connection, state === true ? \"T\" : \"O\");\n        }\n      } else {\n        // cspell:word Tnamespace\n        for (const connection of connections) {\n          const states = new Set();\n          let stateInfo = \"\";\n          forEachRuntime(runtime, runtime => {\n            const state = connection.getActiveState(runtime);\n            states.add(state);\n            stateInfo += activeStateToString(state) + runtime;\n          }, true);\n\n          if (states.size === 1) {\n            const state = first(states);\n            if (state === false) continue;\n            stateInfo = activeStateToString(state);\n          }\n\n          processConnection(connection, stateInfo);\n        }\n      } // cspell:word Tnamespace\n\n\n      if (activeNamespaceModules.size === 0 && connectedModules.size === 0) return graphHash;\n      const connectedModulesInOrder = connectedModules.size > 1 ? Array.from(connectedModules).sort((_ref, _ref2) => {\n        let [a] = _ref;\n        let [b] = _ref2;\n        return a < b ? -1 : 1;\n      }) : connectedModules;\n      const hash = createHash(this._hashFunction);\n\n      const addModuleToHash = module => {\n        hash.update(this._getModuleGraphHashBigInt(this._getChunkGraphModule(module), module, runtime).toString(16));\n      };\n\n      const addModulesToHash = modules => {\n        let xor = ZERO_BIG_INT;\n\n        for (const m of modules) {\n          xor = xor ^ this._getModuleGraphHashBigInt(this._getChunkGraphModule(m), m, runtime);\n        }\n\n        hash.update(xor.toString(16));\n      };\n\n      if (activeNamespaceModules.size === 1) addModuleToHash(activeNamespaceModules.values().next().value);else if (activeNamespaceModules.size > 1) addModulesToHash(activeNamespaceModules);\n\n      for (const [stateInfo, modules] of connectedModulesInOrder) {\n        hash.update(stateInfo);\n\n        if (modules instanceof Set) {\n          addModulesToHash(modules);\n        } else {\n          addModuleToHash(modules);\n        }\n      }\n\n      hash.update(graphHash);\n      return (\n        /** @type {string} */\n        hash.digest(\"hex\")\n      );\n    });\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {ReadonlySet<string>} runtime requirements\n   */\n\n\n  getTreeRuntimeRequirements(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.runtimeRequirementsInTree;\n  } // TODO remove in webpack 6\n\n  /**\n   * @param {Module} module the module\n   * @param {string} deprecateMessage message for the deprecation message\n   * @param {string} deprecationCode code for the deprecation\n   * @returns {ChunkGraph} the chunk graph\n   */\n\n\n  static getChunkGraphForModule(module, deprecateMessage, deprecationCode) {\n    const fn = deprecateGetChunkGraphForModuleMap.get(deprecateMessage);\n    if (fn) return fn(module);\n    const newFn = util.deprecate(\n    /**\n     * @param {Module} module the module\n     * @returns {ChunkGraph} the chunk graph\n     */\n    module => {\n      const chunkGraph = chunkGraphForModuleMap.get(module);\n      if (!chunkGraph) throw new Error(deprecateMessage + \": There was no ChunkGraph assigned to the Module for backward-compat (Use the new API)\");\n      return chunkGraph;\n    }, deprecateMessage + \": Use new ChunkGraph API\", deprecationCode);\n    deprecateGetChunkGraphForModuleMap.set(deprecateMessage, newFn);\n    return newFn(module);\n  } // TODO remove in webpack 6\n\n  /**\n   * @param {Module} module the module\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @returns {void}\n   */\n\n\n  static setChunkGraphForModule(module, chunkGraph) {\n    chunkGraphForModuleMap.set(module, chunkGraph);\n  } // TODO remove in webpack 6\n\n  /**\n   * @param {Module} module the module\n   * @returns {void}\n   */\n\n\n  static clearChunkGraphForModule(module) {\n    chunkGraphForModuleMap.delete(module);\n  } // TODO remove in webpack 6\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {string} deprecateMessage message for the deprecation message\n   * @param {string} deprecationCode code for the deprecation\n   * @returns {ChunkGraph} the chunk graph\n   */\n\n\n  static getChunkGraphForChunk(chunk, deprecateMessage, deprecationCode) {\n    const fn = deprecateGetChunkGraphForChunkMap.get(deprecateMessage);\n    if (fn) return fn(chunk);\n    const newFn = util.deprecate(\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {ChunkGraph} the chunk graph\n     */\n    chunk => {\n      const chunkGraph = chunkGraphForChunkMap.get(chunk);\n      if (!chunkGraph) throw new Error(deprecateMessage + \"There was no ChunkGraph assigned to the Chunk for backward-compat (Use the new API)\");\n      return chunkGraph;\n    }, deprecateMessage + \": Use new ChunkGraph API\", deprecationCode);\n    deprecateGetChunkGraphForChunkMap.set(deprecateMessage, newFn);\n    return newFn(chunk);\n  } // TODO remove in webpack 6\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @returns {void}\n   */\n\n\n  static setChunkGraphForChunk(chunk, chunkGraph) {\n    chunkGraphForChunkMap.set(chunk, chunkGraph);\n  } // TODO remove in webpack 6\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {void}\n   */\n\n\n  static clearChunkGraphForChunk(chunk) {\n    chunkGraphForChunkMap.delete(chunk);\n  }\n\n} // TODO remove in webpack 6\n\n/** @type {WeakMap<Module, ChunkGraph>} */\n\n\nconst chunkGraphForModuleMap = new WeakMap(); // TODO remove in webpack 6\n\n/** @type {WeakMap<Chunk, ChunkGraph>} */\n\nconst chunkGraphForChunkMap = new WeakMap(); // TODO remove in webpack 6\n\n/** @type {Map<string, (module: Module) => ChunkGraph>} */\n\nconst deprecateGetChunkGraphForModuleMap = new Map(); // TODO remove in webpack 6\n\n/** @type {Map<string, (chunk: Chunk) => ChunkGraph>} */\n\nconst deprecateGetChunkGraphForChunkMap = new Map();\nmodule.exports = ChunkGraph;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/ChunkGraph.js"],"names":["util","require","Entrypoint","ModuleGraphConnection","first","SortableSet","compareModulesById","compareIterables","compareModulesByIdentifier","concatComparators","compareSelect","compareIds","createHash","findGraphRoots","RuntimeSpecMap","RuntimeSpecSet","runtimeToString","mergeRuntime","forEachRuntime","EMPTY_SET","Set","ZERO_BIG_INT","BigInt","compareModuleIterables","ModuleHashInfo","constructor","hash","renderedHash","getArray","set","Array","from","getModuleRuntimes","chunks","runtimes","chunk","add","runtime","modulesBySourceType","map","Map","module","sourceType","getSourceTypes","innerSet","get","undefined","key","size","createOrderedArrayFunctionMap","WeakMap","createOrderedArrayFunction","comparator","fn","sortWith","getModulesSize","modules","type","getModulesSizes","sizes","Object","create","isAvailableChunk","a","b","queue","groupsIterable","chunkGroup","isInGroup","isInitial","parent","parentsIterable","ChunkGraphModule","entryInChunks","runtimeInChunks","hashes","id","runtimeRequirements","graphHashes","graphHashesWithConnections","ChunkGraphChunk","entryModules","runtimeModules","fullHashModules","dependentHashModules","runtimeRequirementsInTree","ChunkGraph","moduleGraph","hashFunction","_modules","_chunks","_blockChunkGroups","_runtimeIds","_hashFunction","_getGraphRoots","bind","_getChunkGraphModule","cgm","_getChunkGraphChunk","cgc","addDependencies","connection","getOutgoingConnections","activeState","getActiveState","TRANSITIVE_ONLY","sort","connectChunkAndModule","disconnectChunkAndModule","delete","disconnectChunk","clear","disconnectFromGroups","clearChunkGraphForChunk","attachModules","attachRuntimeModules","attachFullHashModules","attachDependentHashModules","replaceModule","oldModule","newModule","oldCgm","newCgm","old","newEntryModules","m","cg","has","isModuleInChunk","isModuleInChunkGroup","isEntryModule","getModuleChunksIterable","getOrderedModuleChunksIterable","sortFn","getModuleChunks","getFromCache","getNumberOfModuleChunks","getFromUnorderedCache","getNumberOfChunkModules","getNumberOfChunkFullHashModules","getChunkModulesIterable","getChunkModulesIterableBySourceType","modulesWithSourceType","getOrderedChunkModulesIterable","getOrderedChunkModulesIterableBySourceType","getChunkModules","getOrderedChunkModules","arrayFunction","getChunkModuleIdMap","filterFn","includeAllChunks","chunkModuleIdMap","asyncChunk","getAllReferencedChunks","getAllAsyncChunks","array","moduleId","getModuleId","push","getChunkModuleRenderedHashMap","hashLength","chunkModuleHashMap","idToHashMap","getRenderedModuleHash","slice","getChunkConditionMap","c","hasModuleInGraph","filterChunkFn","chunksProcessed","innerChunk","child","childrenIterable","compareChunks","chunkA","chunkB","cgcA","cgcB","getChunkModulesSize","getChunkModulesSizes","getChunkRootModules","getChunkSize","options","modulesSize","chunkOverhead","entryChunkMultiplicator","canBeInitial","getIntegratedChunksSize","allModules","canChunksBeIntegrated","preventIntegration","hasRuntimeA","hasRuntime","hasRuntimeB","getNumberOfEntryModules","integrateChunks","name","length","hint","idNameHints","getChunkEntryModulesWithChunkGroupIterable","disconnectChunkAndEntryModule","connectChunkAndEntryModule","replaceChunk","addGroup","removeGroup","upgradeDependentToFullHashModules","isEntryModuleInChunk","entrypoint","connectChunkAndRuntimeModule","addFullHashModuleToChunk","addDependentHashModuleToChunk","disconnectChunkAndRuntimeModule","disconnectEntryModule","disconnectEntries","keys","getNumberOfRuntimeModules","getChunkEntryModulesIterable","getChunkEntryDependentChunksIterable","entrypointChunk","getEntrypointChunk","values","hasChunkEntryDependentChunks","getChunkRuntimeModulesIterable","getChunkRuntimeModulesInOrder","r","stage","getChunkFullHashModulesIterable","getChunkFullHashModulesSet","getChunkDependentHashModulesIterable","getBlockChunkGroup","depBlock","connectBlockAndChunkGroup","addBlock","disconnectChunkGroup","block","blocksIterable","_blocks","setModuleId","getRuntimeId","setRuntimeId","_getModuleHashInfo","Error","identifier","hashInfoItems","join","hashInfo","hasModuleHashes","getModuleHash","setModuleHashes","addModuleRuntimeRequirements","items","transferOwnership","runtimeRequirementsMap","update","item","addChunkRuntimeRequirements","addTreeRuntimeRequirements","getModuleRuntimeRequirements","getChunkRuntimeRequirements","getModuleGraphHash","withConnections","_getModuleGraphHashWithConnections","_getModuleGraphHashBigInt","toString","getModuleGraphHashBigInt","graphHash","provide","isAsync","getExportsInfo","updateHash","digest","activeStateToString","state","strict","buildMeta","strictHarmonyModule","connections","activeNamespaceModules","connectedModules","processConnection","stateInfo","getExportsType","states","connectedModulesInOrder","addModuleToHash","addModulesToHash","xor","next","value","getTreeRuntimeRequirements","getChunkGraphForModule","deprecateMessage","deprecationCode","deprecateGetChunkGraphForModuleMap","newFn","deprecate","chunkGraph","chunkGraphForModuleMap","setChunkGraphForModule","clearChunkGraphForModule","getChunkGraphForChunk","deprecateGetChunkGraphForChunkMap","chunkGraphForChunkMap","setChunkGraphForChunk","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst util = require(\"util\");\nconst Entrypoint = require(\"./Entrypoint\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst { first } = require(\"./util/SetHelpers\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst {\n\tcompareModulesById,\n\tcompareIterables,\n\tcompareModulesByIdentifier,\n\tconcatComparators,\n\tcompareSelect,\n\tcompareIds\n} = require(\"./util/comparators\");\nconst createHash = require(\"./util/createHash\");\nconst findGraphRoots = require(\"./util/findGraphRoots\");\nconst {\n\tRuntimeSpecMap,\n\tRuntimeSpecSet,\n\truntimeToString,\n\tmergeRuntime,\n\tforEachRuntime\n} = require(\"./util/runtime\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./RuntimeModule\")} RuntimeModule */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @type {ReadonlySet<string>} */\nconst EMPTY_SET = new Set();\n\nconst ZERO_BIG_INT = BigInt(0);\n\nconst compareModuleIterables = compareIterables(compareModulesByIdentifier);\n\n/** @typedef {(c: Chunk, chunkGraph: ChunkGraph) => boolean} ChunkFilterPredicate */\n/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */\n/** @typedef {[Module, Entrypoint | undefined]} EntryModuleWithChunkGroup */\n\n/**\n * @typedef {Object} ChunkSizeOptions\n * @property {number=} chunkOverhead constant overhead for a chunk\n * @property {number=} entryChunkMultiplicator multiplicator for initial chunks\n */\n\nclass ModuleHashInfo {\n\tconstructor(hash, renderedHash) {\n\t\tthis.hash = hash;\n\t\tthis.renderedHash = renderedHash;\n\t}\n}\n\n/** @template T @typedef {(set: SortableSet<T>) => T[]} SetToArrayFunction<T> */\n\n/**\n * @template T\n * @param {SortableSet<T>} set the set\n * @returns {T[]} set as array\n */\nconst getArray = set => {\n\treturn Array.from(set);\n};\n\n/**\n * @param {SortableSet<Chunk>} chunks the chunks\n * @returns {RuntimeSpecSet} runtimes\n */\nconst getModuleRuntimes = chunks => {\n\tconst runtimes = new RuntimeSpecSet();\n\tfor (const chunk of chunks) {\n\t\truntimes.add(chunk.runtime);\n\t}\n\treturn runtimes;\n};\n\n/**\n * @param {SortableSet<Module>} set the set\n * @returns {Map<string, SortableSet<Module>>} modules by source type\n */\nconst modulesBySourceType = set => {\n\t/** @type {Map<string, SortableSet<Module>>} */\n\tconst map = new Map();\n\tfor (const module of set) {\n\t\tfor (const sourceType of module.getSourceTypes()) {\n\t\t\tlet innerSet = map.get(sourceType);\n\t\t\tif (innerSet === undefined) {\n\t\t\t\tinnerSet = new SortableSet();\n\t\t\t\tmap.set(sourceType, innerSet);\n\t\t\t}\n\t\t\tinnerSet.add(module);\n\t\t}\n\t}\n\tfor (const [key, innerSet] of map) {\n\t\t// When all modules have the source type, we reuse the original SortableSet\n\t\t// to benefit from the shared cache (especially for sorting)\n\t\tif (innerSet.size === set.size) {\n\t\t\tmap.set(key, set);\n\t\t}\n\t}\n\treturn map;\n};\n\n/** @type {WeakMap<Function, any>} */\nconst createOrderedArrayFunctionMap = new WeakMap();\n\n/**\n * @template T\n * @param {function(T, T): -1|0|1} comparator comparator function\n * @returns {SetToArrayFunction<T>} set as ordered array\n */\nconst createOrderedArrayFunction = comparator => {\n\t/** @type {SetToArrayFunction<T>} */\n\tlet fn = createOrderedArrayFunctionMap.get(comparator);\n\tif (fn !== undefined) return fn;\n\tfn = set => {\n\t\tset.sortWith(comparator);\n\t\treturn Array.from(set);\n\t};\n\tcreateOrderedArrayFunctionMap.set(comparator, fn);\n\treturn fn;\n};\n\n/**\n * @param {Iterable<Module>} modules the modules to get the count/size of\n * @returns {number} the size of the modules\n */\nconst getModulesSize = modules => {\n\tlet size = 0;\n\tfor (const module of modules) {\n\t\tfor (const type of module.getSourceTypes()) {\n\t\t\tsize += module.size(type);\n\t\t}\n\t}\n\treturn size;\n};\n\n/**\n * @param {Iterable<Module>} modules the sortable Set to get the size of\n * @returns {Record<string, number>} the sizes of the modules\n */\nconst getModulesSizes = modules => {\n\tlet sizes = Object.create(null);\n\tfor (const module of modules) {\n\t\tfor (const type of module.getSourceTypes()) {\n\t\t\tsizes[type] = (sizes[type] || 0) + module.size(type);\n\t\t}\n\t}\n\treturn sizes;\n};\n\n/**\n * @param {Chunk} a chunk\n * @param {Chunk} b chunk\n * @returns {boolean} true, if a is always a parent of b\n */\nconst isAvailableChunk = (a, b) => {\n\tconst queue = new Set(b.groupsIterable);\n\tfor (const chunkGroup of queue) {\n\t\tif (a.isInGroup(chunkGroup)) continue;\n\t\tif (chunkGroup.isInitial()) return false;\n\t\tfor (const parent of chunkGroup.parentsIterable) {\n\t\t\tqueue.add(parent);\n\t\t}\n\t}\n\treturn true;\n};\n\nclass ChunkGraphModule {\n\tconstructor() {\n\t\t/** @type {SortableSet<Chunk>} */\n\t\tthis.chunks = new SortableSet();\n\t\t/** @type {Set<Chunk> | undefined} */\n\t\tthis.entryInChunks = undefined;\n\t\t/** @type {Set<Chunk> | undefined} */\n\t\tthis.runtimeInChunks = undefined;\n\t\t/** @type {RuntimeSpecMap<ModuleHashInfo>} */\n\t\tthis.hashes = undefined;\n\t\t/** @type {string | number} */\n\t\tthis.id = null;\n\t\t/** @type {RuntimeSpecMap<Set<string>> | undefined} */\n\t\tthis.runtimeRequirements = undefined;\n\t\t/** @type {RuntimeSpecMap<string>} */\n\t\tthis.graphHashes = undefined;\n\t\t/** @type {RuntimeSpecMap<string>} */\n\t\tthis.graphHashesWithConnections = undefined;\n\t}\n}\n\nclass ChunkGraphChunk {\n\tconstructor() {\n\t\t/** @type {SortableSet<Module>} */\n\t\tthis.modules = new SortableSet();\n\t\t/** @type {Map<Module, Entrypoint>} */\n\t\tthis.entryModules = new Map();\n\t\t/** @type {SortableSet<RuntimeModule>} */\n\t\tthis.runtimeModules = new SortableSet();\n\t\t/** @type {Set<RuntimeModule> | undefined} */\n\t\tthis.fullHashModules = undefined;\n\t\t/** @type {Set<RuntimeModule> | undefined} */\n\t\tthis.dependentHashModules = undefined;\n\t\t/** @type {Set<string> | undefined} */\n\t\tthis.runtimeRequirements = undefined;\n\t\t/** @type {Set<string>} */\n\t\tthis.runtimeRequirementsInTree = new Set();\n\t}\n}\n\nclass ChunkGraph {\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {string | Hash} hashFunction the hash function to use\n\t */\n\tconstructor(moduleGraph, hashFunction = \"md4\") {\n\t\t/** @private @type {WeakMap<Module, ChunkGraphModule>} */\n\t\tthis._modules = new WeakMap();\n\t\t/** @private @type {WeakMap<Chunk, ChunkGraphChunk>} */\n\t\tthis._chunks = new WeakMap();\n\t\t/** @private @type {WeakMap<AsyncDependenciesBlock, ChunkGroup>} */\n\t\tthis._blockChunkGroups = new WeakMap();\n\t\t/** @private @type {Map<string, string | number>} */\n\t\tthis._runtimeIds = new Map();\n\t\t/** @type {ModuleGraph} */\n\t\tthis.moduleGraph = moduleGraph;\n\n\t\tthis._hashFunction = hashFunction;\n\n\t\tthis._getGraphRoots = this._getGraphRoots.bind(this);\n\t}\n\n\t/**\n\t * @private\n\t * @param {Module} module the module\n\t * @returns {ChunkGraphModule} internal module\n\t */\n\t_getChunkGraphModule(module) {\n\t\tlet cgm = this._modules.get(module);\n\t\tif (cgm === undefined) {\n\t\t\tcgm = new ChunkGraphModule();\n\t\t\tthis._modules.set(module, cgm);\n\t\t}\n\t\treturn cgm;\n\t}\n\n\t/**\n\t * @private\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ChunkGraphChunk} internal chunk\n\t */\n\t_getChunkGraphChunk(chunk) {\n\t\tlet cgc = this._chunks.get(chunk);\n\t\tif (cgc === undefined) {\n\t\t\tcgc = new ChunkGraphChunk();\n\t\t\tthis._chunks.set(chunk, cgc);\n\t\t}\n\t\treturn cgc;\n\t}\n\n\t/**\n\t * @param {SortableSet<Module>} set the sortable Set to get the roots of\n\t * @returns {Module[]} the graph roots\n\t */\n\t_getGraphRoots(set) {\n\t\tconst { moduleGraph } = this;\n\t\treturn Array.from(\n\t\t\tfindGraphRoots(set, module => {\n\t\t\t\t/** @type {Set<Module>} */\n\t\t\t\tconst set = new Set();\n\t\t\t\tconst addDependencies = module => {\n\t\t\t\t\tfor (const connection of moduleGraph.getOutgoingConnections(module)) {\n\t\t\t\t\t\tif (!connection.module) continue;\n\t\t\t\t\t\tconst activeState = connection.getActiveState(undefined);\n\t\t\t\t\t\tif (activeState === false) continue;\n\t\t\t\t\t\tif (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\n\t\t\t\t\t\t\taddDependencies(connection.module);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tset.add(connection.module);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\taddDependencies(module);\n\t\t\t\treturn set;\n\t\t\t})\n\t\t).sort(compareModulesByIdentifier);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tconnectChunkAndModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgm.chunks.add(chunk);\n\t\tcgc.modules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tdisconnectChunkAndModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgc.modules.delete(module);\n\t\tcgm.chunks.delete(chunk);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk which will be disconnected\n\t * @returns {void}\n\t */\n\tdisconnectChunk(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of cgc.modules) {\n\t\t\tconst cgm = this._getChunkGraphModule(module);\n\t\t\tcgm.chunks.delete(chunk);\n\t\t}\n\t\tcgc.modules.clear();\n\t\tchunk.disconnectFromGroups();\n\t\tChunkGraph.clearChunkGraphForChunk(chunk);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<Module>} modules the modules\n\t * @returns {void}\n\t */\n\tattachModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of modules) {\n\t\t\tcgc.modules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<RuntimeModule>} modules the runtime modules\n\t * @returns {void}\n\t */\n\tattachRuntimeModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of modules) {\n\t\t\tcgc.runtimeModules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n\t * @returns {void}\n\t */\n\tattachFullHashModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n\t\tfor (const module of modules) {\n\t\t\tcgc.fullHashModules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n\t * @returns {void}\n\t */\n\tattachDependentHashModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.dependentHashModules === undefined)\n\t\t\tcgc.dependentHashModules = new Set();\n\t\tfor (const module of modules) {\n\t\t\tcgc.dependentHashModules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} oldModule the replaced module\n\t * @param {Module} newModule the replacing module\n\t * @returns {void}\n\t */\n\treplaceModule(oldModule, newModule) {\n\t\tconst oldCgm = this._getChunkGraphModule(oldModule);\n\t\tconst newCgm = this._getChunkGraphModule(newModule);\n\n\t\tfor (const chunk of oldCgm.chunks) {\n\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\tcgc.modules.delete(oldModule);\n\t\t\tcgc.modules.add(newModule);\n\t\t\tnewCgm.chunks.add(chunk);\n\t\t}\n\t\toldCgm.chunks.clear();\n\n\t\tif (oldCgm.entryInChunks !== undefined) {\n\t\t\tif (newCgm.entryInChunks === undefined) {\n\t\t\t\tnewCgm.entryInChunks = new Set();\n\t\t\t}\n\t\t\tfor (const chunk of oldCgm.entryInChunks) {\n\t\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\t\tconst old = cgc.entryModules.get(oldModule);\n\t\t\t\t/** @type {Map<Module, Entrypoint>} */\n\t\t\t\tconst newEntryModules = new Map();\n\t\t\t\tfor (const [m, cg] of cgc.entryModules) {\n\t\t\t\t\tif (m === oldModule) {\n\t\t\t\t\t\tnewEntryModules.set(newModule, old);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewEntryModules.set(m, cg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcgc.entryModules = newEntryModules;\n\t\t\t\tnewCgm.entryInChunks.add(chunk);\n\t\t\t}\n\t\t\toldCgm.entryInChunks = undefined;\n\t\t}\n\n\t\tif (oldCgm.runtimeInChunks !== undefined) {\n\t\t\tif (newCgm.runtimeInChunks === undefined) {\n\t\t\t\tnewCgm.runtimeInChunks = new Set();\n\t\t\t}\n\t\t\tfor (const chunk of oldCgm.runtimeInChunks) {\n\t\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\t\tcgc.runtimeModules.delete(/** @type {RuntimeModule} */ (oldModule));\n\t\t\t\tcgc.runtimeModules.add(/** @type {RuntimeModule} */ (newModule));\n\t\t\t\tnewCgm.runtimeInChunks.add(chunk);\n\t\t\t\tif (\n\t\t\t\t\tcgc.fullHashModules !== undefined &&\n\t\t\t\t\tcgc.fullHashModules.has(/** @type {RuntimeModule} */ (oldModule))\n\t\t\t\t) {\n\t\t\t\t\tcgc.fullHashModules.delete(/** @type {RuntimeModule} */ (oldModule));\n\t\t\t\t\tcgc.fullHashModules.add(/** @type {RuntimeModule} */ (newModule));\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tcgc.dependentHashModules !== undefined &&\n\t\t\t\t\tcgc.dependentHashModules.has(/** @type {RuntimeModule} */ (oldModule))\n\t\t\t\t) {\n\t\t\t\t\tcgc.dependentHashModules.delete(\n\t\t\t\t\t\t/** @type {RuntimeModule} */ (oldModule)\n\t\t\t\t\t);\n\t\t\t\t\tcgc.dependentHashModules.add(\n\t\t\t\t\t\t/** @type {RuntimeModule} */ (newModule)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\toldCgm.runtimeInChunks = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @param {Chunk} chunk the checked chunk\n\t * @returns {boolean} true, if the chunk contains the module\n\t */\n\tisModuleInChunk(module, chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.has(module);\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @param {ChunkGroup} chunkGroup the checked chunk group\n\t * @returns {boolean} true, if the chunk contains the module\n\t */\n\tisModuleInChunkGroup(module, chunkGroup) {\n\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\tif (this.isModuleInChunk(module, chunk)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @returns {boolean} true, if the module is entry of any chunk\n\t */\n\tisEntryModule(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.entryInChunks !== undefined;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n\t */\n\tgetModuleChunksIterable(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {function(Chunk, Chunk): -1|0|1} sortFn sort function\n\t * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n\t */\n\tgetOrderedModuleChunksIterable(module, sortFn) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tcgm.chunks.sortWith(sortFn);\n\t\treturn cgm.chunks;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {Chunk[]} array of chunks (cached, do not modify)\n\t */\n\tgetModuleChunks(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks.getFromCache(getArray);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {number} the number of chunk which contain the module\n\t */\n\tgetNumberOfModuleChunks(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks.size;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {RuntimeSpecSet} runtimes\n\t */\n\tgetModuleRuntimes(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks.getFromUnorderedCache(getModuleRuntimes);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the number of modules which are contained in this chunk\n\t */\n\tgetNumberOfChunkModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the number of full hash modules which are contained in this chunk\n\t */\n\tgetNumberOfChunkFullHashModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.fullHashModules === undefined ? 0 : cgc.fullHashModules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<Module>} return the modules for this chunk\n\t */\n\tgetChunkModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {string} sourceType source type\n\t * @returns {Iterable<Module> | undefined} return the modules for this chunk\n\t */\n\tgetChunkModulesIterableBySourceType(chunk, sourceType) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst modulesWithSourceType = cgc.modules\n\t\t\t.getFromUnorderedCache(modulesBySourceType)\n\t\t\t.get(sourceType);\n\t\treturn modulesWithSourceType;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {function(Module, Module): -1|0|1} comparator comparator function\n\t * @returns {Iterable<Module>} return the modules for this chunk\n\t */\n\tgetOrderedChunkModulesIterable(chunk, comparator) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgc.modules.sortWith(comparator);\n\t\treturn cgc.modules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {string} sourceType source type\n\t * @param {function(Module, Module): -1|0|1} comparator comparator function\n\t * @returns {Iterable<Module> | undefined} return the modules for this chunk\n\t */\n\tgetOrderedChunkModulesIterableBySourceType(chunk, sourceType, comparator) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst modulesWithSourceType = cgc.modules\n\t\t\t.getFromUnorderedCache(modulesBySourceType)\n\t\t\t.get(sourceType);\n\t\tif (modulesWithSourceType === undefined) return undefined;\n\t\tmodulesWithSourceType.sortWith(comparator);\n\t\treturn modulesWithSourceType;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n\t */\n\tgetChunkModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(getArray);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {function(Module, Module): -1|0|1} comparator comparator function\n\t * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n\t */\n\tgetOrderedChunkModules(chunk, comparator) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst arrayFunction = createOrderedArrayFunction(comparator);\n\t\treturn cgc.modules.getFromUnorderedCache(arrayFunction);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\n\t * @param {boolean} includeAllChunks all chunks or only async chunks\n\t * @returns {Record<string|number, (string|number)[]>} chunk to module ids object\n\t */\n\tgetChunkModuleIdMap(chunk, filterFn, includeAllChunks = false) {\n\t\t/** @type {Record<string|number, (string|number)[]>} */\n\t\tconst chunkModuleIdMap = Object.create(null);\n\n\t\tfor (const asyncChunk of includeAllChunks\n\t\t\t? chunk.getAllReferencedChunks()\n\t\t\t: chunk.getAllAsyncChunks()) {\n\t\t\t/** @type {(string|number)[]} */\n\t\t\tlet array;\n\t\t\tfor (const module of this.getOrderedChunkModulesIterable(\n\t\t\t\tasyncChunk,\n\t\t\t\tcompareModulesById(this)\n\t\t\t)) {\n\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\tchunkModuleIdMap[asyncChunk.id] = array;\n\t\t\t\t\t}\n\t\t\t\t\tconst moduleId = this.getModuleId(module);\n\t\t\t\t\tarray.push(moduleId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chunkModuleIdMap;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\n\t * @param {number} hashLength length of the hash\n\t * @param {boolean} includeAllChunks all chunks or only async chunks\n\t * @returns {Record<string|number, Record<string|number, string>>} chunk to module id to module hash object\n\t */\n\tgetChunkModuleRenderedHashMap(\n\t\tchunk,\n\t\tfilterFn,\n\t\thashLength = 0,\n\t\tincludeAllChunks = false\n\t) {\n\t\t/** @type {Record<string|number, Record<string|number, string>>} */\n\t\tconst chunkModuleHashMap = Object.create(null);\n\n\t\tfor (const asyncChunk of includeAllChunks\n\t\t\t? chunk.getAllReferencedChunks()\n\t\t\t: chunk.getAllAsyncChunks()) {\n\t\t\t/** @type {Record<string|number, string>} */\n\t\t\tlet idToHashMap;\n\t\t\tfor (const module of this.getOrderedChunkModulesIterable(\n\t\t\t\tasyncChunk,\n\t\t\t\tcompareModulesById(this)\n\t\t\t)) {\n\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\tif (idToHashMap === undefined) {\n\t\t\t\t\t\tidToHashMap = Object.create(null);\n\t\t\t\t\t\tchunkModuleHashMap[asyncChunk.id] = idToHashMap;\n\t\t\t\t\t}\n\t\t\t\t\tconst moduleId = this.getModuleId(module);\n\t\t\t\t\tconst hash = this.getRenderedModuleHash(module, asyncChunk.runtime);\n\t\t\t\t\tidToHashMap[moduleId] = hashLength ? hash.slice(0, hashLength) : hash;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chunkModuleHashMap;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ChunkFilterPredicate} filterFn function used to filter chunks\n\t * @returns {Record<string|number, boolean>} chunk map\n\t */\n\tgetChunkConditionMap(chunk, filterFn) {\n\t\tconst map = Object.create(null);\n\t\tfor (const c of chunk.getAllReferencedChunks()) {\n\t\t\tmap[c.id] = filterFn(c, this);\n\t\t}\n\t\treturn map;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\n\t * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\n\t * @returns {boolean} return true if module exists in graph\n\t */\n\thasModuleInGraph(chunk, filterFn, filterChunkFn) {\n\t\tconst queue = new Set(chunk.groupsIterable);\n\t\tconst chunksProcessed = new Set();\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const innerChunk of chunkGroup.chunks) {\n\t\t\t\tif (!chunksProcessed.has(innerChunk)) {\n\t\t\t\t\tchunksProcessed.add(innerChunk);\n\t\t\t\t\tif (!filterChunkFn || filterChunkFn(innerChunk, this)) {\n\t\t\t\t\t\tfor (const module of this.getChunkModulesIterable(innerChunk)) {\n\t\t\t\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA first chunk\n\t * @param {Chunk} chunkB second chunk\n\t * @returns {-1|0|1} this is a comparator function like sort and returns -1, 0, or 1 based on sort order\n\t */\n\tcompareChunks(chunkA, chunkB) {\n\t\tconst cgcA = this._getChunkGraphChunk(chunkA);\n\t\tconst cgcB = this._getChunkGraphChunk(chunkB);\n\t\tif (cgcA.modules.size > cgcB.modules.size) return -1;\n\t\tif (cgcA.modules.size < cgcB.modules.size) return 1;\n\t\tcgcA.modules.sortWith(compareModulesByIdentifier);\n\t\tcgcB.modules.sortWith(compareModulesByIdentifier);\n\t\treturn compareModuleIterables(cgcA.modules, cgcB.modules);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} total size of all modules in the chunk\n\t */\n\tgetChunkModulesSize(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(getModulesSize);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Record<string, number>} total sizes of all modules in the chunk by source type\n\t */\n\tgetChunkModulesSizes(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(getModulesSizes);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Module[]} root modules of the chunks (ordered by identifier)\n\t */\n\tgetChunkRootModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(this._getGraphRoots);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ChunkSizeOptions} options options object\n\t * @returns {number} total size of the chunk\n\t */\n\tgetChunkSize(chunk, options = {}) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst modulesSize = cgc.modules.getFromUnorderedCache(getModulesSize);\n\t\tconst chunkOverhead =\n\t\t\ttypeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n\t\tconst entryChunkMultiplicator =\n\t\t\ttypeof options.entryChunkMultiplicator === \"number\"\n\t\t\t\t? options.entryChunkMultiplicator\n\t\t\t\t: 10;\n\t\treturn (\n\t\t\tchunkOverhead +\n\t\t\tmodulesSize * (chunk.canBeInitial() ? entryChunkMultiplicator : 1)\n\t\t);\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA chunk\n\t * @param {Chunk} chunkB chunk\n\t * @param {ChunkSizeOptions} options options object\n\t * @returns {number} total size of the chunk or false if chunks can't be integrated\n\t */\n\tgetIntegratedChunksSize(chunkA, chunkB, options = {}) {\n\t\tconst cgcA = this._getChunkGraphChunk(chunkA);\n\t\tconst cgcB = this._getChunkGraphChunk(chunkB);\n\t\tconst allModules = new Set(cgcA.modules);\n\t\tfor (const m of cgcB.modules) allModules.add(m);\n\t\tlet modulesSize = getModulesSize(allModules);\n\t\tconst chunkOverhead =\n\t\t\ttypeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n\t\tconst entryChunkMultiplicator =\n\t\t\ttypeof options.entryChunkMultiplicator === \"number\"\n\t\t\t\t? options.entryChunkMultiplicator\n\t\t\t\t: 10;\n\t\treturn (\n\t\t\tchunkOverhead +\n\t\t\tmodulesSize *\n\t\t\t\t(chunkA.canBeInitial() || chunkB.canBeInitial()\n\t\t\t\t\t? entryChunkMultiplicator\n\t\t\t\t\t: 1)\n\t\t);\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA chunk\n\t * @param {Chunk} chunkB chunk\n\t * @returns {boolean} true, if chunks could be integrated\n\t */\n\tcanChunksBeIntegrated(chunkA, chunkB) {\n\t\tif (chunkA.preventIntegration || chunkB.preventIntegration) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst hasRuntimeA = chunkA.hasRuntime();\n\t\tconst hasRuntimeB = chunkB.hasRuntime();\n\n\t\tif (hasRuntimeA !== hasRuntimeB) {\n\t\t\tif (hasRuntimeA) {\n\t\t\t\treturn isAvailableChunk(chunkA, chunkB);\n\t\t\t} else if (hasRuntimeB) {\n\t\t\t\treturn isAvailableChunk(chunkB, chunkA);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tthis.getNumberOfEntryModules(chunkA) > 0 ||\n\t\t\tthis.getNumberOfEntryModules(chunkB) > 0\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA the target chunk\n\t * @param {Chunk} chunkB the chunk to integrate\n\t * @returns {void}\n\t */\n\tintegrateChunks(chunkA, chunkB) {\n\t\t// Decide for one name (deterministic)\n\t\tif (chunkA.name && chunkB.name) {\n\t\t\tif (\n\t\t\t\tthis.getNumberOfEntryModules(chunkA) > 0 ===\n\t\t\t\tthis.getNumberOfEntryModules(chunkB) > 0\n\t\t\t) {\n\t\t\t\t// When both chunks have entry modules or none have one, use\n\t\t\t\t// shortest name\n\t\t\t\tif (chunkA.name.length !== chunkB.name.length) {\n\t\t\t\t\tchunkA.name =\n\t\t\t\t\t\tchunkA.name.length < chunkB.name.length ? chunkA.name : chunkB.name;\n\t\t\t\t} else {\n\t\t\t\t\tchunkA.name = chunkA.name < chunkB.name ? chunkA.name : chunkB.name;\n\t\t\t\t}\n\t\t\t} else if (this.getNumberOfEntryModules(chunkB) > 0) {\n\t\t\t\t// Pick the name of the chunk with the entry module\n\t\t\t\tchunkA.name = chunkB.name;\n\t\t\t}\n\t\t} else if (chunkB.name) {\n\t\t\tchunkA.name = chunkB.name;\n\t\t}\n\n\t\t// Merge id name hints\n\t\tfor (const hint of chunkB.idNameHints) {\n\t\t\tchunkA.idNameHints.add(hint);\n\t\t}\n\n\t\t// Merge runtime\n\t\tchunkA.runtime = mergeRuntime(chunkA.runtime, chunkB.runtime);\n\n\t\t// getChunkModules is used here to create a clone, because disconnectChunkAndModule modifies\n\t\tfor (const module of this.getChunkModules(chunkB)) {\n\t\t\tthis.disconnectChunkAndModule(chunkB, module);\n\t\t\tthis.connectChunkAndModule(chunkA, module);\n\t\t}\n\n\t\tfor (const [module, chunkGroup] of Array.from(\n\t\t\tthis.getChunkEntryModulesWithChunkGroupIterable(chunkB)\n\t\t)) {\n\t\t\tthis.disconnectChunkAndEntryModule(chunkB, module);\n\t\t\tthis.connectChunkAndEntryModule(chunkA, module, chunkGroup);\n\t\t}\n\n\t\tfor (const chunkGroup of chunkB.groupsIterable) {\n\t\t\tchunkGroup.replaceChunk(chunkB, chunkA);\n\t\t\tchunkA.addGroup(chunkGroup);\n\t\t\tchunkB.removeGroup(chunkGroup);\n\t\t}\n\t\tChunkGraph.clearChunkGraphForChunk(chunkB);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk to upgrade\n\t * @returns {void}\n\t */\n\tupgradeDependentToFullHashModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.dependentHashModules === undefined) return;\n\t\tif (cgc.fullHashModules === undefined) {\n\t\t\tcgc.fullHashModules = cgc.dependentHashModules;\n\t\t} else {\n\t\t\tfor (const m of cgc.dependentHashModules) {\n\t\t\t\tcgc.fullHashModules.add(m);\n\t\t\t}\n\t\t\tcgc.dependentHashModules = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @param {Chunk} chunk the checked chunk\n\t * @returns {boolean} true, if the chunk contains the module as entry\n\t */\n\tisEntryModuleInChunk(module, chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules.has(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {Module} module the entry module\n\t * @param {Entrypoint=} entrypoint the chunk group which must be loaded before the module is executed\n\t * @returns {void}\n\t */\n\tconnectChunkAndEntryModule(chunk, module, entrypoint) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgm.entryInChunks === undefined) {\n\t\t\tcgm.entryInChunks = new Set();\n\t\t}\n\t\tcgm.entryInChunks.add(chunk);\n\t\tcgc.entryModules.set(module, entrypoint);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the runtime module\n\t * @returns {void}\n\t */\n\tconnectChunkAndRuntimeModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgm.runtimeInChunks === undefined) {\n\t\t\tcgm.runtimeInChunks = new Set();\n\t\t}\n\t\tcgm.runtimeInChunks.add(chunk);\n\t\tcgc.runtimeModules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the module that require a full hash\n\t * @returns {void}\n\t */\n\taddFullHashModuleToChunk(chunk, module) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n\t\tcgc.fullHashModules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the module that require a full hash\n\t * @returns {void}\n\t */\n\taddDependentHashModuleToChunk(chunk, module) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.dependentHashModules === undefined)\n\t\t\tcgc.dependentHashModules = new Set();\n\t\tcgc.dependentHashModules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {Module} module the entry module\n\t * @returns {void}\n\t */\n\tdisconnectChunkAndEntryModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgm.entryInChunks.delete(chunk);\n\t\tif (cgm.entryInChunks.size === 0) {\n\t\t\tcgm.entryInChunks = undefined;\n\t\t}\n\t\tcgc.entryModules.delete(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the runtime module\n\t * @returns {void}\n\t */\n\tdisconnectChunkAndRuntimeModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgm.runtimeInChunks.delete(chunk);\n\t\tif (cgm.runtimeInChunks.size === 0) {\n\t\t\tcgm.runtimeInChunks = undefined;\n\t\t}\n\t\tcgc.runtimeModules.delete(module);\n\t}\n\n\t/**\n\t * @param {Module} module the entry module, it will no longer be entry\n\t * @returns {void}\n\t */\n\tdisconnectEntryModule(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tfor (const chunk of cgm.entryInChunks) {\n\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\tcgc.entryModules.delete(module);\n\t\t}\n\t\tcgm.entryInChunks = undefined;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk, for which all entries will be removed\n\t * @returns {void}\n\t */\n\tdisconnectEntries(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of cgc.entryModules.keys()) {\n\t\t\tconst cgm = this._getChunkGraphModule(module);\n\t\t\tcgm.entryInChunks.delete(chunk);\n\t\t\tif (cgm.entryInChunks.size === 0) {\n\t\t\t\tcgm.entryInChunks = undefined;\n\t\t\t}\n\t\t}\n\t\tcgc.entryModules.clear();\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the amount of entry modules in chunk\n\t */\n\tgetNumberOfEntryModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the amount of entry modules in chunk\n\t */\n\tgetNumberOfRuntimeModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.runtimeModules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<Module>} iterable of modules (do not modify)\n\t */\n\tgetChunkEntryModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules.keys();\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<Chunk>} iterable of chunks\n\t */\n\tgetChunkEntryDependentChunksIterable(chunk) {\n\t\t/** @type {Set<Chunk>} */\n\t\tconst set = new Set();\n\t\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\t\tif (chunkGroup instanceof Entrypoint) {\n\t\t\t\tconst entrypointChunk = chunkGroup.getEntrypointChunk();\n\t\t\t\tconst cgc = this._getChunkGraphChunk(entrypointChunk);\n\t\t\t\tfor (const chunkGroup of cgc.entryModules.values()) {\n\t\t\t\t\tfor (const c of chunkGroup.chunks) {\n\t\t\t\t\t\tif (c !== chunk && c !== entrypointChunk && !c.hasRuntime()) {\n\t\t\t\t\t\t\tset.add(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn set;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {boolean} true, when it has dependent chunks\n\t */\n\thasChunkEntryDependentChunks(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const chunkGroup of cgc.entryModules.values()) {\n\t\t\tfor (const c of chunkGroup.chunks) {\n\t\t\t\tif (c !== chunk) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<RuntimeModule>} iterable of modules (do not modify)\n\t */\n\tgetChunkRuntimeModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.runtimeModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {RuntimeModule[]} array of modules in order of execution\n\t */\n\tgetChunkRuntimeModulesInOrder(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst array = Array.from(cgc.runtimeModules);\n\t\tarray.sort(\n\t\t\tconcatComparators(\n\t\t\t\tcompareSelect(\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {RuntimeModule} r runtime module\n\t\t\t\t\t * @returns {number=} stage\n\t\t\t\t\t */\n\t\t\t\t\tr => r.stage,\n\t\t\t\t\tcompareIds\n\t\t\t\t),\n\t\t\t\tcompareModulesByIdentifier\n\t\t\t)\n\t\t);\n\t\treturn array;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n\t */\n\tgetChunkFullHashModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.fullHashModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ReadonlySet<RuntimeModule> | undefined} set of modules (do not modify)\n\t */\n\tgetChunkFullHashModulesSet(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.fullHashModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n\t */\n\tgetChunkDependentHashModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.dependentHashModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<EntryModuleWithChunkGroup>} iterable of modules (do not modify)\n\t */\n\tgetChunkEntryModulesWithChunkGroupIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules;\n\t}\n\n\t/**\n\t * @param {AsyncDependenciesBlock} depBlock the async block\n\t * @returns {ChunkGroup} the chunk group\n\t */\n\tgetBlockChunkGroup(depBlock) {\n\t\treturn this._blockChunkGroups.get(depBlock);\n\t}\n\n\t/**\n\t * @param {AsyncDependenciesBlock} depBlock the async block\n\t * @param {ChunkGroup} chunkGroup the chunk group\n\t * @returns {void}\n\t */\n\tconnectBlockAndChunkGroup(depBlock, chunkGroup) {\n\t\tthis._blockChunkGroups.set(depBlock, chunkGroup);\n\t\tchunkGroup.addBlock(depBlock);\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunk group\n\t * @returns {void}\n\t */\n\tdisconnectChunkGroup(chunkGroup) {\n\t\tfor (const block of chunkGroup.blocksIterable) {\n\t\t\tthis._blockChunkGroups.delete(block);\n\t\t}\n\t\t// TODO refactor by moving blocks list into ChunkGraph\n\t\tchunkGroup._blocks.clear();\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {string | number} the id of the module\n\t */\n\tgetModuleId(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.id;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {string | number} id the id of the module\n\t * @returns {void}\n\t */\n\tsetModuleId(module, id) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tcgm.id = id;\n\t}\n\n\t/**\n\t * @param {string} runtime runtime\n\t * @returns {string | number} the id of the runtime\n\t */\n\tgetRuntimeId(runtime) {\n\t\treturn this._runtimeIds.get(runtime);\n\t}\n\n\t/**\n\t * @param {string} runtime runtime\n\t * @param {string | number} id the id of the runtime\n\t * @returns {void}\n\t */\n\tsetRuntimeId(runtime, id) {\n\t\tthis._runtimeIds.set(runtime, id);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {Module} module the module\n\t * @param {RuntimeSpecMap<T>} hashes hashes data\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {T} hash\n\t */\n\t_getModuleHashInfo(module, hashes, runtime) {\n\t\tif (!hashes) {\n\t\t\tthrow new Error(\n\t\t\t\t`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(\n\t\t\t\t\truntime\n\t\t\t\t)} (hashes not set at all)`\n\t\t\t);\n\t\t} else if (runtime === undefined) {\n\t\t\tconst hashInfoItems = new Set(hashes.values());\n\t\t\tif (hashInfoItems.size !== 1) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`No unique hash info entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(\n\t\t\t\t\t\thashes.keys(),\n\t\t\t\t\t\tr => runtimeToString(r)\n\t\t\t\t\t).join(\", \")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \"global\").`\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn first(hashInfoItems);\n\t\t} else {\n\t\t\tconst hashInfo = hashes.get(runtime);\n\t\t\tif (!hashInfo) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(\n\t\t\t\t\t\truntime\n\t\t\t\t\t)} (available runtimes ${Array.from(\n\t\t\t\t\t\thashes.keys(),\n\t\t\t\t\t\truntimeToString\n\t\t\t\t\t).join(\", \")})`\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn hashInfo;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {boolean} true, if the module has hashes for this runtime\n\t */\n\thasModuleHashes(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst hashes = cgm.hashes;\n\t\treturn hashes && hashes.has(runtime);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {string} hash\n\t */\n\tgetModuleHash(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst hashes = cgm.hashes;\n\t\treturn this._getModuleHashInfo(module, hashes, runtime).hash;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {string} hash\n\t */\n\tgetRenderedModuleHash(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst hashes = cgm.hashes;\n\t\treturn this._getModuleHashInfo(module, hashes, runtime).renderedHash;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {string} hash the full hash\n\t * @param {string} renderedHash the shortened hash for rendering\n\t * @returns {void}\n\t */\n\tsetModuleHashes(module, runtime, hash, renderedHash) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tif (cgm.hashes === undefined) {\n\t\t\tcgm.hashes = new RuntimeSpecMap();\n\t\t}\n\t\tcgm.hashes.set(runtime, new ModuleHashInfo(hash, renderedHash));\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph when transferOwnership not false)\n\t * @param {boolean} transferOwnership true: transfer ownership of the items object, false: items is immutable and shared and won't be modified\n\t * @returns {void}\n\t */\n\taddModuleRuntimeRequirements(\n\t\tmodule,\n\t\truntime,\n\t\titems,\n\t\ttransferOwnership = true\n\t) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst runtimeRequirementsMap = cgm.runtimeRequirements;\n\t\tif (runtimeRequirementsMap === undefined) {\n\t\t\tconst map = new RuntimeSpecMap();\n\t\t\t// TODO avoid cloning item and track ownership instead\n\t\t\tmap.set(runtime, transferOwnership ? items : new Set(items));\n\t\t\tcgm.runtimeRequirements = map;\n\t\t\treturn;\n\t\t}\n\t\truntimeRequirementsMap.update(runtime, runtimeRequirements => {\n\t\t\tif (runtimeRequirements === undefined) {\n\t\t\t\treturn transferOwnership ? items : new Set(items);\n\t\t\t} else if (!transferOwnership || runtimeRequirements.size >= items.size) {\n\t\t\t\tfor (const item of items) runtimeRequirements.add(item);\n\t\t\t\treturn runtimeRequirements;\n\t\t\t} else {\n\t\t\t\tfor (const item of runtimeRequirements) items.add(item);\n\t\t\t\treturn items;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph)\n\t * @returns {void}\n\t */\n\taddChunkRuntimeRequirements(chunk, items) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst runtimeRequirements = cgc.runtimeRequirements;\n\t\tif (runtimeRequirements === undefined) {\n\t\t\tcgc.runtimeRequirements = items;\n\t\t} else if (runtimeRequirements.size >= items.size) {\n\t\t\tfor (const item of items) runtimeRequirements.add(item);\n\t\t} else {\n\t\t\tfor (const item of runtimeRequirements) items.add(item);\n\t\t\tcgc.runtimeRequirements = items;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<string>} items runtime requirements to be added\n\t * @returns {void}\n\t */\n\taddTreeRuntimeRequirements(chunk, items) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst runtimeRequirements = cgc.runtimeRequirementsInTree;\n\t\tfor (const item of items) runtimeRequirements.add(item);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetModuleRuntimeRequirements(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst runtimeRequirements =\n\t\t\tcgm.runtimeRequirements && cgm.runtimeRequirements.get(runtime);\n\t\treturn runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetChunkRuntimeRequirements(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst runtimeRequirements = cgc.runtimeRequirements;\n\t\treturn runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {boolean} withConnections include connections\n\t * @returns {string} hash\n\t */\n\tgetModuleGraphHash(module, runtime, withConnections = true) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn withConnections\n\t\t\t? this._getModuleGraphHashWithConnections(cgm, module, runtime)\n\t\t\t: this._getModuleGraphHashBigInt(cgm, module, runtime).toString(16);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {boolean} withConnections include connections\n\t * @returns {bigint} hash\n\t */\n\tgetModuleGraphHashBigInt(module, runtime, withConnections = true) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn withConnections\n\t\t\t? BigInt(\n\t\t\t\t\t`0x${this._getModuleGraphHashWithConnections(cgm, module, runtime)}`\n\t\t\t  )\n\t\t\t: this._getModuleGraphHashBigInt(cgm, module, runtime);\n\t}\n\n\t/**\n\t * @param {ChunkGraphModule} cgm the ChunkGraphModule\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {bigint} hash as big int\n\t */\n\t_getModuleGraphHashBigInt(cgm, module, runtime) {\n\t\tif (cgm.graphHashes === undefined) {\n\t\t\tcgm.graphHashes = new RuntimeSpecMap();\n\t\t}\n\t\tconst graphHash = cgm.graphHashes.provide(runtime, () => {\n\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\thash.update(`${cgm.id}${this.moduleGraph.isAsync(module)}`);\n\t\t\tthis.moduleGraph.getExportsInfo(module).updateHash(hash, runtime);\n\t\t\treturn BigInt(`0x${/** @type {string} */ (hash.digest(\"hex\"))}`);\n\t\t});\n\t\treturn graphHash;\n\t}\n\n\t/**\n\t * @param {ChunkGraphModule} cgm the ChunkGraphModule\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {string} hash\n\t */\n\t_getModuleGraphHashWithConnections(cgm, module, runtime) {\n\t\tif (cgm.graphHashesWithConnections === undefined) {\n\t\t\tcgm.graphHashesWithConnections = new RuntimeSpecMap();\n\t\t}\n\t\tconst activeStateToString = state => {\n\t\t\tif (state === false) return \"F\";\n\t\t\tif (state === true) return \"T\";\n\t\t\tif (state === ModuleGraphConnection.TRANSITIVE_ONLY) return \"O\";\n\t\t\tthrow new Error(\"Not implemented active state\");\n\t\t};\n\t\tconst strict = module.buildMeta && module.buildMeta.strictHarmonyModule;\n\t\treturn cgm.graphHashesWithConnections.provide(runtime, () => {\n\t\t\tconst graphHash = this._getModuleGraphHashBigInt(\n\t\t\t\tcgm,\n\t\t\t\tmodule,\n\t\t\t\truntime\n\t\t\t).toString(16);\n\t\t\tconst connections = this.moduleGraph.getOutgoingConnections(module);\n\t\t\t/** @type {Set<Module>} */\n\t\t\tconst activeNamespaceModules = new Set();\n\t\t\t/** @type {Map<string, Module | Set<Module>>} */\n\t\t\tconst connectedModules = new Map();\n\t\t\tconst processConnection = (connection, stateInfo) => {\n\t\t\t\tconst module = connection.module;\n\t\t\t\tstateInfo += module.getExportsType(this.moduleGraph, strict);\n\t\t\t\t// cspell:word Tnamespace\n\t\t\t\tif (stateInfo === \"Tnamespace\") activeNamespaceModules.add(module);\n\t\t\t\telse {\n\t\t\t\t\tconst oldModule = connectedModules.get(stateInfo);\n\t\t\t\t\tif (oldModule === undefined) {\n\t\t\t\t\t\tconnectedModules.set(stateInfo, module);\n\t\t\t\t\t} else if (oldModule instanceof Set) {\n\t\t\t\t\t\toldModule.add(module);\n\t\t\t\t\t} else if (oldModule !== module) {\n\t\t\t\t\t\tconnectedModules.set(stateInfo, new Set([oldModule, module]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (runtime === undefined || typeof runtime === \"string\") {\n\t\t\t\tfor (const connection of connections) {\n\t\t\t\t\tconst state = connection.getActiveState(runtime);\n\t\t\t\t\tif (state === false) continue;\n\t\t\t\t\tprocessConnection(connection, state === true ? \"T\" : \"O\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// cspell:word Tnamespace\n\t\t\t\tfor (const connection of connections) {\n\t\t\t\t\tconst states = new Set();\n\t\t\t\t\tlet stateInfo = \"\";\n\t\t\t\t\tforEachRuntime(\n\t\t\t\t\t\truntime,\n\t\t\t\t\t\truntime => {\n\t\t\t\t\t\t\tconst state = connection.getActiveState(runtime);\n\t\t\t\t\t\t\tstates.add(state);\n\t\t\t\t\t\t\tstateInfo += activeStateToString(state) + runtime;\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttrue\n\t\t\t\t\t);\n\t\t\t\t\tif (states.size === 1) {\n\t\t\t\t\t\tconst state = first(states);\n\t\t\t\t\t\tif (state === false) continue;\n\t\t\t\t\t\tstateInfo = activeStateToString(state);\n\t\t\t\t\t}\n\t\t\t\t\tprocessConnection(connection, stateInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// cspell:word Tnamespace\n\t\t\tif (activeNamespaceModules.size === 0 && connectedModules.size === 0)\n\t\t\t\treturn graphHash;\n\t\t\tconst connectedModulesInOrder =\n\t\t\t\tconnectedModules.size > 1\n\t\t\t\t\t? Array.from(connectedModules).sort(([a], [b]) => (a < b ? -1 : 1))\n\t\t\t\t\t: connectedModules;\n\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\tconst addModuleToHash = module => {\n\t\t\t\thash.update(\n\t\t\t\t\tthis._getModuleGraphHashBigInt(\n\t\t\t\t\t\tthis._getChunkGraphModule(module),\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\truntime\n\t\t\t\t\t).toString(16)\n\t\t\t\t);\n\t\t\t};\n\t\t\tconst addModulesToHash = modules => {\n\t\t\t\tlet xor = ZERO_BIG_INT;\n\t\t\t\tfor (const m of modules) {\n\t\t\t\t\txor =\n\t\t\t\t\t\txor ^\n\t\t\t\t\t\tthis._getModuleGraphHashBigInt(\n\t\t\t\t\t\t\tthis._getChunkGraphModule(m),\n\t\t\t\t\t\t\tm,\n\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\thash.update(xor.toString(16));\n\t\t\t};\n\t\t\tif (activeNamespaceModules.size === 1)\n\t\t\t\taddModuleToHash(activeNamespaceModules.values().next().value);\n\t\t\telse if (activeNamespaceModules.size > 1)\n\t\t\t\taddModulesToHash(activeNamespaceModules);\n\t\t\tfor (const [stateInfo, modules] of connectedModulesInOrder) {\n\t\t\t\thash.update(stateInfo);\n\t\t\t\tif (modules instanceof Set) {\n\t\t\t\t\taddModulesToHash(modules);\n\t\t\t\t} else {\n\t\t\t\t\taddModuleToHash(modules);\n\t\t\t\t}\n\t\t\t}\n\t\t\thash.update(graphHash);\n\t\t\treturn /** @type {string} */ (hash.digest(\"hex\"));\n\t\t});\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetTreeRuntimeRequirements(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.runtimeRequirementsInTree;\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Module} module the module\n\t * @param {string} deprecateMessage message for the deprecation message\n\t * @param {string} deprecationCode code for the deprecation\n\t * @returns {ChunkGraph} the chunk graph\n\t */\n\tstatic getChunkGraphForModule(module, deprecateMessage, deprecationCode) {\n\t\tconst fn = deprecateGetChunkGraphForModuleMap.get(deprecateMessage);\n\t\tif (fn) return fn(module);\n\t\tconst newFn = util.deprecate(\n\t\t\t/**\n\t\t\t * @param {Module} module the module\n\t\t\t * @returns {ChunkGraph} the chunk graph\n\t\t\t */\n\t\t\tmodule => {\n\t\t\t\tconst chunkGraph = chunkGraphForModuleMap.get(module);\n\t\t\t\tif (!chunkGraph)\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\tdeprecateMessage +\n\t\t\t\t\t\t\t\": There was no ChunkGraph assigned to the Module for backward-compat (Use the new API)\"\n\t\t\t\t\t);\n\t\t\t\treturn chunkGraph;\n\t\t\t},\n\t\t\tdeprecateMessage + \": Use new ChunkGraph API\",\n\t\t\tdeprecationCode\n\t\t);\n\t\tdeprecateGetChunkGraphForModuleMap.set(deprecateMessage, newFn);\n\t\treturn newFn(module);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Module} module the module\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @returns {void}\n\t */\n\tstatic setChunkGraphForModule(module, chunkGraph) {\n\t\tchunkGraphForModuleMap.set(module, chunkGraph);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tstatic clearChunkGraphForModule(module) {\n\t\tchunkGraphForModuleMap.delete(module);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {string} deprecateMessage message for the deprecation message\n\t * @param {string} deprecationCode code for the deprecation\n\t * @returns {ChunkGraph} the chunk graph\n\t */\n\tstatic getChunkGraphForChunk(chunk, deprecateMessage, deprecationCode) {\n\t\tconst fn = deprecateGetChunkGraphForChunkMap.get(deprecateMessage);\n\t\tif (fn) return fn(chunk);\n\t\tconst newFn = util.deprecate(\n\t\t\t/**\n\t\t\t * @param {Chunk} chunk the chunk\n\t\t\t * @returns {ChunkGraph} the chunk graph\n\t\t\t */\n\t\t\tchunk => {\n\t\t\t\tconst chunkGraph = chunkGraphForChunkMap.get(chunk);\n\t\t\t\tif (!chunkGraph)\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\tdeprecateMessage +\n\t\t\t\t\t\t\t\"There was no ChunkGraph assigned to the Chunk for backward-compat (Use the new API)\"\n\t\t\t\t\t);\n\t\t\t\treturn chunkGraph;\n\t\t\t},\n\t\t\tdeprecateMessage + \": Use new ChunkGraph API\",\n\t\t\tdeprecationCode\n\t\t);\n\t\tdeprecateGetChunkGraphForChunkMap.set(deprecateMessage, newFn);\n\t\treturn newFn(chunk);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @returns {void}\n\t */\n\tstatic setChunkGraphForChunk(chunk, chunkGraph) {\n\t\tchunkGraphForChunkMap.set(chunk, chunkGraph);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {void}\n\t */\n\tstatic clearChunkGraphForChunk(chunk) {\n\t\tchunkGraphForChunkMap.delete(chunk);\n\t}\n}\n\n// TODO remove in webpack 6\n/** @type {WeakMap<Module, ChunkGraph>} */\nconst chunkGraphForModuleMap = new WeakMap();\n\n// TODO remove in webpack 6\n/** @type {WeakMap<Chunk, ChunkGraph>} */\nconst chunkGraphForChunkMap = new WeakMap();\n\n// TODO remove in webpack 6\n/** @type {Map<string, (module: Module) => ChunkGraph>} */\nconst deprecateGetChunkGraphForModuleMap = new Map();\n\n// TODO remove in webpack 6\n/** @type {Map<string, (chunk: Chunk) => ChunkGraph>} */\nconst deprecateGetChunkGraphForChunkMap = new Map();\n\nmodule.exports = ChunkGraph;\n"]},"metadata":{},"sourceType":"script"}