{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst InitFragment = require(\"../InitFragment\");\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\n\nconst {\n  first\n} = require(\"../util/SetHelpers\");\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../Generator\").GenerateContext} GenerateContext */\n\n\nconst joinIterableWithComma = iterable => {\n  // This is more performant than Array.from().join(\", \")\n  // as it doesn't create an array\n  let str = \"\";\n  let first = true;\n\n  for (const item of iterable) {\n    if (first) {\n      first = false;\n    } else {\n      str += \", \";\n    }\n\n    str += item;\n  }\n\n  return str;\n};\n\nconst EMPTY_MAP = new Map();\nconst EMPTY_SET = new Set();\n/**\n * @typedef {GenerateContext} Context\n */\n\nclass HarmonyExportInitFragment extends InitFragment {\n  /**\n   * @param {string} exportsArgument the exports identifier\n   * @param {Map<string, string>} exportMap mapping from used name to exposed variable name\n   * @param {Set<string>} unusedExports list of unused export names\n   */\n  constructor(exportsArgument) {\n    let exportMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EMPTY_MAP;\n    let unusedExports = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_SET;\n    super(undefined, InitFragment.STAGE_HARMONY_EXPORTS, 1, \"harmony-exports\");\n    this.exportsArgument = exportsArgument;\n    this.exportMap = exportMap;\n    this.unusedExports = unusedExports;\n  }\n  /**\n   * @param {HarmonyExportInitFragment[]} fragments all fragments to merge\n   * @returns {HarmonyExportInitFragment} merged fragment\n   */\n\n\n  mergeAll(fragments) {\n    let exportMap;\n    let exportMapOwned = false;\n    let unusedExports;\n    let unusedExportsOwned = false;\n\n    for (const fragment of fragments) {\n      if (fragment.exportMap.size !== 0) {\n        if (exportMap === undefined) {\n          exportMap = fragment.exportMap;\n          exportMapOwned = false;\n        } else {\n          if (!exportMapOwned) {\n            exportMap = new Map(exportMap);\n            exportMapOwned = true;\n          }\n\n          for (const [key, value] of fragment.exportMap) {\n            if (!exportMap.has(key)) exportMap.set(key, value);\n          }\n        }\n      }\n\n      if (fragment.unusedExports.size !== 0) {\n        if (unusedExports === undefined) {\n          unusedExports = fragment.unusedExports;\n          unusedExportsOwned = false;\n        } else {\n          if (!unusedExportsOwned) {\n            unusedExports = new Set(unusedExports);\n            unusedExportsOwned = true;\n          }\n\n          for (const value of fragment.unusedExports) {\n            unusedExports.add(value);\n          }\n        }\n      }\n    }\n\n    return new HarmonyExportInitFragment(this.exportsArgument, exportMap, unusedExports);\n  }\n\n  merge(other) {\n    let exportMap;\n\n    if (this.exportMap.size === 0) {\n      exportMap = other.exportMap;\n    } else if (other.exportMap.size === 0) {\n      exportMap = this.exportMap;\n    } else {\n      exportMap = new Map(other.exportMap);\n\n      for (const [key, value] of this.exportMap) {\n        if (!exportMap.has(key)) exportMap.set(key, value);\n      }\n    }\n\n    let unusedExports;\n\n    if (this.unusedExports.size === 0) {\n      unusedExports = other.unusedExports;\n    } else if (other.unusedExports.size === 0) {\n      unusedExports = this.unusedExports;\n    } else {\n      unusedExports = new Set(other.unusedExports);\n\n      for (const value of this.unusedExports) {\n        unusedExports.add(value);\n      }\n    }\n\n    return new HarmonyExportInitFragment(this.exportsArgument, exportMap, unusedExports);\n  }\n  /**\n   * @param {Context} context context\n   * @returns {string|Source} the source code that will be included as initialization code\n   */\n\n\n  getContent(_ref) {\n    let {\n      runtimeTemplate,\n      runtimeRequirements\n    } = _ref;\n    runtimeRequirements.add(RuntimeGlobals.exports);\n    runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);\n    const unusedPart = this.unusedExports.size > 1 ? `/* unused harmony exports ${joinIterableWithComma(this.unusedExports)} */\\n` : this.unusedExports.size > 0 ? `/* unused harmony export ${first(this.unusedExports)} */\\n` : \"\";\n    const definitions = [];\n    const orderedExportMap = Array.from(this.exportMap).sort((_ref2, _ref3) => {\n      let [a] = _ref2;\n      let [b] = _ref3;\n      return a < b ? -1 : 1;\n    });\n\n    for (const [key, value] of orderedExportMap) {\n      definitions.push(`\\n/* harmony export */   ${JSON.stringify(key)}: ${runtimeTemplate.returningFunction(value)}`);\n    }\n\n    const definePart = this.exportMap.size > 0 ? `/* harmony export */ ${RuntimeGlobals.definePropertyGetters}(${this.exportsArgument}, {${definitions.join(\",\")}\\n/* harmony export */ });\\n` : \"\";\n    return `${definePart}${unusedPart}`;\n  }\n\n}\n\nmodule.exports = HarmonyExportInitFragment;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/dependencies/HarmonyExportInitFragment.js"],"names":["InitFragment","require","RuntimeGlobals","first","joinIterableWithComma","iterable","str","item","EMPTY_MAP","Map","EMPTY_SET","Set","HarmonyExportInitFragment","constructor","exportsArgument","exportMap","unusedExports","undefined","STAGE_HARMONY_EXPORTS","mergeAll","fragments","exportMapOwned","unusedExportsOwned","fragment","size","key","value","has","set","add","merge","other","getContent","runtimeTemplate","runtimeRequirements","exports","definePropertyGetters","unusedPart","definitions","orderedExportMap","Array","from","sort","a","b","push","JSON","stringify","returningFunction","definePart","join","module"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst InitFragment = require(\"../InitFragment\");\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst { first } = require(\"../util/SetHelpers\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Generator\").GenerateContext} GenerateContext */\n\nconst joinIterableWithComma = iterable => {\n\t// This is more performant than Array.from().join(\", \")\n\t// as it doesn't create an array\n\tlet str = \"\";\n\tlet first = true;\n\tfor (const item of iterable) {\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t} else {\n\t\t\tstr += \", \";\n\t\t}\n\t\tstr += item;\n\t}\n\treturn str;\n};\n\nconst EMPTY_MAP = new Map();\nconst EMPTY_SET = new Set();\n\n/**\n * @typedef {GenerateContext} Context\n */\nclass HarmonyExportInitFragment extends InitFragment {\n\t/**\n\t * @param {string} exportsArgument the exports identifier\n\t * @param {Map<string, string>} exportMap mapping from used name to exposed variable name\n\t * @param {Set<string>} unusedExports list of unused export names\n\t */\n\tconstructor(\n\t\texportsArgument,\n\t\texportMap = EMPTY_MAP,\n\t\tunusedExports = EMPTY_SET\n\t) {\n\t\tsuper(undefined, InitFragment.STAGE_HARMONY_EXPORTS, 1, \"harmony-exports\");\n\t\tthis.exportsArgument = exportsArgument;\n\t\tthis.exportMap = exportMap;\n\t\tthis.unusedExports = unusedExports;\n\t}\n\n\t/**\n\t * @param {HarmonyExportInitFragment[]} fragments all fragments to merge\n\t * @returns {HarmonyExportInitFragment} merged fragment\n\t */\n\tmergeAll(fragments) {\n\t\tlet exportMap;\n\t\tlet exportMapOwned = false;\n\t\tlet unusedExports;\n\t\tlet unusedExportsOwned = false;\n\n\t\tfor (const fragment of fragments) {\n\t\t\tif (fragment.exportMap.size !== 0) {\n\t\t\t\tif (exportMap === undefined) {\n\t\t\t\t\texportMap = fragment.exportMap;\n\t\t\t\t\texportMapOwned = false;\n\t\t\t\t} else {\n\t\t\t\t\tif (!exportMapOwned) {\n\t\t\t\t\t\texportMap = new Map(exportMap);\n\t\t\t\t\t\texportMapOwned = true;\n\t\t\t\t\t}\n\t\t\t\t\tfor (const [key, value] of fragment.exportMap) {\n\t\t\t\t\t\tif (!exportMap.has(key)) exportMap.set(key, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fragment.unusedExports.size !== 0) {\n\t\t\t\tif (unusedExports === undefined) {\n\t\t\t\t\tunusedExports = fragment.unusedExports;\n\t\t\t\t\tunusedExportsOwned = false;\n\t\t\t\t} else {\n\t\t\t\t\tif (!unusedExportsOwned) {\n\t\t\t\t\t\tunusedExports = new Set(unusedExports);\n\t\t\t\t\t\tunusedExportsOwned = true;\n\t\t\t\t\t}\n\t\t\t\t\tfor (const value of fragment.unusedExports) {\n\t\t\t\t\t\tunusedExports.add(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new HarmonyExportInitFragment(\n\t\t\tthis.exportsArgument,\n\t\t\texportMap,\n\t\t\tunusedExports\n\t\t);\n\t}\n\n\tmerge(other) {\n\t\tlet exportMap;\n\t\tif (this.exportMap.size === 0) {\n\t\t\texportMap = other.exportMap;\n\t\t} else if (other.exportMap.size === 0) {\n\t\t\texportMap = this.exportMap;\n\t\t} else {\n\t\t\texportMap = new Map(other.exportMap);\n\t\t\tfor (const [key, value] of this.exportMap) {\n\t\t\t\tif (!exportMap.has(key)) exportMap.set(key, value);\n\t\t\t}\n\t\t}\n\t\tlet unusedExports;\n\t\tif (this.unusedExports.size === 0) {\n\t\t\tunusedExports = other.unusedExports;\n\t\t} else if (other.unusedExports.size === 0) {\n\t\t\tunusedExports = this.unusedExports;\n\t\t} else {\n\t\t\tunusedExports = new Set(other.unusedExports);\n\t\t\tfor (const value of this.unusedExports) {\n\t\t\t\tunusedExports.add(value);\n\t\t\t}\n\t\t}\n\t\treturn new HarmonyExportInitFragment(\n\t\t\tthis.exportsArgument,\n\t\t\texportMap,\n\t\t\tunusedExports\n\t\t);\n\t}\n\n\t/**\n\t * @param {Context} context context\n\t * @returns {string|Source} the source code that will be included as initialization code\n\t */\n\tgetContent({ runtimeTemplate, runtimeRequirements }) {\n\t\truntimeRequirements.add(RuntimeGlobals.exports);\n\t\truntimeRequirements.add(RuntimeGlobals.definePropertyGetters);\n\n\t\tconst unusedPart =\n\t\t\tthis.unusedExports.size > 1\n\t\t\t\t? `/* unused harmony exports ${joinIterableWithComma(\n\t\t\t\t\t\tthis.unusedExports\n\t\t\t\t  )} */\\n`\n\t\t\t\t: this.unusedExports.size > 0\n\t\t\t\t? `/* unused harmony export ${first(this.unusedExports)} */\\n`\n\t\t\t\t: \"\";\n\t\tconst definitions = [];\n\t\tconst orderedExportMap = Array.from(this.exportMap).sort(([a], [b]) =>\n\t\t\ta < b ? -1 : 1\n\t\t);\n\t\tfor (const [key, value] of orderedExportMap) {\n\t\t\tdefinitions.push(\n\t\t\t\t`\\n/* harmony export */   ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)}: ${runtimeTemplate.returningFunction(value)}`\n\t\t\t);\n\t\t}\n\t\tconst definePart =\n\t\t\tthis.exportMap.size > 0\n\t\t\t\t? `/* harmony export */ ${RuntimeGlobals.definePropertyGetters}(${\n\t\t\t\t\t\tthis.exportsArgument\n\t\t\t\t  }, {${definitions.join(\",\")}\\n/* harmony export */ });\\n`\n\t\t\t\t: \"\";\n\t\treturn `${definePart}${unusedPart}`;\n\t}\n}\n\nmodule.exports = HarmonyExportInitFragment;\n"]},"metadata":{},"sourceType":"script"}