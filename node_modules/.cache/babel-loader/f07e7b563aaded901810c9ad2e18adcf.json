{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  STAGE_ADVANCED\n} = require(\"../OptimizationStages\");\n\nconst LazyBucketSortedSet = require(\"../util/LazyBucketSortedSet\");\n\nconst {\n  compareChunks\n} = require(\"../util/comparators\");\n\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\n/** @typedef {import(\"../../declarations/plugins/optimize/LimitChunkCountPlugin\").LimitChunkCountPluginOptions} LimitChunkCountPluginOptions */\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n\nconst validate = createSchemaValidation(require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.check.js\"), () => require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.json\"), {\n  name: \"Limit Chunk Count Plugin\",\n  baseDataPath: \"options\"\n});\n/**\n * @typedef {Object} ChunkCombination\n * @property {boolean} deleted this is set to true when combination was removed\n * @property {number} sizeDiff\n * @property {number} integratedSize\n * @property {Chunk} a\n * @property {Chunk} b\n * @property {number} aIdx\n * @property {number} bIdx\n * @property {number} aSize\n * @property {number} bSize\n */\n\nconst addToSetMap = (map, key, value) => {\n  const set = map.get(key);\n\n  if (set === undefined) {\n    map.set(key, new Set([value]));\n  } else {\n    set.add(value);\n  }\n};\n\nclass LimitChunkCountPlugin {\n  /**\n   * @param {LimitChunkCountPluginOptions=} options options object\n   */\n  constructor(options) {\n    validate(options);\n    this.options = options;\n  }\n  /**\n   * @param {Compiler} compiler the webpack compiler\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const options = this.options;\n    compiler.hooks.compilation.tap(\"LimitChunkCountPlugin\", compilation => {\n      compilation.hooks.optimizeChunks.tap({\n        name: \"LimitChunkCountPlugin\",\n        stage: STAGE_ADVANCED\n      }, chunks => {\n        const chunkGraph = compilation.chunkGraph;\n        const maxChunks = options.maxChunks;\n        if (!maxChunks) return;\n        if (maxChunks < 1) return;\n        if (compilation.chunks.size <= maxChunks) return;\n        let remainingChunksToMerge = compilation.chunks.size - maxChunks; // order chunks in a deterministic way\n\n        const compareChunksWithGraph = compareChunks(chunkGraph);\n        const orderedChunks = Array.from(chunks).sort(compareChunksWithGraph); // create a lazy sorted data structure to keep all combinations\n        // this is large. Size = chunks * (chunks - 1) / 2\n        // It uses a multi layer bucket sort plus normal sort in the last layer\n        // It's also lazy so only accessed buckets are sorted\n\n        const combinations = new LazyBucketSortedSet( // Layer 1: ordered by largest size benefit\n        c => c.sizeDiff, (a, b) => b - a, // Layer 2: ordered by smallest combined size\n        c => c.integratedSize, (a, b) => a - b, // Layer 3: ordered by position difference in orderedChunk (-> to be deterministic)\n        c => c.bIdx - c.aIdx, (a, b) => a - b, // Layer 4: ordered by position in orderedChunk (-> to be deterministic)\n        (a, b) => a.bIdx - b.bIdx); // we keep a mapping from chunk to all combinations\n        // but this mapping is not kept up-to-date with deletions\n        // so `deleted` flag need to be considered when iterating this\n\n        /** @type {Map<Chunk, Set<ChunkCombination>>} */\n\n        const combinationsByChunk = new Map();\n        orderedChunks.forEach((b, bIdx) => {\n          // create combination pairs with size and integrated size\n          for (let aIdx = 0; aIdx < bIdx; aIdx++) {\n            const a = orderedChunks[aIdx]; // filter pairs that can not be integrated!\n\n            if (!chunkGraph.canChunksBeIntegrated(a, b)) continue;\n            const integratedSize = chunkGraph.getIntegratedChunksSize(a, b, options);\n            const aSize = chunkGraph.getChunkSize(a, options);\n            const bSize = chunkGraph.getChunkSize(b, options);\n            const c = {\n              deleted: false,\n              sizeDiff: aSize + bSize - integratedSize,\n              integratedSize,\n              a,\n              b,\n              aIdx,\n              bIdx,\n              aSize,\n              bSize\n            };\n            combinations.add(c);\n            addToSetMap(combinationsByChunk, a, c);\n            addToSetMap(combinationsByChunk, b, c);\n          }\n\n          return combinations;\n        }); // list of modified chunks during this run\n        // combinations affected by this change are skipped to allow\n        // further optimizations\n\n        /** @type {Set<Chunk>} */\n\n        const modifiedChunks = new Set();\n        let changed = false; // eslint-disable-next-line no-constant-condition\n\n        loop: while (true) {\n          const combination = combinations.popFirst();\n          if (combination === undefined) break;\n          combination.deleted = true;\n          const {\n            a,\n            b,\n            integratedSize\n          } = combination; // skip over pair when\n          // one of the already merged chunks is a parent of one of the chunks\n\n          if (modifiedChunks.size > 0) {\n            const queue = new Set(a.groupsIterable);\n\n            for (const group of b.groupsIterable) {\n              queue.add(group);\n            }\n\n            for (const group of queue) {\n              for (const mChunk of modifiedChunks) {\n                if (mChunk !== a && mChunk !== b && mChunk.isInGroup(group)) {\n                  // This is a potential pair which needs recalculation\n                  // We can't do that now, but it merge before following pairs\n                  // so we leave space for it, and consider chunks as modified\n                  // just for the worse case\n                  remainingChunksToMerge--;\n                  if (remainingChunksToMerge <= 0) break loop;\n                  modifiedChunks.add(a);\n                  modifiedChunks.add(b);\n                  continue loop;\n                }\n              }\n\n              for (const parent of group.parentsIterable) {\n                queue.add(parent);\n              }\n            }\n          } // merge the chunks\n\n\n          if (chunkGraph.canChunksBeIntegrated(a, b)) {\n            chunkGraph.integrateChunks(a, b);\n            compilation.chunks.delete(b); // flag chunk a as modified as further optimization are possible for all children here\n\n            modifiedChunks.add(a);\n            changed = true;\n            remainingChunksToMerge--;\n            if (remainingChunksToMerge <= 0) break; // Update all affected combinations\n            // delete all combination with the removed chunk\n            // we will use combinations with the kept chunk instead\n\n            for (const combination of combinationsByChunk.get(a)) {\n              if (combination.deleted) continue;\n              combination.deleted = true;\n              combinations.delete(combination);\n            } // Update combinations with the kept chunk with new sizes\n\n\n            for (const combination of combinationsByChunk.get(b)) {\n              if (combination.deleted) continue;\n\n              if (combination.a === b) {\n                if (!chunkGraph.canChunksBeIntegrated(a, combination.b)) {\n                  combination.deleted = true;\n                  combinations.delete(combination);\n                  continue;\n                } // Update size\n\n\n                const newIntegratedSize = chunkGraph.getIntegratedChunksSize(a, combination.b, options);\n                const finishUpdate = combinations.startUpdate(combination);\n                combination.a = a;\n                combination.integratedSize = newIntegratedSize;\n                combination.aSize = integratedSize;\n                combination.sizeDiff = combination.bSize + integratedSize - newIntegratedSize;\n                finishUpdate();\n              } else if (combination.b === b) {\n                if (!chunkGraph.canChunksBeIntegrated(combination.a, a)) {\n                  combination.deleted = true;\n                  combinations.delete(combination);\n                  continue;\n                } // Update size\n\n\n                const newIntegratedSize = chunkGraph.getIntegratedChunksSize(combination.a, a, options);\n                const finishUpdate = combinations.startUpdate(combination);\n                combination.b = a;\n                combination.integratedSize = newIntegratedSize;\n                combination.bSize = integratedSize;\n                combination.sizeDiff = integratedSize + combination.aSize - newIntegratedSize;\n                finishUpdate();\n              }\n            }\n\n            combinationsByChunk.set(a, combinationsByChunk.get(b));\n            combinationsByChunk.delete(b);\n          }\n        }\n\n        if (changed) return true;\n      });\n    });\n  }\n\n}\n\nmodule.exports = LimitChunkCountPlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/optimize/LimitChunkCountPlugin.js"],"names":["STAGE_ADVANCED","require","LazyBucketSortedSet","compareChunks","createSchemaValidation","validate","name","baseDataPath","addToSetMap","map","key","value","set","get","undefined","Set","add","LimitChunkCountPlugin","constructor","options","apply","compiler","hooks","compilation","tap","optimizeChunks","stage","chunks","chunkGraph","maxChunks","size","remainingChunksToMerge","compareChunksWithGraph","orderedChunks","Array","from","sort","combinations","c","sizeDiff","a","b","integratedSize","bIdx","aIdx","combinationsByChunk","Map","forEach","canChunksBeIntegrated","getIntegratedChunksSize","aSize","getChunkSize","bSize","deleted","modifiedChunks","changed","loop","combination","popFirst","queue","groupsIterable","group","mChunk","isInGroup","parent","parentsIterable","integrateChunks","delete","newIntegratedSize","finishUpdate","startUpdate","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { STAGE_ADVANCED } = require(\"../OptimizationStages\");\nconst LazyBucketSortedSet = require(\"../util/LazyBucketSortedSet\");\nconst { compareChunks } = require(\"../util/comparators\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/LimitChunkCountPlugin\").LimitChunkCountPluginOptions} LimitChunkCountPluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.check.js\"),\n\t() => require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.json\"),\n\t{\n\t\tname: \"Limit Chunk Count Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\n/**\n * @typedef {Object} ChunkCombination\n * @property {boolean} deleted this is set to true when combination was removed\n * @property {number} sizeDiff\n * @property {number} integratedSize\n * @property {Chunk} a\n * @property {Chunk} b\n * @property {number} aIdx\n * @property {number} bIdx\n * @property {number} aSize\n * @property {number} bSize\n */\n\nconst addToSetMap = (map, key, value) => {\n\tconst set = map.get(key);\n\tif (set === undefined) {\n\t\tmap.set(key, new Set([value]));\n\t} else {\n\t\tset.add(value);\n\t}\n};\n\nclass LimitChunkCountPlugin {\n\t/**\n\t * @param {LimitChunkCountPluginOptions=} options options object\n\t */\n\tconstructor(options) {\n\t\tvalidate(options);\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * @param {Compiler} compiler the webpack compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst options = this.options;\n\t\tcompiler.hooks.compilation.tap(\"LimitChunkCountPlugin\", compilation => {\n\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t{\n\t\t\t\t\tname: \"LimitChunkCountPlugin\",\n\t\t\t\t\tstage: STAGE_ADVANCED\n\t\t\t\t},\n\t\t\t\tchunks => {\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\tconst maxChunks = options.maxChunks;\n\t\t\t\t\tif (!maxChunks) return;\n\t\t\t\t\tif (maxChunks < 1) return;\n\t\t\t\t\tif (compilation.chunks.size <= maxChunks) return;\n\n\t\t\t\t\tlet remainingChunksToMerge = compilation.chunks.size - maxChunks;\n\n\t\t\t\t\t// order chunks in a deterministic way\n\t\t\t\t\tconst compareChunksWithGraph = compareChunks(chunkGraph);\n\t\t\t\t\tconst orderedChunks = Array.from(chunks).sort(compareChunksWithGraph);\n\n\t\t\t\t\t// create a lazy sorted data structure to keep all combinations\n\t\t\t\t\t// this is large. Size = chunks * (chunks - 1) / 2\n\t\t\t\t\t// It uses a multi layer bucket sort plus normal sort in the last layer\n\t\t\t\t\t// It's also lazy so only accessed buckets are sorted\n\t\t\t\t\tconst combinations = new LazyBucketSortedSet(\n\t\t\t\t\t\t// Layer 1: ordered by largest size benefit\n\t\t\t\t\t\tc => c.sizeDiff,\n\t\t\t\t\t\t(a, b) => b - a,\n\t\t\t\t\t\t// Layer 2: ordered by smallest combined size\n\t\t\t\t\t\tc => c.integratedSize,\n\t\t\t\t\t\t(a, b) => a - b,\n\t\t\t\t\t\t// Layer 3: ordered by position difference in orderedChunk (-> to be deterministic)\n\t\t\t\t\t\tc => c.bIdx - c.aIdx,\n\t\t\t\t\t\t(a, b) => a - b,\n\t\t\t\t\t\t// Layer 4: ordered by position in orderedChunk (-> to be deterministic)\n\t\t\t\t\t\t(a, b) => a.bIdx - b.bIdx\n\t\t\t\t\t);\n\n\t\t\t\t\t// we keep a mapping from chunk to all combinations\n\t\t\t\t\t// but this mapping is not kept up-to-date with deletions\n\t\t\t\t\t// so `deleted` flag need to be considered when iterating this\n\t\t\t\t\t/** @type {Map<Chunk, Set<ChunkCombination>>} */\n\t\t\t\t\tconst combinationsByChunk = new Map();\n\n\t\t\t\t\torderedChunks.forEach((b, bIdx) => {\n\t\t\t\t\t\t// create combination pairs with size and integrated size\n\t\t\t\t\t\tfor (let aIdx = 0; aIdx < bIdx; aIdx++) {\n\t\t\t\t\t\t\tconst a = orderedChunks[aIdx];\n\t\t\t\t\t\t\t// filter pairs that can not be integrated!\n\t\t\t\t\t\t\tif (!chunkGraph.canChunksBeIntegrated(a, b)) continue;\n\n\t\t\t\t\t\t\tconst integratedSize = chunkGraph.getIntegratedChunksSize(\n\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\tb,\n\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tconst aSize = chunkGraph.getChunkSize(a, options);\n\t\t\t\t\t\t\tconst bSize = chunkGraph.getChunkSize(b, options);\n\t\t\t\t\t\t\tconst c = {\n\t\t\t\t\t\t\t\tdeleted: false,\n\t\t\t\t\t\t\t\tsizeDiff: aSize + bSize - integratedSize,\n\t\t\t\t\t\t\t\tintegratedSize,\n\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\tb,\n\t\t\t\t\t\t\t\taIdx,\n\t\t\t\t\t\t\t\tbIdx,\n\t\t\t\t\t\t\t\taSize,\n\t\t\t\t\t\t\t\tbSize\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcombinations.add(c);\n\t\t\t\t\t\t\taddToSetMap(combinationsByChunk, a, c);\n\t\t\t\t\t\t\taddToSetMap(combinationsByChunk, b, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn combinations;\n\t\t\t\t\t});\n\n\t\t\t\t\t// list of modified chunks during this run\n\t\t\t\t\t// combinations affected by this change are skipped to allow\n\t\t\t\t\t// further optimizations\n\t\t\t\t\t/** @type {Set<Chunk>} */\n\t\t\t\t\tconst modifiedChunks = new Set();\n\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\t// eslint-disable-next-line no-constant-condition\n\t\t\t\t\tloop: while (true) {\n\t\t\t\t\t\tconst combination = combinations.popFirst();\n\t\t\t\t\t\tif (combination === undefined) break;\n\n\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\tconst { a, b, integratedSize } = combination;\n\n\t\t\t\t\t\t// skip over pair when\n\t\t\t\t\t\t// one of the already merged chunks is a parent of one of the chunks\n\t\t\t\t\t\tif (modifiedChunks.size > 0) {\n\t\t\t\t\t\t\tconst queue = new Set(a.groupsIterable);\n\t\t\t\t\t\t\tfor (const group of b.groupsIterable) {\n\t\t\t\t\t\t\t\tqueue.add(group);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const group of queue) {\n\t\t\t\t\t\t\t\tfor (const mChunk of modifiedChunks) {\n\t\t\t\t\t\t\t\t\tif (mChunk !== a && mChunk !== b && mChunk.isInGroup(group)) {\n\t\t\t\t\t\t\t\t\t\t// This is a potential pair which needs recalculation\n\t\t\t\t\t\t\t\t\t\t// We can't do that now, but it merge before following pairs\n\t\t\t\t\t\t\t\t\t\t// so we leave space for it, and consider chunks as modified\n\t\t\t\t\t\t\t\t\t\t// just for the worse case\n\t\t\t\t\t\t\t\t\t\tremainingChunksToMerge--;\n\t\t\t\t\t\t\t\t\t\tif (remainingChunksToMerge <= 0) break loop;\n\t\t\t\t\t\t\t\t\t\tmodifiedChunks.add(a);\n\t\t\t\t\t\t\t\t\t\tmodifiedChunks.add(b);\n\t\t\t\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const parent of group.parentsIterable) {\n\t\t\t\t\t\t\t\t\tqueue.add(parent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// merge the chunks\n\t\t\t\t\t\tif (chunkGraph.canChunksBeIntegrated(a, b)) {\n\t\t\t\t\t\t\tchunkGraph.integrateChunks(a, b);\n\t\t\t\t\t\t\tcompilation.chunks.delete(b);\n\n\t\t\t\t\t\t\t// flag chunk a as modified as further optimization are possible for all children here\n\t\t\t\t\t\t\tmodifiedChunks.add(a);\n\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\tremainingChunksToMerge--;\n\t\t\t\t\t\t\tif (remainingChunksToMerge <= 0) break;\n\n\t\t\t\t\t\t\t// Update all affected combinations\n\t\t\t\t\t\t\t// delete all combination with the removed chunk\n\t\t\t\t\t\t\t// we will use combinations with the kept chunk instead\n\t\t\t\t\t\t\tfor (const combination of combinationsByChunk.get(a)) {\n\t\t\t\t\t\t\t\tif (combination.deleted) continue;\n\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Update combinations with the kept chunk with new sizes\n\t\t\t\t\t\t\tfor (const combination of combinationsByChunk.get(b)) {\n\t\t\t\t\t\t\t\tif (combination.deleted) continue;\n\t\t\t\t\t\t\t\tif (combination.a === b) {\n\t\t\t\t\t\t\t\t\tif (!chunkGraph.canChunksBeIntegrated(a, combination.b)) {\n\t\t\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Update size\n\t\t\t\t\t\t\t\t\tconst newIntegratedSize = chunkGraph.getIntegratedChunksSize(\n\t\t\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\t\t\tcombination.b,\n\t\t\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tconst finishUpdate = combinations.startUpdate(combination);\n\t\t\t\t\t\t\t\t\tcombination.a = a;\n\t\t\t\t\t\t\t\t\tcombination.integratedSize = newIntegratedSize;\n\t\t\t\t\t\t\t\t\tcombination.aSize = integratedSize;\n\t\t\t\t\t\t\t\t\tcombination.sizeDiff =\n\t\t\t\t\t\t\t\t\t\tcombination.bSize + integratedSize - newIntegratedSize;\n\t\t\t\t\t\t\t\t\tfinishUpdate();\n\t\t\t\t\t\t\t\t} else if (combination.b === b) {\n\t\t\t\t\t\t\t\t\tif (!chunkGraph.canChunksBeIntegrated(combination.a, a)) {\n\t\t\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Update size\n\t\t\t\t\t\t\t\t\tconst newIntegratedSize = chunkGraph.getIntegratedChunksSize(\n\t\t\t\t\t\t\t\t\t\tcombination.a,\n\t\t\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tconst finishUpdate = combinations.startUpdate(combination);\n\t\t\t\t\t\t\t\t\tcombination.b = a;\n\t\t\t\t\t\t\t\t\tcombination.integratedSize = newIntegratedSize;\n\t\t\t\t\t\t\t\t\tcombination.bSize = integratedSize;\n\t\t\t\t\t\t\t\t\tcombination.sizeDiff =\n\t\t\t\t\t\t\t\t\t\tintegratedSize + combination.aSize - newIntegratedSize;\n\t\t\t\t\t\t\t\t\tfinishUpdate();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcombinationsByChunk.set(a, combinationsByChunk.get(b));\n\t\t\t\t\t\t\tcombinationsByChunk.delete(b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (changed) return true;\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = LimitChunkCountPlugin;\n"]},"metadata":{},"sourceType":"script"}