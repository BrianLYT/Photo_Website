{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  UsageState\n} = require(\"../ExportsInfo\");\n\nconst {\n  numberToIdentifier,\n  NUMBER_OF_IDENTIFIER_START_CHARS,\n  NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS\n} = require(\"../Template\");\n\nconst {\n  assignDeterministicIds\n} = require(\"../ids/IdHelpers\");\n\nconst {\n  compareSelect,\n  compareStringsNumeric\n} = require(\"../util/comparators\");\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../ExportsInfo\")} ExportsInfo */\n\n/** @typedef {import(\"../ExportsInfo\").ExportInfo} ExportInfo */\n\n/**\n * @param {ExportsInfo} exportsInfo exports info\n * @returns {boolean} mangle is possible\n */\n\n\nconst canMangle = exportsInfo => {\n  if (exportsInfo.otherExportsInfo.getUsed(undefined) !== UsageState.Unused) return false;\n  let hasSomethingToMangle = false;\n\n  for (const exportInfo of exportsInfo.exports) {\n    if (exportInfo.canMangle === true) {\n      hasSomethingToMangle = true;\n    }\n  }\n\n  return hasSomethingToMangle;\n}; // Sort by name\n\n\nconst comparator = compareSelect(e => e.name, compareStringsNumeric);\n/**\n * @param {boolean} deterministic use deterministic names\n * @param {ExportsInfo} exportsInfo exports info\n * @param {boolean} isNamespace is namespace object\n * @returns {void}\n */\n\nconst mangleExportsInfo = (deterministic, exportsInfo, isNamespace) => {\n  if (!canMangle(exportsInfo)) return;\n  const usedNames = new Set();\n  /** @type {ExportInfo[]} */\n\n  const mangleableExports = []; // Avoid to renamed exports that are not provided when\n  // 1. it's not a namespace export: non-provided exports can be found in prototype chain\n  // 2. there are other provided exports and deterministic mode is chosen:\n  //    non-provided exports would break the determinism\n\n  let avoidMangleNonProvided = !isNamespace;\n\n  if (!avoidMangleNonProvided && deterministic) {\n    for (const exportInfo of exportsInfo.ownedExports) {\n      if (exportInfo.provided !== false) {\n        avoidMangleNonProvided = true;\n        break;\n      }\n    }\n  }\n\n  for (const exportInfo of exportsInfo.ownedExports) {\n    const name = exportInfo.name;\n\n    if (!exportInfo.hasUsedName()) {\n      if ( // Can the export be mangled?\n      exportInfo.canMangle !== true || // Never rename 1 char exports\n      name.length === 1 && /^[a-zA-Z0-9_$]/.test(name) || // Don't rename 2 char exports in deterministic mode\n      deterministic && name.length === 2 && /^[a-zA-Z_$][a-zA-Z0-9_$]|^[1-9][0-9]/.test(name) || // Don't rename exports that are not provided\n      avoidMangleNonProvided && exportInfo.provided !== true) {\n        exportInfo.setUsedName(name);\n        usedNames.add(name);\n      } else {\n        mangleableExports.push(exportInfo);\n      }\n    }\n\n    if (exportInfo.exportsInfoOwned) {\n      const used = exportInfo.getUsed(undefined);\n\n      if (used === UsageState.OnlyPropertiesUsed || used === UsageState.Unused) {\n        mangleExportsInfo(deterministic, exportInfo.exportsInfo, false);\n      }\n    }\n  }\n\n  if (deterministic) {\n    assignDeterministicIds(mangleableExports, e => e.name, comparator, (e, id) => {\n      const name = numberToIdentifier(id);\n      const size = usedNames.size;\n      usedNames.add(name);\n      if (size === usedNames.size) return false;\n      e.setUsedName(name);\n      return true;\n    }, [NUMBER_OF_IDENTIFIER_START_CHARS, NUMBER_OF_IDENTIFIER_START_CHARS * NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS], NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS, usedNames.size);\n  } else {\n    const usedExports = [];\n    const unusedExports = [];\n\n    for (const exportInfo of mangleableExports) {\n      if (exportInfo.getUsed(undefined) === UsageState.Unused) {\n        unusedExports.push(exportInfo);\n      } else {\n        usedExports.push(exportInfo);\n      }\n    }\n\n    usedExports.sort(comparator);\n    unusedExports.sort(comparator);\n    let i = 0;\n\n    for (const list of [usedExports, unusedExports]) {\n      for (const exportInfo of list) {\n        let name;\n\n        do {\n          name = numberToIdentifier(i++);\n        } while (usedNames.has(name));\n\n        exportInfo.setUsedName(name);\n      }\n    }\n  }\n};\n\nclass MangleExportsPlugin {\n  /**\n   * @param {boolean} deterministic use deterministic names\n   */\n  constructor(deterministic) {\n    this._deterministic = deterministic;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const {\n      _deterministic: deterministic\n    } = this;\n    compiler.hooks.compilation.tap(\"MangleExportsPlugin\", compilation => {\n      const moduleGraph = compilation.moduleGraph;\n      compilation.hooks.optimizeCodeGeneration.tap(\"MangleExportsPlugin\", modules => {\n        if (compilation.moduleMemCaches) {\n          throw new Error(\"optimization.mangleExports can't be used with cacheUnaffected as export mangling is a global effect\");\n        }\n\n        for (const module of modules) {\n          const isNamespace = module.buildMeta && module.buildMeta.exportsType === \"namespace\";\n          const exportsInfo = moduleGraph.getExportsInfo(module);\n          mangleExportsInfo(deterministic, exportsInfo, isNamespace);\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = MangleExportsPlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/optimize/MangleExportsPlugin.js"],"names":["UsageState","require","numberToIdentifier","NUMBER_OF_IDENTIFIER_START_CHARS","NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS","assignDeterministicIds","compareSelect","compareStringsNumeric","canMangle","exportsInfo","otherExportsInfo","getUsed","undefined","Unused","hasSomethingToMangle","exportInfo","exports","comparator","e","name","mangleExportsInfo","deterministic","isNamespace","usedNames","Set","mangleableExports","avoidMangleNonProvided","ownedExports","provided","hasUsedName","length","test","setUsedName","add","push","exportsInfoOwned","used","OnlyPropertiesUsed","id","size","usedExports","unusedExports","sort","i","list","has","MangleExportsPlugin","constructor","_deterministic","apply","compiler","hooks","compilation","tap","moduleGraph","optimizeCodeGeneration","modules","moduleMemCaches","Error","module","buildMeta","exportsType","getExportsInfo"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { UsageState } = require(\"../ExportsInfo\");\nconst {\n\tnumberToIdentifier,\n\tNUMBER_OF_IDENTIFIER_START_CHARS,\n\tNUMBER_OF_IDENTIFIER_CONTINUATION_CHARS\n} = require(\"../Template\");\nconst { assignDeterministicIds } = require(\"../ids/IdHelpers\");\nconst { compareSelect, compareStringsNumeric } = require(\"../util/comparators\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../ExportsInfo\")} ExportsInfo */\n/** @typedef {import(\"../ExportsInfo\").ExportInfo} ExportInfo */\n\n/**\n * @param {ExportsInfo} exportsInfo exports info\n * @returns {boolean} mangle is possible\n */\nconst canMangle = exportsInfo => {\n\tif (exportsInfo.otherExportsInfo.getUsed(undefined) !== UsageState.Unused)\n\t\treturn false;\n\tlet hasSomethingToMangle = false;\n\tfor (const exportInfo of exportsInfo.exports) {\n\t\tif (exportInfo.canMangle === true) {\n\t\t\thasSomethingToMangle = true;\n\t\t}\n\t}\n\treturn hasSomethingToMangle;\n};\n\n// Sort by name\nconst comparator = compareSelect(e => e.name, compareStringsNumeric);\n/**\n * @param {boolean} deterministic use deterministic names\n * @param {ExportsInfo} exportsInfo exports info\n * @param {boolean} isNamespace is namespace object\n * @returns {void}\n */\nconst mangleExportsInfo = (deterministic, exportsInfo, isNamespace) => {\n\tif (!canMangle(exportsInfo)) return;\n\tconst usedNames = new Set();\n\t/** @type {ExportInfo[]} */\n\tconst mangleableExports = [];\n\n\t// Avoid to renamed exports that are not provided when\n\t// 1. it's not a namespace export: non-provided exports can be found in prototype chain\n\t// 2. there are other provided exports and deterministic mode is chosen:\n\t//    non-provided exports would break the determinism\n\tlet avoidMangleNonProvided = !isNamespace;\n\tif (!avoidMangleNonProvided && deterministic) {\n\t\tfor (const exportInfo of exportsInfo.ownedExports) {\n\t\t\tif (exportInfo.provided !== false) {\n\t\t\t\tavoidMangleNonProvided = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (const exportInfo of exportsInfo.ownedExports) {\n\t\tconst name = exportInfo.name;\n\t\tif (!exportInfo.hasUsedName()) {\n\t\t\tif (\n\t\t\t\t// Can the export be mangled?\n\t\t\t\texportInfo.canMangle !== true ||\n\t\t\t\t// Never rename 1 char exports\n\t\t\t\t(name.length === 1 && /^[a-zA-Z0-9_$]/.test(name)) ||\n\t\t\t\t// Don't rename 2 char exports in deterministic mode\n\t\t\t\t(deterministic &&\n\t\t\t\t\tname.length === 2 &&\n\t\t\t\t\t/^[a-zA-Z_$][a-zA-Z0-9_$]|^[1-9][0-9]/.test(name)) ||\n\t\t\t\t// Don't rename exports that are not provided\n\t\t\t\t(avoidMangleNonProvided && exportInfo.provided !== true)\n\t\t\t) {\n\t\t\t\texportInfo.setUsedName(name);\n\t\t\t\tusedNames.add(name);\n\t\t\t} else {\n\t\t\t\tmangleableExports.push(exportInfo);\n\t\t\t}\n\t\t}\n\t\tif (exportInfo.exportsInfoOwned) {\n\t\t\tconst used = exportInfo.getUsed(undefined);\n\t\t\tif (\n\t\t\t\tused === UsageState.OnlyPropertiesUsed ||\n\t\t\t\tused === UsageState.Unused\n\t\t\t) {\n\t\t\t\tmangleExportsInfo(deterministic, exportInfo.exportsInfo, false);\n\t\t\t}\n\t\t}\n\t}\n\tif (deterministic) {\n\t\tassignDeterministicIds(\n\t\t\tmangleableExports,\n\t\t\te => e.name,\n\t\t\tcomparator,\n\t\t\t(e, id) => {\n\t\t\t\tconst name = numberToIdentifier(id);\n\t\t\t\tconst size = usedNames.size;\n\t\t\t\tusedNames.add(name);\n\t\t\t\tif (size === usedNames.size) return false;\n\t\t\t\te.setUsedName(name);\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\t[\n\t\t\t\tNUMBER_OF_IDENTIFIER_START_CHARS,\n\t\t\t\tNUMBER_OF_IDENTIFIER_START_CHARS *\n\t\t\t\t\tNUMBER_OF_IDENTIFIER_CONTINUATION_CHARS\n\t\t\t],\n\t\t\tNUMBER_OF_IDENTIFIER_CONTINUATION_CHARS,\n\t\t\tusedNames.size\n\t\t);\n\t} else {\n\t\tconst usedExports = [];\n\t\tconst unusedExports = [];\n\t\tfor (const exportInfo of mangleableExports) {\n\t\t\tif (exportInfo.getUsed(undefined) === UsageState.Unused) {\n\t\t\t\tunusedExports.push(exportInfo);\n\t\t\t} else {\n\t\t\t\tusedExports.push(exportInfo);\n\t\t\t}\n\t\t}\n\t\tusedExports.sort(comparator);\n\t\tunusedExports.sort(comparator);\n\t\tlet i = 0;\n\t\tfor (const list of [usedExports, unusedExports]) {\n\t\t\tfor (const exportInfo of list) {\n\t\t\t\tlet name;\n\t\t\t\tdo {\n\t\t\t\t\tname = numberToIdentifier(i++);\n\t\t\t\t} while (usedNames.has(name));\n\t\t\t\texportInfo.setUsedName(name);\n\t\t\t}\n\t\t}\n\t}\n};\n\nclass MangleExportsPlugin {\n\t/**\n\t * @param {boolean} deterministic use deterministic names\n\t */\n\tconstructor(deterministic) {\n\t\tthis._deterministic = deterministic;\n\t}\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst { _deterministic: deterministic } = this;\n\t\tcompiler.hooks.compilation.tap(\"MangleExportsPlugin\", compilation => {\n\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\tcompilation.hooks.optimizeCodeGeneration.tap(\n\t\t\t\t\"MangleExportsPlugin\",\n\t\t\t\tmodules => {\n\t\t\t\t\tif (compilation.moduleMemCaches) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\"optimization.mangleExports can't be used with cacheUnaffected as export mangling is a global effect\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\tconst isNamespace =\n\t\t\t\t\t\t\tmodule.buildMeta && module.buildMeta.exportsType === \"namespace\";\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\tmangleExportsInfo(deterministic, exportsInfo, isNamespace);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = MangleExportsPlugin;\n"]},"metadata":{},"sourceType":"script"}