{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst ModuleNotFoundError = require(\"../ModuleNotFoundError\");\n\nconst LazySet = require(\"../util/LazySet\");\n/** @typedef {import(\"../Compilation\")} Compilation */\n\n/** @typedef {import(\"../ResolverFactory\").ResolveOptionsWithDependencyType} ResolveOptionsWithDependencyType */\n\n/**\n * @template T\n * @typedef {Object} MatchedConfigs\n * @property {Map<string, T>} resolved\n * @property {Map<string, T>} unresolved\n * @property {Map<string, T>} prefixed\n */\n\n/** @type {ResolveOptionsWithDependencyType} */\n\n\nconst RESOLVE_OPTIONS = {\n  dependencyType: \"esm\"\n};\n/**\n * @template T\n * @param {Compilation} compilation the compilation\n * @param {[string, T][]} configs to be processed configs\n * @returns {Promise<MatchedConfigs<T>>} resolved matchers\n */\n\nexports.resolveMatchedConfigs = (compilation, configs) => {\n  /** @type {Map<string, T>} */\n  const resolved = new Map();\n  /** @type {Map<string, T>} */\n\n  const unresolved = new Map();\n  /** @type {Map<string, T>} */\n\n  const prefixed = new Map();\n  const resolveContext = {\n    /** @type {LazySet<string>} */\n    fileDependencies: new LazySet(),\n\n    /** @type {LazySet<string>} */\n    contextDependencies: new LazySet(),\n\n    /** @type {LazySet<string>} */\n    missingDependencies: new LazySet()\n  };\n  const resolver = compilation.resolverFactory.get(\"normal\", RESOLVE_OPTIONS);\n  const context = compilation.compiler.context;\n  return Promise.all(configs.map(_ref => {\n    let [request, config] = _ref;\n\n    if (/^\\.\\.?(\\/|$)/.test(request)) {\n      // relative request\n      return new Promise(resolve => {\n        resolver.resolve({}, context, request, resolveContext, (err, result) => {\n          if (err || result === false) {\n            err = err || new Error(`Can't resolve ${request}`);\n            compilation.errors.push(new ModuleNotFoundError(null, err, {\n              name: `shared module ${request}`\n            }));\n            return resolve();\n          }\n\n          resolved.set(result, config);\n          resolve();\n        });\n      });\n    } else if (/^(\\/|[A-Za-z]:\\\\|\\\\\\\\)/.test(request)) {\n      // absolute path\n      resolved.set(request, config);\n    } else if (request.endsWith(\"/\")) {\n      // module request prefix\n      prefixed.set(request, config);\n    } else {\n      // module request\n      unresolved.set(request, config);\n    }\n  })).then(() => {\n    compilation.contextDependencies.addAll(resolveContext.contextDependencies);\n    compilation.fileDependencies.addAll(resolveContext.fileDependencies);\n    compilation.missingDependencies.addAll(resolveContext.missingDependencies);\n    return {\n      resolved,\n      unresolved,\n      prefixed\n    };\n  });\n};","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/sharing/resolveMatchedConfigs.js"],"names":["ModuleNotFoundError","require","LazySet","RESOLVE_OPTIONS","dependencyType","exports","resolveMatchedConfigs","compilation","configs","resolved","Map","unresolved","prefixed","resolveContext","fileDependencies","contextDependencies","missingDependencies","resolver","resolverFactory","get","context","compiler","Promise","all","map","request","config","test","resolve","err","result","Error","errors","push","name","set","endsWith","then","addAll"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst ModuleNotFoundError = require(\"../ModuleNotFoundError\");\nconst LazySet = require(\"../util/LazySet\");\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../ResolverFactory\").ResolveOptionsWithDependencyType} ResolveOptionsWithDependencyType */\n\n/**\n * @template T\n * @typedef {Object} MatchedConfigs\n * @property {Map<string, T>} resolved\n * @property {Map<string, T>} unresolved\n * @property {Map<string, T>} prefixed\n */\n\n/** @type {ResolveOptionsWithDependencyType} */\nconst RESOLVE_OPTIONS = { dependencyType: \"esm\" };\n\n/**\n * @template T\n * @param {Compilation} compilation the compilation\n * @param {[string, T][]} configs to be processed configs\n * @returns {Promise<MatchedConfigs<T>>} resolved matchers\n */\nexports.resolveMatchedConfigs = (compilation, configs) => {\n\t/** @type {Map<string, T>} */\n\tconst resolved = new Map();\n\t/** @type {Map<string, T>} */\n\tconst unresolved = new Map();\n\t/** @type {Map<string, T>} */\n\tconst prefixed = new Map();\n\tconst resolveContext = {\n\t\t/** @type {LazySet<string>} */\n\t\tfileDependencies: new LazySet(),\n\t\t/** @type {LazySet<string>} */\n\t\tcontextDependencies: new LazySet(),\n\t\t/** @type {LazySet<string>} */\n\t\tmissingDependencies: new LazySet()\n\t};\n\tconst resolver = compilation.resolverFactory.get(\"normal\", RESOLVE_OPTIONS);\n\tconst context = compilation.compiler.context;\n\n\treturn Promise.all(\n\t\tconfigs.map(([request, config]) => {\n\t\t\tif (/^\\.\\.?(\\/|$)/.test(request)) {\n\t\t\t\t// relative request\n\t\t\t\treturn new Promise(resolve => {\n\t\t\t\t\tresolver.resolve(\n\t\t\t\t\t\t{},\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\trequest,\n\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\tif (err || result === false) {\n\t\t\t\t\t\t\t\terr = err || new Error(`Can't resolve ${request}`);\n\t\t\t\t\t\t\t\tcompilation.errors.push(\n\t\t\t\t\t\t\t\t\tnew ModuleNotFoundError(null, err, {\n\t\t\t\t\t\t\t\t\t\tname: `shared module ${request}`\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresolved.set(result, config);\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t} else if (/^(\\/|[A-Za-z]:\\\\|\\\\\\\\)/.test(request)) {\n\t\t\t\t// absolute path\n\t\t\t\tresolved.set(request, config);\n\t\t\t} else if (request.endsWith(\"/\")) {\n\t\t\t\t// module request prefix\n\t\t\t\tprefixed.set(request, config);\n\t\t\t} else {\n\t\t\t\t// module request\n\t\t\t\tunresolved.set(request, config);\n\t\t\t}\n\t\t})\n\t).then(() => {\n\t\tcompilation.contextDependencies.addAll(resolveContext.contextDependencies);\n\t\tcompilation.fileDependencies.addAll(resolveContext.fileDependencies);\n\t\tcompilation.missingDependencies.addAll(resolveContext.missingDependencies);\n\t\treturn { resolved, unresolved, prefixed };\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}