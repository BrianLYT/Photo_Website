{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\n\nconst formatLocation = require(\"../formatLocation\");\n\nconst {\n  evaluateToString\n} = require(\"../javascript/JavascriptParserHelpers\");\n\nconst propertyAccess = require(\"../util/propertyAccess\");\n\nconst CommonJsExportRequireDependency = require(\"./CommonJsExportRequireDependency\");\n\nconst CommonJsExportsDependency = require(\"./CommonJsExportsDependency\");\n\nconst CommonJsSelfReferenceDependency = require(\"./CommonJsSelfReferenceDependency\");\n\nconst DynamicExports = require(\"./DynamicExports\");\n\nconst HarmonyExports = require(\"./HarmonyExports\");\n\nconst ModuleDecoratorDependency = require(\"./ModuleDecoratorDependency\");\n/** @typedef {import(\"estree\").Expression} ExpressionNode */\n\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n\n/** @typedef {import(\"../javascript/BasicEvaluatedExpression\")} BasicEvaluatedExpression */\n\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n\n\nconst getValueOfPropertyDescription = expr => {\n  if (expr.type !== \"ObjectExpression\") return;\n\n  for (const property of expr.properties) {\n    if (property.computed) continue;\n    const key = property.key;\n    if (key.type !== \"Identifier\" || key.name !== \"value\") continue;\n    return property.value;\n  }\n};\n\nconst isTruthyLiteral = expr => {\n  switch (expr.type) {\n    case \"Literal\":\n      return !!expr.value;\n\n    case \"UnaryExpression\":\n      if (expr.operator === \"!\") return isFalsyLiteral(expr.argument);\n  }\n\n  return false;\n};\n\nconst isFalsyLiteral = expr => {\n  switch (expr.type) {\n    case \"Literal\":\n      return !expr.value;\n\n    case \"UnaryExpression\":\n      if (expr.operator === \"!\") return isTruthyLiteral(expr.argument);\n  }\n\n  return false;\n};\n/**\n * @param {JavascriptParser} parser the parser\n * @param {ExpressionNode} expr expression\n * @returns {{ argument: BasicEvaluatedExpression, ids: string[] } | undefined} parsed call\n */\n\n\nconst parseRequireCall = (parser, expr) => {\n  const ids = [];\n\n  while (expr.type === \"MemberExpression\") {\n    if (expr.object.type === \"Super\") return;\n    if (!expr.property) return;\n    const prop = expr.property;\n\n    if (expr.computed) {\n      if (prop.type !== \"Literal\") return;\n      ids.push(`${prop.value}`);\n    } else {\n      if (prop.type !== \"Identifier\") return;\n      ids.push(prop.name);\n    }\n\n    expr = expr.object;\n  }\n\n  if (expr.type !== \"CallExpression\" || expr.arguments.length !== 1) return;\n  const callee = expr.callee;\n\n  if (callee.type !== \"Identifier\" || parser.getVariableInfo(callee.name) !== \"require\") {\n    return;\n  }\n\n  const arg = expr.arguments[0];\n  if (arg.type === \"SpreadElement\") return;\n  const argValue = parser.evaluateExpression(arg);\n  return {\n    argument: argValue,\n    ids: ids.reverse()\n  };\n};\n\nclass CommonJsExportsParserPlugin {\n  constructor(moduleGraph) {\n    this.moduleGraph = moduleGraph;\n  }\n  /**\n   * @param {JavascriptParser} parser the parser\n   */\n\n\n  apply(parser) {\n    const enableStructuredExports = () => {\n      DynamicExports.enable(parser.state);\n    };\n\n    const checkNamespace = (topLevel, members, valueExpr) => {\n      if (!DynamicExports.isEnabled(parser.state)) return;\n\n      if (members.length > 0 && members[0] === \"__esModule\") {\n        if (valueExpr && isTruthyLiteral(valueExpr) && topLevel) {\n          DynamicExports.setFlagged(parser.state);\n        } else {\n          DynamicExports.setDynamic(parser.state);\n        }\n      }\n    };\n\n    const bailout = reason => {\n      DynamicExports.bailout(parser.state);\n      if (reason) bailoutHint(reason);\n    };\n\n    const bailoutHint = reason => {\n      this.moduleGraph.getOptimizationBailout(parser.state.module).push(`CommonJS bailout: ${reason}`);\n    }; // metadata //\n\n\n    parser.hooks.evaluateTypeof.for(\"module\").tap(\"CommonJsExportsParserPlugin\", evaluateToString(\"object\"));\n    parser.hooks.evaluateTypeof.for(\"exports\").tap(\"CommonJsPlugin\", evaluateToString(\"object\")); // exporting //\n\n    const handleAssignExport = (expr, base, members) => {\n      if (HarmonyExports.isEnabled(parser.state)) return; // Handle reexporting\n\n      const requireCall = parseRequireCall(parser, expr.right);\n\n      if (requireCall && requireCall.argument.isString() && (members.length === 0 || members[0] !== \"__esModule\")) {\n        enableStructuredExports(); // It's possible to reexport __esModule, so we must convert to a dynamic module\n\n        if (members.length === 0) DynamicExports.setDynamic(parser.state);\n        const dep = new CommonJsExportRequireDependency(expr.range, null, base, members, requireCall.argument.string, requireCall.ids, !parser.isStatementLevelExpression(expr));\n        dep.loc = expr.loc;\n        dep.optional = !!parser.scope.inTry;\n        parser.state.module.addDependency(dep);\n        return true;\n      }\n\n      if (members.length === 0) return;\n      enableStructuredExports();\n      const remainingMembers = members;\n      checkNamespace(parser.statementPath.length === 1 && parser.isStatementLevelExpression(expr), remainingMembers, expr.right);\n      const dep = new CommonJsExportsDependency(expr.left.range, null, base, remainingMembers);\n      dep.loc = expr.loc;\n      parser.state.module.addDependency(dep);\n      parser.walkExpression(expr.right);\n      return true;\n    };\n\n    parser.hooks.assignMemberChain.for(\"exports\").tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n      return handleAssignExport(expr, \"exports\", members);\n    });\n    parser.hooks.assignMemberChain.for(\"this\").tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n      if (!parser.scope.topLevelScope) return;\n      return handleAssignExport(expr, \"this\", members);\n    });\n    parser.hooks.assignMemberChain.for(\"module\").tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n      if (members[0] !== \"exports\") return;\n      return handleAssignExport(expr, \"module.exports\", members.slice(1));\n    });\n    parser.hooks.call.for(\"Object.defineProperty\").tap(\"CommonJsExportsParserPlugin\", expression => {\n      const expr =\n      /** @type {import(\"estree\").CallExpression} */\n      expression;\n      if (!parser.isStatementLevelExpression(expr)) return;\n      if (expr.arguments.length !== 3) return;\n      if (expr.arguments[0].type === \"SpreadElement\") return;\n      if (expr.arguments[1].type === \"SpreadElement\") return;\n      if (expr.arguments[2].type === \"SpreadElement\") return;\n      const exportsArg = parser.evaluateExpression(expr.arguments[0]);\n      if (!exportsArg || !exportsArg.isIdentifier()) return;\n\n      if (exportsArg.identifier !== \"exports\" && exportsArg.identifier !== \"module.exports\" && (exportsArg.identifier !== \"this\" || !parser.scope.topLevelScope)) {\n        return;\n      }\n\n      const propertyArg = parser.evaluateExpression(expr.arguments[1]);\n      if (!propertyArg) return;\n      const property = propertyArg.asString();\n      if (typeof property !== \"string\") return;\n      enableStructuredExports();\n      const descArg = expr.arguments[2];\n      checkNamespace(parser.statementPath.length === 1, [property], getValueOfPropertyDescription(descArg));\n      const dep = new CommonJsExportsDependency(expr.range, expr.arguments[2].range, `Object.defineProperty(${exportsArg.identifier})`, [property]);\n      dep.loc = expr.loc;\n      parser.state.module.addDependency(dep);\n      parser.walkExpression(expr.arguments[2]);\n      return true;\n    }); // Self reference //\n\n    const handleAccessExport = function (expr, base, members) {\n      let call = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n      if (HarmonyExports.isEnabled(parser.state)) return;\n\n      if (members.length === 0) {\n        bailout(`${base} is used directly at ${formatLocation(expr.loc)}`);\n      }\n\n      if (call && members.length === 1) {\n        bailoutHint(`${base}${propertyAccess(members)}(...) prevents optimization as ${base} is passed as call context at ${formatLocation(expr.loc)}`);\n      }\n\n      const dep = new CommonJsSelfReferenceDependency(expr.range, base, members, !!call);\n      dep.loc = expr.loc;\n      parser.state.module.addDependency(dep);\n\n      if (call) {\n        parser.walkExpressions(call.arguments);\n      }\n\n      return true;\n    };\n\n    parser.hooks.callMemberChain.for(\"exports\").tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n      return handleAccessExport(expr.callee, \"exports\", members, expr);\n    });\n    parser.hooks.expressionMemberChain.for(\"exports\").tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n      return handleAccessExport(expr, \"exports\", members);\n    });\n    parser.hooks.expression.for(\"exports\").tap(\"CommonJsExportsParserPlugin\", expr => {\n      return handleAccessExport(expr, \"exports\", []);\n    });\n    parser.hooks.callMemberChain.for(\"module\").tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n      if (members[0] !== \"exports\") return;\n      return handleAccessExport(expr.callee, \"module.exports\", members.slice(1), expr);\n    });\n    parser.hooks.expressionMemberChain.for(\"module\").tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n      if (members[0] !== \"exports\") return;\n      return handleAccessExport(expr, \"module.exports\", members.slice(1));\n    });\n    parser.hooks.expression.for(\"module.exports\").tap(\"CommonJsExportsParserPlugin\", expr => {\n      return handleAccessExport(expr, \"module.exports\", []);\n    });\n    parser.hooks.callMemberChain.for(\"this\").tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n      if (!parser.scope.topLevelScope) return;\n      return handleAccessExport(expr.callee, \"this\", members, expr);\n    });\n    parser.hooks.expressionMemberChain.for(\"this\").tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n      if (!parser.scope.topLevelScope) return;\n      return handleAccessExport(expr, \"this\", members);\n    });\n    parser.hooks.expression.for(\"this\").tap(\"CommonJsExportsParserPlugin\", expr => {\n      if (!parser.scope.topLevelScope) return;\n      return handleAccessExport(expr, \"this\", []);\n    }); // Bailouts //\n\n    parser.hooks.expression.for(\"module\").tap(\"CommonJsPlugin\", expr => {\n      bailout();\n      const isHarmony = HarmonyExports.isEnabled(parser.state);\n      const dep = new ModuleDecoratorDependency(isHarmony ? RuntimeGlobals.harmonyModuleDecorator : RuntimeGlobals.nodeModuleDecorator, !isHarmony);\n      dep.loc = expr.loc;\n      parser.state.module.addDependency(dep);\n      return true;\n    });\n  }\n\n}\n\nmodule.exports = CommonJsExportsParserPlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/dependencies/CommonJsExportsParserPlugin.js"],"names":["RuntimeGlobals","require","formatLocation","evaluateToString","propertyAccess","CommonJsExportRequireDependency","CommonJsExportsDependency","CommonJsSelfReferenceDependency","DynamicExports","HarmonyExports","ModuleDecoratorDependency","getValueOfPropertyDescription","expr","type","property","properties","computed","key","name","value","isTruthyLiteral","operator","isFalsyLiteral","argument","parseRequireCall","parser","ids","object","prop","push","arguments","length","callee","getVariableInfo","arg","argValue","evaluateExpression","reverse","CommonJsExportsParserPlugin","constructor","moduleGraph","apply","enableStructuredExports","enable","state","checkNamespace","topLevel","members","valueExpr","isEnabled","setFlagged","setDynamic","bailout","reason","bailoutHint","getOptimizationBailout","module","hooks","evaluateTypeof","for","tap","handleAssignExport","base","requireCall","right","isString","dep","range","string","isStatementLevelExpression","loc","optional","scope","inTry","addDependency","remainingMembers","statementPath","left","walkExpression","assignMemberChain","topLevelScope","slice","call","expression","exportsArg","isIdentifier","identifier","propertyArg","asString","descArg","handleAccessExport","undefined","walkExpressions","callMemberChain","expressionMemberChain","isHarmony","harmonyModuleDecorator","nodeModuleDecorator","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst formatLocation = require(\"../formatLocation\");\nconst { evaluateToString } = require(\"../javascript/JavascriptParserHelpers\");\nconst propertyAccess = require(\"../util/propertyAccess\");\nconst CommonJsExportRequireDependency = require(\"./CommonJsExportRequireDependency\");\nconst CommonJsExportsDependency = require(\"./CommonJsExportsDependency\");\nconst CommonJsSelfReferenceDependency = require(\"./CommonJsSelfReferenceDependency\");\nconst DynamicExports = require(\"./DynamicExports\");\nconst HarmonyExports = require(\"./HarmonyExports\");\nconst ModuleDecoratorDependency = require(\"./ModuleDecoratorDependency\");\n\n/** @typedef {import(\"estree\").Expression} ExpressionNode */\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n/** @typedef {import(\"../javascript/BasicEvaluatedExpression\")} BasicEvaluatedExpression */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n\nconst getValueOfPropertyDescription = expr => {\n\tif (expr.type !== \"ObjectExpression\") return;\n\tfor (const property of expr.properties) {\n\t\tif (property.computed) continue;\n\t\tconst key = property.key;\n\t\tif (key.type !== \"Identifier\" || key.name !== \"value\") continue;\n\t\treturn property.value;\n\t}\n};\n\nconst isTruthyLiteral = expr => {\n\tswitch (expr.type) {\n\t\tcase \"Literal\":\n\t\t\treturn !!expr.value;\n\t\tcase \"UnaryExpression\":\n\t\t\tif (expr.operator === \"!\") return isFalsyLiteral(expr.argument);\n\t}\n\treturn false;\n};\n\nconst isFalsyLiteral = expr => {\n\tswitch (expr.type) {\n\t\tcase \"Literal\":\n\t\t\treturn !expr.value;\n\t\tcase \"UnaryExpression\":\n\t\t\tif (expr.operator === \"!\") return isTruthyLiteral(expr.argument);\n\t}\n\treturn false;\n};\n\n/**\n * @param {JavascriptParser} parser the parser\n * @param {ExpressionNode} expr expression\n * @returns {{ argument: BasicEvaluatedExpression, ids: string[] } | undefined} parsed call\n */\nconst parseRequireCall = (parser, expr) => {\n\tconst ids = [];\n\twhile (expr.type === \"MemberExpression\") {\n\t\tif (expr.object.type === \"Super\") return;\n\t\tif (!expr.property) return;\n\t\tconst prop = expr.property;\n\t\tif (expr.computed) {\n\t\t\tif (prop.type !== \"Literal\") return;\n\t\t\tids.push(`${prop.value}`);\n\t\t} else {\n\t\t\tif (prop.type !== \"Identifier\") return;\n\t\t\tids.push(prop.name);\n\t\t}\n\t\texpr = expr.object;\n\t}\n\tif (expr.type !== \"CallExpression\" || expr.arguments.length !== 1) return;\n\tconst callee = expr.callee;\n\tif (\n\t\tcallee.type !== \"Identifier\" ||\n\t\tparser.getVariableInfo(callee.name) !== \"require\"\n\t) {\n\t\treturn;\n\t}\n\tconst arg = expr.arguments[0];\n\tif (arg.type === \"SpreadElement\") return;\n\tconst argValue = parser.evaluateExpression(arg);\n\treturn { argument: argValue, ids: ids.reverse() };\n};\n\nclass CommonJsExportsParserPlugin {\n\tconstructor(moduleGraph) {\n\t\tthis.moduleGraph = moduleGraph;\n\t}\n\n\t/**\n\t * @param {JavascriptParser} parser the parser\n\t */\n\tapply(parser) {\n\t\tconst enableStructuredExports = () => {\n\t\t\tDynamicExports.enable(parser.state);\n\t\t};\n\t\tconst checkNamespace = (topLevel, members, valueExpr) => {\n\t\t\tif (!DynamicExports.isEnabled(parser.state)) return;\n\t\t\tif (members.length > 0 && members[0] === \"__esModule\") {\n\t\t\t\tif (valueExpr && isTruthyLiteral(valueExpr) && topLevel) {\n\t\t\t\t\tDynamicExports.setFlagged(parser.state);\n\t\t\t\t} else {\n\t\t\t\t\tDynamicExports.setDynamic(parser.state);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tconst bailout = reason => {\n\t\t\tDynamicExports.bailout(parser.state);\n\t\t\tif (reason) bailoutHint(reason);\n\t\t};\n\t\tconst bailoutHint = reason => {\n\t\t\tthis.moduleGraph\n\t\t\t\t.getOptimizationBailout(parser.state.module)\n\t\t\t\t.push(`CommonJS bailout: ${reason}`);\n\t\t};\n\n\t\t// metadata //\n\t\tparser.hooks.evaluateTypeof\n\t\t\t.for(\"module\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", evaluateToString(\"object\"));\n\t\tparser.hooks.evaluateTypeof\n\t\t\t.for(\"exports\")\n\t\t\t.tap(\"CommonJsPlugin\", evaluateToString(\"object\"));\n\n\t\t// exporting //\n\t\tconst handleAssignExport = (expr, base, members) => {\n\t\t\tif (HarmonyExports.isEnabled(parser.state)) return;\n\t\t\t// Handle reexporting\n\t\t\tconst requireCall = parseRequireCall(parser, expr.right);\n\t\t\tif (\n\t\t\t\trequireCall &&\n\t\t\t\trequireCall.argument.isString() &&\n\t\t\t\t(members.length === 0 || members[0] !== \"__esModule\")\n\t\t\t) {\n\t\t\t\tenableStructuredExports();\n\t\t\t\t// It's possible to reexport __esModule, so we must convert to a dynamic module\n\t\t\t\tif (members.length === 0) DynamicExports.setDynamic(parser.state);\n\t\t\t\tconst dep = new CommonJsExportRequireDependency(\n\t\t\t\t\texpr.range,\n\t\t\t\t\tnull,\n\t\t\t\t\tbase,\n\t\t\t\t\tmembers,\n\t\t\t\t\trequireCall.argument.string,\n\t\t\t\t\trequireCall.ids,\n\t\t\t\t\t!parser.isStatementLevelExpression(expr)\n\t\t\t\t);\n\t\t\t\tdep.loc = expr.loc;\n\t\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (members.length === 0) return;\n\t\t\tenableStructuredExports();\n\t\t\tconst remainingMembers = members;\n\t\t\tcheckNamespace(\n\t\t\t\tparser.statementPath.length === 1 &&\n\t\t\t\t\tparser.isStatementLevelExpression(expr),\n\t\t\t\tremainingMembers,\n\t\t\t\texpr.right\n\t\t\t);\n\t\t\tconst dep = new CommonJsExportsDependency(\n\t\t\t\texpr.left.range,\n\t\t\t\tnull,\n\t\t\t\tbase,\n\t\t\t\tremainingMembers\n\t\t\t);\n\t\t\tdep.loc = expr.loc;\n\t\t\tparser.state.module.addDependency(dep);\n\t\t\tparser.walkExpression(expr.right);\n\t\t\treturn true;\n\t\t};\n\t\tparser.hooks.assignMemberChain\n\t\t\t.for(\"exports\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n\t\t\t\treturn handleAssignExport(expr, \"exports\", members);\n\t\t\t});\n\t\tparser.hooks.assignMemberChain\n\t\t\t.for(\"this\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n\t\t\t\tif (!parser.scope.topLevelScope) return;\n\t\t\t\treturn handleAssignExport(expr, \"this\", members);\n\t\t\t});\n\t\tparser.hooks.assignMemberChain\n\t\t\t.for(\"module\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n\t\t\t\tif (members[0] !== \"exports\") return;\n\t\t\t\treturn handleAssignExport(expr, \"module.exports\", members.slice(1));\n\t\t\t});\n\t\tparser.hooks.call\n\t\t\t.for(\"Object.defineProperty\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", expression => {\n\t\t\t\tconst expr = /** @type {import(\"estree\").CallExpression} */ (\n\t\t\t\t\texpression\n\t\t\t\t);\n\t\t\t\tif (!parser.isStatementLevelExpression(expr)) return;\n\t\t\t\tif (expr.arguments.length !== 3) return;\n\t\t\t\tif (expr.arguments[0].type === \"SpreadElement\") return;\n\t\t\t\tif (expr.arguments[1].type === \"SpreadElement\") return;\n\t\t\t\tif (expr.arguments[2].type === \"SpreadElement\") return;\n\t\t\t\tconst exportsArg = parser.evaluateExpression(expr.arguments[0]);\n\t\t\t\tif (!exportsArg || !exportsArg.isIdentifier()) return;\n\t\t\t\tif (\n\t\t\t\t\texportsArg.identifier !== \"exports\" &&\n\t\t\t\t\texportsArg.identifier !== \"module.exports\" &&\n\t\t\t\t\t(exportsArg.identifier !== \"this\" || !parser.scope.topLevelScope)\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst propertyArg = parser.evaluateExpression(expr.arguments[1]);\n\t\t\t\tif (!propertyArg) return;\n\t\t\t\tconst property = propertyArg.asString();\n\t\t\t\tif (typeof property !== \"string\") return;\n\t\t\t\tenableStructuredExports();\n\t\t\t\tconst descArg = expr.arguments[2];\n\t\t\t\tcheckNamespace(\n\t\t\t\t\tparser.statementPath.length === 1,\n\t\t\t\t\t[property],\n\t\t\t\t\tgetValueOfPropertyDescription(descArg)\n\t\t\t\t);\n\t\t\t\tconst dep = new CommonJsExportsDependency(\n\t\t\t\t\texpr.range,\n\t\t\t\t\texpr.arguments[2].range,\n\t\t\t\t\t`Object.defineProperty(${exportsArg.identifier})`,\n\t\t\t\t\t[property]\n\t\t\t\t);\n\t\t\t\tdep.loc = expr.loc;\n\t\t\t\tparser.state.module.addDependency(dep);\n\n\t\t\t\tparser.walkExpression(expr.arguments[2]);\n\t\t\t\treturn true;\n\t\t\t});\n\n\t\t// Self reference //\n\t\tconst handleAccessExport = (expr, base, members, call = undefined) => {\n\t\t\tif (HarmonyExports.isEnabled(parser.state)) return;\n\t\t\tif (members.length === 0) {\n\t\t\t\tbailout(`${base} is used directly at ${formatLocation(expr.loc)}`);\n\t\t\t}\n\t\t\tif (call && members.length === 1) {\n\t\t\t\tbailoutHint(\n\t\t\t\t\t`${base}${propertyAccess(\n\t\t\t\t\t\tmembers\n\t\t\t\t\t)}(...) prevents optimization as ${base} is passed as call context at ${formatLocation(\n\t\t\t\t\t\texpr.loc\n\t\t\t\t\t)}`\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst dep = new CommonJsSelfReferenceDependency(\n\t\t\t\texpr.range,\n\t\t\t\tbase,\n\t\t\t\tmembers,\n\t\t\t\t!!call\n\t\t\t);\n\t\t\tdep.loc = expr.loc;\n\t\t\tparser.state.module.addDependency(dep);\n\t\t\tif (call) {\n\t\t\t\tparser.walkExpressions(call.arguments);\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\tparser.hooks.callMemberChain\n\t\t\t.for(\"exports\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n\t\t\t\treturn handleAccessExport(expr.callee, \"exports\", members, expr);\n\t\t\t});\n\t\tparser.hooks.expressionMemberChain\n\t\t\t.for(\"exports\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n\t\t\t\treturn handleAccessExport(expr, \"exports\", members);\n\t\t\t});\n\t\tparser.hooks.expression\n\t\t\t.for(\"exports\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", expr => {\n\t\t\t\treturn handleAccessExport(expr, \"exports\", []);\n\t\t\t});\n\t\tparser.hooks.callMemberChain\n\t\t\t.for(\"module\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n\t\t\t\tif (members[0] !== \"exports\") return;\n\t\t\t\treturn handleAccessExport(\n\t\t\t\t\texpr.callee,\n\t\t\t\t\t\"module.exports\",\n\t\t\t\t\tmembers.slice(1),\n\t\t\t\t\texpr\n\t\t\t\t);\n\t\t\t});\n\t\tparser.hooks.expressionMemberChain\n\t\t\t.for(\"module\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n\t\t\t\tif (members[0] !== \"exports\") return;\n\t\t\t\treturn handleAccessExport(expr, \"module.exports\", members.slice(1));\n\t\t\t});\n\t\tparser.hooks.expression\n\t\t\t.for(\"module.exports\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", expr => {\n\t\t\t\treturn handleAccessExport(expr, \"module.exports\", []);\n\t\t\t});\n\t\tparser.hooks.callMemberChain\n\t\t\t.for(\"this\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n\t\t\t\tif (!parser.scope.topLevelScope) return;\n\t\t\t\treturn handleAccessExport(expr.callee, \"this\", members, expr);\n\t\t\t});\n\t\tparser.hooks.expressionMemberChain\n\t\t\t.for(\"this\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n\t\t\t\tif (!parser.scope.topLevelScope) return;\n\t\t\t\treturn handleAccessExport(expr, \"this\", members);\n\t\t\t});\n\t\tparser.hooks.expression\n\t\t\t.for(\"this\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", expr => {\n\t\t\t\tif (!parser.scope.topLevelScope) return;\n\t\t\t\treturn handleAccessExport(expr, \"this\", []);\n\t\t\t});\n\n\t\t// Bailouts //\n\t\tparser.hooks.expression.for(\"module\").tap(\"CommonJsPlugin\", expr => {\n\t\t\tbailout();\n\t\t\tconst isHarmony = HarmonyExports.isEnabled(parser.state);\n\t\t\tconst dep = new ModuleDecoratorDependency(\n\t\t\t\tisHarmony\n\t\t\t\t\t? RuntimeGlobals.harmonyModuleDecorator\n\t\t\t\t\t: RuntimeGlobals.nodeModuleDecorator,\n\t\t\t\t!isHarmony\n\t\t\t);\n\t\t\tdep.loc = expr.loc;\n\t\t\tparser.state.module.addDependency(dep);\n\t\t\treturn true;\n\t\t});\n\t}\n}\nmodule.exports = CommonJsExportsParserPlugin;\n"]},"metadata":{},"sourceType":"script"}