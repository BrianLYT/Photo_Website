{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst util = require(\"util\");\n\nconst SortableSet = require(\"./util/SortableSet\");\n\nconst {\n  compareLocations,\n  compareChunks,\n  compareIterables\n} = require(\"./util/comparators\");\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./ChunkGraph\")} ChunkGraph */\n\n/** @typedef {import(\"./Dependency\").DependencyLocation} DependencyLocation */\n\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n\n/** @typedef {{id: number}} HasId */\n\n/** @typedef {{module: Module, loc: DependencyLocation, request: string}} OriginRecord */\n\n/**\n * @typedef {Object} RawChunkGroupOptions\n * @property {number=} preloadOrder\n * @property {number=} prefetchOrder\n */\n\n/** @typedef {RawChunkGroupOptions & { name?: string }} ChunkGroupOptions */\n\n\nlet debugId = 5000;\n/**\n * @template T\n * @param {SortableSet<T>} set set to convert to array.\n * @returns {T[]} the array format of existing set\n */\n\nconst getArray = set => Array.from(set);\n/**\n * A convenience method used to sort chunks based on their id's\n * @param {ChunkGroup} a first sorting comparator\n * @param {ChunkGroup} b second sorting comparator\n * @returns {1|0|-1} a sorting index to determine order\n */\n\n\nconst sortById = (a, b) => {\n  if (a.id < b.id) return -1;\n  if (b.id < a.id) return 1;\n  return 0;\n};\n/**\n * @param {OriginRecord} a the first comparator in sort\n * @param {OriginRecord} b the second comparator in sort\n * @returns {1|-1|0} returns sorting order as index\n */\n\n\nconst sortOrigin = (a, b) => {\n  const aIdent = a.module ? a.module.identifier() : \"\";\n  const bIdent = b.module ? b.module.identifier() : \"\";\n  if (aIdent < bIdent) return -1;\n  if (aIdent > bIdent) return 1;\n  return compareLocations(a.loc, b.loc);\n};\n\nclass ChunkGroup {\n  /**\n   * Creates an instance of ChunkGroup.\n   * @param {string|ChunkGroupOptions=} options chunk group options passed to chunkGroup\n   */\n  constructor(options) {\n    if (typeof options === \"string\") {\n      options = {\n        name: options\n      };\n    } else if (!options) {\n      options = {\n        name: undefined\n      };\n    }\n    /** @type {number} */\n\n\n    this.groupDebugId = debugId++;\n    this.options = options;\n    /** @type {SortableSet<ChunkGroup>} */\n\n    this._children = new SortableSet(undefined, sortById);\n    /** @type {SortableSet<ChunkGroup>} */\n\n    this._parents = new SortableSet(undefined, sortById);\n    /** @type {SortableSet<ChunkGroup>} */\n\n    this._asyncEntrypoints = new SortableSet(undefined, sortById);\n    this._blocks = new SortableSet();\n    /** @type {Chunk[]} */\n\n    this.chunks = [];\n    /** @type {OriginRecord[]} */\n\n    this.origins = [];\n    /** Indices in top-down order */\n\n    /** @private @type {Map<Module, number>} */\n\n    this._modulePreOrderIndices = new Map();\n    /** Indices in bottom-up order */\n\n    /** @private @type {Map<Module, number>} */\n\n    this._modulePostOrderIndices = new Map();\n    /** @type {number} */\n\n    this.index = undefined;\n  }\n  /**\n   * when a new chunk is added to a chunkGroup, addingOptions will occur.\n   * @param {ChunkGroupOptions} options the chunkGroup options passed to addOptions\n   * @returns {void}\n   */\n\n\n  addOptions(options) {\n    for (const key of Object.keys(options)) {\n      if (this.options[key] === undefined) {\n        this.options[key] = options[key];\n      } else if (this.options[key] !== options[key]) {\n        if (key.endsWith(\"Order\")) {\n          this.options[key] = Math.max(this.options[key], options[key]);\n        } else {\n          throw new Error(`ChunkGroup.addOptions: No option merge strategy for ${key}`);\n        }\n      }\n    }\n  }\n  /**\n   * returns the name of current ChunkGroup\n   * @returns {string|undefined} returns the ChunkGroup name\n   */\n\n\n  get name() {\n    return this.options.name;\n  }\n  /**\n   * sets a new name for current ChunkGroup\n   * @param {string} value the new name for ChunkGroup\n   * @returns {void}\n   */\n\n\n  set name(value) {\n    this.options.name = value;\n  }\n  /* istanbul ignore next */\n\n  /**\n   * get a uniqueId for ChunkGroup, made up of its member Chunk debugId's\n   * @returns {string} a unique concatenation of chunk debugId's\n   */\n\n\n  get debugId() {\n    return Array.from(this.chunks, x => x.debugId).join(\"+\");\n  }\n  /**\n   * get a unique id for ChunkGroup, made up of its member Chunk id's\n   * @returns {string} a unique concatenation of chunk ids\n   */\n\n\n  get id() {\n    return Array.from(this.chunks, x => x.id).join(\"+\");\n  }\n  /**\n   * Performs an unshift of a specific chunk\n   * @param {Chunk} chunk chunk being unshifted\n   * @returns {boolean} returns true if attempted chunk shift is accepted\n   */\n\n\n  unshiftChunk(chunk) {\n    const oldIdx = this.chunks.indexOf(chunk);\n\n    if (oldIdx > 0) {\n      this.chunks.splice(oldIdx, 1);\n      this.chunks.unshift(chunk);\n    } else if (oldIdx < 0) {\n      this.chunks.unshift(chunk);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * inserts a chunk before another existing chunk in group\n   * @param {Chunk} chunk Chunk being inserted\n   * @param {Chunk} before Placeholder/target chunk marking new chunk insertion point\n   * @returns {boolean} return true if insertion was successful\n   */\n\n\n  insertChunk(chunk, before) {\n    const oldIdx = this.chunks.indexOf(chunk);\n    const idx = this.chunks.indexOf(before);\n\n    if (idx < 0) {\n      throw new Error(\"before chunk not found\");\n    }\n\n    if (oldIdx >= 0 && oldIdx > idx) {\n      this.chunks.splice(oldIdx, 1);\n      this.chunks.splice(idx, 0, chunk);\n    } else if (oldIdx < 0) {\n      this.chunks.splice(idx, 0, chunk);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * add a chunk into ChunkGroup. Is pushed on or prepended\n   * @param {Chunk} chunk chunk being pushed into ChunkGroupS\n   * @returns {boolean} returns true if chunk addition was successful.\n   */\n\n\n  pushChunk(chunk) {\n    const oldIdx = this.chunks.indexOf(chunk);\n\n    if (oldIdx >= 0) {\n      return false;\n    }\n\n    this.chunks.push(chunk);\n    return true;\n  }\n  /**\n   * @param {Chunk} oldChunk chunk to be replaced\n   * @param {Chunk} newChunk New chunk that will be replaced with\n   * @returns {boolean} returns true if the replacement was successful\n   */\n\n\n  replaceChunk(oldChunk, newChunk) {\n    const oldIdx = this.chunks.indexOf(oldChunk);\n    if (oldIdx < 0) return false;\n    const newIdx = this.chunks.indexOf(newChunk);\n\n    if (newIdx < 0) {\n      this.chunks[oldIdx] = newChunk;\n      return true;\n    }\n\n    if (newIdx < oldIdx) {\n      this.chunks.splice(oldIdx, 1);\n      return true;\n    } else if (newIdx !== oldIdx) {\n      this.chunks[oldIdx] = newChunk;\n      this.chunks.splice(newIdx, 1);\n      return true;\n    }\n  }\n  /**\n   * @param {Chunk} chunk chunk to remove\n   * @returns {boolean} returns true if chunk was removed\n   */\n\n\n  removeChunk(chunk) {\n    const idx = this.chunks.indexOf(chunk);\n\n    if (idx >= 0) {\n      this.chunks.splice(idx, 1);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * @returns {boolean} true, when this chunk group will be loaded on initial page load\n   */\n\n\n  isInitial() {\n    return false;\n  }\n  /**\n   * @param {ChunkGroup} group chunk group to add\n   * @returns {boolean} returns true if chunk group was added\n   */\n\n\n  addChild(group) {\n    const size = this._children.size;\n\n    this._children.add(group);\n\n    return size !== this._children.size;\n  }\n  /**\n   * @returns {ChunkGroup[]} returns the children of this group\n   */\n\n\n  getChildren() {\n    return this._children.getFromCache(getArray);\n  }\n\n  getNumberOfChildren() {\n    return this._children.size;\n  }\n\n  get childrenIterable() {\n    return this._children;\n  }\n  /**\n   * @param {ChunkGroup} group the chunk group to remove\n   * @returns {boolean} returns true if the chunk group was removed\n   */\n\n\n  removeChild(group) {\n    if (!this._children.has(group)) {\n      return false;\n    }\n\n    this._children.delete(group);\n\n    group.removeParent(this);\n    return true;\n  }\n  /**\n   * @param {ChunkGroup} parentChunk the parent group to be added into\n   * @returns {boolean} returns true if this chunk group was added to the parent group\n   */\n\n\n  addParent(parentChunk) {\n    if (!this._parents.has(parentChunk)) {\n      this._parents.add(parentChunk);\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * @returns {ChunkGroup[]} returns the parents of this group\n   */\n\n\n  getParents() {\n    return this._parents.getFromCache(getArray);\n  }\n\n  getNumberOfParents() {\n    return this._parents.size;\n  }\n  /**\n   * @param {ChunkGroup} parent the parent group\n   * @returns {boolean} returns true if the parent group contains this group\n   */\n\n\n  hasParent(parent) {\n    return this._parents.has(parent);\n  }\n\n  get parentsIterable() {\n    return this._parents;\n  }\n  /**\n   * @param {ChunkGroup} chunkGroup the parent group\n   * @returns {boolean} returns true if this group has been removed from the parent\n   */\n\n\n  removeParent(chunkGroup) {\n    if (this._parents.delete(chunkGroup)) {\n      chunkGroup.removeChild(this);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * @param {Entrypoint} entrypoint entrypoint to add\n   * @returns {boolean} returns true if entrypoint was added\n   */\n\n\n  addAsyncEntrypoint(entrypoint) {\n    const size = this._asyncEntrypoints.size;\n\n    this._asyncEntrypoints.add(entrypoint);\n\n    return size !== this._asyncEntrypoints.size;\n  }\n\n  get asyncEntrypointsIterable() {\n    return this._asyncEntrypoints;\n  }\n  /**\n   * @returns {Array} an array containing the blocks\n   */\n\n\n  getBlocks() {\n    return this._blocks.getFromCache(getArray);\n  }\n\n  getNumberOfBlocks() {\n    return this._blocks.size;\n  }\n\n  hasBlock(block) {\n    return this._blocks.has(block);\n  }\n  /**\n   * @returns {Iterable<AsyncDependenciesBlock>} blocks\n   */\n\n\n  get blocksIterable() {\n    return this._blocks;\n  }\n  /**\n   * @param {AsyncDependenciesBlock} block a block\n   * @returns {boolean} false, if block was already added\n   */\n\n\n  addBlock(block) {\n    if (!this._blocks.has(block)) {\n      this._blocks.add(block);\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * @param {Module} module origin module\n   * @param {DependencyLocation} loc location of the reference in the origin module\n   * @param {string} request request name of the reference\n   * @returns {void}\n   */\n\n\n  addOrigin(module, loc, request) {\n    this.origins.push({\n      module,\n      loc,\n      request\n    });\n  }\n  /**\n   * @returns {string[]} the files contained this chunk group\n   */\n\n\n  getFiles() {\n    const files = new Set();\n\n    for (const chunk of this.chunks) {\n      for (const file of chunk.files) {\n        files.add(file);\n      }\n    }\n\n    return Array.from(files);\n  }\n  /**\n   * @returns {void}\n   */\n\n\n  remove() {\n    // cleanup parents\n    for (const parentChunkGroup of this._parents) {\n      // remove this chunk from its parents\n      parentChunkGroup._children.delete(this); // cleanup \"sub chunks\"\n\n\n      for (const chunkGroup of this._children) {\n        /**\n         * remove this chunk as \"intermediary\" and connect\n         * it \"sub chunks\" and parents directly\n         */\n        // add parent to each \"sub chunk\"\n        chunkGroup.addParent(parentChunkGroup); // add \"sub chunk\" to parent\n\n        parentChunkGroup.addChild(chunkGroup);\n      }\n    }\n    /**\n     * we need to iterate again over the children\n     * to remove this from the child's parents.\n     * This can not be done in the above loop\n     * as it is not guaranteed that `this._parents` contains anything.\n     */\n\n\n    for (const chunkGroup of this._children) {\n      // remove this as parent of every \"sub chunk\"\n      chunkGroup._parents.delete(this);\n    } // remove chunks\n\n\n    for (const chunk of this.chunks) {\n      chunk.removeGroup(this);\n    }\n  }\n\n  sortItems() {\n    this.origins.sort(sortOrigin);\n  }\n  /**\n   * Sorting predicate which allows current ChunkGroup to be compared against another.\n   * Sorting values are based off of number of chunks in ChunkGroup.\n   *\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @param {ChunkGroup} otherGroup the chunkGroup to compare this against\n   * @returns {-1|0|1} sort position for comparison\n   */\n\n\n  compareTo(chunkGraph, otherGroup) {\n    if (this.chunks.length > otherGroup.chunks.length) return -1;\n    if (this.chunks.length < otherGroup.chunks.length) return 1;\n    return compareIterables(compareChunks(chunkGraph))(this.chunks, otherGroup.chunks);\n  }\n  /**\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @returns {Record<string, ChunkGroup[]>} mapping from children type to ordered list of ChunkGroups\n   */\n\n\n  getChildrenByOrders(moduleGraph, chunkGraph) {\n    /** @type {Map<string, {order: number, group: ChunkGroup}[]>} */\n    const lists = new Map();\n\n    for (const childGroup of this._children) {\n      for (const key of Object.keys(childGroup.options)) {\n        if (key.endsWith(\"Order\")) {\n          const name = key.substr(0, key.length - \"Order\".length);\n          let list = lists.get(name);\n\n          if (list === undefined) {\n            lists.set(name, list = []);\n          }\n\n          list.push({\n            order: childGroup.options[key],\n            group: childGroup\n          });\n        }\n      }\n    }\n    /** @type {Record<string, ChunkGroup[]>} */\n\n\n    const result = Object.create(null);\n\n    for (const [name, list] of lists) {\n      list.sort((a, b) => {\n        const cmp = b.order - a.order;\n        if (cmp !== 0) return cmp;\n        return a.group.compareTo(chunkGraph, b.group);\n      });\n      result[name] = list.map(i => i.group);\n    }\n\n    return result;\n  }\n  /**\n   * Sets the top-down index of a module in this ChunkGroup\n   * @param {Module} module module for which the index should be set\n   * @param {number} index the index of the module\n   * @returns {void}\n   */\n\n\n  setModulePreOrderIndex(module, index) {\n    this._modulePreOrderIndices.set(module, index);\n  }\n  /**\n   * Gets the top-down index of a module in this ChunkGroup\n   * @param {Module} module the module\n   * @returns {number} index\n   */\n\n\n  getModulePreOrderIndex(module) {\n    return this._modulePreOrderIndices.get(module);\n  }\n  /**\n   * Sets the bottom-up index of a module in this ChunkGroup\n   * @param {Module} module module for which the index should be set\n   * @param {number} index the index of the module\n   * @returns {void}\n   */\n\n\n  setModulePostOrderIndex(module, index) {\n    this._modulePostOrderIndices.set(module, index);\n  }\n  /**\n   * Gets the bottom-up index of a module in this ChunkGroup\n   * @param {Module} module the module\n   * @returns {number} index\n   */\n\n\n  getModulePostOrderIndex(module) {\n    return this._modulePostOrderIndices.get(module);\n  }\n  /* istanbul ignore next */\n\n\n  checkConstraints() {\n    const chunk = this;\n\n    for (const child of chunk._children) {\n      if (!child._parents.has(chunk)) {\n        throw new Error(`checkConstraints: child missing parent ${chunk.debugId} -> ${child.debugId}`);\n      }\n    }\n\n    for (const parentChunk of chunk._parents) {\n      if (!parentChunk._children.has(chunk)) {\n        throw new Error(`checkConstraints: parent missing child ${parentChunk.debugId} <- ${chunk.debugId}`);\n      }\n    }\n  }\n\n}\n\nChunkGroup.prototype.getModuleIndex = util.deprecate(ChunkGroup.prototype.getModulePreOrderIndex, \"ChunkGroup.getModuleIndex was renamed to getModulePreOrderIndex\", \"DEP_WEBPACK_CHUNK_GROUP_GET_MODULE_INDEX\");\nChunkGroup.prototype.getModuleIndex2 = util.deprecate(ChunkGroup.prototype.getModulePostOrderIndex, \"ChunkGroup.getModuleIndex2 was renamed to getModulePostOrderIndex\", \"DEP_WEBPACK_CHUNK_GROUP_GET_MODULE_INDEX_2\");\nmodule.exports = ChunkGroup;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/ChunkGroup.js"],"names":["util","require","SortableSet","compareLocations","compareChunks","compareIterables","debugId","getArray","set","Array","from","sortById","a","b","id","sortOrigin","aIdent","module","identifier","bIdent","loc","ChunkGroup","constructor","options","name","undefined","groupDebugId","_children","_parents","_asyncEntrypoints","_blocks","chunks","origins","_modulePreOrderIndices","Map","_modulePostOrderIndices","index","addOptions","key","Object","keys","endsWith","Math","max","Error","value","x","join","unshiftChunk","chunk","oldIdx","indexOf","splice","unshift","insertChunk","before","idx","pushChunk","push","replaceChunk","oldChunk","newChunk","newIdx","removeChunk","isInitial","addChild","group","size","add","getChildren","getFromCache","getNumberOfChildren","childrenIterable","removeChild","has","delete","removeParent","addParent","parentChunk","getParents","getNumberOfParents","hasParent","parent","parentsIterable","chunkGroup","addAsyncEntrypoint","entrypoint","asyncEntrypointsIterable","getBlocks","getNumberOfBlocks","hasBlock","block","blocksIterable","addBlock","addOrigin","request","getFiles","files","Set","file","remove","parentChunkGroup","removeGroup","sortItems","sort","compareTo","chunkGraph","otherGroup","length","getChildrenByOrders","moduleGraph","lists","childGroup","substr","list","get","order","result","create","cmp","map","i","setModulePreOrderIndex","getModulePreOrderIndex","setModulePostOrderIndex","getModulePostOrderIndex","checkConstraints","child","prototype","getModuleIndex","deprecate","getModuleIndex2","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,oBAAD,CAA3B;;AACA,MAAM;AACLE,EAAAA,gBADK;AAELC,EAAAA,aAFK;AAGLC,EAAAA;AAHK,IAIFJ,OAAO,CAAC,oBAAD,CAJX;AAMA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAEA,IAAIK,OAAO,GAAG,IAAd;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAMC,QAAQ,GAAGC,GAAG,IAAIC,KAAK,CAACC,IAAN,CAAWF,GAAX,CAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMG,QAAQ,GAAG,CAACC,CAAD,EAAIC,CAAJ,KAAU;AAC1B,MAAID,CAAC,CAACE,EAAF,GAAOD,CAAC,CAACC,EAAb,EAAiB,OAAO,CAAC,CAAR;AACjB,MAAID,CAAC,CAACC,EAAF,GAAOF,CAAC,CAACE,EAAb,EAAiB,OAAO,CAAP;AACjB,SAAO,CAAP;AACA,CAJD;AAMA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,UAAU,GAAG,CAACH,CAAD,EAAIC,CAAJ,KAAU;AAC5B,QAAMG,MAAM,GAAGJ,CAAC,CAACK,MAAF,GAAWL,CAAC,CAACK,MAAF,CAASC,UAAT,EAAX,GAAmC,EAAlD;AACA,QAAMC,MAAM,GAAGN,CAAC,CAACI,MAAF,GAAWJ,CAAC,CAACI,MAAF,CAASC,UAAT,EAAX,GAAmC,EAAlD;AACA,MAAIF,MAAM,GAAGG,MAAb,EAAqB,OAAO,CAAC,CAAR;AACrB,MAAIH,MAAM,GAAGG,MAAb,EAAqB,OAAO,CAAP;AACrB,SAAOhB,gBAAgB,CAACS,CAAC,CAACQ,GAAH,EAAQP,CAAC,CAACO,GAAV,CAAvB;AACA,CAND;;AAQA,MAAMC,UAAN,CAAiB;AAChB;AACD;AACA;AACA;AACCC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACpB,QAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAChCA,MAAAA,OAAO,GAAG;AAAEC,QAAAA,IAAI,EAAED;AAAR,OAAV;AACA,KAFD,MAEO,IAAI,CAACA,OAAL,EAAc;AACpBA,MAAAA,OAAO,GAAG;AAAEC,QAAAA,IAAI,EAAEC;AAAR,OAAV;AACA;AACD;;;AACA,SAAKC,YAAL,GAAoBpB,OAAO,EAA3B;AACA,SAAKiB,OAAL,GAAeA,OAAf;AACA;;AACA,SAAKI,SAAL,GAAiB,IAAIzB,WAAJ,CAAgBuB,SAAhB,EAA2Bd,QAA3B,CAAjB;AACA;;AACA,SAAKiB,QAAL,GAAgB,IAAI1B,WAAJ,CAAgBuB,SAAhB,EAA2Bd,QAA3B,CAAhB;AACA;;AACA,SAAKkB,iBAAL,GAAyB,IAAI3B,WAAJ,CAAgBuB,SAAhB,EAA2Bd,QAA3B,CAAzB;AACA,SAAKmB,OAAL,GAAe,IAAI5B,WAAJ,EAAf;AACA;;AACA,SAAK6B,MAAL,GAAc,EAAd;AACA;;AACA,SAAKC,OAAL,GAAe,EAAf;AACA;;AACA;;AACA,SAAKC,sBAAL,GAA8B,IAAIC,GAAJ,EAA9B;AACA;;AACA;;AACA,SAAKC,uBAAL,GAA+B,IAAID,GAAJ,EAA/B;AACA;;AACA,SAAKE,KAAL,GAAaX,SAAb;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCY,EAAAA,UAAU,CAACd,OAAD,EAAU;AACnB,SAAK,MAAMe,GAAX,IAAkBC,MAAM,CAACC,IAAP,CAAYjB,OAAZ,CAAlB,EAAwC;AACvC,UAAI,KAAKA,OAAL,CAAae,GAAb,MAAsBb,SAA1B,EAAqC;AACpC,aAAKF,OAAL,CAAae,GAAb,IAAoBf,OAAO,CAACe,GAAD,CAA3B;AACA,OAFD,MAEO,IAAI,KAAKf,OAAL,CAAae,GAAb,MAAsBf,OAAO,CAACe,GAAD,CAAjC,EAAwC;AAC9C,YAAIA,GAAG,CAACG,QAAJ,CAAa,OAAb,CAAJ,EAA2B;AAC1B,eAAKlB,OAAL,CAAae,GAAb,IAAoBI,IAAI,CAACC,GAAL,CAAS,KAAKpB,OAAL,CAAae,GAAb,CAAT,EAA4Bf,OAAO,CAACe,GAAD,CAAnC,CAApB;AACA,SAFD,MAEO;AACN,gBAAM,IAAIM,KAAJ,CACJ,uDAAsDN,GAAI,EADtD,CAAN;AAGA;AACD;AACD;AACD;AAED;AACD;AACA;AACA;;;AACS,MAAJd,IAAI,GAAG;AACV,WAAO,KAAKD,OAAL,CAAaC,IAApB;AACA;AAED;AACD;AACA;AACA;AACA;;;AACS,MAAJA,IAAI,CAACqB,KAAD,EAAQ;AACf,SAAKtB,OAAL,CAAaC,IAAb,GAAoBqB,KAApB;AACA;AAED;;AACA;AACD;AACA;AACA;;;AACY,MAAPvC,OAAO,GAAG;AACb,WAAOG,KAAK,CAACC,IAAN,CAAW,KAAKqB,MAAhB,EAAwBe,CAAC,IAAIA,CAAC,CAACxC,OAA/B,EAAwCyC,IAAxC,CAA6C,GAA7C,CAAP;AACA;AAED;AACD;AACA;AACA;;;AACO,MAAFjC,EAAE,GAAG;AACR,WAAOL,KAAK,CAACC,IAAN,CAAW,KAAKqB,MAAhB,EAAwBe,CAAC,IAAIA,CAAC,CAAChC,EAA/B,EAAmCiC,IAAnC,CAAwC,GAAxC,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCC,EAAAA,YAAY,CAACC,KAAD,EAAQ;AACnB,UAAMC,MAAM,GAAG,KAAKnB,MAAL,CAAYoB,OAAZ,CAAoBF,KAApB,CAAf;;AACA,QAAIC,MAAM,GAAG,CAAb,EAAgB;AACf,WAAKnB,MAAL,CAAYqB,MAAZ,CAAmBF,MAAnB,EAA2B,CAA3B;AACA,WAAKnB,MAAL,CAAYsB,OAAZ,CAAoBJ,KAApB;AACA,KAHD,MAGO,IAAIC,MAAM,GAAG,CAAb,EAAgB;AACtB,WAAKnB,MAAL,CAAYsB,OAAZ,CAAoBJ,KAApB;AACA,aAAO,IAAP;AACA;;AACD,WAAO,KAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCK,EAAAA,WAAW,CAACL,KAAD,EAAQM,MAAR,EAAgB;AAC1B,UAAML,MAAM,GAAG,KAAKnB,MAAL,CAAYoB,OAAZ,CAAoBF,KAApB,CAAf;AACA,UAAMO,GAAG,GAAG,KAAKzB,MAAL,CAAYoB,OAAZ,CAAoBI,MAApB,CAAZ;;AACA,QAAIC,GAAG,GAAG,CAAV,EAAa;AACZ,YAAM,IAAIZ,KAAJ,CAAU,wBAAV,CAAN;AACA;;AACD,QAAIM,MAAM,IAAI,CAAV,IAAeA,MAAM,GAAGM,GAA5B,EAAiC;AAChC,WAAKzB,MAAL,CAAYqB,MAAZ,CAAmBF,MAAnB,EAA2B,CAA3B;AACA,WAAKnB,MAAL,CAAYqB,MAAZ,CAAmBI,GAAnB,EAAwB,CAAxB,EAA2BP,KAA3B;AACA,KAHD,MAGO,IAAIC,MAAM,GAAG,CAAb,EAAgB;AACtB,WAAKnB,MAAL,CAAYqB,MAAZ,CAAmBI,GAAnB,EAAwB,CAAxB,EAA2BP,KAA3B;AACA,aAAO,IAAP;AACA;;AACD,WAAO,KAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCQ,EAAAA,SAAS,CAACR,KAAD,EAAQ;AAChB,UAAMC,MAAM,GAAG,KAAKnB,MAAL,CAAYoB,OAAZ,CAAoBF,KAApB,CAAf;;AACA,QAAIC,MAAM,IAAI,CAAd,EAAiB;AAChB,aAAO,KAAP;AACA;;AACD,SAAKnB,MAAL,CAAY2B,IAAZ,CAAiBT,KAAjB;AACA,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCU,EAAAA,YAAY,CAACC,QAAD,EAAWC,QAAX,EAAqB;AAChC,UAAMX,MAAM,GAAG,KAAKnB,MAAL,CAAYoB,OAAZ,CAAoBS,QAApB,CAAf;AACA,QAAIV,MAAM,GAAG,CAAb,EAAgB,OAAO,KAAP;AAChB,UAAMY,MAAM,GAAG,KAAK/B,MAAL,CAAYoB,OAAZ,CAAoBU,QAApB,CAAf;;AACA,QAAIC,MAAM,GAAG,CAAb,EAAgB;AACf,WAAK/B,MAAL,CAAYmB,MAAZ,IAAsBW,QAAtB;AACA,aAAO,IAAP;AACA;;AACD,QAAIC,MAAM,GAAGZ,MAAb,EAAqB;AACpB,WAAKnB,MAAL,CAAYqB,MAAZ,CAAmBF,MAAnB,EAA2B,CAA3B;AACA,aAAO,IAAP;AACA,KAHD,MAGO,IAAIY,MAAM,KAAKZ,MAAf,EAAuB;AAC7B,WAAKnB,MAAL,CAAYmB,MAAZ,IAAsBW,QAAtB;AACA,WAAK9B,MAAL,CAAYqB,MAAZ,CAAmBU,MAAnB,EAA2B,CAA3B;AACA,aAAO,IAAP;AACA;AACD;AAED;AACD;AACA;AACA;;;AACCC,EAAAA,WAAW,CAACd,KAAD,EAAQ;AAClB,UAAMO,GAAG,GAAG,KAAKzB,MAAL,CAAYoB,OAAZ,CAAoBF,KAApB,CAAZ;;AACA,QAAIO,GAAG,IAAI,CAAX,EAAc;AACb,WAAKzB,MAAL,CAAYqB,MAAZ,CAAmBI,GAAnB,EAAwB,CAAxB;AACA,aAAO,IAAP;AACA;;AACD,WAAO,KAAP;AACA;AAED;AACD;AACA;;;AACCQ,EAAAA,SAAS,GAAG;AACX,WAAO,KAAP;AACA;AAED;AACD;AACA;AACA;;;AACCC,EAAAA,QAAQ,CAACC,KAAD,EAAQ;AACf,UAAMC,IAAI,GAAG,KAAKxC,SAAL,CAAewC,IAA5B;;AACA,SAAKxC,SAAL,CAAeyC,GAAf,CAAmBF,KAAnB;;AACA,WAAOC,IAAI,KAAK,KAAKxC,SAAL,CAAewC,IAA/B;AACA;AAED;AACD;AACA;;;AACCE,EAAAA,WAAW,GAAG;AACb,WAAO,KAAK1C,SAAL,CAAe2C,YAAf,CAA4B/D,QAA5B,CAAP;AACA;;AAEDgE,EAAAA,mBAAmB,GAAG;AACrB,WAAO,KAAK5C,SAAL,CAAewC,IAAtB;AACA;;AAEmB,MAAhBK,gBAAgB,GAAG;AACtB,WAAO,KAAK7C,SAAZ;AACA;AAED;AACD;AACA;AACA;;;AACC8C,EAAAA,WAAW,CAACP,KAAD,EAAQ;AAClB,QAAI,CAAC,KAAKvC,SAAL,CAAe+C,GAAf,CAAmBR,KAAnB,CAAL,EAAgC;AAC/B,aAAO,KAAP;AACA;;AAED,SAAKvC,SAAL,CAAegD,MAAf,CAAsBT,KAAtB;;AACAA,IAAAA,KAAK,CAACU,YAAN,CAAmB,IAAnB;AACA,WAAO,IAAP;AACA;AAED;AACD;AACA;AACA;;;AACCC,EAAAA,SAAS,CAACC,WAAD,EAAc;AACtB,QAAI,CAAC,KAAKlD,QAAL,CAAc8C,GAAd,CAAkBI,WAAlB,CAAL,EAAqC;AACpC,WAAKlD,QAAL,CAAcwC,GAAd,CAAkBU,WAAlB;;AACA,aAAO,IAAP;AACA;;AACD,WAAO,KAAP;AACA;AAED;AACD;AACA;;;AACCC,EAAAA,UAAU,GAAG;AACZ,WAAO,KAAKnD,QAAL,CAAc0C,YAAd,CAA2B/D,QAA3B,CAAP;AACA;;AAEDyE,EAAAA,kBAAkB,GAAG;AACpB,WAAO,KAAKpD,QAAL,CAAcuC,IAArB;AACA;AAED;AACD;AACA;AACA;;;AACCc,EAAAA,SAAS,CAACC,MAAD,EAAS;AACjB,WAAO,KAAKtD,QAAL,CAAc8C,GAAd,CAAkBQ,MAAlB,CAAP;AACA;;AAEkB,MAAfC,eAAe,GAAG;AACrB,WAAO,KAAKvD,QAAZ;AACA;AAED;AACD;AACA;AACA;;;AACCgD,EAAAA,YAAY,CAACQ,UAAD,EAAa;AACxB,QAAI,KAAKxD,QAAL,CAAc+C,MAAd,CAAqBS,UAArB,CAAJ,EAAsC;AACrCA,MAAAA,UAAU,CAACX,WAAX,CAAuB,IAAvB;AACA,aAAO,IAAP;AACA;;AACD,WAAO,KAAP;AACA;AAED;AACD;AACA;AACA;;;AACCY,EAAAA,kBAAkB,CAACC,UAAD,EAAa;AAC9B,UAAMnB,IAAI,GAAG,KAAKtC,iBAAL,CAAuBsC,IAApC;;AACA,SAAKtC,iBAAL,CAAuBuC,GAAvB,CAA2BkB,UAA3B;;AACA,WAAOnB,IAAI,KAAK,KAAKtC,iBAAL,CAAuBsC,IAAvC;AACA;;AAE2B,MAAxBoB,wBAAwB,GAAG;AAC9B,WAAO,KAAK1D,iBAAZ;AACA;AAED;AACD;AACA;;;AACC2D,EAAAA,SAAS,GAAG;AACX,WAAO,KAAK1D,OAAL,CAAawC,YAAb,CAA0B/D,QAA1B,CAAP;AACA;;AAEDkF,EAAAA,iBAAiB,GAAG;AACnB,WAAO,KAAK3D,OAAL,CAAaqC,IAApB;AACA;;AAEDuB,EAAAA,QAAQ,CAACC,KAAD,EAAQ;AACf,WAAO,KAAK7D,OAAL,CAAa4C,GAAb,CAAiBiB,KAAjB,CAAP;AACA;AAED;AACD;AACA;;;AACmB,MAAdC,cAAc,GAAG;AACpB,WAAO,KAAK9D,OAAZ;AACA;AAED;AACD;AACA;AACA;;;AACC+D,EAAAA,QAAQ,CAACF,KAAD,EAAQ;AACf,QAAI,CAAC,KAAK7D,OAAL,CAAa4C,GAAb,CAAiBiB,KAAjB,CAAL,EAA8B;AAC7B,WAAK7D,OAAL,CAAasC,GAAb,CAAiBuB,KAAjB;;AACA,aAAO,IAAP;AACA;;AACD,WAAO,KAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCG,EAAAA,SAAS,CAAC7E,MAAD,EAASG,GAAT,EAAc2E,OAAd,EAAuB;AAC/B,SAAK/D,OAAL,CAAa0B,IAAb,CAAkB;AACjBzC,MAAAA,MADiB;AAEjBG,MAAAA,GAFiB;AAGjB2E,MAAAA;AAHiB,KAAlB;AAKA;AAED;AACD;AACA;;;AACCC,EAAAA,QAAQ,GAAG;AACV,UAAMC,KAAK,GAAG,IAAIC,GAAJ,EAAd;;AAEA,SAAK,MAAMjD,KAAX,IAAoB,KAAKlB,MAAzB,EAAiC;AAChC,WAAK,MAAMoE,IAAX,IAAmBlD,KAAK,CAACgD,KAAzB,EAAgC;AAC/BA,QAAAA,KAAK,CAAC7B,GAAN,CAAU+B,IAAV;AACA;AACD;;AAED,WAAO1F,KAAK,CAACC,IAAN,CAAWuF,KAAX,CAAP;AACA;AAED;AACD;AACA;;;AACCG,EAAAA,MAAM,GAAG;AACR;AACA,SAAK,MAAMC,gBAAX,IAA+B,KAAKzE,QAApC,EAA8C;AAC7C;AACAyE,MAAAA,gBAAgB,CAAC1E,SAAjB,CAA2BgD,MAA3B,CAAkC,IAAlC,EAF6C,CAI7C;;;AACA,WAAK,MAAMS,UAAX,IAAyB,KAAKzD,SAA9B,EAAyC;AACxC;AACJ;AACA;AACA;AACI;AACAyD,QAAAA,UAAU,CAACP,SAAX,CAAqBwB,gBAArB,EANwC,CAOxC;;AACAA,QAAAA,gBAAgB,CAACpC,QAAjB,CAA0BmB,UAA1B;AACA;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACE,SAAK,MAAMA,UAAX,IAAyB,KAAKzD,SAA9B,EAAyC;AACxC;AACAyD,MAAAA,UAAU,CAACxD,QAAX,CAAoB+C,MAApB,CAA2B,IAA3B;AACA,KA5BO,CA8BR;;;AACA,SAAK,MAAM1B,KAAX,IAAoB,KAAKlB,MAAzB,EAAiC;AAChCkB,MAAAA,KAAK,CAACqD,WAAN,CAAkB,IAAlB;AACA;AACD;;AAEDC,EAAAA,SAAS,GAAG;AACX,SAAKvE,OAAL,CAAawE,IAAb,CAAkBzF,UAAlB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACC0F,EAAAA,SAAS,CAACC,UAAD,EAAaC,UAAb,EAAyB;AACjC,QAAI,KAAK5E,MAAL,CAAY6E,MAAZ,GAAqBD,UAAU,CAAC5E,MAAX,CAAkB6E,MAA3C,EAAmD,OAAO,CAAC,CAAR;AACnD,QAAI,KAAK7E,MAAL,CAAY6E,MAAZ,GAAqBD,UAAU,CAAC5E,MAAX,CAAkB6E,MAA3C,EAAmD,OAAO,CAAP;AACnD,WAAOvG,gBAAgB,CAACD,aAAa,CAACsG,UAAD,CAAd,CAAhB,CACN,KAAK3E,MADC,EAEN4E,UAAU,CAAC5E,MAFL,CAAP;AAIA;AAED;AACD;AACA;AACA;AACA;;;AACC8E,EAAAA,mBAAmB,CAACC,WAAD,EAAcJ,UAAd,EAA0B;AAC5C;AACA,UAAMK,KAAK,GAAG,IAAI7E,GAAJ,EAAd;;AACA,SAAK,MAAM8E,UAAX,IAAyB,KAAKrF,SAA9B,EAAyC;AACxC,WAAK,MAAMW,GAAX,IAAkBC,MAAM,CAACC,IAAP,CAAYwE,UAAU,CAACzF,OAAvB,CAAlB,EAAmD;AAClD,YAAIe,GAAG,CAACG,QAAJ,CAAa,OAAb,CAAJ,EAA2B;AAC1B,gBAAMjB,IAAI,GAAGc,GAAG,CAAC2E,MAAJ,CAAW,CAAX,EAAc3E,GAAG,CAACsE,MAAJ,GAAa,QAAQA,MAAnC,CAAb;AACA,cAAIM,IAAI,GAAGH,KAAK,CAACI,GAAN,CAAU3F,IAAV,CAAX;;AACA,cAAI0F,IAAI,KAAKzF,SAAb,EAAwB;AACvBsF,YAAAA,KAAK,CAACvG,GAAN,CAAUgB,IAAV,EAAiB0F,IAAI,GAAG,EAAxB;AACA;;AACDA,UAAAA,IAAI,CAACxD,IAAL,CAAU;AACT0D,YAAAA,KAAK,EAAEJ,UAAU,CAACzF,OAAX,CAAmBe,GAAnB,CADE;AAET4B,YAAAA,KAAK,EAAE8C;AAFE,WAAV;AAIA;AACD;AACD;AACD;;;AACA,UAAMK,MAAM,GAAG9E,MAAM,CAAC+E,MAAP,CAAc,IAAd,CAAf;;AACA,SAAK,MAAM,CAAC9F,IAAD,EAAO0F,IAAP,CAAX,IAA2BH,KAA3B,EAAkC;AACjCG,MAAAA,IAAI,CAACV,IAAL,CAAU,CAAC5F,CAAD,EAAIC,CAAJ,KAAU;AACnB,cAAM0G,GAAG,GAAG1G,CAAC,CAACuG,KAAF,GAAUxG,CAAC,CAACwG,KAAxB;AACA,YAAIG,GAAG,KAAK,CAAZ,EAAe,OAAOA,GAAP;AACf,eAAO3G,CAAC,CAACsD,KAAF,CAAQuC,SAAR,CAAkBC,UAAlB,EAA8B7F,CAAC,CAACqD,KAAhC,CAAP;AACA,OAJD;AAKAmD,MAAAA,MAAM,CAAC7F,IAAD,CAAN,GAAe0F,IAAI,CAACM,GAAL,CAASC,CAAC,IAAIA,CAAC,CAACvD,KAAhB,CAAf;AACA;;AACD,WAAOmD,MAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCK,EAAAA,sBAAsB,CAACzG,MAAD,EAASmB,KAAT,EAAgB;AACrC,SAAKH,sBAAL,CAA4BzB,GAA5B,CAAgCS,MAAhC,EAAwCmB,KAAxC;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCuF,EAAAA,sBAAsB,CAAC1G,MAAD,EAAS;AAC9B,WAAO,KAAKgB,sBAAL,CAA4BkF,GAA5B,CAAgClG,MAAhC,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACC2G,EAAAA,uBAAuB,CAAC3G,MAAD,EAASmB,KAAT,EAAgB;AACtC,SAAKD,uBAAL,CAA6B3B,GAA7B,CAAiCS,MAAjC,EAAyCmB,KAAzC;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCyF,EAAAA,uBAAuB,CAAC5G,MAAD,EAAS;AAC/B,WAAO,KAAKkB,uBAAL,CAA6BgF,GAA7B,CAAiClG,MAAjC,CAAP;AACA;AAED;;;AACA6G,EAAAA,gBAAgB,GAAG;AAClB,UAAM7E,KAAK,GAAG,IAAd;;AACA,SAAK,MAAM8E,KAAX,IAAoB9E,KAAK,CAACtB,SAA1B,EAAqC;AACpC,UAAI,CAACoG,KAAK,CAACnG,QAAN,CAAe8C,GAAf,CAAmBzB,KAAnB,CAAL,EAAgC;AAC/B,cAAM,IAAIL,KAAJ,CACJ,0CAAyCK,KAAK,CAAC3C,OAAQ,OAAMyH,KAAK,CAACzH,OAAQ,EADvE,CAAN;AAGA;AACD;;AACD,SAAK,MAAMwE,WAAX,IAA0B7B,KAAK,CAACrB,QAAhC,EAA0C;AACzC,UAAI,CAACkD,WAAW,CAACnD,SAAZ,CAAsB+C,GAAtB,CAA0BzB,KAA1B,CAAL,EAAuC;AACtC,cAAM,IAAIL,KAAJ,CACJ,0CAAyCkC,WAAW,CAACxE,OAAQ,OAAM2C,KAAK,CAAC3C,OAAQ,EAD7E,CAAN;AAGA;AACD;AACD;;AApfe;;AAufjBe,UAAU,CAAC2G,SAAX,CAAqBC,cAArB,GAAsCjI,IAAI,CAACkI,SAAL,CACrC7G,UAAU,CAAC2G,SAAX,CAAqBL,sBADgB,EAErC,iEAFqC,EAGrC,0CAHqC,CAAtC;AAMAtG,UAAU,CAAC2G,SAAX,CAAqBG,eAArB,GAAuCnI,IAAI,CAACkI,SAAL,CACtC7G,UAAU,CAAC2G,SAAX,CAAqBH,uBADiB,EAEtC,mEAFsC,EAGtC,4CAHsC,CAAvC;AAMA5G,MAAM,CAACmH,OAAP,GAAiB/G,UAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst util = require(\"util\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst {\n\tcompareLocations,\n\tcompareChunks,\n\tcompareIterables\n} = require(\"./util/comparators\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"./Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n\n/** @typedef {{id: number}} HasId */\n/** @typedef {{module: Module, loc: DependencyLocation, request: string}} OriginRecord */\n\n/**\n * @typedef {Object} RawChunkGroupOptions\n * @property {number=} preloadOrder\n * @property {number=} prefetchOrder\n */\n\n/** @typedef {RawChunkGroupOptions & { name?: string }} ChunkGroupOptions */\n\nlet debugId = 5000;\n\n/**\n * @template T\n * @param {SortableSet<T>} set set to convert to array.\n * @returns {T[]} the array format of existing set\n */\nconst getArray = set => Array.from(set);\n\n/**\n * A convenience method used to sort chunks based on their id's\n * @param {ChunkGroup} a first sorting comparator\n * @param {ChunkGroup} b second sorting comparator\n * @returns {1|0|-1} a sorting index to determine order\n */\nconst sortById = (a, b) => {\n\tif (a.id < b.id) return -1;\n\tif (b.id < a.id) return 1;\n\treturn 0;\n};\n\n/**\n * @param {OriginRecord} a the first comparator in sort\n * @param {OriginRecord} b the second comparator in sort\n * @returns {1|-1|0} returns sorting order as index\n */\nconst sortOrigin = (a, b) => {\n\tconst aIdent = a.module ? a.module.identifier() : \"\";\n\tconst bIdent = b.module ? b.module.identifier() : \"\";\n\tif (aIdent < bIdent) return -1;\n\tif (aIdent > bIdent) return 1;\n\treturn compareLocations(a.loc, b.loc);\n};\n\nclass ChunkGroup {\n\t/**\n\t * Creates an instance of ChunkGroup.\n\t * @param {string|ChunkGroupOptions=} options chunk group options passed to chunkGroup\n\t */\n\tconstructor(options) {\n\t\tif (typeof options === \"string\") {\n\t\t\toptions = { name: options };\n\t\t} else if (!options) {\n\t\t\toptions = { name: undefined };\n\t\t}\n\t\t/** @type {number} */\n\t\tthis.groupDebugId = debugId++;\n\t\tthis.options = options;\n\t\t/** @type {SortableSet<ChunkGroup>} */\n\t\tthis._children = new SortableSet(undefined, sortById);\n\t\t/** @type {SortableSet<ChunkGroup>} */\n\t\tthis._parents = new SortableSet(undefined, sortById);\n\t\t/** @type {SortableSet<ChunkGroup>} */\n\t\tthis._asyncEntrypoints = new SortableSet(undefined, sortById);\n\t\tthis._blocks = new SortableSet();\n\t\t/** @type {Chunk[]} */\n\t\tthis.chunks = [];\n\t\t/** @type {OriginRecord[]} */\n\t\tthis.origins = [];\n\t\t/** Indices in top-down order */\n\t\t/** @private @type {Map<Module, number>} */\n\t\tthis._modulePreOrderIndices = new Map();\n\t\t/** Indices in bottom-up order */\n\t\t/** @private @type {Map<Module, number>} */\n\t\tthis._modulePostOrderIndices = new Map();\n\t\t/** @type {number} */\n\t\tthis.index = undefined;\n\t}\n\n\t/**\n\t * when a new chunk is added to a chunkGroup, addingOptions will occur.\n\t * @param {ChunkGroupOptions} options the chunkGroup options passed to addOptions\n\t * @returns {void}\n\t */\n\taddOptions(options) {\n\t\tfor (const key of Object.keys(options)) {\n\t\t\tif (this.options[key] === undefined) {\n\t\t\t\tthis.options[key] = options[key];\n\t\t\t} else if (this.options[key] !== options[key]) {\n\t\t\t\tif (key.endsWith(\"Order\")) {\n\t\t\t\t\tthis.options[key] = Math.max(this.options[key], options[key]);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`ChunkGroup.addOptions: No option merge strategy for ${key}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * returns the name of current ChunkGroup\n\t * @returns {string|undefined} returns the ChunkGroup name\n\t */\n\tget name() {\n\t\treturn this.options.name;\n\t}\n\n\t/**\n\t * sets a new name for current ChunkGroup\n\t * @param {string} value the new name for ChunkGroup\n\t * @returns {void}\n\t */\n\tset name(value) {\n\t\tthis.options.name = value;\n\t}\n\n\t/* istanbul ignore next */\n\t/**\n\t * get a uniqueId for ChunkGroup, made up of its member Chunk debugId's\n\t * @returns {string} a unique concatenation of chunk debugId's\n\t */\n\tget debugId() {\n\t\treturn Array.from(this.chunks, x => x.debugId).join(\"+\");\n\t}\n\n\t/**\n\t * get a unique id for ChunkGroup, made up of its member Chunk id's\n\t * @returns {string} a unique concatenation of chunk ids\n\t */\n\tget id() {\n\t\treturn Array.from(this.chunks, x => x.id).join(\"+\");\n\t}\n\n\t/**\n\t * Performs an unshift of a specific chunk\n\t * @param {Chunk} chunk chunk being unshifted\n\t * @returns {boolean} returns true if attempted chunk shift is accepted\n\t */\n\tunshiftChunk(chunk) {\n\t\tconst oldIdx = this.chunks.indexOf(chunk);\n\t\tif (oldIdx > 0) {\n\t\t\tthis.chunks.splice(oldIdx, 1);\n\t\t\tthis.chunks.unshift(chunk);\n\t\t} else if (oldIdx < 0) {\n\t\t\tthis.chunks.unshift(chunk);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * inserts a chunk before another existing chunk in group\n\t * @param {Chunk} chunk Chunk being inserted\n\t * @param {Chunk} before Placeholder/target chunk marking new chunk insertion point\n\t * @returns {boolean} return true if insertion was successful\n\t */\n\tinsertChunk(chunk, before) {\n\t\tconst oldIdx = this.chunks.indexOf(chunk);\n\t\tconst idx = this.chunks.indexOf(before);\n\t\tif (idx < 0) {\n\t\t\tthrow new Error(\"before chunk not found\");\n\t\t}\n\t\tif (oldIdx >= 0 && oldIdx > idx) {\n\t\t\tthis.chunks.splice(oldIdx, 1);\n\t\t\tthis.chunks.splice(idx, 0, chunk);\n\t\t} else if (oldIdx < 0) {\n\t\t\tthis.chunks.splice(idx, 0, chunk);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * add a chunk into ChunkGroup. Is pushed on or prepended\n\t * @param {Chunk} chunk chunk being pushed into ChunkGroupS\n\t * @returns {boolean} returns true if chunk addition was successful.\n\t */\n\tpushChunk(chunk) {\n\t\tconst oldIdx = this.chunks.indexOf(chunk);\n\t\tif (oldIdx >= 0) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.chunks.push(chunk);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Chunk} oldChunk chunk to be replaced\n\t * @param {Chunk} newChunk New chunk that will be replaced with\n\t * @returns {boolean} returns true if the replacement was successful\n\t */\n\treplaceChunk(oldChunk, newChunk) {\n\t\tconst oldIdx = this.chunks.indexOf(oldChunk);\n\t\tif (oldIdx < 0) return false;\n\t\tconst newIdx = this.chunks.indexOf(newChunk);\n\t\tif (newIdx < 0) {\n\t\t\tthis.chunks[oldIdx] = newChunk;\n\t\t\treturn true;\n\t\t}\n\t\tif (newIdx < oldIdx) {\n\t\t\tthis.chunks.splice(oldIdx, 1);\n\t\t\treturn true;\n\t\t} else if (newIdx !== oldIdx) {\n\t\t\tthis.chunks[oldIdx] = newChunk;\n\t\t\tthis.chunks.splice(newIdx, 1);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk chunk to remove\n\t * @returns {boolean} returns true if chunk was removed\n\t */\n\tremoveChunk(chunk) {\n\t\tconst idx = this.chunks.indexOf(chunk);\n\t\tif (idx >= 0) {\n\t\t\tthis.chunks.splice(idx, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {boolean} true, when this chunk group will be loaded on initial page load\n\t */\n\tisInitial() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} group chunk group to add\n\t * @returns {boolean} returns true if chunk group was added\n\t */\n\taddChild(group) {\n\t\tconst size = this._children.size;\n\t\tthis._children.add(group);\n\t\treturn size !== this._children.size;\n\t}\n\n\t/**\n\t * @returns {ChunkGroup[]} returns the children of this group\n\t */\n\tgetChildren() {\n\t\treturn this._children.getFromCache(getArray);\n\t}\n\n\tgetNumberOfChildren() {\n\t\treturn this._children.size;\n\t}\n\n\tget childrenIterable() {\n\t\treturn this._children;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} group the chunk group to remove\n\t * @returns {boolean} returns true if the chunk group was removed\n\t */\n\tremoveChild(group) {\n\t\tif (!this._children.has(group)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._children.delete(group);\n\t\tgroup.removeParent(this);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} parentChunk the parent group to be added into\n\t * @returns {boolean} returns true if this chunk group was added to the parent group\n\t */\n\taddParent(parentChunk) {\n\t\tif (!this._parents.has(parentChunk)) {\n\t\t\tthis._parents.add(parentChunk);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {ChunkGroup[]} returns the parents of this group\n\t */\n\tgetParents() {\n\t\treturn this._parents.getFromCache(getArray);\n\t}\n\n\tgetNumberOfParents() {\n\t\treturn this._parents.size;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} parent the parent group\n\t * @returns {boolean} returns true if the parent group contains this group\n\t */\n\thasParent(parent) {\n\t\treturn this._parents.has(parent);\n\t}\n\n\tget parentsIterable() {\n\t\treturn this._parents;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the parent group\n\t * @returns {boolean} returns true if this group has been removed from the parent\n\t */\n\tremoveParent(chunkGroup) {\n\t\tif (this._parents.delete(chunkGroup)) {\n\t\t\tchunkGroup.removeChild(this);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Entrypoint} entrypoint entrypoint to add\n\t * @returns {boolean} returns true if entrypoint was added\n\t */\n\taddAsyncEntrypoint(entrypoint) {\n\t\tconst size = this._asyncEntrypoints.size;\n\t\tthis._asyncEntrypoints.add(entrypoint);\n\t\treturn size !== this._asyncEntrypoints.size;\n\t}\n\n\tget asyncEntrypointsIterable() {\n\t\treturn this._asyncEntrypoints;\n\t}\n\n\t/**\n\t * @returns {Array} an array containing the blocks\n\t */\n\tgetBlocks() {\n\t\treturn this._blocks.getFromCache(getArray);\n\t}\n\n\tgetNumberOfBlocks() {\n\t\treturn this._blocks.size;\n\t}\n\n\thasBlock(block) {\n\t\treturn this._blocks.has(block);\n\t}\n\n\t/**\n\t * @returns {Iterable<AsyncDependenciesBlock>} blocks\n\t */\n\tget blocksIterable() {\n\t\treturn this._blocks;\n\t}\n\n\t/**\n\t * @param {AsyncDependenciesBlock} block a block\n\t * @returns {boolean} false, if block was already added\n\t */\n\taddBlock(block) {\n\t\tif (!this._blocks.has(block)) {\n\t\t\tthis._blocks.add(block);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Module} module origin module\n\t * @param {DependencyLocation} loc location of the reference in the origin module\n\t * @param {string} request request name of the reference\n\t * @returns {void}\n\t */\n\taddOrigin(module, loc, request) {\n\t\tthis.origins.push({\n\t\t\tmodule,\n\t\t\tloc,\n\t\t\trequest\n\t\t});\n\t}\n\n\t/**\n\t * @returns {string[]} the files contained this chunk group\n\t */\n\tgetFiles() {\n\t\tconst files = new Set();\n\n\t\tfor (const chunk of this.chunks) {\n\t\t\tfor (const file of chunk.files) {\n\t\t\t\tfiles.add(file);\n\t\t\t}\n\t\t}\n\n\t\treturn Array.from(files);\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tremove() {\n\t\t// cleanup parents\n\t\tfor (const parentChunkGroup of this._parents) {\n\t\t\t// remove this chunk from its parents\n\t\t\tparentChunkGroup._children.delete(this);\n\n\t\t\t// cleanup \"sub chunks\"\n\t\t\tfor (const chunkGroup of this._children) {\n\t\t\t\t/**\n\t\t\t\t * remove this chunk as \"intermediary\" and connect\n\t\t\t\t * it \"sub chunks\" and parents directly\n\t\t\t\t */\n\t\t\t\t// add parent to each \"sub chunk\"\n\t\t\t\tchunkGroup.addParent(parentChunkGroup);\n\t\t\t\t// add \"sub chunk\" to parent\n\t\t\t\tparentChunkGroup.addChild(chunkGroup);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * we need to iterate again over the children\n\t\t * to remove this from the child's parents.\n\t\t * This can not be done in the above loop\n\t\t * as it is not guaranteed that `this._parents` contains anything.\n\t\t */\n\t\tfor (const chunkGroup of this._children) {\n\t\t\t// remove this as parent of every \"sub chunk\"\n\t\t\tchunkGroup._parents.delete(this);\n\t\t}\n\n\t\t// remove chunks\n\t\tfor (const chunk of this.chunks) {\n\t\t\tchunk.removeGroup(this);\n\t\t}\n\t}\n\n\tsortItems() {\n\t\tthis.origins.sort(sortOrigin);\n\t}\n\n\t/**\n\t * Sorting predicate which allows current ChunkGroup to be compared against another.\n\t * Sorting values are based off of number of chunks in ChunkGroup.\n\t *\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {ChunkGroup} otherGroup the chunkGroup to compare this against\n\t * @returns {-1|0|1} sort position for comparison\n\t */\n\tcompareTo(chunkGraph, otherGroup) {\n\t\tif (this.chunks.length > otherGroup.chunks.length) return -1;\n\t\tif (this.chunks.length < otherGroup.chunks.length) return 1;\n\t\treturn compareIterables(compareChunks(chunkGraph))(\n\t\t\tthis.chunks,\n\t\t\totherGroup.chunks\n\t\t);\n\t}\n\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @returns {Record<string, ChunkGroup[]>} mapping from children type to ordered list of ChunkGroups\n\t */\n\tgetChildrenByOrders(moduleGraph, chunkGraph) {\n\t\t/** @type {Map<string, {order: number, group: ChunkGroup}[]>} */\n\t\tconst lists = new Map();\n\t\tfor (const childGroup of this._children) {\n\t\t\tfor (const key of Object.keys(childGroup.options)) {\n\t\t\t\tif (key.endsWith(\"Order\")) {\n\t\t\t\t\tconst name = key.substr(0, key.length - \"Order\".length);\n\t\t\t\t\tlet list = lists.get(name);\n\t\t\t\t\tif (list === undefined) {\n\t\t\t\t\t\tlists.set(name, (list = []));\n\t\t\t\t\t}\n\t\t\t\t\tlist.push({\n\t\t\t\t\t\torder: childGroup.options[key],\n\t\t\t\t\t\tgroup: childGroup\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/** @type {Record<string, ChunkGroup[]>} */\n\t\tconst result = Object.create(null);\n\t\tfor (const [name, list] of lists) {\n\t\t\tlist.sort((a, b) => {\n\t\t\t\tconst cmp = b.order - a.order;\n\t\t\t\tif (cmp !== 0) return cmp;\n\t\t\t\treturn a.group.compareTo(chunkGraph, b.group);\n\t\t\t});\n\t\t\tresult[name] = list.map(i => i.group);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Sets the top-down index of a module in this ChunkGroup\n\t * @param {Module} module module for which the index should be set\n\t * @param {number} index the index of the module\n\t * @returns {void}\n\t */\n\tsetModulePreOrderIndex(module, index) {\n\t\tthis._modulePreOrderIndices.set(module, index);\n\t}\n\n\t/**\n\t * Gets the top-down index of a module in this ChunkGroup\n\t * @param {Module} module the module\n\t * @returns {number} index\n\t */\n\tgetModulePreOrderIndex(module) {\n\t\treturn this._modulePreOrderIndices.get(module);\n\t}\n\n\t/**\n\t * Sets the bottom-up index of a module in this ChunkGroup\n\t * @param {Module} module module for which the index should be set\n\t * @param {number} index the index of the module\n\t * @returns {void}\n\t */\n\tsetModulePostOrderIndex(module, index) {\n\t\tthis._modulePostOrderIndices.set(module, index);\n\t}\n\n\t/**\n\t * Gets the bottom-up index of a module in this ChunkGroup\n\t * @param {Module} module the module\n\t * @returns {number} index\n\t */\n\tgetModulePostOrderIndex(module) {\n\t\treturn this._modulePostOrderIndices.get(module);\n\t}\n\n\t/* istanbul ignore next */\n\tcheckConstraints() {\n\t\tconst chunk = this;\n\t\tfor (const child of chunk._children) {\n\t\t\tif (!child._parents.has(chunk)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`checkConstraints: child missing parent ${chunk.debugId} -> ${child.debugId}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tfor (const parentChunk of chunk._parents) {\n\t\t\tif (!parentChunk._children.has(chunk)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`checkConstraints: parent missing child ${parentChunk.debugId} <- ${chunk.debugId}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\nChunkGroup.prototype.getModuleIndex = util.deprecate(\n\tChunkGroup.prototype.getModulePreOrderIndex,\n\t\"ChunkGroup.getModuleIndex was renamed to getModulePreOrderIndex\",\n\t\"DEP_WEBPACK_CHUNK_GROUP_GET_MODULE_INDEX\"\n);\n\nChunkGroup.prototype.getModuleIndex2 = util.deprecate(\n\tChunkGroup.prototype.getModulePostOrderIndex,\n\t\"ChunkGroup.getModuleIndex2 was renamed to getModulePostOrderIndex\",\n\t\"DEP_WEBPACK_CHUNK_GROUP_GET_MODULE_INDEX_2\"\n);\n\nmodule.exports = ChunkGroup;\n"]},"metadata":{},"sourceType":"script"}