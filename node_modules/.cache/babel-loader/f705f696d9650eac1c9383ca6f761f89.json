{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  getMap,\n  getSourceAndMap\n} = require(\"./helpers/getFromStreamChunks\");\n\nconst streamChunks = require(\"./helpers/streamChunks\");\n\nconst Source = require(\"./Source\");\n\nconst splitIntoLines = require(\"./helpers/splitIntoLines\"); // since v8 7.0, Array.prototype.sort is stable\n\n\nconst hasStableSort = typeof process === \"object\" && process.versions && typeof process.versions.v8 === \"string\" && !/^[0-6]\\./.test(process.versions.v8); // This is larger than max string length\n\nconst MAX_SOURCE_POSITION = 0x20000000;\n\nclass Replacement {\n  constructor(start, end, content, name) {\n    this.start = start;\n    this.end = end;\n    this.content = content;\n    this.name = name;\n\n    if (!hasStableSort) {\n      this.index = -1;\n    }\n  }\n\n}\n\nclass ReplaceSource extends Source {\n  constructor(source, name) {\n    super();\n    this._source = source;\n    this._name = name;\n    /** @type {Replacement[]} */\n\n    this._replacements = [];\n    this._isSorted = true;\n  }\n\n  getName() {\n    return this._name;\n  }\n\n  getReplacements() {\n    this._sortReplacements();\n\n    return this._replacements;\n  }\n\n  replace(start, end, newValue, name) {\n    if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + typeof newValue);\n\n    this._replacements.push(new Replacement(start, end, newValue, name));\n\n    this._isSorted = false;\n  }\n\n  insert(pos, newValue, name) {\n    if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + typeof newValue + \": \" + newValue);\n\n    this._replacements.push(new Replacement(pos, pos - 1, newValue, name));\n\n    this._isSorted = false;\n  }\n\n  source() {\n    if (this._replacements.length === 0) {\n      return this._source.source();\n    }\n\n    let current = this._source.source();\n\n    let pos = 0;\n    const result = [];\n\n    this._sortReplacements();\n\n    for (const replacement of this._replacements) {\n      const start = Math.floor(replacement.start);\n      const end = Math.floor(replacement.end + 1);\n\n      if (pos < start) {\n        const offset = start - pos;\n        result.push(current.slice(0, offset));\n        current = current.slice(offset);\n        pos = start;\n      }\n\n      result.push(replacement.content);\n\n      if (pos < end) {\n        const offset = end - pos;\n        current = current.slice(offset);\n        pos = end;\n      }\n    }\n\n    result.push(current);\n    return result.join(\"\");\n  }\n\n  map(options) {\n    if (this._replacements.length === 0) {\n      return this._source.map(options);\n    }\n\n    return getMap(this, options);\n  }\n\n  sourceAndMap(options) {\n    if (this._replacements.length === 0) {\n      return this._source.sourceAndMap(options);\n    }\n\n    return getSourceAndMap(this, options);\n  }\n\n  original() {\n    return this._source;\n  }\n\n  _sortReplacements() {\n    if (this._isSorted) return;\n\n    if (hasStableSort) {\n      this._replacements.sort(function (a, b) {\n        const diff1 = a.start - b.start;\n        if (diff1 !== 0) return diff1;\n        const diff2 = a.end - b.end;\n        if (diff2 !== 0) return diff2;\n        return 0;\n      });\n    } else {\n      this._replacements.forEach((repl, i) => repl.index = i);\n\n      this._replacements.sort(function (a, b) {\n        const diff1 = a.start - b.start;\n        if (diff1 !== 0) return diff1;\n        const diff2 = a.end - b.end;\n        if (diff2 !== 0) return diff2;\n        return a.index - b.index;\n      });\n    }\n\n    this._isSorted = true;\n  }\n\n  streamChunks(options, onChunk, onSource, onName) {\n    this._sortReplacements();\n\n    const repls = this._replacements;\n    let pos = 0;\n    let i = 0;\n    let replacmentEnd = -1;\n    let nextReplacement = i < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION;\n    let generatedLineOffset = 0;\n    let generatedColumnOffset = 0;\n    let generatedColumnOffsetLine = 0;\n    const sourceContents = [];\n    const nameMapping = new Map();\n    const nameIndexMapping = [];\n\n    const checkOriginalContent = (sourceIndex, line, column, expectedChunk) => {\n      let content = sourceIndex < sourceContents.length ? sourceContents[sourceIndex] : undefined;\n      if (content === undefined) return false;\n\n      if (typeof content === \"string\") {\n        content = splitIntoLines(content);\n        sourceContents[sourceIndex] = content;\n      }\n\n      const contentLine = line <= content.length ? content[line - 1] : null;\n      if (contentLine === null) return false;\n      return contentLine.slice(column, column + expectedChunk.length) === expectedChunk;\n    };\n\n    let {\n      generatedLine,\n      generatedColumn\n    } = streamChunks(this._source, Object.assign({}, options, {\n      finalSource: false\n    }), (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {\n      let chunkPos = 0;\n      let endPos = pos + chunk.length; // Skip over when it has been replaced\n\n      if (replacmentEnd > pos) {\n        // Skip over the whole chunk\n        if (replacmentEnd >= endPos) {\n          const line = generatedLine + generatedLineOffset;\n\n          if (chunk.endsWith(\"\\n\")) {\n            generatedLineOffset--;\n\n            if (generatedColumnOffsetLine === line) {\n              // undo exiting corrections form the current line\n              generatedColumnOffset += generatedColumn;\n            }\n          } else if (generatedColumnOffsetLine === line) {\n            generatedColumnOffset -= chunk.length;\n          } else {\n            generatedColumnOffset = -chunk.length;\n            generatedColumnOffsetLine = line;\n          }\n\n          pos = endPos;\n          return;\n        } // Partially skip over chunk\n\n\n        chunkPos = replacmentEnd - pos;\n\n        if (checkOriginalContent(sourceIndex, originalLine, originalColumn, chunk.slice(0, chunkPos))) {\n          originalColumn += chunkPos;\n        }\n\n        pos += chunkPos;\n        const line = generatedLine + generatedLineOffset;\n\n        if (generatedColumnOffsetLine === line) {\n          generatedColumnOffset -= chunkPos;\n        } else {\n          generatedColumnOffset = -chunkPos;\n          generatedColumnOffsetLine = line;\n        }\n\n        generatedColumn += chunkPos;\n      } // Is a replacement in the chunk?\n\n\n      if (nextReplacement < endPos) {\n        do {\n          let line = generatedLine + generatedLineOffset;\n\n          if (nextReplacement > pos) {\n            // Emit chunk until replacement\n            const offset = nextReplacement - pos;\n            const chunkSlice = chunk.slice(chunkPos, chunkPos + offset);\n            onChunk(chunkSlice, line, generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0), sourceIndex, originalLine, originalColumn, nameIndex < 0 || nameIndex >= nameIndexMapping.length ? -1 : nameIndexMapping[nameIndex]);\n            generatedColumn += offset;\n            chunkPos += offset;\n            pos = nextReplacement;\n\n            if (checkOriginalContent(sourceIndex, originalLine, originalColumn, chunkSlice)) {\n              originalColumn += chunkSlice.length;\n            }\n          } // Insert replacement content splitted into chunks by lines\n\n\n          const {\n            content,\n            name\n          } = repls[i];\n          let matches = splitIntoLines(content);\n          let replacementNameIndex = nameIndex;\n\n          if (sourceIndex >= 0 && name) {\n            let globalIndex = nameMapping.get(name);\n\n            if (globalIndex === undefined) {\n              globalIndex = nameMapping.size;\n              nameMapping.set(name, globalIndex);\n              onName(globalIndex, name);\n            }\n\n            replacementNameIndex = globalIndex;\n          }\n\n          for (let m = 0; m < matches.length; m++) {\n            const contentLine = matches[m];\n            onChunk(contentLine, line, generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0), sourceIndex, originalLine, originalColumn, replacementNameIndex); // Only the first chunk has name assigned\n\n            replacementNameIndex = -1;\n\n            if (m === matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\n              if (generatedColumnOffsetLine === line) {\n                generatedColumnOffset += contentLine.length;\n              } else {\n                generatedColumnOffset = contentLine.length;\n                generatedColumnOffsetLine = line;\n              }\n            } else {\n              generatedLineOffset++;\n              line++;\n              generatedColumnOffset = -generatedColumn;\n              generatedColumnOffsetLine = line;\n            }\n          } // Remove replaced content by settings this variable\n\n\n          replacmentEnd = Math.max(replacmentEnd, Math.floor(repls[i].end + 1)); // Move to next replacment\n\n          i++;\n          nextReplacement = i < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION; // Skip over when it has been replaced\n\n          const offset = chunk.length - endPos + replacmentEnd - chunkPos;\n\n          if (offset > 0) {\n            // Skip over whole chunk\n            if (replacmentEnd >= endPos) {\n              let line = generatedLine + generatedLineOffset;\n\n              if (chunk.endsWith(\"\\n\")) {\n                generatedLineOffset--;\n\n                if (generatedColumnOffsetLine === line) {\n                  // undo exiting corrections form the current line\n                  generatedColumnOffset += generatedColumn;\n                }\n              } else if (generatedColumnOffsetLine === line) {\n                generatedColumnOffset -= chunk.length - chunkPos;\n              } else {\n                generatedColumnOffset = chunkPos - chunk.length;\n                generatedColumnOffsetLine = line;\n              }\n\n              pos = endPos;\n              return;\n            } // Partially skip over chunk\n\n\n            const line = generatedLine + generatedLineOffset;\n\n            if (checkOriginalContent(sourceIndex, originalLine, originalColumn, chunk.slice(chunkPos, chunkPos + offset))) {\n              originalColumn += offset;\n            }\n\n            chunkPos += offset;\n            pos += offset;\n\n            if (generatedColumnOffsetLine === line) {\n              generatedColumnOffset -= offset;\n            } else {\n              generatedColumnOffset = -offset;\n              generatedColumnOffsetLine = line;\n            }\n\n            generatedColumn += offset;\n          }\n        } while (nextReplacement < endPos);\n      } // Emit remaining chunk\n\n\n      if (chunkPos < chunk.length) {\n        const chunkSlice = chunkPos === 0 ? chunk : chunk.slice(chunkPos);\n        const line = generatedLine + generatedLineOffset;\n        onChunk(chunkSlice, line, generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0), sourceIndex, originalLine, originalColumn, nameIndex < 0 ? -1 : nameIndexMapping[nameIndex]);\n      }\n\n      pos = endPos;\n    }, (sourceIndex, source, sourceContent) => {\n      while (sourceContents.length < sourceIndex) sourceContents.push(undefined);\n\n      sourceContents[sourceIndex] = sourceContent;\n      onSource(sourceIndex, source, sourceContent);\n    }, (nameIndex, name) => {\n      let globalIndex = nameMapping.get(name);\n\n      if (globalIndex === undefined) {\n        globalIndex = nameMapping.size;\n        nameMapping.set(name, globalIndex);\n        onName(globalIndex, name);\n      }\n\n      nameIndexMapping[nameIndex] = globalIndex;\n    }); // Handle remaining replacements\n\n    let remainer = \"\";\n\n    for (; i < repls.length; i++) {\n      remainer += repls[i].content;\n    } // Insert remaining replacements content splitted into chunks by lines\n\n\n    let line = generatedLine + generatedLineOffset;\n    let matches = splitIntoLines(remainer);\n\n    for (let m = 0; m < matches.length; m++) {\n      const contentLine = matches[m];\n      onChunk(contentLine, line, generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0), -1, -1, -1, -1);\n\n      if (m === matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\n        if (generatedColumnOffsetLine === line) {\n          generatedColumnOffset += contentLine.length;\n        } else {\n          generatedColumnOffset = contentLine.length;\n          generatedColumnOffsetLine = line;\n        }\n      } else {\n        generatedLineOffset++;\n        line++;\n        generatedColumnOffset = -generatedColumn;\n        generatedColumnOffsetLine = line;\n      }\n    }\n\n    return {\n      generatedLine: line,\n      generatedColumn: generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0)\n    };\n  }\n\n  updateHash(hash) {\n    this._sortReplacements();\n\n    hash.update(\"ReplaceSource\");\n\n    this._source.updateHash(hash);\n\n    hash.update(this._name || \"\");\n\n    for (const repl of this._replacements) {\n      hash.update(`${repl.start}${repl.end}${repl.content}${repl.name}`);\n    }\n  }\n\n}\n\nmodule.exports = ReplaceSource;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack-sources/lib/ReplaceSource.js"],"names":["getMap","getSourceAndMap","require","streamChunks","Source","splitIntoLines","hasStableSort","process","versions","v8","test","MAX_SOURCE_POSITION","Replacement","constructor","start","end","content","name","index","ReplaceSource","source","_source","_name","_replacements","_isSorted","getName","getReplacements","_sortReplacements","replace","newValue","Error","push","insert","pos","length","current","result","replacement","Math","floor","offset","slice","join","map","options","sourceAndMap","original","sort","a","b","diff1","diff2","forEach","repl","i","onChunk","onSource","onName","repls","replacmentEnd","nextReplacement","generatedLineOffset","generatedColumnOffset","generatedColumnOffsetLine","sourceContents","nameMapping","Map","nameIndexMapping","checkOriginalContent","sourceIndex","line","column","expectedChunk","undefined","contentLine","generatedLine","generatedColumn","Object","assign","finalSource","chunk","originalLine","originalColumn","nameIndex","chunkPos","endPos","endsWith","chunkSlice","matches","replacementNameIndex","globalIndex","get","size","set","m","max","sourceContent","remainer","updateHash","hash","update","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst { getMap, getSourceAndMap } = require(\"./helpers/getFromStreamChunks\");\nconst streamChunks = require(\"./helpers/streamChunks\");\nconst Source = require(\"./Source\");\nconst splitIntoLines = require(\"./helpers/splitIntoLines\");\n\n// since v8 7.0, Array.prototype.sort is stable\nconst hasStableSort =\n\ttypeof process === \"object\" &&\n\tprocess.versions &&\n\ttypeof process.versions.v8 === \"string\" &&\n\t!/^[0-6]\\./.test(process.versions.v8);\n\n// This is larger than max string length\nconst MAX_SOURCE_POSITION = 0x20000000;\n\nclass Replacement {\n\tconstructor(start, end, content, name) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.content = content;\n\t\tthis.name = name;\n\t\tif (!hasStableSort) {\n\t\t\tthis.index = -1;\n\t\t}\n\t}\n}\n\nclass ReplaceSource extends Source {\n\tconstructor(source, name) {\n\t\tsuper();\n\t\tthis._source = source;\n\t\tthis._name = name;\n\t\t/** @type {Replacement[]} */\n\t\tthis._replacements = [];\n\t\tthis._isSorted = true;\n\t}\n\n\tgetName() {\n\t\treturn this._name;\n\t}\n\n\tgetReplacements() {\n\t\tthis._sortReplacements();\n\t\treturn this._replacements;\n\t}\n\n\treplace(start, end, newValue, name) {\n\t\tif (typeof newValue !== \"string\")\n\t\t\tthrow new Error(\n\t\t\t\t\"insertion must be a string, but is a \" + typeof newValue\n\t\t\t);\n\t\tthis._replacements.push(new Replacement(start, end, newValue, name));\n\t\tthis._isSorted = false;\n\t}\n\n\tinsert(pos, newValue, name) {\n\t\tif (typeof newValue !== \"string\")\n\t\t\tthrow new Error(\n\t\t\t\t\"insertion must be a string, but is a \" +\n\t\t\t\t\ttypeof newValue +\n\t\t\t\t\t\": \" +\n\t\t\t\t\tnewValue\n\t\t\t);\n\t\tthis._replacements.push(new Replacement(pos, pos - 1, newValue, name));\n\t\tthis._isSorted = false;\n\t}\n\n\tsource() {\n\t\tif (this._replacements.length === 0) {\n\t\t\treturn this._source.source();\n\t\t}\n\t\tlet current = this._source.source();\n\t\tlet pos = 0;\n\t\tconst result = [];\n\n\t\tthis._sortReplacements();\n\t\tfor (const replacement of this._replacements) {\n\t\t\tconst start = Math.floor(replacement.start);\n\t\t\tconst end = Math.floor(replacement.end + 1);\n\t\t\tif (pos < start) {\n\t\t\t\tconst offset = start - pos;\n\t\t\t\tresult.push(current.slice(0, offset));\n\t\t\t\tcurrent = current.slice(offset);\n\t\t\t\tpos = start;\n\t\t\t}\n\t\t\tresult.push(replacement.content);\n\t\t\tif (pos < end) {\n\t\t\t\tconst offset = end - pos;\n\t\t\t\tcurrent = current.slice(offset);\n\t\t\t\tpos = end;\n\t\t\t}\n\t\t}\n\t\tresult.push(current);\n\t\treturn result.join(\"\");\n\t}\n\n\tmap(options) {\n\t\tif (this._replacements.length === 0) {\n\t\t\treturn this._source.map(options);\n\t\t}\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\tif (this._replacements.length === 0) {\n\t\t\treturn this._source.sourceAndMap(options);\n\t\t}\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\toriginal() {\n\t\treturn this._source;\n\t}\n\n\t_sortReplacements() {\n\t\tif (this._isSorted) return;\n\t\tif (hasStableSort) {\n\t\t\tthis._replacements.sort(function (a, b) {\n\t\t\t\tconst diff1 = a.start - b.start;\n\t\t\t\tif (diff1 !== 0) return diff1;\n\t\t\t\tconst diff2 = a.end - b.end;\n\t\t\t\tif (diff2 !== 0) return diff2;\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t} else {\n\t\t\tthis._replacements.forEach((repl, i) => (repl.index = i));\n\t\t\tthis._replacements.sort(function (a, b) {\n\t\t\t\tconst diff1 = a.start - b.start;\n\t\t\t\tif (diff1 !== 0) return diff1;\n\t\t\t\tconst diff2 = a.end - b.end;\n\t\t\t\tif (diff2 !== 0) return diff2;\n\t\t\t\treturn a.index - b.index;\n\t\t\t});\n\t\t}\n\t\tthis._isSorted = true;\n\t}\n\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tthis._sortReplacements();\n\t\tconst repls = this._replacements;\n\t\tlet pos = 0;\n\t\tlet i = 0;\n\t\tlet replacmentEnd = -1;\n\t\tlet nextReplacement =\n\t\t\ti < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION;\n\t\tlet generatedLineOffset = 0;\n\t\tlet generatedColumnOffset = 0;\n\t\tlet generatedColumnOffsetLine = 0;\n\t\tconst sourceContents = [];\n\t\tconst nameMapping = new Map();\n\t\tconst nameIndexMapping = [];\n\t\tconst checkOriginalContent = (sourceIndex, line, column, expectedChunk) => {\n\t\t\tlet content =\n\t\t\t\tsourceIndex < sourceContents.length\n\t\t\t\t\t? sourceContents[sourceIndex]\n\t\t\t\t\t: undefined;\n\t\t\tif (content === undefined) return false;\n\t\t\tif (typeof content === \"string\") {\n\t\t\t\tcontent = splitIntoLines(content);\n\t\t\t\tsourceContents[sourceIndex] = content;\n\t\t\t}\n\t\t\tconst contentLine = line <= content.length ? content[line - 1] : null;\n\t\t\tif (contentLine === null) return false;\n\t\t\treturn (\n\t\t\t\tcontentLine.slice(column, column + expectedChunk.length) ===\n\t\t\t\texpectedChunk\n\t\t\t);\n\t\t};\n\t\tlet { generatedLine, generatedColumn } = streamChunks(\n\t\t\tthis._source,\n\t\t\tObject.assign({}, options, { finalSource: false }),\n\t\t\t(\n\t\t\t\tchunk,\n\t\t\t\tgeneratedLine,\n\t\t\t\tgeneratedColumn,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\tnameIndex\n\t\t\t) => {\n\t\t\t\tlet chunkPos = 0;\n\t\t\t\tlet endPos = pos + chunk.length;\n\n\t\t\t\t// Skip over when it has been replaced\n\t\t\t\tif (replacmentEnd > pos) {\n\t\t\t\t\t// Skip over the whole chunk\n\t\t\t\t\tif (replacmentEnd >= endPos) {\n\t\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\tif (chunk.endsWith(\"\\n\")) {\n\t\t\t\t\t\t\tgeneratedLineOffset--;\n\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t// undo exiting corrections form the current line\n\t\t\t\t\t\t\t\tgeneratedColumnOffset += generatedColumn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\tgeneratedColumnOffset -= chunk.length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgeneratedColumnOffset = -chunk.length;\n\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos = endPos;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Partially skip over chunk\n\t\t\t\t\tchunkPos = replacmentEnd - pos;\n\t\t\t\t\tif (\n\t\t\t\t\t\tcheckOriginalContent(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\tchunk.slice(0, chunkPos)\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\toriginalColumn += chunkPos;\n\t\t\t\t\t}\n\t\t\t\t\tpos += chunkPos;\n\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\tgeneratedColumnOffset -= chunkPos;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgeneratedColumnOffset = -chunkPos;\n\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t}\n\t\t\t\t\tgeneratedColumn += chunkPos;\n\t\t\t\t}\n\n\t\t\t\t// Is a replacement in the chunk?\n\t\t\t\tif (nextReplacement < endPos) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tlet line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\tif (nextReplacement > pos) {\n\t\t\t\t\t\t\t// Emit chunk until replacement\n\t\t\t\t\t\t\tconst offset = nextReplacement - pos;\n\t\t\t\t\t\t\tconst chunkSlice = chunk.slice(chunkPos, chunkPos + offset);\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tchunkSlice,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tgeneratedColumn +\n\t\t\t\t\t\t\t\t\t(line === generatedColumnOffsetLine\n\t\t\t\t\t\t\t\t\t\t? generatedColumnOffset\n\t\t\t\t\t\t\t\t\t\t: 0),\n\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\tnameIndex < 0 || nameIndex >= nameIndexMapping.length\n\t\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t\t: nameIndexMapping[nameIndex]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tgeneratedColumn += offset;\n\t\t\t\t\t\t\tchunkPos += offset;\n\t\t\t\t\t\t\tpos = nextReplacement;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcheckOriginalContent(\n\t\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\t\tchunkSlice\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\toriginalColumn += chunkSlice.length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Insert replacement content splitted into chunks by lines\n\t\t\t\t\t\tconst { content, name } = repls[i];\n\t\t\t\t\t\tlet matches = splitIntoLines(content);\n\t\t\t\t\t\tlet replacementNameIndex = nameIndex;\n\t\t\t\t\t\tif (sourceIndex >= 0 && name) {\n\t\t\t\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\t\t\tglobalIndex = nameMapping.size;\n\t\t\t\t\t\t\t\tnameMapping.set(name, globalIndex);\n\t\t\t\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treplacementNameIndex = globalIndex;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let m = 0; m < matches.length; m++) {\n\t\t\t\t\t\t\tconst contentLine = matches[m];\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tcontentLine,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tgeneratedColumn +\n\t\t\t\t\t\t\t\t\t(line === generatedColumnOffsetLine\n\t\t\t\t\t\t\t\t\t\t? generatedColumnOffset\n\t\t\t\t\t\t\t\t\t\t: 0),\n\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\treplacementNameIndex\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Only the first chunk has name assigned\n\t\t\t\t\t\t\treplacementNameIndex = -1;\n\n\t\t\t\t\t\t\tif (m === matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\n\t\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset += contentLine.length;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset = contentLine.length;\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgeneratedLineOffset++;\n\t\t\t\t\t\t\t\tline++;\n\t\t\t\t\t\t\t\tgeneratedColumnOffset = -generatedColumn;\n\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Remove replaced content by settings this variable\n\t\t\t\t\t\treplacmentEnd = Math.max(\n\t\t\t\t\t\t\treplacmentEnd,\n\t\t\t\t\t\t\tMath.floor(repls[i].end + 1)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Move to next replacment\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tnextReplacement =\n\t\t\t\t\t\t\ti < repls.length\n\t\t\t\t\t\t\t\t? Math.floor(repls[i].start)\n\t\t\t\t\t\t\t\t: MAX_SOURCE_POSITION;\n\n\t\t\t\t\t\t// Skip over when it has been replaced\n\t\t\t\t\t\tconst offset = chunk.length - endPos + replacmentEnd - chunkPos;\n\t\t\t\t\t\tif (offset > 0) {\n\t\t\t\t\t\t\t// Skip over whole chunk\n\t\t\t\t\t\t\tif (replacmentEnd >= endPos) {\n\t\t\t\t\t\t\t\tlet line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\t\t\tif (chunk.endsWith(\"\\n\")) {\n\t\t\t\t\t\t\t\t\tgeneratedLineOffset--;\n\t\t\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t\t\t// undo exiting corrections form the current line\n\t\t\t\t\t\t\t\t\t\tgeneratedColumnOffset += generatedColumn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset -= chunk.length - chunkPos;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset = chunkPos - chunk.length;\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpos = endPos;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Partially skip over chunk\n\t\t\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcheckOriginalContent(\n\t\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\t\tchunk.slice(chunkPos, chunkPos + offset)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\toriginalColumn += offset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchunkPos += offset;\n\t\t\t\t\t\t\tpos += offset;\n\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\tgeneratedColumnOffset -= offset;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgeneratedColumnOffset = -offset;\n\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgeneratedColumn += offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (nextReplacement < endPos);\n\t\t\t\t}\n\n\t\t\t\t// Emit remaining chunk\n\t\t\t\tif (chunkPos < chunk.length) {\n\t\t\t\t\tconst chunkSlice = chunkPos === 0 ? chunk : chunk.slice(chunkPos);\n\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\tonChunk(\n\t\t\t\t\t\tchunkSlice,\n\t\t\t\t\t\tline,\n\t\t\t\t\t\tgeneratedColumn +\n\t\t\t\t\t\t\t(line === generatedColumnOffsetLine ? generatedColumnOffset : 0),\n\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\tnameIndex < 0 ? -1 : nameIndexMapping[nameIndex]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tpos = endPos;\n\t\t\t},\n\t\t\t(sourceIndex, source, sourceContent) => {\n\t\t\t\twhile (sourceContents.length < sourceIndex)\n\t\t\t\t\tsourceContents.push(undefined);\n\t\t\t\tsourceContents[sourceIndex] = sourceContent;\n\t\t\t\tonSource(sourceIndex, source, sourceContent);\n\t\t\t},\n\t\t\t(nameIndex, name) => {\n\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\tglobalIndex = nameMapping.size;\n\t\t\t\t\tnameMapping.set(name, globalIndex);\n\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t}\n\t\t\t\tnameIndexMapping[nameIndex] = globalIndex;\n\t\t\t}\n\t\t);\n\n\t\t// Handle remaining replacements\n\t\tlet remainer = \"\";\n\t\tfor (; i < repls.length; i++) {\n\t\t\tremainer += repls[i].content;\n\t\t}\n\n\t\t// Insert remaining replacements content splitted into chunks by lines\n\t\tlet line = generatedLine + generatedLineOffset;\n\t\tlet matches = splitIntoLines(remainer);\n\t\tfor (let m = 0; m < matches.length; m++) {\n\t\t\tconst contentLine = matches[m];\n\t\t\tonChunk(\n\t\t\t\tcontentLine,\n\t\t\t\tline,\n\t\t\t\tgeneratedColumn +\n\t\t\t\t\t(line === generatedColumnOffsetLine ? generatedColumnOffset : 0),\n\t\t\t\t-1,\n\t\t\t\t-1,\n\t\t\t\t-1,\n\t\t\t\t-1\n\t\t\t);\n\n\t\t\tif (m === matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\n\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\tgeneratedColumnOffset += contentLine.length;\n\t\t\t\t} else {\n\t\t\t\t\tgeneratedColumnOffset = contentLine.length;\n\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgeneratedLineOffset++;\n\t\t\t\tline++;\n\t\t\t\tgeneratedColumnOffset = -generatedColumn;\n\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tgeneratedLine: line,\n\t\t\tgeneratedColumn:\n\t\t\t\tgeneratedColumn +\n\t\t\t\t(line === generatedColumnOffsetLine ? generatedColumnOffset : 0)\n\t\t};\n\t}\n\n\tupdateHash(hash) {\n\t\tthis._sortReplacements();\n\t\thash.update(\"ReplaceSource\");\n\t\tthis._source.updateHash(hash);\n\t\thash.update(this._name || \"\");\n\t\tfor (const repl of this._replacements) {\n\t\t\thash.update(`${repl.start}${repl.end}${repl.content}${repl.name}`);\n\t\t}\n\t}\n}\n\nmodule.exports = ReplaceSource;\n"]},"metadata":{},"sourceType":"script"}