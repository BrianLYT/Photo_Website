{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/** @typedef {import(\"./Resolver\")} Resolver */\n\n/** @typedef {import(\"./Resolver\").ResolveRequest} ResolveRequest */\n\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n\nmodule.exports = class ParsePlugin {\n  /**\n   * @param {string | ResolveStepHook} source source\n   * @param {Partial<ResolveRequest>} requestOptions request options\n   * @param {string | ResolveStepHook} target target\n   */\n  constructor(source, requestOptions, target) {\n    this.source = source;\n    this.requestOptions = requestOptions;\n    this.target = target;\n  }\n  /**\n   * @param {Resolver} resolver the resolver\n   * @returns {void}\n   */\n\n\n  apply(resolver) {\n    const target = resolver.ensureHook(this.target);\n    resolver.getHook(this.source).tapAsync(\"ParsePlugin\", (request, resolveContext, callback) => {\n      const parsed = resolver.parse(\n      /** @type {string} */\n      request.request);\n      const obj = { ...request,\n        ...parsed,\n        ...this.requestOptions\n      };\n\n      if (request.query && !parsed.query) {\n        obj.query = request.query;\n      }\n\n      if (request.fragment && !parsed.fragment) {\n        obj.fragment = request.fragment;\n      }\n\n      if (parsed && resolveContext.log) {\n        if (parsed.module) resolveContext.log(\"Parsed request is a module\");\n        if (parsed.directory) resolveContext.log(\"Parsed request is a directory\");\n      } // There is an edge-case where a request with # can be a path or a fragment -> try both\n\n\n      if (obj.request && !obj.query && obj.fragment) {\n        const directory = obj.fragment.endsWith(\"/\");\n        const alternative = { ...obj,\n          directory,\n          request: obj.request + (obj.directory ? \"/\" : \"\") + (directory ? obj.fragment.slice(0, -1) : obj.fragment),\n          fragment: \"\"\n        };\n        resolver.doResolve(target, alternative, null, resolveContext, (err, result) => {\n          if (err) return callback(err);\n          if (result) return callback(null, result);\n          resolver.doResolve(target, obj, null, resolveContext, callback);\n        });\n        return;\n      }\n\n      resolver.doResolve(target, obj, null, resolveContext, callback);\n    });\n  }\n\n};","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/enhanced-resolve/lib/ParsePlugin.js"],"names":["module","exports","ParsePlugin","constructor","source","requestOptions","target","apply","resolver","ensureHook","getHook","tapAsync","request","resolveContext","callback","parsed","parse","obj","query","fragment","log","directory","endsWith","alternative","slice","doResolve","err","result"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;AAEA;;AACA;;AACA;;AAEAA,MAAM,CAACC,OAAP,GAAiB,MAAMC,WAAN,CAAkB;AAClC;AACD;AACA;AACA;AACA;AACCC,EAAAA,WAAW,CAACC,MAAD,EAASC,cAAT,EAAyBC,MAAzB,EAAiC;AAC3C,SAAKF,MAAL,GAAcA,MAAd;AACA,SAAKC,cAAL,GAAsBA,cAAtB;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA;AAED;AACD;AACA;AACA;;;AACCC,EAAAA,KAAK,CAACC,QAAD,EAAW;AACf,UAAMF,MAAM,GAAGE,QAAQ,CAACC,UAAT,CAAoB,KAAKH,MAAzB,CAAf;AACAE,IAAAA,QAAQ,CACNE,OADF,CACU,KAAKN,MADf,EAEEO,QAFF,CAEW,aAFX,EAE0B,CAACC,OAAD,EAAUC,cAAV,EAA0BC,QAA1B,KAAuC;AAC/D,YAAMC,MAAM,GAAGP,QAAQ,CAACQ,KAAT;AAAe;AAAuBJ,MAAAA,OAAO,CAACA,OAA9C,CAAf;AACA,YAAMK,GAAG,GAAG,EAAE,GAAGL,OAAL;AAAc,WAAGG,MAAjB;AAAyB,WAAG,KAAKV;AAAjC,OAAZ;;AACA,UAAIO,OAAO,CAACM,KAAR,IAAiB,CAACH,MAAM,CAACG,KAA7B,EAAoC;AACnCD,QAAAA,GAAG,CAACC,KAAJ,GAAYN,OAAO,CAACM,KAApB;AACA;;AACD,UAAIN,OAAO,CAACO,QAAR,IAAoB,CAACJ,MAAM,CAACI,QAAhC,EAA0C;AACzCF,QAAAA,GAAG,CAACE,QAAJ,GAAeP,OAAO,CAACO,QAAvB;AACA;;AACD,UAAIJ,MAAM,IAAIF,cAAc,CAACO,GAA7B,EAAkC;AACjC,YAAIL,MAAM,CAACf,MAAX,EAAmBa,cAAc,CAACO,GAAf,CAAmB,4BAAnB;AACnB,YAAIL,MAAM,CAACM,SAAX,EACCR,cAAc,CAACO,GAAf,CAAmB,+BAAnB;AACD,OAb8D,CAc/D;;;AACA,UAAIH,GAAG,CAACL,OAAJ,IAAe,CAACK,GAAG,CAACC,KAApB,IAA6BD,GAAG,CAACE,QAArC,EAA+C;AAC9C,cAAME,SAAS,GAAGJ,GAAG,CAACE,QAAJ,CAAaG,QAAb,CAAsB,GAAtB,CAAlB;AACA,cAAMC,WAAW,GAAG,EACnB,GAAGN,GADgB;AAEnBI,UAAAA,SAFmB;AAGnBT,UAAAA,OAAO,EACNK,GAAG,CAACL,OAAJ,IACCK,GAAG,CAACI,SAAJ,GAAgB,GAAhB,GAAsB,EADvB,KAECA,SAAS,GAAGJ,GAAG,CAACE,QAAJ,CAAaK,KAAb,CAAmB,CAAnB,EAAsB,CAAC,CAAvB,CAAH,GAA+BP,GAAG,CAACE,QAF7C,CAJkB;AAOnBA,UAAAA,QAAQ,EAAE;AAPS,SAApB;AASAX,QAAAA,QAAQ,CAACiB,SAAT,CACCnB,MADD,EAECiB,WAFD,EAGC,IAHD,EAICV,cAJD,EAKC,CAACa,GAAD,EAAMC,MAAN,KAAiB;AAChB,cAAID,GAAJ,EAAS,OAAOZ,QAAQ,CAACY,GAAD,CAAf;AACT,cAAIC,MAAJ,EAAY,OAAOb,QAAQ,CAAC,IAAD,EAAOa,MAAP,CAAf;AACZnB,UAAAA,QAAQ,CAACiB,SAAT,CAAmBnB,MAAnB,EAA2BW,GAA3B,EAAgC,IAAhC,EAAsCJ,cAAtC,EAAsDC,QAAtD;AACA,SATF;AAWA;AACA;;AACDN,MAAAA,QAAQ,CAACiB,SAAT,CAAmBnB,MAAnB,EAA2BW,GAA3B,EAAgC,IAAhC,EAAsCJ,cAAtC,EAAsDC,QAAtD;AACA,KA1CF;AA2CA;;AA7DiC,CAAnC","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @typedef {import(\"./Resolver\")} Resolver */\n/** @typedef {import(\"./Resolver\").ResolveRequest} ResolveRequest */\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n\nmodule.exports = class ParsePlugin {\n\t/**\n\t * @param {string | ResolveStepHook} source source\n\t * @param {Partial<ResolveRequest>} requestOptions request options\n\t * @param {string | ResolveStepHook} target target\n\t */\n\tconstructor(source, requestOptions, target) {\n\t\tthis.source = source;\n\t\tthis.requestOptions = requestOptions;\n\t\tthis.target = target;\n\t}\n\n\t/**\n\t * @param {Resolver} resolver the resolver\n\t * @returns {void}\n\t */\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"ParsePlugin\", (request, resolveContext, callback) => {\n\t\t\t\tconst parsed = resolver.parse(/** @type {string} */ (request.request));\n\t\t\t\tconst obj = { ...request, ...parsed, ...this.requestOptions };\n\t\t\t\tif (request.query && !parsed.query) {\n\t\t\t\t\tobj.query = request.query;\n\t\t\t\t}\n\t\t\t\tif (request.fragment && !parsed.fragment) {\n\t\t\t\t\tobj.fragment = request.fragment;\n\t\t\t\t}\n\t\t\t\tif (parsed && resolveContext.log) {\n\t\t\t\t\tif (parsed.module) resolveContext.log(\"Parsed request is a module\");\n\t\t\t\t\tif (parsed.directory)\n\t\t\t\t\t\tresolveContext.log(\"Parsed request is a directory\");\n\t\t\t\t}\n\t\t\t\t// There is an edge-case where a request with # can be a path or a fragment -> try both\n\t\t\t\tif (obj.request && !obj.query && obj.fragment) {\n\t\t\t\t\tconst directory = obj.fragment.endsWith(\"/\");\n\t\t\t\t\tconst alternative = {\n\t\t\t\t\t\t...obj,\n\t\t\t\t\t\tdirectory,\n\t\t\t\t\t\trequest:\n\t\t\t\t\t\t\tobj.request +\n\t\t\t\t\t\t\t(obj.directory ? \"/\" : \"\") +\n\t\t\t\t\t\t\t(directory ? obj.fragment.slice(0, -1) : obj.fragment),\n\t\t\t\t\t\tfragment: \"\"\n\t\t\t\t\t};\n\t\t\t\t\tresolver.doResolve(\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\talternative,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tif (result) return callback(null, result);\n\t\t\t\t\t\t\tresolver.doResolve(target, obj, null, resolveContext, callback);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresolver.doResolve(target, obj, null, resolveContext, callback);\n\t\t\t});\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}