{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst arraySum = array => {\n  let sum = 0;\n\n  for (const item of array) sum += item;\n\n  return sum;\n};\n/**\n * @param {any[]} args items to be truncated\n * @param {number} maxLength maximum length of args including spaces between\n * @returns {string[]} truncated args\n */\n\n\nconst truncateArgs = (args, maxLength) => {\n  const lengths = args.map(a => `${a}`.length);\n  const availableLength = maxLength - lengths.length + 1;\n\n  if (availableLength > 0 && args.length === 1) {\n    if (availableLength >= args[0].length) {\n      return args;\n    } else if (availableLength > 3) {\n      return [\"...\" + args[0].slice(-availableLength + 3)];\n    } else {\n      return [args[0].slice(-availableLength)];\n    }\n  } // Check if there is space for at least 4 chars per arg\n\n\n  if (availableLength < arraySum(lengths.map(i => Math.min(i, 6)))) {\n    // remove args\n    if (args.length > 1) return truncateArgs(args.slice(0, args.length - 1), maxLength);\n    return [];\n  }\n\n  let currentLength = arraySum(lengths); // Check if all fits into maxLength\n\n  if (currentLength <= availableLength) return args; // Try to remove chars from the longest items until it fits\n\n  while (currentLength > availableLength) {\n    const maxLength = Math.max(...lengths);\n    const shorterItems = lengths.filter(l => l !== maxLength);\n    const nextToMaxLength = shorterItems.length > 0 ? Math.max(...shorterItems) : 0;\n    const maxReduce = maxLength - nextToMaxLength;\n    let maxItems = lengths.length - shorterItems.length;\n    let overrun = currentLength - availableLength;\n\n    for (let i = 0; i < lengths.length; i++) {\n      if (lengths[i] === maxLength) {\n        const reduce = Math.min(Math.floor(overrun / maxItems), maxReduce);\n        lengths[i] -= reduce;\n        currentLength -= reduce;\n        overrun -= reduce;\n        maxItems--;\n      }\n    }\n  } // Return args reduced to length in lengths\n\n\n  return args.map((a, i) => {\n    const str = `${a}`;\n    const length = lengths[i];\n\n    if (str.length === length) {\n      return str;\n    } else if (length > 5) {\n      return \"...\" + str.slice(-length + 3);\n    } else if (length > 0) {\n      return str.slice(-length);\n    } else {\n      return \"\";\n    }\n  });\n};\n\nmodule.exports = truncateArgs;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/logging/truncateArgs.js"],"names":["arraySum","array","sum","item","truncateArgs","args","maxLength","lengths","map","a","length","availableLength","slice","i","Math","min","currentLength","max","shorterItems","filter","l","nextToMaxLength","maxReduce","maxItems","overrun","reduce","floor","str","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst arraySum = array => {\n\tlet sum = 0;\n\tfor (const item of array) sum += item;\n\treturn sum;\n};\n\n/**\n * @param {any[]} args items to be truncated\n * @param {number} maxLength maximum length of args including spaces between\n * @returns {string[]} truncated args\n */\nconst truncateArgs = (args, maxLength) => {\n\tconst lengths = args.map(a => `${a}`.length);\n\tconst availableLength = maxLength - lengths.length + 1;\n\n\tif (availableLength > 0 && args.length === 1) {\n\t\tif (availableLength >= args[0].length) {\n\t\t\treturn args;\n\t\t} else if (availableLength > 3) {\n\t\t\treturn [\"...\" + args[0].slice(-availableLength + 3)];\n\t\t} else {\n\t\t\treturn [args[0].slice(-availableLength)];\n\t\t}\n\t}\n\n\t// Check if there is space for at least 4 chars per arg\n\tif (availableLength < arraySum(lengths.map(i => Math.min(i, 6)))) {\n\t\t// remove args\n\t\tif (args.length > 1)\n\t\t\treturn truncateArgs(args.slice(0, args.length - 1), maxLength);\n\t\treturn [];\n\t}\n\n\tlet currentLength = arraySum(lengths);\n\n\t// Check if all fits into maxLength\n\tif (currentLength <= availableLength) return args;\n\n\t// Try to remove chars from the longest items until it fits\n\twhile (currentLength > availableLength) {\n\t\tconst maxLength = Math.max(...lengths);\n\t\tconst shorterItems = lengths.filter(l => l !== maxLength);\n\t\tconst nextToMaxLength =\n\t\t\tshorterItems.length > 0 ? Math.max(...shorterItems) : 0;\n\t\tconst maxReduce = maxLength - nextToMaxLength;\n\t\tlet maxItems = lengths.length - shorterItems.length;\n\t\tlet overrun = currentLength - availableLength;\n\t\tfor (let i = 0; i < lengths.length; i++) {\n\t\t\tif (lengths[i] === maxLength) {\n\t\t\t\tconst reduce = Math.min(Math.floor(overrun / maxItems), maxReduce);\n\t\t\t\tlengths[i] -= reduce;\n\t\t\t\tcurrentLength -= reduce;\n\t\t\t\toverrun -= reduce;\n\t\t\t\tmaxItems--;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return args reduced to length in lengths\n\treturn args.map((a, i) => {\n\t\tconst str = `${a}`;\n\t\tconst length = lengths[i];\n\t\tif (str.length === length) {\n\t\t\treturn str;\n\t\t} else if (length > 5) {\n\t\t\treturn \"...\" + str.slice(-length + 3);\n\t\t} else if (length > 0) {\n\t\t\treturn str.slice(-length);\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t});\n};\n\nmodule.exports = truncateArgs;\n"]},"metadata":{},"sourceType":"script"}