{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  find\n} = require(\"../util/SetHelpers\");\n\nconst {\n  compareModulesByPreOrderIndexOrIdentifier,\n  compareModulesByPostOrderIndexOrIdentifier\n} = require(\"../util/comparators\");\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n\nclass ChunkModuleIdRangePlugin {\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const options = this.options;\n    compiler.hooks.compilation.tap(\"ChunkModuleIdRangePlugin\", compilation => {\n      const moduleGraph = compilation.moduleGraph;\n      compilation.hooks.moduleIds.tap(\"ChunkModuleIdRangePlugin\", modules => {\n        const chunkGraph = compilation.chunkGraph;\n        const chunk = find(compilation.chunks, chunk => chunk.name === options.name);\n\n        if (!chunk) {\n          throw new Error(`ChunkModuleIdRangePlugin: Chunk with name '${options.name}\"' was not found`);\n        }\n\n        let chunkModules;\n\n        if (options.order) {\n          let cmpFn;\n\n          switch (options.order) {\n            case \"index\":\n            case \"preOrderIndex\":\n              cmpFn = compareModulesByPreOrderIndexOrIdentifier(moduleGraph);\n              break;\n\n            case \"index2\":\n            case \"postOrderIndex\":\n              cmpFn = compareModulesByPostOrderIndexOrIdentifier(moduleGraph);\n              break;\n\n            default:\n              throw new Error(\"ChunkModuleIdRangePlugin: unexpected value of order\");\n          }\n\n          chunkModules = chunkGraph.getOrderedChunkModules(chunk, cmpFn);\n        } else {\n          chunkModules = Array.from(modules).filter(m => {\n            return chunkGraph.isModuleInChunk(m, chunk);\n          }).sort(compareModulesByPreOrderIndexOrIdentifier(moduleGraph));\n        }\n\n        let currentId = options.start || 0;\n\n        for (let i = 0; i < chunkModules.length; i++) {\n          const m = chunkModules[i];\n\n          if (m.needId && chunkGraph.getModuleId(m) === null) {\n            chunkGraph.setModuleId(m, currentId++);\n          }\n\n          if (options.end && currentId > options.end) break;\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = ChunkModuleIdRangePlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/ids/ChunkModuleIdRangePlugin.js"],"names":["find","require","compareModulesByPreOrderIndexOrIdentifier","compareModulesByPostOrderIndexOrIdentifier","ChunkModuleIdRangePlugin","constructor","options","apply","compiler","hooks","compilation","tap","moduleGraph","moduleIds","modules","chunkGraph","chunk","chunks","name","Error","chunkModules","order","cmpFn","getOrderedChunkModules","Array","from","filter","m","isModuleInChunk","sort","currentId","start","i","length","needId","getModuleId","setModuleId","end","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAWC,OAAO,CAAC,oBAAD,CAAxB;;AACA,MAAM;AACLC,EAAAA,yCADK;AAELC,EAAAA;AAFK,IAGFF,OAAO,CAAC,qBAAD,CAHX;AAKA;;;AAEA,MAAMG,wBAAN,CAA+B;AAC9BC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACpB,SAAKA,OAAL,GAAeA,OAAf;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCC,EAAAA,KAAK,CAACC,QAAD,EAAW;AACf,UAAMF,OAAO,GAAG,KAAKA,OAArB;AACAE,IAAAA,QAAQ,CAACC,KAAT,CAAeC,WAAf,CAA2BC,GAA3B,CAA+B,0BAA/B,EAA2DD,WAAW,IAAI;AACzE,YAAME,WAAW,GAAGF,WAAW,CAACE,WAAhC;AACAF,MAAAA,WAAW,CAACD,KAAZ,CAAkBI,SAAlB,CAA4BF,GAA5B,CAAgC,0BAAhC,EAA4DG,OAAO,IAAI;AACtE,cAAMC,UAAU,GAAGL,WAAW,CAACK,UAA/B;AACA,cAAMC,KAAK,GAAGhB,IAAI,CACjBU,WAAW,CAACO,MADK,EAEjBD,KAAK,IAAIA,KAAK,CAACE,IAAN,KAAeZ,OAAO,CAACY,IAFf,CAAlB;;AAIA,YAAI,CAACF,KAAL,EAAY;AACX,gBAAM,IAAIG,KAAJ,CACJ,8CAA6Cb,OAAO,CAACY,IAAK,kBADtD,CAAN;AAGA;;AAED,YAAIE,YAAJ;;AACA,YAAId,OAAO,CAACe,KAAZ,EAAmB;AAClB,cAAIC,KAAJ;;AACA,kBAAQhB,OAAO,CAACe,KAAhB;AACC,iBAAK,OAAL;AACA,iBAAK,eAAL;AACCC,cAAAA,KAAK,GAAGpB,yCAAyC,CAACU,WAAD,CAAjD;AACA;;AACD,iBAAK,QAAL;AACA,iBAAK,gBAAL;AACCU,cAAAA,KAAK,GAAGnB,0CAA0C,CAACS,WAAD,CAAlD;AACA;;AACD;AACC,oBAAM,IAAIO,KAAJ,CACL,qDADK,CAAN;AAVF;;AAcAC,UAAAA,YAAY,GAAGL,UAAU,CAACQ,sBAAX,CAAkCP,KAAlC,EAAyCM,KAAzC,CAAf;AACA,SAjBD,MAiBO;AACNF,UAAAA,YAAY,GAAGI,KAAK,CAACC,IAAN,CAAWX,OAAX,EACbY,MADa,CACNC,CAAC,IAAI;AACZ,mBAAOZ,UAAU,CAACa,eAAX,CAA2BD,CAA3B,EAA8BX,KAA9B,CAAP;AACA,WAHa,EAIba,IAJa,CAIR3B,yCAAyC,CAACU,WAAD,CAJjC,CAAf;AAKA;;AAED,YAAIkB,SAAS,GAAGxB,OAAO,CAACyB,KAAR,IAAiB,CAAjC;;AACA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,YAAY,CAACa,MAAjC,EAAyCD,CAAC,EAA1C,EAA8C;AAC7C,gBAAML,CAAC,GAAGP,YAAY,CAACY,CAAD,CAAtB;;AACA,cAAIL,CAAC,CAACO,MAAF,IAAYnB,UAAU,CAACoB,WAAX,CAAuBR,CAAvB,MAA8B,IAA9C,EAAoD;AACnDZ,YAAAA,UAAU,CAACqB,WAAX,CAAuBT,CAAvB,EAA0BG,SAAS,EAAnC;AACA;;AACD,cAAIxB,OAAO,CAAC+B,GAAR,IAAeP,SAAS,GAAGxB,OAAO,CAAC+B,GAAvC,EAA4C;AAC5C;AACD,OA9CD;AA+CA,KAjDD;AAkDA;;AA9D6B;;AAgE/BC,MAAM,CAACC,OAAP,GAAiBnC,wBAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { find } = require(\"../util/SetHelpers\");\nconst {\n\tcompareModulesByPreOrderIndexOrIdentifier,\n\tcompareModulesByPostOrderIndexOrIdentifier\n} = require(\"../util/comparators\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nclass ChunkModuleIdRangePlugin {\n\tconstructor(options) {\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst options = this.options;\n\t\tcompiler.hooks.compilation.tap(\"ChunkModuleIdRangePlugin\", compilation => {\n\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\tcompilation.hooks.moduleIds.tap(\"ChunkModuleIdRangePlugin\", modules => {\n\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\tconst chunk = find(\n\t\t\t\t\tcompilation.chunks,\n\t\t\t\t\tchunk => chunk.name === options.name\n\t\t\t\t);\n\t\t\t\tif (!chunk) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`ChunkModuleIdRangePlugin: Chunk with name '${options.name}\"' was not found`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet chunkModules;\n\t\t\t\tif (options.order) {\n\t\t\t\t\tlet cmpFn;\n\t\t\t\t\tswitch (options.order) {\n\t\t\t\t\t\tcase \"index\":\n\t\t\t\t\t\tcase \"preOrderIndex\":\n\t\t\t\t\t\t\tcmpFn = compareModulesByPreOrderIndexOrIdentifier(moduleGraph);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"index2\":\n\t\t\t\t\t\tcase \"postOrderIndex\":\n\t\t\t\t\t\t\tcmpFn = compareModulesByPostOrderIndexOrIdentifier(moduleGraph);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\"ChunkModuleIdRangePlugin: unexpected value of order\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tchunkModules = chunkGraph.getOrderedChunkModules(chunk, cmpFn);\n\t\t\t\t} else {\n\t\t\t\t\tchunkModules = Array.from(modules)\n\t\t\t\t\t\t.filter(m => {\n\t\t\t\t\t\t\treturn chunkGraph.isModuleInChunk(m, chunk);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.sort(compareModulesByPreOrderIndexOrIdentifier(moduleGraph));\n\t\t\t\t}\n\n\t\t\t\tlet currentId = options.start || 0;\n\t\t\t\tfor (let i = 0; i < chunkModules.length; i++) {\n\t\t\t\t\tconst m = chunkModules[i];\n\t\t\t\t\tif (m.needId && chunkGraph.getModuleId(m) === null) {\n\t\t\t\t\t\tchunkGraph.setModuleId(m, currentId++);\n\t\t\t\t\t}\n\t\t\t\t\tif (options.end && currentId > options.end) break;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\nmodule.exports = ChunkModuleIdRangePlugin;\n"]},"metadata":{},"sourceType":"script"}