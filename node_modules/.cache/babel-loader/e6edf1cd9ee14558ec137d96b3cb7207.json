{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst EventEmitter = require(\"events\");\n\nconst {\n  extname,\n  basename\n} = require(\"path\");\n\nconst {\n  URL\n} = require(\"url\");\n\nconst {\n  createGunzip,\n  createBrotliDecompress,\n  createInflate\n} = require(\"zlib\");\n\nconst NormalModule = require(\"../NormalModule\");\n\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\n\nconst createHash = require(\"../util/createHash\");\n\nconst {\n  mkdirp,\n  dirname,\n  join\n} = require(\"../util/fs\");\n\nconst memoize = require(\"../util/memoize\");\n/** @typedef {import(\"../../declarations/plugins/schemes/HttpUriPlugin\").HttpUriPluginOptions} HttpUriPluginOptions */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n\nconst getHttp = memoize(() => require(\"http\"));\nconst getHttps = memoize(() => require(\"https\"));\n\nconst proxyFetch = (request, proxy) => (url, options, callback) => {\n  const eventEmitter = new EventEmitter();\n\n  const doRequest = socket => request.get(url, { ...options,\n    ...(socket && {\n      socket\n    })\n  }, callback).on(\"error\", eventEmitter.emit.bind(eventEmitter, \"error\"));\n\n  if (proxy) {\n    const {\n      hostname: host,\n      port\n    } = new URL(proxy);\n    getHttp().request({\n      host,\n      // IP address of proxy server\n      port,\n      // port of proxy server\n      method: \"CONNECT\",\n      path: url.host\n    }).on(\"connect\", (res, socket) => {\n      if (res.statusCode === 200) {\n        // connected to proxy server\n        doRequest(socket);\n      }\n    }).on(\"error\", err => {\n      eventEmitter.emit(\"error\", new Error(`Failed to connect to proxy server \"${proxy}\": ${err.message}`));\n    }).end();\n  } else {\n    doRequest();\n  }\n\n  return eventEmitter;\n};\n/** @type {(() => void)[] | undefined} */\n\n\nlet inProgressWrite = undefined;\nconst validate = createSchemaValidation(require(\"../../schemas/plugins/schemes/HttpUriPlugin.check.js\"), () => require(\"../../schemas/plugins/schemes/HttpUriPlugin.json\"), {\n  name: \"Http Uri Plugin\",\n  baseDataPath: \"options\"\n});\n\nconst toSafePath = str => str.replace(/^[^a-zA-Z0-9]+|[^a-zA-Z0-9]+$/g, \"\").replace(/[^a-zA-Z0-9._-]+/g, \"_\");\n\nconst computeIntegrity = content => {\n  const hash = createHash(\"sha512\");\n  hash.update(content);\n  const integrity = \"sha512-\" + hash.digest(\"base64\");\n  return integrity;\n};\n\nconst verifyIntegrity = (content, integrity) => {\n  if (integrity === \"ignore\") return true;\n  return computeIntegrity(content) === integrity;\n};\n/**\n * @param {string} str input\n * @returns {Record<string, string>} parsed\n */\n\n\nconst parseKeyValuePairs = str => {\n  /** @type {Record<string, string>} */\n  const result = {};\n\n  for (const item of str.split(\",\")) {\n    const i = item.indexOf(\"=\");\n\n    if (i >= 0) {\n      const key = item.slice(0, i).trim();\n      const value = item.slice(i + 1).trim();\n      result[key] = value;\n    } else {\n      const key = item.trim();\n      if (!key) continue;\n      result[key] = key;\n    }\n  }\n\n  return result;\n};\n\nconst parseCacheControl = (cacheControl, requestTime) => {\n  // When false resource is not stored in cache\n  let storeCache = true; // When false resource is not stored in lockfile cache\n\n  let storeLock = true; // Resource is only revalidated, after that timestamp and when upgrade is chosen\n\n  let validUntil = 0;\n\n  if (cacheControl) {\n    const parsed = parseKeyValuePairs(cacheControl);\n    if (parsed[\"no-cache\"]) storeCache = storeLock = false;\n\n    if (parsed[\"max-age\"] && !isNaN(+parsed[\"max-age\"])) {\n      validUntil = requestTime + +parsed[\"max-age\"] * 1000;\n    }\n\n    if (parsed[\"must-revalidate\"]) validUntil = 0;\n  }\n\n  return {\n    storeLock,\n    storeCache,\n    validUntil\n  };\n};\n/**\n * @typedef {Object} LockfileEntry\n * @property {string} resolved\n * @property {string} integrity\n * @property {string} contentType\n */\n\n\nconst areLockfileEntriesEqual = (a, b) => {\n  return a.resolved === b.resolved && a.integrity === b.integrity && a.contentType === b.contentType;\n};\n\nconst entryToString = entry => {\n  return `resolved: ${entry.resolved}, integrity: ${entry.integrity}, contentType: ${entry.contentType}`;\n};\n\nclass Lockfile {\n  constructor() {\n    this.version = 1;\n    /** @type {Map<string, LockfileEntry | \"ignore\" | \"no-cache\">} */\n\n    this.entries = new Map();\n  }\n\n  static parse(content) {\n    // TODO handle merge conflicts\n    const data = JSON.parse(content);\n    if (data.version !== 1) throw new Error(`Unsupported lockfile version ${data.version}`);\n    const lockfile = new Lockfile();\n\n    for (const key of Object.keys(data)) {\n      if (key === \"version\") continue;\n      const entry = data[key];\n      lockfile.entries.set(key, typeof entry === \"string\" ? entry : {\n        resolved: key,\n        ...entry\n      });\n    }\n\n    return lockfile;\n  }\n\n  toString() {\n    let str = \"{\\n\";\n    const entries = Array.from(this.entries).sort((_ref, _ref2) => {\n      let [a] = _ref;\n      let [b] = _ref2;\n      return a < b ? -1 : 1;\n    });\n\n    for (const [key, entry] of entries) {\n      if (typeof entry === \"string\") {\n        str += `  ${JSON.stringify(key)}: ${JSON.stringify(entry)},\\n`;\n      } else {\n        str += `  ${JSON.stringify(key)}: { `;\n        if (entry.resolved !== key) str += `\"resolved\": ${JSON.stringify(entry.resolved)}, `;\n        str += `\"integrity\": ${JSON.stringify(entry.integrity)}, \"contentType\": ${JSON.stringify(entry.contentType)} },\\n`;\n      }\n    }\n\n    str += `  \"version\": ${this.version}\\n}\\n`;\n    return str;\n  }\n\n}\n/**\n * @template R\n * @param {function(function(Error=, R=): void): void} fn function\n * @returns {function(function((Error | null)=, R=): void): void} cached function\n */\n\n\nconst cachedWithoutKey = fn => {\n  let inFlight = false;\n  /** @type {Error | undefined} */\n\n  let cachedError = undefined;\n  /** @type {R | undefined} */\n\n  let cachedResult = undefined;\n  /** @type {(function(Error=, R=): void)[] | undefined} */\n\n  let cachedCallbacks = undefined;\n  return callback => {\n    if (inFlight) {\n      if (cachedResult !== undefined) return callback(null, cachedResult);\n      if (cachedError !== undefined) return callback(cachedError);\n      if (cachedCallbacks === undefined) cachedCallbacks = [callback];else cachedCallbacks.push(callback);\n      return;\n    }\n\n    inFlight = true;\n    fn((err, result) => {\n      if (err) cachedError = err;else cachedResult = result;\n      const callbacks = cachedCallbacks;\n      cachedCallbacks = undefined;\n      callback(err, result);\n      if (callbacks !== undefined) for (const cb of callbacks) cb(err, result);\n    });\n  };\n};\n/**\n * @template T\n * @template R\n * @param {function(T, function(Error=, R=): void): void} fn function\n * @param {function(T, function(Error=, R=): void): void=} forceFn function for the second try\n * @returns {(function(T, function((Error | null)=, R=): void): void) & { force: function(T, function((Error | null)=, R=): void): void }} cached function\n */\n\n\nconst cachedWithKey = function (fn) {\n  let forceFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : fn;\n\n  /** @typedef {{ result?: R, error?: Error, callbacks?: (function((Error | null)=, R=): void)[], force?: true }} CacheEntry */\n\n  /** @type {Map<T, CacheEntry>} */\n  const cache = new Map();\n\n  const resultFn = (arg, callback) => {\n    const cacheEntry = cache.get(arg);\n\n    if (cacheEntry !== undefined) {\n      if (cacheEntry.result !== undefined) return callback(null, cacheEntry.result);\n      if (cacheEntry.error !== undefined) return callback(cacheEntry.error);\n      if (cacheEntry.callbacks === undefined) cacheEntry.callbacks = [callback];else cacheEntry.callbacks.push(callback);\n      return;\n    }\n    /** @type {CacheEntry} */\n\n\n    const newCacheEntry = {\n      result: undefined,\n      error: undefined,\n      callbacks: undefined\n    };\n    cache.set(arg, newCacheEntry);\n    fn(arg, (err, result) => {\n      if (err) newCacheEntry.error = err;else newCacheEntry.result = result;\n      const callbacks = newCacheEntry.callbacks;\n      newCacheEntry.callbacks = undefined;\n      callback(err, result);\n      if (callbacks !== undefined) for (const cb of callbacks) cb(err, result);\n    });\n  };\n\n  resultFn.force = (arg, callback) => {\n    const cacheEntry = cache.get(arg);\n\n    if (cacheEntry !== undefined && cacheEntry.force) {\n      if (cacheEntry.result !== undefined) return callback(null, cacheEntry.result);\n      if (cacheEntry.error !== undefined) return callback(cacheEntry.error);\n      if (cacheEntry.callbacks === undefined) cacheEntry.callbacks = [callback];else cacheEntry.callbacks.push(callback);\n      return;\n    }\n    /** @type {CacheEntry} */\n\n\n    const newCacheEntry = {\n      result: undefined,\n      error: undefined,\n      callbacks: undefined,\n      force: true\n    };\n    cache.set(arg, newCacheEntry);\n    forceFn(arg, (err, result) => {\n      if (err) newCacheEntry.error = err;else newCacheEntry.result = result;\n      const callbacks = newCacheEntry.callbacks;\n      newCacheEntry.callbacks = undefined;\n      callback(err, result);\n      if (callbacks !== undefined) for (const cb of callbacks) cb(err, result);\n    });\n  };\n\n  return resultFn;\n};\n\nclass HttpUriPlugin {\n  /**\n   * @param {HttpUriPluginOptions} options options\n   */\n  constructor(options) {\n    validate(options);\n    this._lockfileLocation = options.lockfileLocation;\n    this._cacheLocation = options.cacheLocation;\n    this._upgrade = options.upgrade;\n    this._frozen = options.frozen;\n    this._allowedUris = options.allowedUris;\n    this._proxy = options.proxy;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const proxy = this._proxy || process.env[\"http_proxy\"] || process.env[\"HTTP_PROXY\"];\n    const schemes = [{\n      scheme: \"http\",\n      fetch: proxyFetch(getHttp(), proxy)\n    }, {\n      scheme: \"https\",\n      fetch: proxyFetch(getHttps(), proxy)\n    }];\n    let lockfileCache;\n    compiler.hooks.compilation.tap(\"HttpUriPlugin\", (compilation, _ref3) => {\n      let {\n        normalModuleFactory\n      } = _ref3;\n      const intermediateFs = compiler.intermediateFileSystem;\n      const fs = compilation.inputFileSystem;\n      const cache = compilation.getCache(\"webpack.HttpUriPlugin\");\n      const logger = compilation.getLogger(\"webpack.HttpUriPlugin\");\n      const lockfileLocation = this._lockfileLocation || join(intermediateFs, compiler.context, compiler.name ? `${toSafePath(compiler.name)}.webpack.lock` : \"webpack.lock\");\n      const cacheLocation = this._cacheLocation !== undefined ? this._cacheLocation : lockfileLocation + \".data\";\n      const upgrade = this._upgrade || false;\n      const frozen = this._frozen || false;\n      const hashFunction = \"sha512\";\n      const hashDigest = \"hex\";\n      const hashDigestLength = 20;\n      const allowedUris = this._allowedUris;\n      let warnedAboutEol = false;\n      const cacheKeyCache = new Map();\n      /**\n       * @param {string} url the url\n       * @returns {string} the key\n       */\n\n      const getCacheKey = url => {\n        const cachedResult = cacheKeyCache.get(url);\n        if (cachedResult !== undefined) return cachedResult;\n\n        const result = _getCacheKey(url);\n\n        cacheKeyCache.set(url, result);\n        return result;\n      };\n      /**\n       * @param {string} url the url\n       * @returns {string} the key\n       */\n\n\n      const _getCacheKey = url => {\n        const parsedUrl = new URL(url);\n        const folder = toSafePath(parsedUrl.origin);\n        const name = toSafePath(parsedUrl.pathname);\n        const query = toSafePath(parsedUrl.search);\n        let ext = extname(name);\n        if (ext.length > 20) ext = \"\";\n        const basename = ext ? name.slice(0, -ext.length) : name;\n        const hash = createHash(hashFunction);\n        hash.update(url);\n        const digest = hash.digest(hashDigest).slice(0, hashDigestLength);\n        return `${folder.slice(-50)}/${`${basename}${query ? `_${query}` : \"\"}`.slice(0, 150)}_${digest}${ext}`;\n      };\n\n      const getLockfile = cachedWithoutKey(\n      /**\n       * @param {function((Error | null)=, Lockfile=): void} callback callback\n       * @returns {void}\n       */\n      callback => {\n        const readLockfile = () => {\n          intermediateFs.readFile(lockfileLocation, (err, buffer) => {\n            if (err && err.code !== \"ENOENT\") {\n              compilation.missingDependencies.add(lockfileLocation);\n              return callback(err);\n            }\n\n            compilation.fileDependencies.add(lockfileLocation);\n            compilation.fileSystemInfo.createSnapshot(compiler.fsStartTime, buffer ? [lockfileLocation] : [], [], buffer ? [] : [lockfileLocation], {\n              timestamp: true\n            }, (err, snapshot) => {\n              if (err) return callback(err);\n              const lockfile = buffer ? Lockfile.parse(buffer.toString(\"utf-8\")) : new Lockfile();\n              lockfileCache = {\n                lockfile,\n                snapshot\n              };\n              callback(null, lockfile);\n            });\n          });\n        };\n\n        if (lockfileCache) {\n          compilation.fileSystemInfo.checkSnapshotValid(lockfileCache.snapshot, (err, valid) => {\n            if (err) return callback(err);\n            if (!valid) return readLockfile();\n            callback(null, lockfileCache.lockfile);\n          });\n        } else {\n          readLockfile();\n        }\n      });\n      /** @type {Map<string, LockfileEntry | \"ignore\" | \"no-cache\"> | undefined} */\n\n      let lockfileUpdates = undefined;\n\n      const storeLockEntry = (lockfile, url, entry) => {\n        const oldEntry = lockfile.entries.get(url);\n        if (lockfileUpdates === undefined) lockfileUpdates = new Map();\n        lockfileUpdates.set(url, entry);\n        lockfile.entries.set(url, entry);\n\n        if (!oldEntry) {\n          logger.log(`${url} added to lockfile`);\n        } else if (typeof oldEntry === \"string\") {\n          if (typeof entry === \"string\") {\n            logger.log(`${url} updated in lockfile: ${oldEntry} -> ${entry}`);\n          } else {\n            logger.log(`${url} updated in lockfile: ${oldEntry} -> ${entry.resolved}`);\n          }\n        } else if (typeof entry === \"string\") {\n          logger.log(`${url} updated in lockfile: ${oldEntry.resolved} -> ${entry}`);\n        } else if (oldEntry.resolved !== entry.resolved) {\n          logger.log(`${url} updated in lockfile: ${oldEntry.resolved} -> ${entry.resolved}`);\n        } else if (oldEntry.integrity !== entry.integrity) {\n          logger.log(`${url} updated in lockfile: content changed`);\n        } else if (oldEntry.contentType !== entry.contentType) {\n          logger.log(`${url} updated in lockfile: ${oldEntry.contentType} -> ${entry.contentType}`);\n        } else {\n          logger.log(`${url} updated in lockfile`);\n        }\n      };\n\n      const storeResult = (lockfile, url, result, callback) => {\n        if (result.storeLock) {\n          storeLockEntry(lockfile, url, result.entry);\n          if (!cacheLocation || !result.content) return callback(null, result);\n          const key = getCacheKey(result.entry.resolved);\n          const filePath = join(intermediateFs, cacheLocation, key);\n          mkdirp(intermediateFs, dirname(intermediateFs, filePath), err => {\n            if (err) return callback(err);\n            intermediateFs.writeFile(filePath, result.content, err => {\n              if (err) return callback(err);\n              callback(null, result);\n            });\n          });\n        } else {\n          storeLockEntry(lockfile, url, \"no-cache\");\n          callback(null, result);\n        }\n      };\n\n      for (const {\n        scheme,\n        fetch\n      } of schemes) {\n        /**\n         *\n         * @param {string} url URL\n         * @param {string} integrity integrity\n         * @param {function((Error | null)=, { entry: LockfileEntry, content: Buffer, storeLock: boolean }=): void} callback callback\n         */\n        const resolveContent = (url, integrity, callback) => {\n          const handleResult = (err, result) => {\n            if (err) return callback(err);\n\n            if (\"location\" in result) {\n              return resolveContent(result.location, integrity, (err, innerResult) => {\n                if (err) return callback(err);\n                callback(null, {\n                  entry: innerResult.entry,\n                  content: innerResult.content,\n                  storeLock: innerResult.storeLock && result.storeLock\n                });\n              });\n            } else {\n              if (!result.fresh && integrity && result.entry.integrity !== integrity && !verifyIntegrity(result.content, integrity)) {\n                return fetchContent.force(url, handleResult);\n              }\n\n              return callback(null, {\n                entry: result.entry,\n                content: result.content,\n                storeLock: result.storeLock\n              });\n            }\n          };\n\n          fetchContent(url, handleResult);\n        };\n        /** @typedef {{ storeCache: boolean, storeLock: boolean, validUntil: number, etag: string | undefined, fresh: boolean }} FetchResultMeta */\n\n        /** @typedef {FetchResultMeta & { location: string }} RedirectFetchResult */\n\n        /** @typedef {FetchResultMeta & { entry: LockfileEntry, content: Buffer }} ContentFetchResult */\n\n        /** @typedef {RedirectFetchResult | ContentFetchResult} FetchResult */\n\n        /**\n         * @param {string} url URL\n         * @param {FetchResult | RedirectFetchResult} cachedResult result from cache\n         * @param {function((Error | null)=, FetchResult=): void} callback callback\n         * @returns {void}\n         */\n\n\n        const fetchContentRaw = (url, cachedResult, callback) => {\n          const requestTime = Date.now();\n          fetch(new URL(url), {\n            headers: {\n              \"accept-encoding\": \"gzip, deflate, br\",\n              \"user-agent\": \"webpack\",\n              \"if-none-match\": cachedResult ? cachedResult.etag || null : null\n            }\n          }, res => {\n            const etag = res.headers[\"etag\"];\n            const location = res.headers[\"location\"];\n            const cacheControl = res.headers[\"cache-control\"];\n            const {\n              storeLock,\n              storeCache,\n              validUntil\n            } = parseCacheControl(cacheControl, requestTime);\n            /**\n             * @param {Partial<Pick<FetchResultMeta, \"fresh\">> & (Pick<RedirectFetchResult, \"location\"> | Pick<ContentFetchResult, \"content\" | \"entry\">)} partialResult result\n             * @returns {void}\n             */\n\n            const finishWith = partialResult => {\n              if (\"location\" in partialResult) {\n                logger.debug(`GET ${url} [${res.statusCode}] -> ${partialResult.location}`);\n              } else {\n                logger.debug(`GET ${url} [${res.statusCode}] ${Math.ceil(partialResult.content.length / 1024)} kB${!storeLock ? \" no-cache\" : \"\"}`);\n              }\n\n              const result = { ...partialResult,\n                fresh: true,\n                storeLock,\n                storeCache,\n                validUntil,\n                etag\n              };\n\n              if (!storeCache) {\n                logger.log(`${url} can't be stored in cache, due to Cache-Control header: ${cacheControl}`);\n                return callback(null, result);\n              }\n\n              cache.store(url, null, { ...result,\n                fresh: false\n              }, err => {\n                if (err) {\n                  logger.warn(`${url} can't be stored in cache: ${err.message}`);\n                  logger.debug(err.stack);\n                }\n\n                callback(null, result);\n              });\n            };\n\n            if (res.statusCode === 304) {\n              if (cachedResult.validUntil < validUntil || cachedResult.storeLock !== storeLock || cachedResult.storeCache !== storeCache || cachedResult.etag !== etag) {\n                return finishWith(cachedResult);\n              } else {\n                logger.debug(`GET ${url} [${res.statusCode}] (unchanged)`);\n                return callback(null, { ...cachedResult,\n                  fresh: true\n                });\n              }\n            }\n\n            if (location && res.statusCode >= 301 && res.statusCode <= 308) {\n              const result = {\n                location: new URL(location, url).href\n              };\n\n              if (!cachedResult || !(\"location\" in cachedResult) || cachedResult.location !== result.location || cachedResult.validUntil < validUntil || cachedResult.storeLock !== storeLock || cachedResult.storeCache !== storeCache || cachedResult.etag !== etag) {\n                return finishWith(result);\n              } else {\n                logger.debug(`GET ${url} [${res.statusCode}] (unchanged)`);\n                return callback(null, { ...result,\n                  fresh: true,\n                  storeLock,\n                  storeCache,\n                  validUntil,\n                  etag\n                });\n              }\n            }\n\n            const contentType = res.headers[\"content-type\"] || \"\";\n            const bufferArr = [];\n            const contentEncoding = res.headers[\"content-encoding\"];\n            let stream = res;\n\n            if (contentEncoding === \"gzip\") {\n              stream = stream.pipe(createGunzip());\n            } else if (contentEncoding === \"br\") {\n              stream = stream.pipe(createBrotliDecompress());\n            } else if (contentEncoding === \"deflate\") {\n              stream = stream.pipe(createInflate());\n            }\n\n            stream.on(\"data\", chunk => {\n              bufferArr.push(chunk);\n            });\n            stream.on(\"end\", () => {\n              if (!res.complete) {\n                logger.log(`GET ${url} [${res.statusCode}] (terminated)`);\n                return callback(new Error(`${url} request was terminated`));\n              }\n\n              const content = Buffer.concat(bufferArr);\n\n              if (res.statusCode !== 200) {\n                logger.log(`GET ${url} [${res.statusCode}]`);\n                return callback(new Error(`${url} request status code = ${res.statusCode}\\n${content.toString(\"utf-8\")}`));\n              }\n\n              const integrity = computeIntegrity(content);\n              const entry = {\n                resolved: url,\n                integrity,\n                contentType\n              };\n              finishWith({\n                entry,\n                content\n              });\n            });\n          }).on(\"error\", err => {\n            logger.log(`GET ${url} (error)`);\n            err.message += `\\nwhile fetching ${url}`;\n            callback(err);\n          });\n        };\n\n        const fetchContent = cachedWithKey(\n        /**\n         * @param {string} url URL\n         * @param {function((Error | null)=, { validUntil: number, etag?: string, entry: LockfileEntry, content: Buffer, fresh: boolean } | { validUntil: number, etag?: string, location: string, fresh: boolean }=): void} callback callback\n         * @returns {void}\n         */\n        (url, callback) => {\n          cache.get(url, null, (err, cachedResult) => {\n            if (err) return callback(err);\n\n            if (cachedResult) {\n              const isValid = cachedResult.validUntil >= Date.now();\n              if (isValid) return callback(null, cachedResult);\n            }\n\n            fetchContentRaw(url, cachedResult, callback);\n          });\n        }, (url, callback) => fetchContentRaw(url, undefined, callback));\n\n        const isAllowed = uri => {\n          for (const allowed of allowedUris) {\n            if (typeof allowed === \"string\") {\n              if (uri.startsWith(allowed)) return true;\n            } else if (typeof allowed === \"function\") {\n              if (allowed(uri)) return true;\n            } else {\n              if (allowed.test(uri)) return true;\n            }\n          }\n\n          return false;\n        };\n\n        const getInfo = cachedWithKey(\n        /**\n         * @param {string} url the url\n         * @param {function((Error | null)=, { entry: LockfileEntry, content: Buffer }=): void} callback callback\n         * @returns {void}\n         */\n        (url, callback) => {\n          if (!isAllowed(url)) {\n            return callback(new Error(`${url} doesn't match the allowedUris policy. These URIs are allowed:\\n${allowedUris.map(uri => ` - ${uri}`).join(\"\\n\")}`));\n          }\n\n          getLockfile((err, lockfile) => {\n            if (err) return callback(err);\n            const entryOrString = lockfile.entries.get(url);\n\n            if (!entryOrString) {\n              if (frozen) {\n                return callback(new Error(`${url} has no lockfile entry and lockfile is frozen`));\n              }\n\n              resolveContent(url, null, (err, result) => {\n                if (err) return callback(err);\n                storeResult(lockfile, url, result, callback);\n              });\n              return;\n            }\n\n            if (typeof entryOrString === \"string\") {\n              const entryTag = entryOrString;\n              resolveContent(url, null, (err, result) => {\n                if (err) return callback(err);\n                if (!result.storeLock || entryTag === \"ignore\") return callback(null, result);\n\n                if (frozen) {\n                  return callback(new Error(`${url} used to have ${entryTag} lockfile entry and has content now, but lockfile is frozen`));\n                }\n\n                if (!upgrade) {\n                  return callback(new Error(`${url} used to have ${entryTag} lockfile entry and has content now.\nThis should be reflected in the lockfile, so this lockfile entry must be upgraded, but upgrading is not enabled.\nRemove this line from the lockfile to force upgrading.`));\n                }\n\n                storeResult(lockfile, url, result, callback);\n              });\n              return;\n            }\n\n            let entry = entryOrString;\n\n            const doFetch = lockedContent => {\n              resolveContent(url, entry.integrity, (err, result) => {\n                if (err) {\n                  if (lockedContent) {\n                    logger.warn(`Upgrade request to ${url} failed: ${err.message}`);\n                    logger.debug(err.stack);\n                    return callback(null, {\n                      entry,\n                      content: lockedContent\n                    });\n                  }\n\n                  return callback(err);\n                }\n\n                if (!result.storeLock) {\n                  // When the lockfile entry should be no-cache\n                  // we need to update the lockfile\n                  if (frozen) {\n                    return callback(new Error(`${url} has a lockfile entry and is no-cache now, but lockfile is frozen\\nLockfile: ${entryToString(entry)}`));\n                  }\n\n                  storeResult(lockfile, url, result, callback);\n                  return;\n                }\n\n                if (!areLockfileEntriesEqual(result.entry, entry)) {\n                  // When the lockfile entry is outdated\n                  // we need to update the lockfile\n                  if (frozen) {\n                    return callback(new Error(`${url} has an outdated lockfile entry, but lockfile is frozen\\nLockfile: ${entryToString(entry)}\\nExpected: ${entryToString(result.entry)}`));\n                  }\n\n                  storeResult(lockfile, url, result, callback);\n                  return;\n                }\n\n                if (!lockedContent && cacheLocation) {\n                  // When the lockfile cache content is missing\n                  // we need to update the lockfile\n                  if (frozen) {\n                    return callback(new Error(`${url} is missing content in the lockfile cache, but lockfile is frozen\\nLockfile: ${entryToString(entry)}`));\n                  }\n\n                  storeResult(lockfile, url, result, callback);\n                  return;\n                }\n\n                return callback(null, result);\n              });\n            };\n\n            if (cacheLocation) {\n              // When there is a lockfile cache\n              // we read the content from there\n              const key = getCacheKey(entry.resolved);\n              const filePath = join(intermediateFs, cacheLocation, key);\n              fs.readFile(filePath, (err, result) => {\n                const content =\n                /** @type {Buffer} */\n                result;\n\n                if (err) {\n                  if (err.code === \"ENOENT\") return doFetch();\n                  return callback(err);\n                }\n\n                const continueWithCachedContent = result => {\n                  if (!upgrade) {\n                    // When not in upgrade mode, we accept the result from the lockfile cache\n                    return callback(null, {\n                      entry,\n                      content\n                    });\n                  }\n\n                  return doFetch(content);\n                };\n\n                if (!verifyIntegrity(content, entry.integrity)) {\n                  let contentWithChangedEol;\n                  let isEolChanged = false;\n\n                  try {\n                    contentWithChangedEol = Buffer.from(content.toString(\"utf-8\").replace(/\\r\\n/g, \"\\n\"));\n                    isEolChanged = verifyIntegrity(contentWithChangedEol, entry.integrity);\n                  } catch (e) {// ignore\n                  }\n\n                  if (isEolChanged) {\n                    if (!warnedAboutEol) {\n                      const explainer = `Incorrect end of line sequence was detected in the lockfile cache.\nThe lockfile cache is protected by integrity checks, so any external modification will lead to a corrupted lockfile cache.\nWhen using git make sure to configure .gitattributes correctly for the lockfile cache:\n  **/*webpack.lock.data/** -text\nThis will avoid that the end of line sequence is changed by git on Windows.`;\n\n                      if (frozen) {\n                        logger.error(explainer);\n                      } else {\n                        logger.warn(explainer);\n                        logger.info(\"Lockfile cache will be automatically fixed now, but when lockfile is frozen this would result in an error.\");\n                      }\n\n                      warnedAboutEol = true;\n                    }\n\n                    if (!frozen) {\n                      // \"fix\" the end of line sequence of the lockfile content\n                      logger.log(`${filePath} fixed end of line sequence (\\\\r\\\\n instead of \\\\n).`);\n                      intermediateFs.writeFile(filePath, contentWithChangedEol, err => {\n                        if (err) return callback(err);\n                        continueWithCachedContent(contentWithChangedEol);\n                      });\n                      return;\n                    }\n                  }\n\n                  if (frozen) {\n                    return callback(new Error(`${entry.resolved} integrity mismatch, expected content with integrity ${entry.integrity} but got ${computeIntegrity(content)}.\nLockfile corrupted (${isEolChanged ? \"end of line sequence was unexpectedly changed\" : \"incorrectly merged? changed by other tools?\"}).\nRun build with un-frozen lockfile to automatically fix lockfile.`));\n                  } else {\n                    // \"fix\" the lockfile entry to the correct integrity\n                    // the content has priority over the integrity value\n                    entry = { ...entry,\n                      integrity: computeIntegrity(content)\n                    };\n                    storeLockEntry(lockfile, url, entry);\n                  }\n                }\n\n                continueWithCachedContent(result);\n              });\n            } else {\n              doFetch();\n            }\n          });\n        });\n\n        const respondWithUrlModule = (url, resourceData, callback) => {\n          getInfo(url.href, (err, result) => {\n            if (err) return callback(err);\n            resourceData.resource = url.href;\n            resourceData.path = url.origin + url.pathname;\n            resourceData.query = url.search;\n            resourceData.fragment = url.hash;\n            resourceData.context = new URL(\".\", result.entry.resolved).href.slice(0, -1);\n            resourceData.data.mimetype = result.entry.contentType;\n            callback(null, true);\n          });\n        };\n\n        normalModuleFactory.hooks.resolveForScheme.for(scheme).tapAsync(\"HttpUriPlugin\", (resourceData, resolveData, callback) => {\n          respondWithUrlModule(new URL(resourceData.resource), resourceData, callback);\n        });\n        normalModuleFactory.hooks.resolveInScheme.for(scheme).tapAsync(\"HttpUriPlugin\", (resourceData, data, callback) => {\n          // Only handle relative urls (./xxx, ../xxx, /xxx, //xxx)\n          if (data.dependencyType !== \"url\" && !/^\\.{0,2}\\//.test(resourceData.resource)) {\n            return callback();\n          }\n\n          respondWithUrlModule(new URL(resourceData.resource, data.context + \"/\"), resourceData, callback);\n        });\n        const hooks = NormalModule.getCompilationHooks(compilation);\n        hooks.readResourceForScheme.for(scheme).tapAsync(\"HttpUriPlugin\", (resource, module, callback) => {\n          return getInfo(resource, (err, result) => {\n            if (err) return callback(err);\n            module.buildInfo.resourceIntegrity = result.entry.integrity;\n            callback(null, result.content);\n          });\n        });\n        hooks.needBuild.tapAsync(\"HttpUriPlugin\", (module, context, callback) => {\n          if (module.resource && module.resource.startsWith(`${scheme}://`)) {\n            getInfo(module.resource, (err, result) => {\n              if (err) return callback(err);\n\n              if (result.entry.integrity !== module.buildInfo.resourceIntegrity) {\n                return callback(null, true);\n              }\n\n              callback();\n            });\n          } else {\n            return callback();\n          }\n        });\n      }\n\n      compilation.hooks.finishModules.tapAsync(\"HttpUriPlugin\", (modules, callback) => {\n        if (!lockfileUpdates) return callback();\n        const ext = extname(lockfileLocation);\n        const tempFile = join(intermediateFs, dirname(intermediateFs, lockfileLocation), `.${basename(lockfileLocation, ext)}.${Math.random() * 10000 | 0}${ext}`);\n\n        const writeDone = () => {\n          const nextOperation = inProgressWrite.shift();\n\n          if (nextOperation) {\n            nextOperation();\n          } else {\n            inProgressWrite = undefined;\n          }\n        };\n\n        const runWrite = () => {\n          intermediateFs.readFile(lockfileLocation, (err, buffer) => {\n            if (err && err.code !== \"ENOENT\") {\n              writeDone();\n              return callback(err);\n            }\n\n            const lockfile = buffer ? Lockfile.parse(buffer.toString(\"utf-8\")) : new Lockfile();\n\n            for (const [key, value] of lockfileUpdates) {\n              lockfile.entries.set(key, value);\n            }\n\n            intermediateFs.writeFile(tempFile, lockfile.toString(), err => {\n              if (err) {\n                writeDone();\n                return intermediateFs.unlink(tempFile, () => callback(err));\n              }\n\n              intermediateFs.rename(tempFile, lockfileLocation, err => {\n                if (err) {\n                  writeDone();\n                  return intermediateFs.unlink(tempFile, () => callback(err));\n                }\n\n                writeDone();\n                callback();\n              });\n            });\n          });\n        };\n\n        if (inProgressWrite) {\n          inProgressWrite.push(runWrite);\n        } else {\n          inProgressWrite = [];\n          runWrite();\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = HttpUriPlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/schemes/HttpUriPlugin.js"],"names":["EventEmitter","require","extname","basename","URL","createGunzip","createBrotliDecompress","createInflate","NormalModule","createSchemaValidation","createHash","mkdirp","dirname","join","memoize","getHttp","getHttps","proxyFetch","request","proxy","url","options","callback","eventEmitter","doRequest","socket","get","on","emit","bind","hostname","host","port","method","path","res","statusCode","err","Error","message","end","inProgressWrite","undefined","validate","name","baseDataPath","toSafePath","str","replace","computeIntegrity","content","hash","update","integrity","digest","verifyIntegrity","parseKeyValuePairs","result","item","split","i","indexOf","key","slice","trim","value","parseCacheControl","cacheControl","requestTime","storeCache","storeLock","validUntil","parsed","isNaN","areLockfileEntriesEqual","a","b","resolved","contentType","entryToString","entry","Lockfile","constructor","version","entries","Map","parse","data","JSON","lockfile","Object","keys","set","toString","Array","from","sort","stringify","cachedWithoutKey","fn","inFlight","cachedError","cachedResult","cachedCallbacks","push","callbacks","cb","cachedWithKey","forceFn","cache","resultFn","arg","cacheEntry","error","newCacheEntry","force","HttpUriPlugin","_lockfileLocation","lockfileLocation","_cacheLocation","cacheLocation","_upgrade","upgrade","_frozen","frozen","_allowedUris","allowedUris","_proxy","apply","compiler","process","env","schemes","scheme","fetch","lockfileCache","hooks","compilation","tap","normalModuleFactory","intermediateFs","intermediateFileSystem","fs","inputFileSystem","getCache","logger","getLogger","context","hashFunction","hashDigest","hashDigestLength","warnedAboutEol","cacheKeyCache","getCacheKey","_getCacheKey","parsedUrl","folder","origin","pathname","query","search","ext","length","getLockfile","readLockfile","readFile","buffer","code","missingDependencies","add","fileDependencies","fileSystemInfo","createSnapshot","fsStartTime","timestamp","snapshot","checkSnapshotValid","valid","lockfileUpdates","storeLockEntry","oldEntry","log","storeResult","filePath","writeFile","resolveContent","handleResult","location","innerResult","fresh","fetchContent","fetchContentRaw","Date","now","headers","etag","finishWith","partialResult","debug","Math","ceil","store","warn","stack","href","bufferArr","contentEncoding","stream","pipe","chunk","complete","Buffer","concat","isValid","isAllowed","uri","allowed","startsWith","test","getInfo","map","entryOrString","entryTag","doFetch","lockedContent","continueWithCachedContent","contentWithChangedEol","isEolChanged","e","explainer","info","respondWithUrlModule","resourceData","resource","fragment","mimetype","resolveForScheme","for","tapAsync","resolveData","resolveInScheme","dependencyType","getCompilationHooks","readResourceForScheme","module","buildInfo","resourceIntegrity","needBuild","finishModules","modules","tempFile","random","writeDone","nextOperation","shift","runWrite","unlink","rename","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst EventEmitter = require(\"events\");\nconst { extname, basename } = require(\"path\");\nconst { URL } = require(\"url\");\nconst { createGunzip, createBrotliDecompress, createInflate } = require(\"zlib\");\nconst NormalModule = require(\"../NormalModule\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst createHash = require(\"../util/createHash\");\nconst { mkdirp, dirname, join } = require(\"../util/fs\");\nconst memoize = require(\"../util/memoize\");\n\n/** @typedef {import(\"../../declarations/plugins/schemes/HttpUriPlugin\").HttpUriPluginOptions} HttpUriPluginOptions */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nconst getHttp = memoize(() => require(\"http\"));\nconst getHttps = memoize(() => require(\"https\"));\nconst proxyFetch = (request, proxy) => (url, options, callback) => {\n\tconst eventEmitter = new EventEmitter();\n\tconst doRequest = socket =>\n\t\trequest\n\t\t\t.get(url, { ...options, ...(socket && { socket }) }, callback)\n\t\t\t.on(\"error\", eventEmitter.emit.bind(eventEmitter, \"error\"));\n\n\tif (proxy) {\n\t\tconst { hostname: host, port } = new URL(proxy);\n\n\t\tgetHttp()\n\t\t\t.request({\n\t\t\t\thost, // IP address of proxy server\n\t\t\t\tport, // port of proxy server\n\t\t\t\tmethod: \"CONNECT\",\n\t\t\t\tpath: url.host\n\t\t\t})\n\t\t\t.on(\"connect\", (res, socket) => {\n\t\t\t\tif (res.statusCode === 200) {\n\t\t\t\t\t// connected to proxy server\n\t\t\t\t\tdoRequest(socket);\n\t\t\t\t}\n\t\t\t})\n\t\t\t.on(\"error\", err => {\n\t\t\t\teventEmitter.emit(\n\t\t\t\t\t\"error\",\n\t\t\t\t\tnew Error(\n\t\t\t\t\t\t`Failed to connect to proxy server \"${proxy}\": ${err.message}`\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t})\n\t\t\t.end();\n\t} else {\n\t\tdoRequest();\n\t}\n\n\treturn eventEmitter;\n};\n\n/** @type {(() => void)[] | undefined} */\nlet inProgressWrite = undefined;\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/schemes/HttpUriPlugin.check.js\"),\n\t() => require(\"../../schemas/plugins/schemes/HttpUriPlugin.json\"),\n\t{\n\t\tname: \"Http Uri Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\nconst toSafePath = str =>\n\tstr\n\t\t.replace(/^[^a-zA-Z0-9]+|[^a-zA-Z0-9]+$/g, \"\")\n\t\t.replace(/[^a-zA-Z0-9._-]+/g, \"_\");\n\nconst computeIntegrity = content => {\n\tconst hash = createHash(\"sha512\");\n\thash.update(content);\n\tconst integrity = \"sha512-\" + hash.digest(\"base64\");\n\treturn integrity;\n};\n\nconst verifyIntegrity = (content, integrity) => {\n\tif (integrity === \"ignore\") return true;\n\treturn computeIntegrity(content) === integrity;\n};\n\n/**\n * @param {string} str input\n * @returns {Record<string, string>} parsed\n */\nconst parseKeyValuePairs = str => {\n\t/** @type {Record<string, string>} */\n\tconst result = {};\n\tfor (const item of str.split(\",\")) {\n\t\tconst i = item.indexOf(\"=\");\n\t\tif (i >= 0) {\n\t\t\tconst key = item.slice(0, i).trim();\n\t\t\tconst value = item.slice(i + 1).trim();\n\t\t\tresult[key] = value;\n\t\t} else {\n\t\t\tconst key = item.trim();\n\t\t\tif (!key) continue;\n\t\t\tresult[key] = key;\n\t\t}\n\t}\n\treturn result;\n};\n\nconst parseCacheControl = (cacheControl, requestTime) => {\n\t// When false resource is not stored in cache\n\tlet storeCache = true;\n\t// When false resource is not stored in lockfile cache\n\tlet storeLock = true;\n\t// Resource is only revalidated, after that timestamp and when upgrade is chosen\n\tlet validUntil = 0;\n\tif (cacheControl) {\n\t\tconst parsed = parseKeyValuePairs(cacheControl);\n\t\tif (parsed[\"no-cache\"]) storeCache = storeLock = false;\n\t\tif (parsed[\"max-age\"] && !isNaN(+parsed[\"max-age\"])) {\n\t\t\tvalidUntil = requestTime + +parsed[\"max-age\"] * 1000;\n\t\t}\n\t\tif (parsed[\"must-revalidate\"]) validUntil = 0;\n\t}\n\treturn {\n\t\tstoreLock,\n\t\tstoreCache,\n\t\tvalidUntil\n\t};\n};\n\n/**\n * @typedef {Object} LockfileEntry\n * @property {string} resolved\n * @property {string} integrity\n * @property {string} contentType\n */\n\nconst areLockfileEntriesEqual = (a, b) => {\n\treturn (\n\t\ta.resolved === b.resolved &&\n\t\ta.integrity === b.integrity &&\n\t\ta.contentType === b.contentType\n\t);\n};\n\nconst entryToString = entry => {\n\treturn `resolved: ${entry.resolved}, integrity: ${entry.integrity}, contentType: ${entry.contentType}`;\n};\n\nclass Lockfile {\n\tconstructor() {\n\t\tthis.version = 1;\n\t\t/** @type {Map<string, LockfileEntry | \"ignore\" | \"no-cache\">} */\n\t\tthis.entries = new Map();\n\t}\n\n\tstatic parse(content) {\n\t\t// TODO handle merge conflicts\n\t\tconst data = JSON.parse(content);\n\t\tif (data.version !== 1)\n\t\t\tthrow new Error(`Unsupported lockfile version ${data.version}`);\n\t\tconst lockfile = new Lockfile();\n\t\tfor (const key of Object.keys(data)) {\n\t\t\tif (key === \"version\") continue;\n\t\t\tconst entry = data[key];\n\t\t\tlockfile.entries.set(\n\t\t\t\tkey,\n\t\t\t\ttypeof entry === \"string\"\n\t\t\t\t\t? entry\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tresolved: key,\n\t\t\t\t\t\t\t...entry\n\t\t\t\t\t  }\n\t\t\t);\n\t\t}\n\t\treturn lockfile;\n\t}\n\n\ttoString() {\n\t\tlet str = \"{\\n\";\n\t\tconst entries = Array.from(this.entries).sort(([a], [b]) =>\n\t\t\ta < b ? -1 : 1\n\t\t);\n\t\tfor (const [key, entry] of entries) {\n\t\t\tif (typeof entry === \"string\") {\n\t\t\t\tstr += `  ${JSON.stringify(key)}: ${JSON.stringify(entry)},\\n`;\n\t\t\t} else {\n\t\t\t\tstr += `  ${JSON.stringify(key)}: { `;\n\t\t\t\tif (entry.resolved !== key)\n\t\t\t\t\tstr += `\"resolved\": ${JSON.stringify(entry.resolved)}, `;\n\t\t\t\tstr += `\"integrity\": ${JSON.stringify(\n\t\t\t\t\tentry.integrity\n\t\t\t\t)}, \"contentType\": ${JSON.stringify(entry.contentType)} },\\n`;\n\t\t\t}\n\t\t}\n\t\tstr += `  \"version\": ${this.version}\\n}\\n`;\n\t\treturn str;\n\t}\n}\n\n/**\n * @template R\n * @param {function(function(Error=, R=): void): void} fn function\n * @returns {function(function((Error | null)=, R=): void): void} cached function\n */\nconst cachedWithoutKey = fn => {\n\tlet inFlight = false;\n\t/** @type {Error | undefined} */\n\tlet cachedError = undefined;\n\t/** @type {R | undefined} */\n\tlet cachedResult = undefined;\n\t/** @type {(function(Error=, R=): void)[] | undefined} */\n\tlet cachedCallbacks = undefined;\n\treturn callback => {\n\t\tif (inFlight) {\n\t\t\tif (cachedResult !== undefined) return callback(null, cachedResult);\n\t\t\tif (cachedError !== undefined) return callback(cachedError);\n\t\t\tif (cachedCallbacks === undefined) cachedCallbacks = [callback];\n\t\t\telse cachedCallbacks.push(callback);\n\t\t\treturn;\n\t\t}\n\t\tinFlight = true;\n\t\tfn((err, result) => {\n\t\t\tif (err) cachedError = err;\n\t\t\telse cachedResult = result;\n\t\t\tconst callbacks = cachedCallbacks;\n\t\t\tcachedCallbacks = undefined;\n\t\t\tcallback(err, result);\n\t\t\tif (callbacks !== undefined) for (const cb of callbacks) cb(err, result);\n\t\t});\n\t};\n};\n\n/**\n * @template T\n * @template R\n * @param {function(T, function(Error=, R=): void): void} fn function\n * @param {function(T, function(Error=, R=): void): void=} forceFn function for the second try\n * @returns {(function(T, function((Error | null)=, R=): void): void) & { force: function(T, function((Error | null)=, R=): void): void }} cached function\n */\nconst cachedWithKey = (fn, forceFn = fn) => {\n\t/** @typedef {{ result?: R, error?: Error, callbacks?: (function((Error | null)=, R=): void)[], force?: true }} CacheEntry */\n\t/** @type {Map<T, CacheEntry>} */\n\tconst cache = new Map();\n\tconst resultFn = (arg, callback) => {\n\t\tconst cacheEntry = cache.get(arg);\n\t\tif (cacheEntry !== undefined) {\n\t\t\tif (cacheEntry.result !== undefined)\n\t\t\t\treturn callback(null, cacheEntry.result);\n\t\t\tif (cacheEntry.error !== undefined) return callback(cacheEntry.error);\n\t\t\tif (cacheEntry.callbacks === undefined) cacheEntry.callbacks = [callback];\n\t\t\telse cacheEntry.callbacks.push(callback);\n\t\t\treturn;\n\t\t}\n\t\t/** @type {CacheEntry} */\n\t\tconst newCacheEntry = {\n\t\t\tresult: undefined,\n\t\t\terror: undefined,\n\t\t\tcallbacks: undefined\n\t\t};\n\t\tcache.set(arg, newCacheEntry);\n\t\tfn(arg, (err, result) => {\n\t\t\tif (err) newCacheEntry.error = err;\n\t\t\telse newCacheEntry.result = result;\n\t\t\tconst callbacks = newCacheEntry.callbacks;\n\t\t\tnewCacheEntry.callbacks = undefined;\n\t\t\tcallback(err, result);\n\t\t\tif (callbacks !== undefined) for (const cb of callbacks) cb(err, result);\n\t\t});\n\t};\n\tresultFn.force = (arg, callback) => {\n\t\tconst cacheEntry = cache.get(arg);\n\t\tif (cacheEntry !== undefined && cacheEntry.force) {\n\t\t\tif (cacheEntry.result !== undefined)\n\t\t\t\treturn callback(null, cacheEntry.result);\n\t\t\tif (cacheEntry.error !== undefined) return callback(cacheEntry.error);\n\t\t\tif (cacheEntry.callbacks === undefined) cacheEntry.callbacks = [callback];\n\t\t\telse cacheEntry.callbacks.push(callback);\n\t\t\treturn;\n\t\t}\n\t\t/** @type {CacheEntry} */\n\t\tconst newCacheEntry = {\n\t\t\tresult: undefined,\n\t\t\terror: undefined,\n\t\t\tcallbacks: undefined,\n\t\t\tforce: true\n\t\t};\n\t\tcache.set(arg, newCacheEntry);\n\t\tforceFn(arg, (err, result) => {\n\t\t\tif (err) newCacheEntry.error = err;\n\t\t\telse newCacheEntry.result = result;\n\t\t\tconst callbacks = newCacheEntry.callbacks;\n\t\t\tnewCacheEntry.callbacks = undefined;\n\t\t\tcallback(err, result);\n\t\t\tif (callbacks !== undefined) for (const cb of callbacks) cb(err, result);\n\t\t});\n\t};\n\treturn resultFn;\n};\n\nclass HttpUriPlugin {\n\t/**\n\t * @param {HttpUriPluginOptions} options options\n\t */\n\tconstructor(options) {\n\t\tvalidate(options);\n\t\tthis._lockfileLocation = options.lockfileLocation;\n\t\tthis._cacheLocation = options.cacheLocation;\n\t\tthis._upgrade = options.upgrade;\n\t\tthis._frozen = options.frozen;\n\t\tthis._allowedUris = options.allowedUris;\n\t\tthis._proxy = options.proxy;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst proxy =\n\t\t\tthis._proxy || process.env[\"http_proxy\"] || process.env[\"HTTP_PROXY\"];\n\t\tconst schemes = [\n\t\t\t{\n\t\t\t\tscheme: \"http\",\n\t\t\t\tfetch: proxyFetch(getHttp(), proxy)\n\t\t\t},\n\t\t\t{\n\t\t\t\tscheme: \"https\",\n\t\t\t\tfetch: proxyFetch(getHttps(), proxy)\n\t\t\t}\n\t\t];\n\t\tlet lockfileCache;\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"HttpUriPlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tconst intermediateFs = compiler.intermediateFileSystem;\n\t\t\t\tconst fs = compilation.inputFileSystem;\n\t\t\t\tconst cache = compilation.getCache(\"webpack.HttpUriPlugin\");\n\t\t\t\tconst logger = compilation.getLogger(\"webpack.HttpUriPlugin\");\n\t\t\t\tconst lockfileLocation =\n\t\t\t\t\tthis._lockfileLocation ||\n\t\t\t\t\tjoin(\n\t\t\t\t\t\tintermediateFs,\n\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\tcompiler.name\n\t\t\t\t\t\t\t? `${toSafePath(compiler.name)}.webpack.lock`\n\t\t\t\t\t\t\t: \"webpack.lock\"\n\t\t\t\t\t);\n\t\t\t\tconst cacheLocation =\n\t\t\t\t\tthis._cacheLocation !== undefined\n\t\t\t\t\t\t? this._cacheLocation\n\t\t\t\t\t\t: lockfileLocation + \".data\";\n\t\t\t\tconst upgrade = this._upgrade || false;\n\t\t\t\tconst frozen = this._frozen || false;\n\t\t\t\tconst hashFunction = \"sha512\";\n\t\t\t\tconst hashDigest = \"hex\";\n\t\t\t\tconst hashDigestLength = 20;\n\t\t\t\tconst allowedUris = this._allowedUris;\n\n\t\t\t\tlet warnedAboutEol = false;\n\n\t\t\t\tconst cacheKeyCache = new Map();\n\t\t\t\t/**\n\t\t\t\t * @param {string} url the url\n\t\t\t\t * @returns {string} the key\n\t\t\t\t */\n\t\t\t\tconst getCacheKey = url => {\n\t\t\t\t\tconst cachedResult = cacheKeyCache.get(url);\n\t\t\t\t\tif (cachedResult !== undefined) return cachedResult;\n\t\t\t\t\tconst result = _getCacheKey(url);\n\t\t\t\t\tcacheKeyCache.set(url, result);\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\t/**\n\t\t\t\t * @param {string} url the url\n\t\t\t\t * @returns {string} the key\n\t\t\t\t */\n\t\t\t\tconst _getCacheKey = url => {\n\t\t\t\t\tconst parsedUrl = new URL(url);\n\t\t\t\t\tconst folder = toSafePath(parsedUrl.origin);\n\t\t\t\t\tconst name = toSafePath(parsedUrl.pathname);\n\t\t\t\t\tconst query = toSafePath(parsedUrl.search);\n\t\t\t\t\tlet ext = extname(name);\n\t\t\t\t\tif (ext.length > 20) ext = \"\";\n\t\t\t\t\tconst basename = ext ? name.slice(0, -ext.length) : name;\n\t\t\t\t\tconst hash = createHash(hashFunction);\n\t\t\t\t\thash.update(url);\n\t\t\t\t\tconst digest = hash.digest(hashDigest).slice(0, hashDigestLength);\n\t\t\t\t\treturn `${folder.slice(-50)}/${`${basename}${\n\t\t\t\t\t\tquery ? `_${query}` : \"\"\n\t\t\t\t\t}`.slice(0, 150)}_${digest}${ext}`;\n\t\t\t\t};\n\n\t\t\t\tconst getLockfile = cachedWithoutKey(\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {function((Error | null)=, Lockfile=): void} callback callback\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tcallback => {\n\t\t\t\t\t\tconst readLockfile = () => {\n\t\t\t\t\t\t\tintermediateFs.readFile(lockfileLocation, (err, buffer) => {\n\t\t\t\t\t\t\t\tif (err && err.code !== \"ENOENT\") {\n\t\t\t\t\t\t\t\t\tcompilation.missingDependencies.add(lockfileLocation);\n\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcompilation.fileDependencies.add(lockfileLocation);\n\t\t\t\t\t\t\t\tcompilation.fileSystemInfo.createSnapshot(\n\t\t\t\t\t\t\t\t\tcompiler.fsStartTime,\n\t\t\t\t\t\t\t\t\tbuffer ? [lockfileLocation] : [],\n\t\t\t\t\t\t\t\t\t[],\n\t\t\t\t\t\t\t\t\tbuffer ? [] : [lockfileLocation],\n\t\t\t\t\t\t\t\t\t{ timestamp: true },\n\t\t\t\t\t\t\t\t\t(err, snapshot) => {\n\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\tconst lockfile = buffer\n\t\t\t\t\t\t\t\t\t\t\t? Lockfile.parse(buffer.toString(\"utf-8\"))\n\t\t\t\t\t\t\t\t\t\t\t: new Lockfile();\n\t\t\t\t\t\t\t\t\t\tlockfileCache = {\n\t\t\t\t\t\t\t\t\t\t\tlockfile,\n\t\t\t\t\t\t\t\t\t\t\tsnapshot\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tcallback(null, lockfile);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (lockfileCache) {\n\t\t\t\t\t\t\tcompilation.fileSystemInfo.checkSnapshotValid(\n\t\t\t\t\t\t\t\tlockfileCache.snapshot,\n\t\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\tif (!valid) return readLockfile();\n\t\t\t\t\t\t\t\t\tcallback(null, lockfileCache.lockfile);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treadLockfile();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t/** @type {Map<string, LockfileEntry | \"ignore\" | \"no-cache\"> | undefined} */\n\t\t\t\tlet lockfileUpdates = undefined;\n\t\t\t\tconst storeLockEntry = (lockfile, url, entry) => {\n\t\t\t\t\tconst oldEntry = lockfile.entries.get(url);\n\t\t\t\t\tif (lockfileUpdates === undefined) lockfileUpdates = new Map();\n\t\t\t\t\tlockfileUpdates.set(url, entry);\n\t\t\t\t\tlockfile.entries.set(url, entry);\n\t\t\t\t\tif (!oldEntry) {\n\t\t\t\t\t\tlogger.log(`${url} added to lockfile`);\n\t\t\t\t\t} else if (typeof oldEntry === \"string\") {\n\t\t\t\t\t\tif (typeof entry === \"string\") {\n\t\t\t\t\t\t\tlogger.log(`${url} updated in lockfile: ${oldEntry} -> ${entry}`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t`${url} updated in lockfile: ${oldEntry} -> ${entry.resolved}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (typeof entry === \"string\") {\n\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t`${url} updated in lockfile: ${oldEntry.resolved} -> ${entry}`\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (oldEntry.resolved !== entry.resolved) {\n\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t`${url} updated in lockfile: ${oldEntry.resolved} -> ${entry.resolved}`\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (oldEntry.integrity !== entry.integrity) {\n\t\t\t\t\t\tlogger.log(`${url} updated in lockfile: content changed`);\n\t\t\t\t\t} else if (oldEntry.contentType !== entry.contentType) {\n\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t`${url} updated in lockfile: ${oldEntry.contentType} -> ${entry.contentType}`\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.log(`${url} updated in lockfile`);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tconst storeResult = (lockfile, url, result, callback) => {\n\t\t\t\t\tif (result.storeLock) {\n\t\t\t\t\t\tstoreLockEntry(lockfile, url, result.entry);\n\t\t\t\t\t\tif (!cacheLocation || !result.content)\n\t\t\t\t\t\t\treturn callback(null, result);\n\t\t\t\t\t\tconst key = getCacheKey(result.entry.resolved);\n\t\t\t\t\t\tconst filePath = join(intermediateFs, cacheLocation, key);\n\t\t\t\t\t\tmkdirp(intermediateFs, dirname(intermediateFs, filePath), err => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tintermediateFs.writeFile(filePath, result.content, err => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstoreLockEntry(lockfile, url, \"no-cache\");\n\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tfor (const { scheme, fetch } of schemes) {\n\t\t\t\t\t/**\n\t\t\t\t\t *\n\t\t\t\t\t * @param {string} url URL\n\t\t\t\t\t * @param {string} integrity integrity\n\t\t\t\t\t * @param {function((Error | null)=, { entry: LockfileEntry, content: Buffer, storeLock: boolean }=): void} callback callback\n\t\t\t\t\t */\n\t\t\t\t\tconst resolveContent = (url, integrity, callback) => {\n\t\t\t\t\t\tconst handleResult = (err, result) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tif (\"location\" in result) {\n\t\t\t\t\t\t\t\treturn resolveContent(\n\t\t\t\t\t\t\t\t\tresult.location,\n\t\t\t\t\t\t\t\t\tintegrity,\n\t\t\t\t\t\t\t\t\t(err, innerResult) => {\n\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\tcallback(null, {\n\t\t\t\t\t\t\t\t\t\t\tentry: innerResult.entry,\n\t\t\t\t\t\t\t\t\t\t\tcontent: innerResult.content,\n\t\t\t\t\t\t\t\t\t\t\tstoreLock: innerResult.storeLock && result.storeLock\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t!result.fresh &&\n\t\t\t\t\t\t\t\t\tintegrity &&\n\t\t\t\t\t\t\t\t\tresult.entry.integrity !== integrity &&\n\t\t\t\t\t\t\t\t\t!verifyIntegrity(result.content, integrity)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\treturn fetchContent.force(url, handleResult);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\t\tentry: result.entry,\n\t\t\t\t\t\t\t\t\tcontent: result.content,\n\t\t\t\t\t\t\t\t\tstoreLock: result.storeLock\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfetchContent(url, handleResult);\n\t\t\t\t\t};\n\n\t\t\t\t\t/** @typedef {{ storeCache: boolean, storeLock: boolean, validUntil: number, etag: string | undefined, fresh: boolean }} FetchResultMeta */\n\t\t\t\t\t/** @typedef {FetchResultMeta & { location: string }} RedirectFetchResult */\n\t\t\t\t\t/** @typedef {FetchResultMeta & { entry: LockfileEntry, content: Buffer }} ContentFetchResult */\n\t\t\t\t\t/** @typedef {RedirectFetchResult | ContentFetchResult} FetchResult */\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} url URL\n\t\t\t\t\t * @param {FetchResult | RedirectFetchResult} cachedResult result from cache\n\t\t\t\t\t * @param {function((Error | null)=, FetchResult=): void} callback callback\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst fetchContentRaw = (url, cachedResult, callback) => {\n\t\t\t\t\t\tconst requestTime = Date.now();\n\t\t\t\t\t\tfetch(\n\t\t\t\t\t\t\tnew URL(url),\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t\t\"accept-encoding\": \"gzip, deflate, br\",\n\t\t\t\t\t\t\t\t\t\"user-agent\": \"webpack\",\n\t\t\t\t\t\t\t\t\t\"if-none-match\": cachedResult\n\t\t\t\t\t\t\t\t\t\t? cachedResult.etag || null\n\t\t\t\t\t\t\t\t\t\t: null\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tres => {\n\t\t\t\t\t\t\t\tconst etag = res.headers[\"etag\"];\n\t\t\t\t\t\t\t\tconst location = res.headers[\"location\"];\n\t\t\t\t\t\t\t\tconst cacheControl = res.headers[\"cache-control\"];\n\t\t\t\t\t\t\t\tconst { storeLock, storeCache, validUntil } = parseCacheControl(\n\t\t\t\t\t\t\t\t\tcacheControl,\n\t\t\t\t\t\t\t\t\trequestTime\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @param {Partial<Pick<FetchResultMeta, \"fresh\">> & (Pick<RedirectFetchResult, \"location\"> | Pick<ContentFetchResult, \"content\" | \"entry\">)} partialResult result\n\t\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst finishWith = partialResult => {\n\t\t\t\t\t\t\t\t\tif (\"location\" in partialResult) {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`GET ${url} [${res.statusCode}] -> ${partialResult.location}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`GET ${url} [${res.statusCode}] ${Math.ceil(\n\t\t\t\t\t\t\t\t\t\t\t\tpartialResult.content.length / 1024\n\t\t\t\t\t\t\t\t\t\t\t)} kB${!storeLock ? \" no-cache\" : \"\"}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst result = {\n\t\t\t\t\t\t\t\t\t\t...partialResult,\n\t\t\t\t\t\t\t\t\t\tfresh: true,\n\t\t\t\t\t\t\t\t\t\tstoreLock,\n\t\t\t\t\t\t\t\t\t\tstoreCache,\n\t\t\t\t\t\t\t\t\t\tvalidUntil,\n\t\t\t\t\t\t\t\t\t\tetag\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tif (!storeCache) {\n\t\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t\t`${url} can't be stored in cache, due to Cache-Control header: ${cacheControl}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\treturn callback(null, result);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcache.store(\n\t\t\t\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t...result,\n\t\t\t\t\t\t\t\t\t\t\tfresh: false\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t\t\t\t\t\t\t`${url} can't be stored in cache: ${err.message}`\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tif (res.statusCode === 304) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tcachedResult.validUntil < validUntil ||\n\t\t\t\t\t\t\t\t\t\tcachedResult.storeLock !== storeLock ||\n\t\t\t\t\t\t\t\t\t\tcachedResult.storeCache !== storeCache ||\n\t\t\t\t\t\t\t\t\t\tcachedResult.etag !== etag\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\treturn finishWith(cachedResult);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(`GET ${url} [${res.statusCode}] (unchanged)`);\n\t\t\t\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\t\t\t\t...cachedResult,\n\t\t\t\t\t\t\t\t\t\t\tfresh: true\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tlocation &&\n\t\t\t\t\t\t\t\t\tres.statusCode >= 301 &&\n\t\t\t\t\t\t\t\t\tres.statusCode <= 308\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tconst result = {\n\t\t\t\t\t\t\t\t\t\tlocation: new URL(location, url).href\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!cachedResult ||\n\t\t\t\t\t\t\t\t\t\t!(\"location\" in cachedResult) ||\n\t\t\t\t\t\t\t\t\t\tcachedResult.location !== result.location ||\n\t\t\t\t\t\t\t\t\t\tcachedResult.validUntil < validUntil ||\n\t\t\t\t\t\t\t\t\t\tcachedResult.storeLock !== storeLock ||\n\t\t\t\t\t\t\t\t\t\tcachedResult.storeCache !== storeCache ||\n\t\t\t\t\t\t\t\t\t\tcachedResult.etag !== etag\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\treturn finishWith(result);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(`GET ${url} [${res.statusCode}] (unchanged)`);\n\t\t\t\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\t\t\t\t...result,\n\t\t\t\t\t\t\t\t\t\t\tfresh: true,\n\t\t\t\t\t\t\t\t\t\t\tstoreLock,\n\t\t\t\t\t\t\t\t\t\t\tstoreCache,\n\t\t\t\t\t\t\t\t\t\t\tvalidUntil,\n\t\t\t\t\t\t\t\t\t\t\tetag\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst contentType = res.headers[\"content-type\"] || \"\";\n\t\t\t\t\t\t\t\tconst bufferArr = [];\n\n\t\t\t\t\t\t\t\tconst contentEncoding = res.headers[\"content-encoding\"];\n\t\t\t\t\t\t\t\tlet stream = res;\n\t\t\t\t\t\t\t\tif (contentEncoding === \"gzip\") {\n\t\t\t\t\t\t\t\t\tstream = stream.pipe(createGunzip());\n\t\t\t\t\t\t\t\t} else if (contentEncoding === \"br\") {\n\t\t\t\t\t\t\t\t\tstream = stream.pipe(createBrotliDecompress());\n\t\t\t\t\t\t\t\t} else if (contentEncoding === \"deflate\") {\n\t\t\t\t\t\t\t\t\tstream = stream.pipe(createInflate());\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tstream.on(\"data\", chunk => {\n\t\t\t\t\t\t\t\t\tbufferArr.push(chunk);\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tstream.on(\"end\", () => {\n\t\t\t\t\t\t\t\t\tif (!res.complete) {\n\t\t\t\t\t\t\t\t\t\tlogger.log(`GET ${url} [${res.statusCode}] (terminated)`);\n\t\t\t\t\t\t\t\t\t\treturn callback(new Error(`${url} request was terminated`));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tconst content = Buffer.concat(bufferArr);\n\n\t\t\t\t\t\t\t\t\tif (res.statusCode !== 200) {\n\t\t\t\t\t\t\t\t\t\tlogger.log(`GET ${url} [${res.statusCode}]`);\n\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t`${url} request status code = ${\n\t\t\t\t\t\t\t\t\t\t\t\t\tres.statusCode\n\t\t\t\t\t\t\t\t\t\t\t\t}\\n${content.toString(\"utf-8\")}`\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tconst integrity = computeIntegrity(content);\n\t\t\t\t\t\t\t\t\tconst entry = { resolved: url, integrity, contentType };\n\n\t\t\t\t\t\t\t\t\tfinishWith({\n\t\t\t\t\t\t\t\t\t\tentry,\n\t\t\t\t\t\t\t\t\t\tcontent\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t).on(\"error\", err => {\n\t\t\t\t\t\t\tlogger.log(`GET ${url} (error)`);\n\t\t\t\t\t\t\terr.message += `\\nwhile fetching ${url}`;\n\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\tconst fetchContent = cachedWithKey(\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {string} url URL\n\t\t\t\t\t\t * @param {function((Error | null)=, { validUntil: number, etag?: string, entry: LockfileEntry, content: Buffer, fresh: boolean } | { validUntil: number, etag?: string, location: string, fresh: boolean }=): void} callback callback\n\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t */ (url, callback) => {\n\t\t\t\t\t\t\tcache.get(url, null, (err, cachedResult) => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\tif (cachedResult) {\n\t\t\t\t\t\t\t\t\tconst isValid = cachedResult.validUntil >= Date.now();\n\t\t\t\t\t\t\t\t\tif (isValid) return callback(null, cachedResult);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfetchContentRaw(url, cachedResult, callback);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t\t(url, callback) => fetchContentRaw(url, undefined, callback)\n\t\t\t\t\t);\n\n\t\t\t\t\tconst isAllowed = uri => {\n\t\t\t\t\t\tfor (const allowed of allowedUris) {\n\t\t\t\t\t\t\tif (typeof allowed === \"string\") {\n\t\t\t\t\t\t\t\tif (uri.startsWith(allowed)) return true;\n\t\t\t\t\t\t\t} else if (typeof allowed === \"function\") {\n\t\t\t\t\t\t\t\tif (allowed(uri)) return true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (allowed.test(uri)) return true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t};\n\n\t\t\t\t\tconst getInfo = cachedWithKey(\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {string} url the url\n\t\t\t\t\t\t * @param {function((Error | null)=, { entry: LockfileEntry, content: Buffer }=): void} callback callback\n\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t */\n\t\t\t\t\t\t(url, callback) => {\n\t\t\t\t\t\t\tif (!isAllowed(url)) {\n\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t`${url} doesn't match the allowedUris policy. These URIs are allowed:\\n${allowedUris\n\t\t\t\t\t\t\t\t\t\t\t.map(uri => ` - ${uri}`)\n\t\t\t\t\t\t\t\t\t\t\t.join(\"\\n\")}`\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgetLockfile((err, lockfile) => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\tconst entryOrString = lockfile.entries.get(url);\n\t\t\t\t\t\t\t\tif (!entryOrString) {\n\t\t\t\t\t\t\t\t\tif (frozen) {\n\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t`${url} has no lockfile entry and lockfile is frozen`\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tresolveContent(url, null, (err, result) => {\n\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\tstoreResult(lockfile, url, result, callback);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (typeof entryOrString === \"string\") {\n\t\t\t\t\t\t\t\t\tconst entryTag = entryOrString;\n\t\t\t\t\t\t\t\t\tresolveContent(url, null, (err, result) => {\n\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\tif (!result.storeLock || entryTag === \"ignore\")\n\t\t\t\t\t\t\t\t\t\t\treturn callback(null, result);\n\t\t\t\t\t\t\t\t\t\tif (frozen) {\n\t\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\t`${url} used to have ${entryTag} lockfile entry and has content now, but lockfile is frozen`\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!upgrade) {\n\t\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\t`${url} used to have ${entryTag} lockfile entry and has content now.\nThis should be reflected in the lockfile, so this lockfile entry must be upgraded, but upgrading is not enabled.\nRemove this line from the lockfile to force upgrading.`\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tstoreResult(lockfile, url, result, callback);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet entry = entryOrString;\n\t\t\t\t\t\t\t\tconst doFetch = lockedContent => {\n\t\t\t\t\t\t\t\t\tresolveContent(url, entry.integrity, (err, result) => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tif (lockedContent) {\n\t\t\t\t\t\t\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t\t\t\t\t\t\t`Upgrade request to ${url} failed: ${err.message}`\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\t\t\t\t\t\tentry,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontent: lockedContent\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!result.storeLock) {\n\t\t\t\t\t\t\t\t\t\t\t// When the lockfile entry should be no-cache\n\t\t\t\t\t\t\t\t\t\t\t// we need to update the lockfile\n\t\t\t\t\t\t\t\t\t\t\tif (frozen) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`${url} has a lockfile entry and is no-cache now, but lockfile is frozen\\nLockfile: ${entryToString(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tentry\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)}`\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tstoreResult(lockfile, url, result, callback);\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!areLockfileEntriesEqual(result.entry, entry)) {\n\t\t\t\t\t\t\t\t\t\t\t// When the lockfile entry is outdated\n\t\t\t\t\t\t\t\t\t\t\t// we need to update the lockfile\n\t\t\t\t\t\t\t\t\t\t\tif (frozen) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`${url} has an outdated lockfile entry, but lockfile is frozen\\nLockfile: ${entryToString(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tentry\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)}\\nExpected: ${entryToString(result.entry)}`\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tstoreResult(lockfile, url, result, callback);\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!lockedContent && cacheLocation) {\n\t\t\t\t\t\t\t\t\t\t\t// When the lockfile cache content is missing\n\t\t\t\t\t\t\t\t\t\t\t// we need to update the lockfile\n\t\t\t\t\t\t\t\t\t\t\tif (frozen) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`${url} is missing content in the lockfile cache, but lockfile is frozen\\nLockfile: ${entryToString(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tentry\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)}`\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tstoreResult(lockfile, url, result, callback);\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn callback(null, result);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tif (cacheLocation) {\n\t\t\t\t\t\t\t\t\t// When there is a lockfile cache\n\t\t\t\t\t\t\t\t\t// we read the content from there\n\t\t\t\t\t\t\t\t\tconst key = getCacheKey(entry.resolved);\n\t\t\t\t\t\t\t\t\tconst filePath = join(intermediateFs, cacheLocation, key);\n\t\t\t\t\t\t\t\t\tfs.readFile(filePath, (err, result) => {\n\t\t\t\t\t\t\t\t\t\tconst content = /** @type {Buffer} */ (result);\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tif (err.code === \"ENOENT\") return doFetch();\n\t\t\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst continueWithCachedContent = result => {\n\t\t\t\t\t\t\t\t\t\t\tif (!upgrade) {\n\t\t\t\t\t\t\t\t\t\t\t\t// When not in upgrade mode, we accept the result from the lockfile cache\n\t\t\t\t\t\t\t\t\t\t\t\treturn callback(null, { entry, content });\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treturn doFetch(content);\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tif (!verifyIntegrity(content, entry.integrity)) {\n\t\t\t\t\t\t\t\t\t\t\tlet contentWithChangedEol;\n\t\t\t\t\t\t\t\t\t\t\tlet isEolChanged = false;\n\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\tcontentWithChangedEol = Buffer.from(\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontent.toString(\"utf-8\").replace(/\\r\\n/g, \"\\n\")\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tisEolChanged = verifyIntegrity(\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontentWithChangedEol,\n\t\t\t\t\t\t\t\t\t\t\t\t\tentry.integrity\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\t\t\t\t// ignore\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (isEolChanged) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (!warnedAboutEol) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst explainer = `Incorrect end of line sequence was detected in the lockfile cache.\nThe lockfile cache is protected by integrity checks, so any external modification will lead to a corrupted lockfile cache.\nWhen using git make sure to configure .gitattributes correctly for the lockfile cache:\n  **/*webpack.lock.data/** -text\nThis will avoid that the end of line sequence is changed by git on Windows.`;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (frozen) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlogger.error(explainer);\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlogger.warn(explainer);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"Lockfile cache will be automatically fixed now, but when lockfile is frozen this would result in an error.\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\twarnedAboutEol = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif (!frozen) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// \"fix\" the end of line sequence of the lockfile content\n\t\t\t\t\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`${filePath} fixed end of line sequence (\\\\r\\\\n instead of \\\\n).`\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\tintermediateFs.writeFile(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfilePath,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontentWithChangedEol,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontinueWithCachedContent(contentWithChangedEol);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (frozen) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`${\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tentry.resolved\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} integrity mismatch, expected content with integrity ${\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tentry.integrity\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} but got ${computeIntegrity(content)}.\nLockfile corrupted (${\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tisEolChanged\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? \"end of line sequence was unexpectedly changed\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: \"incorrectly merged? changed by other tools?\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}).\nRun build with un-frozen lockfile to automatically fix lockfile.`\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t// \"fix\" the lockfile entry to the correct integrity\n\t\t\t\t\t\t\t\t\t\t\t\t// the content has priority over the integrity value\n\t\t\t\t\t\t\t\t\t\t\t\tentry = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t...entry,\n\t\t\t\t\t\t\t\t\t\t\t\t\tintegrity: computeIntegrity(content)\n\t\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\t\t\tstoreLockEntry(lockfile, url, entry);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcontinueWithCachedContent(result);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdoFetch();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tconst respondWithUrlModule = (url, resourceData, callback) => {\n\t\t\t\t\t\tgetInfo(url.href, (err, result) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tresourceData.resource = url.href;\n\t\t\t\t\t\t\tresourceData.path = url.origin + url.pathname;\n\t\t\t\t\t\t\tresourceData.query = url.search;\n\t\t\t\t\t\t\tresourceData.fragment = url.hash;\n\t\t\t\t\t\t\tresourceData.context = new URL(\n\t\t\t\t\t\t\t\t\".\",\n\t\t\t\t\t\t\t\tresult.entry.resolved\n\t\t\t\t\t\t\t).href.slice(0, -1);\n\t\t\t\t\t\t\tresourceData.data.mimetype = result.entry.contentType;\n\t\t\t\t\t\t\tcallback(null, true);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\t\t\t\t\tnormalModuleFactory.hooks.resolveForScheme\n\t\t\t\t\t\t.for(scheme)\n\t\t\t\t\t\t.tapAsync(\n\t\t\t\t\t\t\t\"HttpUriPlugin\",\n\t\t\t\t\t\t\t(resourceData, resolveData, callback) => {\n\t\t\t\t\t\t\t\trespondWithUrlModule(\n\t\t\t\t\t\t\t\t\tnew URL(resourceData.resource),\n\t\t\t\t\t\t\t\t\tresourceData,\n\t\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\tnormalModuleFactory.hooks.resolveInScheme\n\t\t\t\t\t\t.for(scheme)\n\t\t\t\t\t\t.tapAsync(\"HttpUriPlugin\", (resourceData, data, callback) => {\n\t\t\t\t\t\t\t// Only handle relative urls (./xxx, ../xxx, /xxx, //xxx)\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tdata.dependencyType !== \"url\" &&\n\t\t\t\t\t\t\t\t!/^\\.{0,2}\\//.test(resourceData.resource)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trespondWithUrlModule(\n\t\t\t\t\t\t\t\tnew URL(resourceData.resource, data.context + \"/\"),\n\t\t\t\t\t\t\t\tresourceData,\n\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\tconst hooks = NormalModule.getCompilationHooks(compilation);\n\t\t\t\t\thooks.readResourceForScheme\n\t\t\t\t\t\t.for(scheme)\n\t\t\t\t\t\t.tapAsync(\"HttpUriPlugin\", (resource, module, callback) => {\n\t\t\t\t\t\t\treturn getInfo(resource, (err, result) => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\tmodule.buildInfo.resourceIntegrity = result.entry.integrity;\n\t\t\t\t\t\t\t\tcallback(null, result.content);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\thooks.needBuild.tapAsync(\n\t\t\t\t\t\t\"HttpUriPlugin\",\n\t\t\t\t\t\t(module, context, callback) => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tmodule.resource &&\n\t\t\t\t\t\t\t\tmodule.resource.startsWith(`${scheme}://`)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tgetInfo(module.resource, (err, result) => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tresult.entry.integrity !==\n\t\t\t\t\t\t\t\t\t\tmodule.buildInfo.resourceIntegrity\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\treturn callback(null, true);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcompilation.hooks.finishModules.tapAsync(\n\t\t\t\t\t\"HttpUriPlugin\",\n\t\t\t\t\t(modules, callback) => {\n\t\t\t\t\t\tif (!lockfileUpdates) return callback();\n\t\t\t\t\t\tconst ext = extname(lockfileLocation);\n\t\t\t\t\t\tconst tempFile = join(\n\t\t\t\t\t\t\tintermediateFs,\n\t\t\t\t\t\t\tdirname(intermediateFs, lockfileLocation),\n\t\t\t\t\t\t\t`.${basename(lockfileLocation, ext)}.${\n\t\t\t\t\t\t\t\t(Math.random() * 10000) | 0\n\t\t\t\t\t\t\t}${ext}`\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tconst writeDone = () => {\n\t\t\t\t\t\t\tconst nextOperation = inProgressWrite.shift();\n\t\t\t\t\t\t\tif (nextOperation) {\n\t\t\t\t\t\t\t\tnextOperation();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tinProgressWrite = undefined;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst runWrite = () => {\n\t\t\t\t\t\t\tintermediateFs.readFile(lockfileLocation, (err, buffer) => {\n\t\t\t\t\t\t\t\tif (err && err.code !== \"ENOENT\") {\n\t\t\t\t\t\t\t\t\twriteDone();\n\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst lockfile = buffer\n\t\t\t\t\t\t\t\t\t? Lockfile.parse(buffer.toString(\"utf-8\"))\n\t\t\t\t\t\t\t\t\t: new Lockfile();\n\t\t\t\t\t\t\t\tfor (const [key, value] of lockfileUpdates) {\n\t\t\t\t\t\t\t\t\tlockfile.entries.set(key, value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tintermediateFs.writeFile(tempFile, lockfile.toString(), err => {\n\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\twriteDone();\n\t\t\t\t\t\t\t\t\t\treturn intermediateFs.unlink(tempFile, () => callback(err));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tintermediateFs.rename(tempFile, lockfileLocation, err => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\twriteDone();\n\t\t\t\t\t\t\t\t\t\t\treturn intermediateFs.unlink(tempFile, () =>\n\t\t\t\t\t\t\t\t\t\t\t\tcallback(err)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\twriteDone();\n\t\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (inProgressWrite) {\n\t\t\t\t\t\t\tinProgressWrite.push(runWrite);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinProgressWrite = [];\n\t\t\t\t\t\t\trunWrite();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = HttpUriPlugin;\n"]},"metadata":{},"sourceType":"script"}