{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\n\nconst {\n  AsyncSeriesWaterfallHook,\n  SyncWaterfallHook\n} = require(\"tapable\");\n\nconst ContextModule = require(\"./ContextModule\");\n\nconst ModuleFactory = require(\"./ModuleFactory\");\n\nconst ContextElementDependency = require(\"./dependencies/ContextElementDependency\");\n\nconst LazySet = require(\"./util/LazySet\");\n\nconst {\n  cachedSetProperty\n} = require(\"./util/cleverMerge\");\n\nconst {\n  createFakeHook\n} = require(\"./util/deprecation\");\n\nconst {\n  join\n} = require(\"./util/fs\");\n/** @typedef {import(\"./ContextModule\").ContextModuleOptions} ContextModuleOptions */\n\n/** @typedef {import(\"./ContextModule\").ResolveDependenciesCallback} ResolveDependenciesCallback */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryCreateData} ModuleFactoryCreateData */\n\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryResult} ModuleFactoryResult */\n\n/** @typedef {import(\"./ResolverFactory\")} ResolverFactory */\n\n/** @typedef {import(\"./dependencies/ContextDependency\")} ContextDependency */\n\n/** @template T @typedef {import(\"./util/deprecation\").FakeHook<T>} FakeHook<T> */\n\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n\n\nconst EMPTY_RESOLVE_OPTIONS = {};\nmodule.exports = class ContextModuleFactory extends ModuleFactory {\n  /**\n   * @param {ResolverFactory} resolverFactory resolverFactory\n   */\n  constructor(resolverFactory) {\n    super();\n    /** @type {AsyncSeriesWaterfallHook<[TODO[], ContextModuleOptions]>} */\n\n    const alternativeRequests = new AsyncSeriesWaterfallHook([\"modules\", \"options\"]);\n    this.hooks = Object.freeze({\n      /** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n      beforeResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\n      /** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n      afterResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\n      /** @type {SyncWaterfallHook<[string[]]>} */\n      contextModuleFiles: new SyncWaterfallHook([\"files\"]),\n\n      /** @type {FakeHook<Pick<AsyncSeriesWaterfallHook<[TODO[]]>, \"tap\" | \"tapAsync\" | \"tapPromise\" | \"name\">>} */\n      alternatives: createFakeHook({\n        name: \"alternatives\",\n\n        /** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"intercept\"]} */\n        intercept: interceptor => {\n          throw new Error(\"Intercepting fake hook ContextModuleFactory.hooks.alternatives is not possible, use ContextModuleFactory.hooks.alternativeRequests instead\");\n        },\n\n        /** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tap\"]} */\n        tap: (options, fn) => {\n          alternativeRequests.tap(options, fn);\n        },\n\n        /** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tapAsync\"]} */\n        tapAsync: (options, fn) => {\n          alternativeRequests.tapAsync(options, (items, _options, callback) => fn(items, callback));\n        },\n\n        /** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tapPromise\"]} */\n        tapPromise: (options, fn) => {\n          alternativeRequests.tapPromise(options, fn);\n        }\n      }, \"ContextModuleFactory.hooks.alternatives has deprecated in favor of ContextModuleFactory.hooks.alternativeRequests with an additional options argument.\", \"DEP_WEBPACK_CONTEXT_MODULE_FACTORY_ALTERNATIVES\"),\n      alternativeRequests\n    });\n    this.resolverFactory = resolverFactory;\n  }\n  /**\n   * @param {ModuleFactoryCreateData} data data object\n   * @param {function(Error=, ModuleFactoryResult=): void} callback callback\n   * @returns {void}\n   */\n\n\n  create(data, callback) {\n    const context = data.context;\n    const dependencies = data.dependencies;\n    const resolveOptions = data.resolveOptions;\n    const dependency =\n    /** @type {ContextDependency} */\n    dependencies[0];\n    const fileDependencies = new LazySet();\n    const missingDependencies = new LazySet();\n    const contextDependencies = new LazySet();\n    this.hooks.beforeResolve.callAsync({\n      context: context,\n      dependencies: dependencies,\n      resolveOptions,\n      fileDependencies,\n      missingDependencies,\n      contextDependencies,\n      ...dependency.options\n    }, (err, beforeResolveResult) => {\n      if (err) {\n        return callback(err, {\n          fileDependencies,\n          missingDependencies,\n          contextDependencies\n        });\n      } // Ignored\n\n\n      if (!beforeResolveResult) {\n        return callback(null, {\n          fileDependencies,\n          missingDependencies,\n          contextDependencies\n        });\n      }\n\n      const context = beforeResolveResult.context;\n      const request = beforeResolveResult.request;\n      const resolveOptions = beforeResolveResult.resolveOptions;\n      let loaders,\n          resource,\n          loadersPrefix = \"\";\n      const idx = request.lastIndexOf(\"!\");\n\n      if (idx >= 0) {\n        let loadersRequest = request.substr(0, idx + 1);\n        let i;\n\n        for (i = 0; i < loadersRequest.length && loadersRequest[i] === \"!\"; i++) {\n          loadersPrefix += \"!\";\n        }\n\n        loadersRequest = loadersRequest.substr(i).replace(/!+$/, \"\").replace(/!!+/g, \"!\");\n\n        if (loadersRequest === \"\") {\n          loaders = [];\n        } else {\n          loaders = loadersRequest.split(\"!\");\n        }\n\n        resource = request.substr(idx + 1);\n      } else {\n        loaders = [];\n        resource = request;\n      }\n\n      const contextResolver = this.resolverFactory.get(\"context\", dependencies.length > 0 ? cachedSetProperty(resolveOptions || EMPTY_RESOLVE_OPTIONS, \"dependencyType\", dependencies[0].category) : resolveOptions);\n      const loaderResolver = this.resolverFactory.get(\"loader\");\n      asyncLib.parallel([callback => {\n        const results = [];\n\n        const yield_ = obj => results.push(obj);\n\n        contextResolver.resolve({}, context, resource, {\n          fileDependencies,\n          missingDependencies,\n          contextDependencies,\n          yield: yield_\n        }, err => {\n          if (err) return callback(err);\n          callback(null, results);\n        });\n      }, callback => {\n        asyncLib.map(loaders, (loader, callback) => {\n          loaderResolver.resolve({}, context, loader, {\n            fileDependencies,\n            missingDependencies,\n            contextDependencies\n          }, (err, result) => {\n            if (err) return callback(err);\n            callback(null, result);\n          });\n        }, callback);\n      }], (err, result) => {\n        if (err) {\n          return callback(err, {\n            fileDependencies,\n            missingDependencies,\n            contextDependencies\n          });\n        }\n\n        let [contextResult, loaderResult] = result;\n\n        if (contextResult.length > 1) {\n          const first = contextResult[0];\n          contextResult = contextResult.filter(r => r.path);\n          if (contextResult.length === 0) contextResult.push(first);\n        }\n\n        this.hooks.afterResolve.callAsync({\n          addon: loadersPrefix + loaderResult.join(\"!\") + (loaderResult.length > 0 ? \"!\" : \"\"),\n          resource: contextResult.length > 1 ? contextResult.map(r => r.path) : contextResult[0].path,\n          resolveDependencies: this.resolveDependencies.bind(this),\n          resourceQuery: contextResult[0].query,\n          resourceFragment: contextResult[0].fragment,\n          ...beforeResolveResult\n        }, (err, result) => {\n          if (err) {\n            return callback(err, {\n              fileDependencies,\n              missingDependencies,\n              contextDependencies\n            });\n          } // Ignored\n\n\n          if (!result) {\n            return callback(null, {\n              fileDependencies,\n              missingDependencies,\n              contextDependencies\n            });\n          }\n\n          return callback(null, {\n            module: new ContextModule(result.resolveDependencies, result),\n            fileDependencies,\n            missingDependencies,\n            contextDependencies\n          });\n        });\n      });\n    });\n  }\n  /**\n   * @param {InputFileSystem} fs file system\n   * @param {ContextModuleOptions} options options\n   * @param {ResolveDependenciesCallback} callback callback function\n   * @returns {void}\n   */\n\n\n  resolveDependencies(fs, options, callback) {\n    const cmf = this;\n    const {\n      resource,\n      resourceQuery,\n      resourceFragment,\n      recursive,\n      regExp,\n      include,\n      exclude,\n      referencedExports,\n      category,\n      typePrefix\n    } = options;\n    if (!regExp || !resource) return callback(null, []);\n    let severalContexts = false;\n\n    const addDirectoryChecked = (ctx, directory, visited, callback) => {\n      fs.realpath(directory, (err, realPath) => {\n        if (err) return callback(err);\n        if (visited.has(realPath)) return callback(null, []);\n        let recursionStack;\n        addDirectory(ctx, directory, (_, dir, callback) => {\n          if (recursionStack === undefined) {\n            recursionStack = new Set(visited);\n            recursionStack.add(realPath);\n          }\n\n          addDirectoryChecked(ctx, dir, recursionStack, callback);\n        }, callback);\n      });\n    };\n\n    const addDirectory = (ctx, directory, addSubDirectory, callback) => {\n      fs.readdir(directory, (err, files) => {\n        if (err) return callback(err);\n        const processedFiles = cmf.hooks.contextModuleFiles.call(\n        /** @type {string[]} */\n        files.map(file => file.normalize(\"NFC\")));\n        if (!processedFiles || processedFiles.length === 0) return callback(null, []);\n        asyncLib.map(processedFiles.filter(p => p.indexOf(\".\") !== 0), (segment, callback) => {\n          const subResource = join(fs, directory, segment);\n\n          if (!exclude || !subResource.match(exclude)) {\n            fs.stat(subResource, (err, stat) => {\n              if (err) {\n                if (err.code === \"ENOENT\") {\n                  // ENOENT is ok here because the file may have been deleted between\n                  // the readdir and stat calls.\n                  return callback();\n                } else {\n                  return callback(err);\n                }\n              }\n\n              if (stat.isDirectory()) {\n                if (!recursive) return callback();\n                addSubDirectory(ctx, subResource, callback);\n              } else if (stat.isFile() && (!include || subResource.match(include))) {\n                const obj = {\n                  context: ctx,\n                  request: \".\" + subResource.substr(ctx.length).replace(/\\\\/g, \"/\")\n                };\n                this.hooks.alternativeRequests.callAsync([obj], options, (err, alternatives) => {\n                  if (err) return callback(err);\n                  alternatives = alternatives.filter(obj => regExp.test(obj.request)).map(obj => {\n                    const request = severalContexts ? join(fs, obj.context, obj.request) : obj.request;\n                    const dep = new ContextElementDependency(request + resourceQuery + resourceFragment, obj.request, typePrefix, category, referencedExports);\n                    dep.optional = true;\n                    return dep;\n                  });\n                  callback(null, alternatives);\n                });\n              } else {\n                callback();\n              }\n            });\n          } else {\n            callback();\n          }\n        }, (err, result) => {\n          if (err) return callback(err);\n          if (!result) return callback(null, []);\n          const flattenedResult = [];\n\n          for (const item of result) {\n            if (item) flattenedResult.push(...item);\n          }\n\n          callback(null, flattenedResult);\n        });\n      });\n    };\n\n    const addSubDirectory = (ctx, dir, callback) => addDirectory(ctx, dir, addSubDirectory, callback);\n\n    const visitResource = (resource, callback) => {\n      if (typeof fs.realpath === \"function\") {\n        addDirectoryChecked(resource, resource, new Set(), callback);\n      } else {\n        addDirectory(resource, resource, addSubDirectory, callback);\n      }\n    };\n\n    if (typeof resource === \"string\") {\n      visitResource(resource, callback);\n    } else {\n      severalContexts = true;\n      asyncLib.map(resource, visitResource, (err, result) => {\n        if (err) return callback(err); // result dependencies should have unique userRequest\n        // ordered by resolve result\n\n        const temp = new Set();\n        const res = [];\n\n        for (let i = 0; i < result.length; i++) {\n          const inner = result[i];\n\n          for (const el of inner) {\n            if (temp.has(el.userRequest)) continue;\n            res.push(el);\n            temp.add(el.userRequest);\n          }\n        }\n\n        callback(null, res);\n      });\n    }\n  }\n\n};","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/ContextModuleFactory.js"],"names":["asyncLib","require","AsyncSeriesWaterfallHook","SyncWaterfallHook","ContextModule","ModuleFactory","ContextElementDependency","LazySet","cachedSetProperty","createFakeHook","join","EMPTY_RESOLVE_OPTIONS","module","exports","ContextModuleFactory","constructor","resolverFactory","alternativeRequests","hooks","Object","freeze","beforeResolve","afterResolve","contextModuleFiles","alternatives","name","intercept","interceptor","Error","tap","options","fn","tapAsync","items","_options","callback","tapPromise","create","data","context","dependencies","resolveOptions","dependency","fileDependencies","missingDependencies","contextDependencies","callAsync","err","beforeResolveResult","request","loaders","resource","loadersPrefix","idx","lastIndexOf","loadersRequest","substr","i","length","replace","split","contextResolver","get","category","loaderResolver","parallel","results","yield_","obj","push","resolve","yield","map","loader","result","contextResult","loaderResult","first","filter","r","path","addon","resolveDependencies","bind","resourceQuery","query","resourceFragment","fragment","fs","cmf","recursive","regExp","include","exclude","referencedExports","typePrefix","severalContexts","addDirectoryChecked","ctx","directory","visited","realpath","realPath","has","recursionStack","addDirectory","_","dir","undefined","Set","add","addSubDirectory","readdir","files","processedFiles","call","file","normalize","p","indexOf","segment","subResource","match","stat","code","isDirectory","isFile","test","dep","optional","flattenedResult","item","visitResource","temp","res","inner","el","userRequest"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst { AsyncSeriesWaterfallHook, SyncWaterfallHook } = require(\"tapable\");\nconst ContextModule = require(\"./ContextModule\");\nconst ModuleFactory = require(\"./ModuleFactory\");\nconst ContextElementDependency = require(\"./dependencies/ContextElementDependency\");\nconst LazySet = require(\"./util/LazySet\");\nconst { cachedSetProperty } = require(\"./util/cleverMerge\");\nconst { createFakeHook } = require(\"./util/deprecation\");\nconst { join } = require(\"./util/fs\");\n\n/** @typedef {import(\"./ContextModule\").ContextModuleOptions} ContextModuleOptions */\n/** @typedef {import(\"./ContextModule\").ResolveDependenciesCallback} ResolveDependenciesCallback */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryCreateData} ModuleFactoryCreateData */\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryResult} ModuleFactoryResult */\n/** @typedef {import(\"./ResolverFactory\")} ResolverFactory */\n/** @typedef {import(\"./dependencies/ContextDependency\")} ContextDependency */\n/** @template T @typedef {import(\"./util/deprecation\").FakeHook<T>} FakeHook<T> */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n\nconst EMPTY_RESOLVE_OPTIONS = {};\n\nmodule.exports = class ContextModuleFactory extends ModuleFactory {\n\t/**\n\t * @param {ResolverFactory} resolverFactory resolverFactory\n\t */\n\tconstructor(resolverFactory) {\n\t\tsuper();\n\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[], ContextModuleOptions]>} */\n\t\tconst alternativeRequests = new AsyncSeriesWaterfallHook([\n\t\t\t\"modules\",\n\t\t\t\"options\"\n\t\t]);\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n\t\t\tbeforeResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n\t\t\tafterResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\t\t\t/** @type {SyncWaterfallHook<[string[]]>} */\n\t\t\tcontextModuleFiles: new SyncWaterfallHook([\"files\"]),\n\t\t\t/** @type {FakeHook<Pick<AsyncSeriesWaterfallHook<[TODO[]]>, \"tap\" | \"tapAsync\" | \"tapPromise\" | \"name\">>} */\n\t\t\talternatives: createFakeHook(\n\t\t\t\t{\n\t\t\t\t\tname: \"alternatives\",\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"intercept\"]} */\n\t\t\t\t\tintercept: interceptor => {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\"Intercepting fake hook ContextModuleFactory.hooks.alternatives is not possible, use ContextModuleFactory.hooks.alternativeRequests instead\"\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tap\"]} */\n\t\t\t\t\ttap: (options, fn) => {\n\t\t\t\t\t\talternativeRequests.tap(options, fn);\n\t\t\t\t\t},\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tapAsync\"]} */\n\t\t\t\t\ttapAsync: (options, fn) => {\n\t\t\t\t\t\talternativeRequests.tapAsync(options, (items, _options, callback) =>\n\t\t\t\t\t\t\tfn(items, callback)\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tapPromise\"]} */\n\t\t\t\t\ttapPromise: (options, fn) => {\n\t\t\t\t\t\talternativeRequests.tapPromise(options, fn);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"ContextModuleFactory.hooks.alternatives has deprecated in favor of ContextModuleFactory.hooks.alternativeRequests with an additional options argument.\",\n\t\t\t\t\"DEP_WEBPACK_CONTEXT_MODULE_FACTORY_ALTERNATIVES\"\n\t\t\t),\n\t\t\talternativeRequests\n\t\t});\n\t\tthis.resolverFactory = resolverFactory;\n\t}\n\n\t/**\n\t * @param {ModuleFactoryCreateData} data data object\n\t * @param {function(Error=, ModuleFactoryResult=): void} callback callback\n\t * @returns {void}\n\t */\n\tcreate(data, callback) {\n\t\tconst context = data.context;\n\t\tconst dependencies = data.dependencies;\n\t\tconst resolveOptions = data.resolveOptions;\n\t\tconst dependency = /** @type {ContextDependency} */ (dependencies[0]);\n\t\tconst fileDependencies = new LazySet();\n\t\tconst missingDependencies = new LazySet();\n\t\tconst contextDependencies = new LazySet();\n\t\tthis.hooks.beforeResolve.callAsync(\n\t\t\t{\n\t\t\t\tcontext: context,\n\t\t\t\tdependencies: dependencies,\n\t\t\t\tresolveOptions,\n\t\t\t\tfileDependencies,\n\t\t\t\tmissingDependencies,\n\t\t\t\tcontextDependencies,\n\t\t\t\t...dependency.options\n\t\t\t},\n\t\t\t(err, beforeResolveResult) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err, {\n\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Ignored\n\t\t\t\tif (!beforeResolveResult) {\n\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst context = beforeResolveResult.context;\n\t\t\t\tconst request = beforeResolveResult.request;\n\t\t\t\tconst resolveOptions = beforeResolveResult.resolveOptions;\n\n\t\t\t\tlet loaders,\n\t\t\t\t\tresource,\n\t\t\t\t\tloadersPrefix = \"\";\n\t\t\t\tconst idx = request.lastIndexOf(\"!\");\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tlet loadersRequest = request.substr(0, idx + 1);\n\t\t\t\t\tlet i;\n\t\t\t\t\tfor (\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\ti < loadersRequest.length && loadersRequest[i] === \"!\";\n\t\t\t\t\t\ti++\n\t\t\t\t\t) {\n\t\t\t\t\t\tloadersPrefix += \"!\";\n\t\t\t\t\t}\n\t\t\t\t\tloadersRequest = loadersRequest\n\t\t\t\t\t\t.substr(i)\n\t\t\t\t\t\t.replace(/!+$/, \"\")\n\t\t\t\t\t\t.replace(/!!+/g, \"!\");\n\t\t\t\t\tif (loadersRequest === \"\") {\n\t\t\t\t\t\tloaders = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tloaders = loadersRequest.split(\"!\");\n\t\t\t\t\t}\n\t\t\t\t\tresource = request.substr(idx + 1);\n\t\t\t\t} else {\n\t\t\t\t\tloaders = [];\n\t\t\t\t\tresource = request;\n\t\t\t\t}\n\n\t\t\t\tconst contextResolver = this.resolverFactory.get(\n\t\t\t\t\t\"context\",\n\t\t\t\t\tdependencies.length > 0\n\t\t\t\t\t\t? cachedSetProperty(\n\t\t\t\t\t\t\t\tresolveOptions || EMPTY_RESOLVE_OPTIONS,\n\t\t\t\t\t\t\t\t\"dependencyType\",\n\t\t\t\t\t\t\t\tdependencies[0].category\n\t\t\t\t\t\t  )\n\t\t\t\t\t\t: resolveOptions\n\t\t\t\t);\n\t\t\t\tconst loaderResolver = this.resolverFactory.get(\"loader\");\n\n\t\t\t\tasyncLib.parallel(\n\t\t\t\t\t[\n\t\t\t\t\t\tcallback => {\n\t\t\t\t\t\t\tconst results = [];\n\t\t\t\t\t\t\tconst yield_ = obj => results.push(obj);\n\n\t\t\t\t\t\t\tcontextResolver.resolve(\n\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\tresource,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\tcontextDependencies,\n\t\t\t\t\t\t\t\t\tyield: yield_\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\tcallback(null, results);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcallback => {\n\t\t\t\t\t\t\tasyncLib.map(\n\t\t\t\t\t\t\t\tloaders,\n\t\t\t\t\t\t\t\t(loader, callback) => {\n\t\t\t\t\t\t\t\t\tloaderResolver.resolve(\n\t\t\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\t\t\tloader,\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treturn callback(err, {\n\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet [contextResult, loaderResult] = result;\n\t\t\t\t\t\tif (contextResult.length > 1) {\n\t\t\t\t\t\t\tconst first = contextResult[0];\n\t\t\t\t\t\t\tcontextResult = contextResult.filter(r => r.path);\n\t\t\t\t\t\t\tif (contextResult.length === 0) contextResult.push(first);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.hooks.afterResolve.callAsync(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\taddon:\n\t\t\t\t\t\t\t\t\tloadersPrefix +\n\t\t\t\t\t\t\t\t\tloaderResult.join(\"!\") +\n\t\t\t\t\t\t\t\t\t(loaderResult.length > 0 ? \"!\" : \"\"),\n\t\t\t\t\t\t\t\tresource:\n\t\t\t\t\t\t\t\t\tcontextResult.length > 1\n\t\t\t\t\t\t\t\t\t\t? contextResult.map(r => r.path)\n\t\t\t\t\t\t\t\t\t\t: contextResult[0].path,\n\t\t\t\t\t\t\t\tresolveDependencies: this.resolveDependencies.bind(this),\n\t\t\t\t\t\t\t\tresourceQuery: contextResult[0].query,\n\t\t\t\t\t\t\t\tresourceFragment: contextResult[0].fragment,\n\t\t\t\t\t\t\t\t...beforeResolveResult\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treturn callback(err, {\n\t\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Ignored\n\t\t\t\t\t\t\t\tif (!result) {\n\t\t\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\t\tmodule: new ContextModule(result.resolveDependencies, result),\n\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {InputFileSystem} fs file system\n\t * @param {ContextModuleOptions} options options\n\t * @param {ResolveDependenciesCallback} callback callback function\n\t * @returns {void}\n\t */\n\tresolveDependencies(fs, options, callback) {\n\t\tconst cmf = this;\n\t\tconst {\n\t\t\tresource,\n\t\t\tresourceQuery,\n\t\t\tresourceFragment,\n\t\t\trecursive,\n\t\t\tregExp,\n\t\t\tinclude,\n\t\t\texclude,\n\t\t\treferencedExports,\n\t\t\tcategory,\n\t\t\ttypePrefix\n\t\t} = options;\n\t\tif (!regExp || !resource) return callback(null, []);\n\n\t\tlet severalContexts = false;\n\t\tconst addDirectoryChecked = (ctx, directory, visited, callback) => {\n\t\t\tfs.realpath(directory, (err, realPath) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tif (visited.has(realPath)) return callback(null, []);\n\t\t\t\tlet recursionStack;\n\t\t\t\taddDirectory(\n\t\t\t\t\tctx,\n\t\t\t\t\tdirectory,\n\t\t\t\t\t(_, dir, callback) => {\n\t\t\t\t\t\tif (recursionStack === undefined) {\n\t\t\t\t\t\t\trecursionStack = new Set(visited);\n\t\t\t\t\t\t\trecursionStack.add(realPath);\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddDirectoryChecked(ctx, dir, recursionStack, callback);\n\t\t\t\t\t},\n\t\t\t\t\tcallback\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\tconst addDirectory = (ctx, directory, addSubDirectory, callback) => {\n\t\t\tfs.readdir(directory, (err, files) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tconst processedFiles = cmf.hooks.contextModuleFiles.call(\n\t\t\t\t\t/** @type {string[]} */ (files).map(file => file.normalize(\"NFC\"))\n\t\t\t\t);\n\t\t\t\tif (!processedFiles || processedFiles.length === 0)\n\t\t\t\t\treturn callback(null, []);\n\t\t\t\tasyncLib.map(\n\t\t\t\t\tprocessedFiles.filter(p => p.indexOf(\".\") !== 0),\n\t\t\t\t\t(segment, callback) => {\n\t\t\t\t\t\tconst subResource = join(fs, directory, segment);\n\n\t\t\t\t\t\tif (!exclude || !subResource.match(exclude)) {\n\t\t\t\t\t\t\tfs.stat(subResource, (err, stat) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\t\t\t\t\t\t\t// ENOENT is ok here because the file may have been deleted between\n\t\t\t\t\t\t\t\t\t\t// the readdir and stat calls.\n\t\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\t\t\t\t\tif (!recursive) return callback();\n\t\t\t\t\t\t\t\t\taddSubDirectory(ctx, subResource, callback);\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tstat.isFile() &&\n\t\t\t\t\t\t\t\t\t(!include || subResource.match(include))\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\t\t\t\tcontext: ctx,\n\t\t\t\t\t\t\t\t\t\trequest:\n\t\t\t\t\t\t\t\t\t\t\t\".\" + subResource.substr(ctx.length).replace(/\\\\/g, \"/\")\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tthis.hooks.alternativeRequests.callAsync(\n\t\t\t\t\t\t\t\t\t\t[obj],\n\t\t\t\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\t\t\t\t(err, alternatives) => {\n\t\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\t\talternatives = alternatives\n\t\t\t\t\t\t\t\t\t\t\t\t.filter(obj => regExp.test(obj.request))\n\t\t\t\t\t\t\t\t\t\t\t\t.map(obj => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst request = severalContexts\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? join(fs, obj.context, obj.request)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: obj.request;\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new ContextElementDependency(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trequest + resourceQuery + resourceFragment,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tobj.request,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttypePrefix,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcategory,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treferencedExports\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\tdep.optional = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn dep;\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\tcallback(null, alternatives);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\tif (!result) return callback(null, []);\n\n\t\t\t\t\t\tconst flattenedResult = [];\n\n\t\t\t\t\t\tfor (const item of result) {\n\t\t\t\t\t\t\tif (item) flattenedResult.push(...item);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcallback(null, flattenedResult);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\tconst addSubDirectory = (ctx, dir, callback) =>\n\t\t\taddDirectory(ctx, dir, addSubDirectory, callback);\n\n\t\tconst visitResource = (resource, callback) => {\n\t\t\tif (typeof fs.realpath === \"function\") {\n\t\t\t\taddDirectoryChecked(resource, resource, new Set(), callback);\n\t\t\t} else {\n\t\t\t\taddDirectory(resource, resource, addSubDirectory, callback);\n\t\t\t}\n\t\t};\n\n\t\tif (typeof resource === \"string\") {\n\t\t\tvisitResource(resource, callback);\n\t\t} else {\n\t\t\tseveralContexts = true;\n\t\t\tasyncLib.map(resource, visitResource, (err, result) => {\n\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t// result dependencies should have unique userRequest\n\t\t\t\t// ordered by resolve result\n\t\t\t\tconst temp = new Set();\n\t\t\t\tconst res = [];\n\t\t\t\tfor (let i = 0; i < result.length; i++) {\n\t\t\t\t\tconst inner = result[i];\n\t\t\t\t\tfor (const el of inner) {\n\t\t\t\t\t\tif (temp.has(el.userRequest)) continue;\n\t\t\t\t\t\tres.push(el);\n\t\t\t\t\t\ttemp.add(el.userRequest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcallback(null, res);\n\t\t\t});\n\t\t}\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}