{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  SyncHook\n} = require(\"tapable\");\n/**\n * @typedef {Object} RuleCondition\n * @property {string | string[]} property\n * @property {boolean} matchWhenEmpty\n * @property {function(string): boolean} fn\n */\n\n/**\n * @typedef {Object} Condition\n * @property {boolean} matchWhenEmpty\n * @property {function(string): boolean} fn\n */\n\n/**\n * @typedef {Object} CompiledRule\n * @property {RuleCondition[]} conditions\n * @property {(Effect|function(object): Effect[])[]} effects\n * @property {CompiledRule[]=} rules\n * @property {CompiledRule[]=} oneOf\n */\n\n/**\n * @typedef {Object} Effect\n * @property {string} type\n * @property {any} value\n */\n\n/**\n * @typedef {Object} RuleSet\n * @property {Map<string, any>} references map of references in the rule set (may grow over time)\n * @property {function(object): Effect[]} exec execute the rule set\n */\n\n\nclass RuleSetCompiler {\n  constructor(plugins) {\n    this.hooks = Object.freeze({\n      /** @type {SyncHook<[string, object, Set<string>, CompiledRule, Map<string, any>]>} */\n      rule: new SyncHook([\"path\", \"rule\", \"unhandledProperties\", \"compiledRule\", \"references\"])\n    });\n\n    if (plugins) {\n      for (const plugin of plugins) {\n        plugin.apply(this);\n      }\n    }\n  }\n  /**\n   * @param {object[]} ruleSet raw user provided rules\n   * @returns {RuleSet} compiled RuleSet\n   */\n\n\n  compile(ruleSet) {\n    const refs = new Map();\n    const rules = this.compileRules(\"ruleSet\", ruleSet, refs);\n    /**\n     * @param {object} data data passed in\n     * @param {CompiledRule} rule the compiled rule\n     * @param {Effect[]} effects an array where effects are pushed to\n     * @returns {boolean} true, if the rule has matched\n     */\n\n    const execRule = (data, rule, effects) => {\n      for (const condition of rule.conditions) {\n        const p = condition.property;\n\n        if (Array.isArray(p)) {\n          let current = data;\n\n          for (const subProperty of p) {\n            if (current && typeof current === \"object\" && Object.prototype.hasOwnProperty.call(current, subProperty)) {\n              current = current[subProperty];\n            } else {\n              current = undefined;\n              break;\n            }\n          }\n\n          if (current !== undefined) {\n            if (!condition.fn(current)) return false;\n            continue;\n          }\n        } else if (p in data) {\n          const value = data[p];\n\n          if (value !== undefined) {\n            if (!condition.fn(value)) return false;\n            continue;\n          }\n        }\n\n        if (!condition.matchWhenEmpty) {\n          return false;\n        }\n      }\n\n      for (const effect of rule.effects) {\n        if (typeof effect === \"function\") {\n          const returnedEffects = effect(data);\n\n          for (const effect of returnedEffects) {\n            effects.push(effect);\n          }\n        } else {\n          effects.push(effect);\n        }\n      }\n\n      if (rule.rules) {\n        for (const childRule of rule.rules) {\n          execRule(data, childRule, effects);\n        }\n      }\n\n      if (rule.oneOf) {\n        for (const childRule of rule.oneOf) {\n          if (execRule(data, childRule, effects)) {\n            break;\n          }\n        }\n      }\n\n      return true;\n    };\n\n    return {\n      references: refs,\n      exec: data => {\n        /** @type {Effect[]} */\n        const effects = [];\n\n        for (const rule of rules) {\n          execRule(data, rule, effects);\n        }\n\n        return effects;\n      }\n    };\n  }\n  /**\n   * @param {string} path current path\n   * @param {object[]} rules the raw rules provided by user\n   * @param {Map<string, any>} refs references\n   * @returns {CompiledRule[]} rules\n   */\n\n\n  compileRules(path, rules, refs) {\n    return rules.map((rule, i) => this.compileRule(`${path}[${i}]`, rule, refs));\n  }\n  /**\n   * @param {string} path current path\n   * @param {object} rule the raw rule provided by user\n   * @param {Map<string, any>} refs references\n   * @returns {CompiledRule} normalized and compiled rule for processing\n   */\n\n\n  compileRule(path, rule, refs) {\n    const unhandledProperties = new Set(Object.keys(rule).filter(key => rule[key] !== undefined));\n    /** @type {CompiledRule} */\n\n    const compiledRule = {\n      conditions: [],\n      effects: [],\n      rules: undefined,\n      oneOf: undefined\n    };\n    this.hooks.rule.call(path, rule, unhandledProperties, compiledRule, refs);\n\n    if (unhandledProperties.has(\"rules\")) {\n      unhandledProperties.delete(\"rules\");\n      const rules = rule.rules;\n      if (!Array.isArray(rules)) throw this.error(path, rules, \"Rule.rules must be an array of rules\");\n      compiledRule.rules = this.compileRules(`${path}.rules`, rules, refs);\n    }\n\n    if (unhandledProperties.has(\"oneOf\")) {\n      unhandledProperties.delete(\"oneOf\");\n      const oneOf = rule.oneOf;\n      if (!Array.isArray(oneOf)) throw this.error(path, oneOf, \"Rule.oneOf must be an array of rules\");\n      compiledRule.oneOf = this.compileRules(`${path}.oneOf`, oneOf, refs);\n    }\n\n    if (unhandledProperties.size > 0) {\n      throw this.error(path, rule, `Properties ${Array.from(unhandledProperties).join(\", \")} are unknown`);\n    }\n\n    return compiledRule;\n  }\n  /**\n   * @param {string} path current path\n   * @param {any} condition user provided condition value\n   * @returns {Condition} compiled condition\n   */\n\n\n  compileCondition(path, condition) {\n    if (condition === \"\") {\n      return {\n        matchWhenEmpty: true,\n        fn: str => str === \"\"\n      };\n    }\n\n    if (!condition) {\n      throw this.error(path, condition, \"Expected condition but got falsy value\");\n    }\n\n    if (typeof condition === \"string\") {\n      return {\n        matchWhenEmpty: condition.length === 0,\n        fn: str => typeof str === \"string\" && str.startsWith(condition)\n      };\n    }\n\n    if (typeof condition === \"function\") {\n      try {\n        return {\n          matchWhenEmpty: condition(\"\"),\n          fn: condition\n        };\n      } catch (err) {\n        throw this.error(path, condition, \"Evaluation of condition function threw error\");\n      }\n    }\n\n    if (condition instanceof RegExp) {\n      return {\n        matchWhenEmpty: condition.test(\"\"),\n        fn: v => typeof v === \"string\" && condition.test(v)\n      };\n    }\n\n    if (Array.isArray(condition)) {\n      const items = condition.map((c, i) => this.compileCondition(`${path}[${i}]`, c));\n      return this.combineConditionsOr(items);\n    }\n\n    if (typeof condition !== \"object\") {\n      throw this.error(path, condition, `Unexpected ${typeof condition} when condition was expected`);\n    }\n\n    const conditions = [];\n\n    for (const key of Object.keys(condition)) {\n      const value = condition[key];\n\n      switch (key) {\n        case \"or\":\n          if (value) {\n            if (!Array.isArray(value)) {\n              throw this.error(`${path}.or`, condition.and, \"Expected array of conditions\");\n            }\n\n            conditions.push(this.compileCondition(`${path}.or`, value));\n          }\n\n          break;\n\n        case \"and\":\n          if (value) {\n            if (!Array.isArray(value)) {\n              throw this.error(`${path}.and`, condition.and, \"Expected array of conditions\");\n            }\n\n            let i = 0;\n\n            for (const item of value) {\n              conditions.push(this.compileCondition(`${path}.and[${i}]`, item));\n              i++;\n            }\n          }\n\n          break;\n\n        case \"not\":\n          if (value) {\n            const matcher = this.compileCondition(`${path}.not`, value);\n            const fn = matcher.fn;\n            conditions.push({\n              matchWhenEmpty: !matcher.matchWhenEmpty,\n              fn: v => !fn(v)\n            });\n          }\n\n          break;\n\n        default:\n          throw this.error(`${path}.${key}`, condition[key], `Unexpected property ${key} in condition`);\n      }\n    }\n\n    if (conditions.length === 0) {\n      throw this.error(path, condition, \"Expected condition, but got empty thing\");\n    }\n\n    return this.combineConditionsAnd(conditions);\n  }\n  /**\n   * @param {Condition[]} conditions some conditions\n   * @returns {Condition} merged condition\n   */\n\n\n  combineConditionsOr(conditions) {\n    if (conditions.length === 0) {\n      return {\n        matchWhenEmpty: false,\n        fn: () => false\n      };\n    } else if (conditions.length === 1) {\n      return conditions[0];\n    } else {\n      return {\n        matchWhenEmpty: conditions.some(c => c.matchWhenEmpty),\n        fn: v => conditions.some(c => c.fn(v))\n      };\n    }\n  }\n  /**\n   * @param {Condition[]} conditions some conditions\n   * @returns {Condition} merged condition\n   */\n\n\n  combineConditionsAnd(conditions) {\n    if (conditions.length === 0) {\n      return {\n        matchWhenEmpty: false,\n        fn: () => false\n      };\n    } else if (conditions.length === 1) {\n      return conditions[0];\n    } else {\n      return {\n        matchWhenEmpty: conditions.every(c => c.matchWhenEmpty),\n        fn: v => conditions.every(c => c.fn(v))\n      };\n    }\n  }\n  /**\n   * @param {string} path current path\n   * @param {any} value value at the error location\n   * @param {string} message message explaining the problem\n   * @returns {Error} an error object\n   */\n\n\n  error(path, value, message) {\n    return new Error(`Compiling RuleSet failed: ${message} (at ${path}: ${value})`);\n  }\n\n}\n\nmodule.exports = RuleSetCompiler;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/rules/RuleSetCompiler.js"],"names":["SyncHook","require","RuleSetCompiler","constructor","plugins","hooks","Object","freeze","rule","plugin","apply","compile","ruleSet","refs","Map","rules","compileRules","execRule","data","effects","condition","conditions","p","property","Array","isArray","current","subProperty","prototype","hasOwnProperty","call","undefined","fn","value","matchWhenEmpty","effect","returnedEffects","push","childRule","oneOf","references","exec","path","map","i","compileRule","unhandledProperties","Set","keys","filter","key","compiledRule","has","delete","error","size","from","join","compileCondition","str","length","startsWith","err","RegExp","test","v","items","c","combineConditionsOr","and","item","matcher","combineConditionsAnd","some","every","message","Error","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { SyncHook } = require(\"tapable\");\n\n/**\n * @typedef {Object} RuleCondition\n * @property {string | string[]} property\n * @property {boolean} matchWhenEmpty\n * @property {function(string): boolean} fn\n */\n\n/**\n * @typedef {Object} Condition\n * @property {boolean} matchWhenEmpty\n * @property {function(string): boolean} fn\n */\n\n/**\n * @typedef {Object} CompiledRule\n * @property {RuleCondition[]} conditions\n * @property {(Effect|function(object): Effect[])[]} effects\n * @property {CompiledRule[]=} rules\n * @property {CompiledRule[]=} oneOf\n */\n\n/**\n * @typedef {Object} Effect\n * @property {string} type\n * @property {any} value\n */\n\n/**\n * @typedef {Object} RuleSet\n * @property {Map<string, any>} references map of references in the rule set (may grow over time)\n * @property {function(object): Effect[]} exec execute the rule set\n */\n\nclass RuleSetCompiler {\n\tconstructor(plugins) {\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {SyncHook<[string, object, Set<string>, CompiledRule, Map<string, any>]>} */\n\t\t\trule: new SyncHook([\n\t\t\t\t\"path\",\n\t\t\t\t\"rule\",\n\t\t\t\t\"unhandledProperties\",\n\t\t\t\t\"compiledRule\",\n\t\t\t\t\"references\"\n\t\t\t])\n\t\t});\n\t\tif (plugins) {\n\t\t\tfor (const plugin of plugins) {\n\t\t\t\tplugin.apply(this);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {object[]} ruleSet raw user provided rules\n\t * @returns {RuleSet} compiled RuleSet\n\t */\n\tcompile(ruleSet) {\n\t\tconst refs = new Map();\n\t\tconst rules = this.compileRules(\"ruleSet\", ruleSet, refs);\n\n\t\t/**\n\t\t * @param {object} data data passed in\n\t\t * @param {CompiledRule} rule the compiled rule\n\t\t * @param {Effect[]} effects an array where effects are pushed to\n\t\t * @returns {boolean} true, if the rule has matched\n\t\t */\n\t\tconst execRule = (data, rule, effects) => {\n\t\t\tfor (const condition of rule.conditions) {\n\t\t\t\tconst p = condition.property;\n\t\t\t\tif (Array.isArray(p)) {\n\t\t\t\t\tlet current = data;\n\t\t\t\t\tfor (const subProperty of p) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tcurrent &&\n\t\t\t\t\t\t\ttypeof current === \"object\" &&\n\t\t\t\t\t\t\tObject.prototype.hasOwnProperty.call(current, subProperty)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcurrent = current[subProperty];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcurrent = undefined;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (current !== undefined) {\n\t\t\t\t\t\tif (!condition.fn(current)) return false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else if (p in data) {\n\t\t\t\t\tconst value = data[p];\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\tif (!condition.fn(value)) return false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!condition.matchWhenEmpty) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const effect of rule.effects) {\n\t\t\t\tif (typeof effect === \"function\") {\n\t\t\t\t\tconst returnedEffects = effect(data);\n\t\t\t\t\tfor (const effect of returnedEffects) {\n\t\t\t\t\t\teffects.push(effect);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\teffects.push(effect);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rule.rules) {\n\t\t\t\tfor (const childRule of rule.rules) {\n\t\t\t\t\texecRule(data, childRule, effects);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rule.oneOf) {\n\t\t\t\tfor (const childRule of rule.oneOf) {\n\t\t\t\t\tif (execRule(data, childRule, effects)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t\treturn {\n\t\t\treferences: refs,\n\t\t\texec: data => {\n\t\t\t\t/** @type {Effect[]} */\n\t\t\t\tconst effects = [];\n\t\t\t\tfor (const rule of rules) {\n\t\t\t\t\texecRule(data, rule, effects);\n\t\t\t\t}\n\t\t\t\treturn effects;\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * @param {string} path current path\n\t * @param {object[]} rules the raw rules provided by user\n\t * @param {Map<string, any>} refs references\n\t * @returns {CompiledRule[]} rules\n\t */\n\tcompileRules(path, rules, refs) {\n\t\treturn rules.map((rule, i) =>\n\t\t\tthis.compileRule(`${path}[${i}]`, rule, refs)\n\t\t);\n\t}\n\n\t/**\n\t * @param {string} path current path\n\t * @param {object} rule the raw rule provided by user\n\t * @param {Map<string, any>} refs references\n\t * @returns {CompiledRule} normalized and compiled rule for processing\n\t */\n\tcompileRule(path, rule, refs) {\n\t\tconst unhandledProperties = new Set(\n\t\t\tObject.keys(rule).filter(key => rule[key] !== undefined)\n\t\t);\n\n\t\t/** @type {CompiledRule} */\n\t\tconst compiledRule = {\n\t\t\tconditions: [],\n\t\t\teffects: [],\n\t\t\trules: undefined,\n\t\t\toneOf: undefined\n\t\t};\n\n\t\tthis.hooks.rule.call(path, rule, unhandledProperties, compiledRule, refs);\n\n\t\tif (unhandledProperties.has(\"rules\")) {\n\t\t\tunhandledProperties.delete(\"rules\");\n\t\t\tconst rules = rule.rules;\n\t\t\tif (!Array.isArray(rules))\n\t\t\t\tthrow this.error(path, rules, \"Rule.rules must be an array of rules\");\n\t\t\tcompiledRule.rules = this.compileRules(`${path}.rules`, rules, refs);\n\t\t}\n\n\t\tif (unhandledProperties.has(\"oneOf\")) {\n\t\t\tunhandledProperties.delete(\"oneOf\");\n\t\t\tconst oneOf = rule.oneOf;\n\t\t\tif (!Array.isArray(oneOf))\n\t\t\t\tthrow this.error(path, oneOf, \"Rule.oneOf must be an array of rules\");\n\t\t\tcompiledRule.oneOf = this.compileRules(`${path}.oneOf`, oneOf, refs);\n\t\t}\n\n\t\tif (unhandledProperties.size > 0) {\n\t\t\tthrow this.error(\n\t\t\t\tpath,\n\t\t\t\trule,\n\t\t\t\t`Properties ${Array.from(unhandledProperties).join(\", \")} are unknown`\n\t\t\t);\n\t\t}\n\n\t\treturn compiledRule;\n\t}\n\n\t/**\n\t * @param {string} path current path\n\t * @param {any} condition user provided condition value\n\t * @returns {Condition} compiled condition\n\t */\n\tcompileCondition(path, condition) {\n\t\tif (condition === \"\") {\n\t\t\treturn {\n\t\t\t\tmatchWhenEmpty: true,\n\t\t\t\tfn: str => str === \"\"\n\t\t\t};\n\t\t}\n\t\tif (!condition) {\n\t\t\tthrow this.error(\n\t\t\t\tpath,\n\t\t\t\tcondition,\n\t\t\t\t\"Expected condition but got falsy value\"\n\t\t\t);\n\t\t}\n\t\tif (typeof condition === \"string\") {\n\t\t\treturn {\n\t\t\t\tmatchWhenEmpty: condition.length === 0,\n\t\t\t\tfn: str => typeof str === \"string\" && str.startsWith(condition)\n\t\t\t};\n\t\t}\n\t\tif (typeof condition === \"function\") {\n\t\t\ttry {\n\t\t\t\treturn {\n\t\t\t\t\tmatchWhenEmpty: condition(\"\"),\n\t\t\t\t\tfn: condition\n\t\t\t\t};\n\t\t\t} catch (err) {\n\t\t\t\tthrow this.error(\n\t\t\t\t\tpath,\n\t\t\t\t\tcondition,\n\t\t\t\t\t\"Evaluation of condition function threw error\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (condition instanceof RegExp) {\n\t\t\treturn {\n\t\t\t\tmatchWhenEmpty: condition.test(\"\"),\n\t\t\t\tfn: v => typeof v === \"string\" && condition.test(v)\n\t\t\t};\n\t\t}\n\t\tif (Array.isArray(condition)) {\n\t\t\tconst items = condition.map((c, i) =>\n\t\t\t\tthis.compileCondition(`${path}[${i}]`, c)\n\t\t\t);\n\t\t\treturn this.combineConditionsOr(items);\n\t\t}\n\n\t\tif (typeof condition !== \"object\") {\n\t\t\tthrow this.error(\n\t\t\t\tpath,\n\t\t\t\tcondition,\n\t\t\t\t`Unexpected ${typeof condition} when condition was expected`\n\t\t\t);\n\t\t}\n\n\t\tconst conditions = [];\n\t\tfor (const key of Object.keys(condition)) {\n\t\t\tconst value = condition[key];\n\t\t\tswitch (key) {\n\t\t\t\tcase \"or\":\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\t\t\tthrow this.error(\n\t\t\t\t\t\t\t\t`${path}.or`,\n\t\t\t\t\t\t\t\tcondition.and,\n\t\t\t\t\t\t\t\t\"Expected array of conditions\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconditions.push(this.compileCondition(`${path}.or`, value));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"and\":\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\t\t\tthrow this.error(\n\t\t\t\t\t\t\t\t`${path}.and`,\n\t\t\t\t\t\t\t\tcondition.and,\n\t\t\t\t\t\t\t\t\"Expected array of conditions\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\tfor (const item of value) {\n\t\t\t\t\t\t\tconditions.push(this.compileCondition(`${path}.and[${i}]`, item));\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"not\":\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tconst matcher = this.compileCondition(`${path}.not`, value);\n\t\t\t\t\t\tconst fn = matcher.fn;\n\t\t\t\t\t\tconditions.push({\n\t\t\t\t\t\t\tmatchWhenEmpty: !matcher.matchWhenEmpty,\n\t\t\t\t\t\t\tfn: v => !fn(v)\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow this.error(\n\t\t\t\t\t\t`${path}.${key}`,\n\t\t\t\t\t\tcondition[key],\n\t\t\t\t\t\t`Unexpected property ${key} in condition`\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (conditions.length === 0) {\n\t\t\tthrow this.error(\n\t\t\t\tpath,\n\t\t\t\tcondition,\n\t\t\t\t\"Expected condition, but got empty thing\"\n\t\t\t);\n\t\t}\n\t\treturn this.combineConditionsAnd(conditions);\n\t}\n\n\t/**\n\t * @param {Condition[]} conditions some conditions\n\t * @returns {Condition} merged condition\n\t */\n\tcombineConditionsOr(conditions) {\n\t\tif (conditions.length === 0) {\n\t\t\treturn {\n\t\t\t\tmatchWhenEmpty: false,\n\t\t\t\tfn: () => false\n\t\t\t};\n\t\t} else if (conditions.length === 1) {\n\t\t\treturn conditions[0];\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tmatchWhenEmpty: conditions.some(c => c.matchWhenEmpty),\n\t\t\t\tfn: v => conditions.some(c => c.fn(v))\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * @param {Condition[]} conditions some conditions\n\t * @returns {Condition} merged condition\n\t */\n\tcombineConditionsAnd(conditions) {\n\t\tif (conditions.length === 0) {\n\t\t\treturn {\n\t\t\t\tmatchWhenEmpty: false,\n\t\t\t\tfn: () => false\n\t\t\t};\n\t\t} else if (conditions.length === 1) {\n\t\t\treturn conditions[0];\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tmatchWhenEmpty: conditions.every(c => c.matchWhenEmpty),\n\t\t\t\tfn: v => conditions.every(c => c.fn(v))\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} path current path\n\t * @param {any} value value at the error location\n\t * @param {string} message message explaining the problem\n\t * @returns {Error} an error object\n\t */\n\terror(path, value, message) {\n\t\treturn new Error(\n\t\t\t`Compiling RuleSet failed: ${message} (at ${path}: ${value})`\n\t\t);\n\t}\n}\n\nmodule.exports = RuleSetCompiler;\n"]},"metadata":{},"sourceType":"script"}