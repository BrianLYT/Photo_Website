{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst path = require(\"path\");\n/**\n * @template T\n * @typedef {Object} TreeNode\n * @property {string} filePath\n * @property {TreeNode} parent\n * @property {TreeNode[]} children\n * @property {number} entries\n * @property {boolean} active\n * @property {T[] | T | undefined} value\n */\n\n/**\n * @template T\n * @param {Map<string, T[] | T} plan\n * @param {number} limit\n * @returns {Map<string, Map<T, string>>} the new plan\n */\n\n\nmodule.exports = (plan, limit) => {\n  const treeMap = new Map(); // Convert to tree\n\n  for (const [filePath, value] of plan) {\n    treeMap.set(filePath, {\n      filePath,\n      parent: undefined,\n      children: undefined,\n      entries: 1,\n      active: true,\n      value\n    });\n  }\n\n  let currentCount = treeMap.size; // Create parents and calculate sum of entries\n\n  for (const node of treeMap.values()) {\n    const parentPath = path.dirname(node.filePath);\n\n    if (parentPath !== node.filePath) {\n      let parent = treeMap.get(parentPath);\n\n      if (parent === undefined) {\n        parent = {\n          filePath: parentPath,\n          parent: undefined,\n          children: [node],\n          entries: node.entries,\n          active: false,\n          value: undefined\n        };\n        treeMap.set(parentPath, parent);\n        node.parent = parent;\n      } else {\n        node.parent = parent;\n\n        if (parent.children === undefined) {\n          parent.children = [node];\n        } else {\n          parent.children.push(node);\n        }\n\n        do {\n          parent.entries += node.entries;\n          parent = parent.parent;\n        } while (parent);\n      }\n    }\n  } // Reduce until limit reached\n\n\n  while (currentCount > limit) {\n    // Select node that helps reaching the limit most effectively without overmerging\n    const overLimit = currentCount - limit;\n    let bestNode = undefined;\n    let bestCost = Infinity;\n\n    for (const node of treeMap.values()) {\n      if (node.entries <= 1 || !node.children || !node.parent) continue;\n      if (node.children.length === 0) continue;\n      if (node.children.length === 1 && !node.value) continue; // Try to select the node with has just a bit more entries than we need to reduce\n      // When just a bit more is over 30% over the limit,\n      // also consider just a bit less entries then we need to reduce\n\n      const cost = node.entries - 1 >= overLimit ? node.entries - 1 - overLimit : overLimit - node.entries + 1 + limit * 0.3;\n\n      if (cost < bestCost) {\n        bestNode = node;\n        bestCost = cost;\n      }\n    }\n\n    if (!bestNode) break; // Merge all children\n\n    const reduction = bestNode.entries - 1;\n    bestNode.active = true;\n    bestNode.entries = 1;\n    currentCount -= reduction;\n    let parent = bestNode.parent;\n\n    while (parent) {\n      parent.entries -= reduction;\n      parent = parent.parent;\n    }\n\n    const queue = new Set(bestNode.children);\n\n    for (const node of queue) {\n      node.active = false;\n      node.entries = 0;\n\n      if (node.children) {\n        for (const child of node.children) queue.add(child);\n      }\n    }\n  } // Write down new plan\n\n\n  const newPlan = new Map();\n\n  for (const rootNode of treeMap.values()) {\n    if (!rootNode.active) continue;\n    const map = new Map();\n    const queue = new Set([rootNode]);\n\n    for (const node of queue) {\n      if (node.active && node !== rootNode) continue;\n\n      if (node.value) {\n        if (Array.isArray(node.value)) {\n          for (const item of node.value) {\n            map.set(item, node.filePath);\n          }\n        } else {\n          map.set(node.value, node.filePath);\n        }\n      }\n\n      if (node.children) {\n        for (const child of node.children) {\n          queue.add(child);\n        }\n      }\n    }\n\n    newPlan.set(rootNode.filePath, map);\n  }\n\n  return newPlan;\n};","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/watchpack/lib/reducePlan.js"],"names":["path","require","module","exports","plan","limit","treeMap","Map","filePath","value","set","parent","undefined","children","entries","active","currentCount","size","node","values","parentPath","dirname","get","push","overLimit","bestNode","bestCost","Infinity","length","cost","reduction","queue","Set","child","add","newPlan","rootNode","map","Array","isArray","item"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst path = require(\"path\");\n\n/**\n * @template T\n * @typedef {Object} TreeNode\n * @property {string} filePath\n * @property {TreeNode} parent\n * @property {TreeNode[]} children\n * @property {number} entries\n * @property {boolean} active\n * @property {T[] | T | undefined} value\n */\n\n/**\n * @template T\n * @param {Map<string, T[] | T} plan\n * @param {number} limit\n * @returns {Map<string, Map<T, string>>} the new plan\n */\nmodule.exports = (plan, limit) => {\n\tconst treeMap = new Map();\n\t// Convert to tree\n\tfor (const [filePath, value] of plan) {\n\t\ttreeMap.set(filePath, {\n\t\t\tfilePath,\n\t\t\tparent: undefined,\n\t\t\tchildren: undefined,\n\t\t\tentries: 1,\n\t\t\tactive: true,\n\t\t\tvalue\n\t\t});\n\t}\n\tlet currentCount = treeMap.size;\n\t// Create parents and calculate sum of entries\n\tfor (const node of treeMap.values()) {\n\t\tconst parentPath = path.dirname(node.filePath);\n\t\tif (parentPath !== node.filePath) {\n\t\t\tlet parent = treeMap.get(parentPath);\n\t\t\tif (parent === undefined) {\n\t\t\t\tparent = {\n\t\t\t\t\tfilePath: parentPath,\n\t\t\t\t\tparent: undefined,\n\t\t\t\t\tchildren: [node],\n\t\t\t\t\tentries: node.entries,\n\t\t\t\t\tactive: false,\n\t\t\t\t\tvalue: undefined\n\t\t\t\t};\n\t\t\t\ttreeMap.set(parentPath, parent);\n\t\t\t\tnode.parent = parent;\n\t\t\t} else {\n\t\t\t\tnode.parent = parent;\n\t\t\t\tif (parent.children === undefined) {\n\t\t\t\t\tparent.children = [node];\n\t\t\t\t} else {\n\t\t\t\t\tparent.children.push(node);\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tparent.entries += node.entries;\n\t\t\t\t\tparent = parent.parent;\n\t\t\t\t} while (parent);\n\t\t\t}\n\t\t}\n\t}\n\t// Reduce until limit reached\n\twhile (currentCount > limit) {\n\t\t// Select node that helps reaching the limit most effectively without overmerging\n\t\tconst overLimit = currentCount - limit;\n\t\tlet bestNode = undefined;\n\t\tlet bestCost = Infinity;\n\t\tfor (const node of treeMap.values()) {\n\t\t\tif (node.entries <= 1 || !node.children || !node.parent) continue;\n\t\t\tif (node.children.length === 0) continue;\n\t\t\tif (node.children.length === 1 && !node.value) continue;\n\t\t\t// Try to select the node with has just a bit more entries than we need to reduce\n\t\t\t// When just a bit more is over 30% over the limit,\n\t\t\t// also consider just a bit less entries then we need to reduce\n\t\t\tconst cost =\n\t\t\t\tnode.entries - 1 >= overLimit\n\t\t\t\t\t? node.entries - 1 - overLimit\n\t\t\t\t\t: overLimit - node.entries + 1 + limit * 0.3;\n\t\t\tif (cost < bestCost) {\n\t\t\t\tbestNode = node;\n\t\t\t\tbestCost = cost;\n\t\t\t}\n\t\t}\n\t\tif (!bestNode) break;\n\t\t// Merge all children\n\t\tconst reduction = bestNode.entries - 1;\n\t\tbestNode.active = true;\n\t\tbestNode.entries = 1;\n\t\tcurrentCount -= reduction;\n\t\tlet parent = bestNode.parent;\n\t\twhile (parent) {\n\t\t\tparent.entries -= reduction;\n\t\t\tparent = parent.parent;\n\t\t}\n\t\tconst queue = new Set(bestNode.children);\n\t\tfor (const node of queue) {\n\t\t\tnode.active = false;\n\t\t\tnode.entries = 0;\n\t\t\tif (node.children) {\n\t\t\t\tfor (const child of node.children) queue.add(child);\n\t\t\t}\n\t\t}\n\t}\n\t// Write down new plan\n\tconst newPlan = new Map();\n\tfor (const rootNode of treeMap.values()) {\n\t\tif (!rootNode.active) continue;\n\t\tconst map = new Map();\n\t\tconst queue = new Set([rootNode]);\n\t\tfor (const node of queue) {\n\t\t\tif (node.active && node !== rootNode) continue;\n\t\t\tif (node.value) {\n\t\t\t\tif (Array.isArray(node.value)) {\n\t\t\t\t\tfor (const item of node.value) {\n\t\t\t\t\t\tmap.set(item, node.filePath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmap.set(node.value, node.filePath);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.children) {\n\t\t\t\tfor (const child of node.children) {\n\t\t\t\t\tqueue.add(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnewPlan.set(rootNode.filePath, map);\n\t}\n\treturn newPlan;\n};\n"]},"metadata":{},"sourceType":"script"}