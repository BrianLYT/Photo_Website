{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  SyncBailHook\n} = require(\"tapable\");\n\nconst {\n  RawSource\n} = require(\"webpack-sources\");\n\nconst ChunkGraph = require(\"./ChunkGraph\");\n\nconst Compilation = require(\"./Compilation\");\n\nconst HotUpdateChunk = require(\"./HotUpdateChunk\");\n\nconst NormalModule = require(\"./NormalModule\");\n\nconst RuntimeGlobals = require(\"./RuntimeGlobals\");\n\nconst WebpackError = require(\"./WebpackError\");\n\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\n\nconst ImportMetaHotAcceptDependency = require(\"./dependencies/ImportMetaHotAcceptDependency\");\n\nconst ImportMetaHotDeclineDependency = require(\"./dependencies/ImportMetaHotDeclineDependency\");\n\nconst ModuleHotAcceptDependency = require(\"./dependencies/ModuleHotAcceptDependency\");\n\nconst ModuleHotDeclineDependency = require(\"./dependencies/ModuleHotDeclineDependency\");\n\nconst HotModuleReplacementRuntimeModule = require(\"./hmr/HotModuleReplacementRuntimeModule\");\n\nconst JavascriptParser = require(\"./javascript/JavascriptParser\");\n\nconst {\n  evaluateToIdentifier\n} = require(\"./javascript/JavascriptParserHelpers\");\n\nconst {\n  find,\n  isSubset\n} = require(\"./util/SetHelpers\");\n\nconst TupleSet = require(\"./util/TupleSet\");\n\nconst {\n  compareModulesById\n} = require(\"./util/comparators\");\n\nconst {\n  getRuntimeKey,\n  keyToRuntime,\n  forEachRuntime,\n  mergeRuntimeOwned,\n  subtractRuntime,\n  intersectRuntime\n} = require(\"./util/runtime\");\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./RuntimeModule\")} RuntimeModule */\n\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {Object} HMRJavascriptParserHooks\n * @property {SyncBailHook<[TODO, string[]], void>} hotAcceptCallback\n * @property {SyncBailHook<[TODO, string[]], void>} hotAcceptWithoutCallback\n */\n\n/** @type {WeakMap<JavascriptParser, HMRJavascriptParserHooks>} */\n\n\nconst parserHooksMap = new WeakMap();\n\nclass HotModuleReplacementPlugin {\n  /**\n   * @param {JavascriptParser} parser the parser\n   * @returns {HMRJavascriptParserHooks} the attached hooks\n   */\n  static getParserHooks(parser) {\n    if (!(parser instanceof JavascriptParser)) {\n      throw new TypeError(\"The 'parser' argument must be an instance of JavascriptParser\");\n    }\n\n    let hooks = parserHooksMap.get(parser);\n\n    if (hooks === undefined) {\n      hooks = {\n        hotAcceptCallback: new SyncBailHook([\"expression\", \"requests\"]),\n        hotAcceptWithoutCallback: new SyncBailHook([\"expression\", \"requests\"])\n      };\n      parserHooksMap.set(parser, hooks);\n    }\n\n    return hooks;\n  }\n\n  constructor(options) {\n    this.options = options || {};\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const {\n      _backCompat: backCompat\n    } = compiler;\n    if (compiler.options.output.strictModuleErrorHandling === undefined) compiler.options.output.strictModuleErrorHandling = true;\n    const runtimeRequirements = [RuntimeGlobals.module];\n\n    const createAcceptHandler = (parser, ParamDependency) => {\n      const {\n        hotAcceptCallback,\n        hotAcceptWithoutCallback\n      } = HotModuleReplacementPlugin.getParserHooks(parser);\n      return expr => {\n        const module = parser.state.module;\n        const dep = new ConstDependency(`${module.moduleArgument}.hot.accept`, expr.callee.range, runtimeRequirements);\n        dep.loc = expr.loc;\n        module.addPresentationalDependency(dep);\n        module.buildInfo.moduleConcatenationBailout = \"Hot Module Replacement\";\n\n        if (expr.arguments.length >= 1) {\n          const arg = parser.evaluateExpression(expr.arguments[0]);\n          let params = [];\n          let requests = [];\n\n          if (arg.isString()) {\n            params = [arg];\n          } else if (arg.isArray()) {\n            params = arg.items.filter(param => param.isString());\n          }\n\n          if (params.length > 0) {\n            params.forEach((param, idx) => {\n              const request = param.string;\n              const dep = new ParamDependency(request, param.range);\n              dep.optional = true;\n              dep.loc = Object.create(expr.loc);\n              dep.loc.index = idx;\n              module.addDependency(dep);\n              requests.push(request);\n            });\n\n            if (expr.arguments.length > 1) {\n              hotAcceptCallback.call(expr.arguments[1], requests);\n\n              for (let i = 1; i < expr.arguments.length; i++) {\n                parser.walkExpression(expr.arguments[i]);\n              }\n\n              return true;\n            } else {\n              hotAcceptWithoutCallback.call(expr, requests);\n              return true;\n            }\n          }\n        }\n\n        parser.walkExpressions(expr.arguments);\n        return true;\n      };\n    };\n\n    const createDeclineHandler = (parser, ParamDependency) => expr => {\n      const module = parser.state.module;\n      const dep = new ConstDependency(`${module.moduleArgument}.hot.decline`, expr.callee.range, runtimeRequirements);\n      dep.loc = expr.loc;\n      module.addPresentationalDependency(dep);\n      module.buildInfo.moduleConcatenationBailout = \"Hot Module Replacement\";\n\n      if (expr.arguments.length === 1) {\n        const arg = parser.evaluateExpression(expr.arguments[0]);\n        let params = [];\n\n        if (arg.isString()) {\n          params = [arg];\n        } else if (arg.isArray()) {\n          params = arg.items.filter(param => param.isString());\n        }\n\n        params.forEach((param, idx) => {\n          const dep = new ParamDependency(param.string, param.range);\n          dep.optional = true;\n          dep.loc = Object.create(expr.loc);\n          dep.loc.index = idx;\n          module.addDependency(dep);\n        });\n      }\n\n      return true;\n    };\n\n    const createHMRExpressionHandler = parser => expr => {\n      const module = parser.state.module;\n      const dep = new ConstDependency(`${module.moduleArgument}.hot`, expr.range, runtimeRequirements);\n      dep.loc = expr.loc;\n      module.addPresentationalDependency(dep);\n      module.buildInfo.moduleConcatenationBailout = \"Hot Module Replacement\";\n      return true;\n    };\n\n    const applyModuleHot = parser => {\n      parser.hooks.evaluateIdentifier.for(\"module.hot\").tap({\n        name: \"HotModuleReplacementPlugin\",\n        before: \"NodeStuffPlugin\"\n      }, expr => {\n        return evaluateToIdentifier(\"module.hot\", \"module\", () => [\"hot\"], true)(expr);\n      });\n      parser.hooks.call.for(\"module.hot.accept\").tap(\"HotModuleReplacementPlugin\", createAcceptHandler(parser, ModuleHotAcceptDependency));\n      parser.hooks.call.for(\"module.hot.decline\").tap(\"HotModuleReplacementPlugin\", createDeclineHandler(parser, ModuleHotDeclineDependency));\n      parser.hooks.expression.for(\"module.hot\").tap(\"HotModuleReplacementPlugin\", createHMRExpressionHandler(parser));\n    };\n\n    const applyImportMetaHot = parser => {\n      parser.hooks.evaluateIdentifier.for(\"import.meta.webpackHot\").tap(\"HotModuleReplacementPlugin\", expr => {\n        return evaluateToIdentifier(\"import.meta.webpackHot\", \"import.meta\", () => [\"webpackHot\"], true)(expr);\n      });\n      parser.hooks.call.for(\"import.meta.webpackHot.accept\").tap(\"HotModuleReplacementPlugin\", createAcceptHandler(parser, ImportMetaHotAcceptDependency));\n      parser.hooks.call.for(\"import.meta.webpackHot.decline\").tap(\"HotModuleReplacementPlugin\", createDeclineHandler(parser, ImportMetaHotDeclineDependency));\n      parser.hooks.expression.for(\"import.meta.webpackHot\").tap(\"HotModuleReplacementPlugin\", createHMRExpressionHandler(parser));\n    };\n\n    compiler.hooks.compilation.tap(\"HotModuleReplacementPlugin\", (compilation, _ref) => {\n      let {\n        normalModuleFactory\n      } = _ref;\n      // This applies the HMR plugin only to the targeted compiler\n      // It should not affect child compilations\n      if (compilation.compiler !== compiler) return; //#region module.hot.* API\n\n      compilation.dependencyFactories.set(ModuleHotAcceptDependency, normalModuleFactory);\n      compilation.dependencyTemplates.set(ModuleHotAcceptDependency, new ModuleHotAcceptDependency.Template());\n      compilation.dependencyFactories.set(ModuleHotDeclineDependency, normalModuleFactory);\n      compilation.dependencyTemplates.set(ModuleHotDeclineDependency, new ModuleHotDeclineDependency.Template()); //#endregion\n      //#region import.meta.webpackHot.* API\n\n      compilation.dependencyFactories.set(ImportMetaHotAcceptDependency, normalModuleFactory);\n      compilation.dependencyTemplates.set(ImportMetaHotAcceptDependency, new ImportMetaHotAcceptDependency.Template());\n      compilation.dependencyFactories.set(ImportMetaHotDeclineDependency, normalModuleFactory);\n      compilation.dependencyTemplates.set(ImportMetaHotDeclineDependency, new ImportMetaHotDeclineDependency.Template()); //#endregion\n\n      let hotIndex = 0;\n      const fullHashChunkModuleHashes = {};\n      const chunkModuleHashes = {};\n      compilation.hooks.record.tap(\"HotModuleReplacementPlugin\", (compilation, records) => {\n        if (records.hash === compilation.hash) return;\n        const chunkGraph = compilation.chunkGraph;\n        records.hash = compilation.hash;\n        records.hotIndex = hotIndex;\n        records.fullHashChunkModuleHashes = fullHashChunkModuleHashes;\n        records.chunkModuleHashes = chunkModuleHashes;\n        records.chunkHashes = {};\n        records.chunkRuntime = {};\n\n        for (const chunk of compilation.chunks) {\n          records.chunkHashes[chunk.id] = chunk.hash;\n          records.chunkRuntime[chunk.id] = getRuntimeKey(chunk.runtime);\n        }\n\n        records.chunkModuleIds = {};\n\n        for (const chunk of compilation.chunks) {\n          records.chunkModuleIds[chunk.id] = Array.from(chunkGraph.getOrderedChunkModulesIterable(chunk, compareModulesById(chunkGraph)), m => chunkGraph.getModuleId(m));\n        }\n      });\n      /** @type {TupleSet<[Module, Chunk]>} */\n\n      const updatedModules = new TupleSet();\n      /** @type {TupleSet<[Module, Chunk]>} */\n\n      const fullHashModules = new TupleSet();\n      /** @type {TupleSet<[Module, RuntimeSpec]>} */\n\n      const nonCodeGeneratedModules = new TupleSet();\n      compilation.hooks.fullHash.tap(\"HotModuleReplacementPlugin\", hash => {\n        const chunkGraph = compilation.chunkGraph;\n        const records = compilation.records;\n\n        for (const chunk of compilation.chunks) {\n          const getModuleHash = module => {\n            if (compilation.codeGenerationResults.has(module, chunk.runtime)) {\n              return compilation.codeGenerationResults.getHash(module, chunk.runtime);\n            } else {\n              nonCodeGeneratedModules.add(module, chunk.runtime);\n              return chunkGraph.getModuleHash(module, chunk.runtime);\n            }\n          };\n\n          const fullHashModulesInThisChunk = chunkGraph.getChunkFullHashModulesSet(chunk);\n\n          if (fullHashModulesInThisChunk !== undefined) {\n            for (const module of fullHashModulesInThisChunk) {\n              fullHashModules.add(module, chunk);\n            }\n          }\n\n          const modules = chunkGraph.getChunkModulesIterable(chunk);\n\n          if (modules !== undefined) {\n            if (records.chunkModuleHashes) {\n              if (fullHashModulesInThisChunk !== undefined) {\n                for (const module of modules) {\n                  const key = `${chunk.id}|${module.identifier()}`;\n                  const hash = getModuleHash(module);\n\n                  if (fullHashModulesInThisChunk.has(\n                  /** @type {RuntimeModule} */\n                  module)) {\n                    if (records.fullHashChunkModuleHashes[key] !== hash) {\n                      updatedModules.add(module, chunk);\n                    }\n\n                    fullHashChunkModuleHashes[key] = hash;\n                  } else {\n                    if (records.chunkModuleHashes[key] !== hash) {\n                      updatedModules.add(module, chunk);\n                    }\n\n                    chunkModuleHashes[key] = hash;\n                  }\n                }\n              } else {\n                for (const module of modules) {\n                  const key = `${chunk.id}|${module.identifier()}`;\n                  const hash = getModuleHash(module);\n\n                  if (records.chunkModuleHashes[key] !== hash) {\n                    updatedModules.add(module, chunk);\n                  }\n\n                  chunkModuleHashes[key] = hash;\n                }\n              }\n            } else {\n              if (fullHashModulesInThisChunk !== undefined) {\n                for (const module of modules) {\n                  const key = `${chunk.id}|${module.identifier()}`;\n                  const hash = getModuleHash(module);\n\n                  if (fullHashModulesInThisChunk.has(\n                  /** @type {RuntimeModule} */\n                  module)) {\n                    fullHashChunkModuleHashes[key] = hash;\n                  } else {\n                    chunkModuleHashes[key] = hash;\n                  }\n                }\n              } else {\n                for (const module of modules) {\n                  const key = `${chunk.id}|${module.identifier()}`;\n                  const hash = getModuleHash(module);\n                  chunkModuleHashes[key] = hash;\n                }\n              }\n            }\n          }\n        }\n\n        hotIndex = records.hotIndex || 0;\n        if (updatedModules.size > 0) hotIndex++;\n        hash.update(`${hotIndex}`);\n      });\n      compilation.hooks.processAssets.tap({\n        name: \"HotModuleReplacementPlugin\",\n        stage: Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL\n      }, () => {\n        const chunkGraph = compilation.chunkGraph;\n        const records = compilation.records;\n        if (records.hash === compilation.hash) return;\n\n        if (!records.chunkModuleHashes || !records.chunkHashes || !records.chunkModuleIds) {\n          return;\n        }\n\n        for (const [module, chunk] of fullHashModules) {\n          const key = `${chunk.id}|${module.identifier()}`;\n          const hash = nonCodeGeneratedModules.has(module, chunk.runtime) ? chunkGraph.getModuleHash(module, chunk.runtime) : compilation.codeGenerationResults.getHash(module, chunk.runtime);\n\n          if (records.chunkModuleHashes[key] !== hash) {\n            updatedModules.add(module, chunk);\n          }\n\n          chunkModuleHashes[key] = hash;\n        }\n        /** @type {Map<string, { updatedChunkIds: Set<string|number>, removedChunkIds: Set<string|number>, removedModules: Set<Module>, filename: string, assetInfo: AssetInfo }>} */\n\n\n        const hotUpdateMainContentByRuntime = new Map();\n        let allOldRuntime;\n\n        for (const key of Object.keys(records.chunkRuntime)) {\n          const runtime = keyToRuntime(records.chunkRuntime[key]);\n          allOldRuntime = mergeRuntimeOwned(allOldRuntime, runtime);\n        }\n\n        forEachRuntime(allOldRuntime, runtime => {\n          const {\n            path: filename,\n            info: assetInfo\n          } = compilation.getPathWithInfo(compilation.outputOptions.hotUpdateMainFilename, {\n            hash: records.hash,\n            runtime\n          });\n          hotUpdateMainContentByRuntime.set(runtime, {\n            updatedChunkIds: new Set(),\n            removedChunkIds: new Set(),\n            removedModules: new Set(),\n            filename,\n            assetInfo\n          });\n        });\n        if (hotUpdateMainContentByRuntime.size === 0) return; // Create a list of all active modules to verify which modules are removed completely\n\n        /** @type {Map<number|string, Module>} */\n\n        const allModules = new Map();\n\n        for (const module of compilation.modules) {\n          const id = chunkGraph.getModuleId(module);\n          allModules.set(id, module);\n        } // List of completely removed modules\n\n        /** @type {Set<string | number>} */\n\n\n        const completelyRemovedModules = new Set();\n\n        for (const key of Object.keys(records.chunkHashes)) {\n          const oldRuntime = keyToRuntime(records.chunkRuntime[key]);\n          /** @type {Module[]} */\n\n          const remainingModules = []; // Check which modules are removed\n\n          for (const id of records.chunkModuleIds[key]) {\n            const module = allModules.get(id);\n\n            if (module === undefined) {\n              completelyRemovedModules.add(id);\n            } else {\n              remainingModules.push(module);\n            }\n          }\n\n          let chunkId;\n          let newModules;\n          let newRuntimeModules;\n          let newFullHashModules;\n          let newDependentHashModules;\n          let newRuntime;\n          let removedFromRuntime;\n          const currentChunk = find(compilation.chunks, chunk => `${chunk.id}` === key);\n\n          if (currentChunk) {\n            chunkId = currentChunk.id;\n            newRuntime = intersectRuntime(currentChunk.runtime, allOldRuntime);\n            if (newRuntime === undefined) continue;\n            newModules = chunkGraph.getChunkModules(currentChunk).filter(module => updatedModules.has(module, currentChunk));\n            newRuntimeModules = Array.from(chunkGraph.getChunkRuntimeModulesIterable(currentChunk)).filter(module => updatedModules.has(module, currentChunk));\n            const fullHashModules = chunkGraph.getChunkFullHashModulesIterable(currentChunk);\n            newFullHashModules = fullHashModules && Array.from(fullHashModules).filter(module => updatedModules.has(module, currentChunk));\n            const dependentHashModules = chunkGraph.getChunkDependentHashModulesIterable(currentChunk);\n            newDependentHashModules = dependentHashModules && Array.from(dependentHashModules).filter(module => updatedModules.has(module, currentChunk));\n            removedFromRuntime = subtractRuntime(oldRuntime, newRuntime);\n          } else {\n            // chunk has completely removed\n            chunkId = `${+key}` === key ? +key : key;\n            removedFromRuntime = oldRuntime;\n            newRuntime = oldRuntime;\n          }\n\n          if (removedFromRuntime) {\n            // chunk was removed from some runtimes\n            forEachRuntime(removedFromRuntime, runtime => {\n              hotUpdateMainContentByRuntime.get(runtime).removedChunkIds.add(chunkId);\n            }); // dispose modules from the chunk in these runtimes\n            // where they are no longer in this runtime\n\n            for (const module of remainingModules) {\n              const moduleKey = `${key}|${module.identifier()}`;\n              const oldHash = records.chunkModuleHashes[moduleKey];\n              const runtimes = chunkGraph.getModuleRuntimes(module);\n\n              if (oldRuntime === newRuntime && runtimes.has(newRuntime)) {\n                // Module is still in the same runtime combination\n                const hash = nonCodeGeneratedModules.has(module, newRuntime) ? chunkGraph.getModuleHash(module, newRuntime) : compilation.codeGenerationResults.getHash(module, newRuntime);\n\n                if (hash !== oldHash) {\n                  if (module.type === \"runtime\") {\n                    newRuntimeModules = newRuntimeModules || [];\n                    newRuntimeModules.push(\n                    /** @type {RuntimeModule} */\n                    module);\n                  } else {\n                    newModules = newModules || [];\n                    newModules.push(module);\n                  }\n                }\n              } else {\n                // module is no longer in this runtime combination\n                // We (incorrectly) assume that it's not in an overlapping runtime combination\n                // and dispose it from the main runtimes the chunk was removed from\n                forEachRuntime(removedFromRuntime, runtime => {\n                  // If the module is still used in this runtime, do not dispose it\n                  // This could create a bad runtime state where the module is still loaded,\n                  // but no chunk which contains it. This means we don't receive further HMR updates\n                  // to this module and that's bad.\n                  // TODO force load one of the chunks which contains the module\n                  for (const moduleRuntime of runtimes) {\n                    if (typeof moduleRuntime === \"string\") {\n                      if (moduleRuntime === runtime) return;\n                    } else if (moduleRuntime !== undefined) {\n                      if (moduleRuntime.has(runtime)) return;\n                    }\n                  }\n\n                  hotUpdateMainContentByRuntime.get(runtime).removedModules.add(module);\n                });\n              }\n            }\n          }\n\n          if (newModules && newModules.length > 0 || newRuntimeModules && newRuntimeModules.length > 0) {\n            const hotUpdateChunk = new HotUpdateChunk();\n            if (backCompat) ChunkGraph.setChunkGraphForChunk(hotUpdateChunk, chunkGraph);\n            hotUpdateChunk.id = chunkId;\n            hotUpdateChunk.runtime = newRuntime;\n\n            if (currentChunk) {\n              for (const group of currentChunk.groupsIterable) hotUpdateChunk.addGroup(group);\n            }\n\n            chunkGraph.attachModules(hotUpdateChunk, newModules || []);\n            chunkGraph.attachRuntimeModules(hotUpdateChunk, newRuntimeModules || []);\n\n            if (newFullHashModules) {\n              chunkGraph.attachFullHashModules(hotUpdateChunk, newFullHashModules);\n            }\n\n            if (newDependentHashModules) {\n              chunkGraph.attachDependentHashModules(hotUpdateChunk, newDependentHashModules);\n            }\n\n            const renderManifest = compilation.getRenderManifest({\n              chunk: hotUpdateChunk,\n              hash: records.hash,\n              fullHash: records.hash,\n              outputOptions: compilation.outputOptions,\n              moduleTemplates: compilation.moduleTemplates,\n              dependencyTemplates: compilation.dependencyTemplates,\n              codeGenerationResults: compilation.codeGenerationResults,\n              runtimeTemplate: compilation.runtimeTemplate,\n              moduleGraph: compilation.moduleGraph,\n              chunkGraph\n            });\n\n            for (const entry of renderManifest) {\n              /** @type {string} */\n              let filename;\n              /** @type {AssetInfo} */\n\n              let assetInfo;\n\n              if (\"filename\" in entry) {\n                filename = entry.filename;\n                assetInfo = entry.info;\n              } else {\n                ({\n                  path: filename,\n                  info: assetInfo\n                } = compilation.getPathWithInfo(entry.filenameTemplate, entry.pathOptions));\n              }\n\n              const source = entry.render();\n              compilation.additionalChunkAssets.push(filename);\n              compilation.emitAsset(filename, source, {\n                hotModuleReplacement: true,\n                ...assetInfo\n              });\n\n              if (currentChunk) {\n                currentChunk.files.add(filename);\n                compilation.hooks.chunkAsset.call(currentChunk, filename);\n              }\n            }\n\n            forEachRuntime(newRuntime, runtime => {\n              hotUpdateMainContentByRuntime.get(runtime).updatedChunkIds.add(chunkId);\n            });\n          }\n        }\n\n        const completelyRemovedModulesArray = Array.from(completelyRemovedModules);\n        const hotUpdateMainContentByFilename = new Map();\n\n        for (const {\n          removedChunkIds,\n          removedModules,\n          updatedChunkIds,\n          filename,\n          assetInfo\n        } of hotUpdateMainContentByRuntime.values()) {\n          const old = hotUpdateMainContentByFilename.get(filename);\n\n          if (old && (!isSubset(old.removedChunkIds, removedChunkIds) || !isSubset(old.removedModules, removedModules) || !isSubset(old.updatedChunkIds, updatedChunkIds))) {\n            compilation.warnings.push(new WebpackError(`HotModuleReplacementPlugin\nThe configured output.hotUpdateMainFilename doesn't lead to unique filenames per runtime and HMR update differs between runtimes.\nThis might lead to incorrect runtime behavior of the applied update.\nTo fix this, make sure to include [runtime] in the output.hotUpdateMainFilename option, or use the default config.`));\n\n            for (const chunkId of removedChunkIds) old.removedChunkIds.add(chunkId);\n\n            for (const chunkId of removedModules) old.removedModules.add(chunkId);\n\n            for (const chunkId of updatedChunkIds) old.updatedChunkIds.add(chunkId);\n\n            continue;\n          }\n\n          hotUpdateMainContentByFilename.set(filename, {\n            removedChunkIds,\n            removedModules,\n            updatedChunkIds,\n            assetInfo\n          });\n        }\n\n        for (const [filename, {\n          removedChunkIds,\n          removedModules,\n          updatedChunkIds,\n          assetInfo\n        }] of hotUpdateMainContentByFilename) {\n          const hotUpdateMainJson = {\n            c: Array.from(updatedChunkIds),\n            r: Array.from(removedChunkIds),\n            m: removedModules.size === 0 ? completelyRemovedModulesArray : completelyRemovedModulesArray.concat(Array.from(removedModules, m => chunkGraph.getModuleId(m)))\n          };\n          const source = new RawSource(JSON.stringify(hotUpdateMainJson));\n          compilation.emitAsset(filename, source, {\n            hotModuleReplacement: true,\n            ...assetInfo\n          });\n        }\n      });\n      compilation.hooks.additionalTreeRuntimeRequirements.tap(\"HotModuleReplacementPlugin\", (chunk, runtimeRequirements) => {\n        runtimeRequirements.add(RuntimeGlobals.hmrDownloadManifest);\n        runtimeRequirements.add(RuntimeGlobals.hmrDownloadUpdateHandlers);\n        runtimeRequirements.add(RuntimeGlobals.interceptModuleExecution);\n        runtimeRequirements.add(RuntimeGlobals.moduleCache);\n        compilation.addRuntimeModule(chunk, new HotModuleReplacementRuntimeModule());\n      });\n      normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"HotModuleReplacementPlugin\", parser => {\n        applyModuleHot(parser);\n        applyImportMetaHot(parser);\n      });\n      normalModuleFactory.hooks.parser.for(\"javascript/dynamic\").tap(\"HotModuleReplacementPlugin\", parser => {\n        applyModuleHot(parser);\n      });\n      normalModuleFactory.hooks.parser.for(\"javascript/esm\").tap(\"HotModuleReplacementPlugin\", parser => {\n        applyImportMetaHot(parser);\n      });\n      NormalModule.getCompilationHooks(compilation).loader.tap(\"HotModuleReplacementPlugin\", context => {\n        context.hot = true;\n      });\n    });\n  }\n\n}\n\nmodule.exports = HotModuleReplacementPlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/HotModuleReplacementPlugin.js"],"names":["SyncBailHook","require","RawSource","ChunkGraph","Compilation","HotUpdateChunk","NormalModule","RuntimeGlobals","WebpackError","ConstDependency","ImportMetaHotAcceptDependency","ImportMetaHotDeclineDependency","ModuleHotAcceptDependency","ModuleHotDeclineDependency","HotModuleReplacementRuntimeModule","JavascriptParser","evaluateToIdentifier","find","isSubset","TupleSet","compareModulesById","getRuntimeKey","keyToRuntime","forEachRuntime","mergeRuntimeOwned","subtractRuntime","intersectRuntime","parserHooksMap","WeakMap","HotModuleReplacementPlugin","getParserHooks","parser","TypeError","hooks","get","undefined","hotAcceptCallback","hotAcceptWithoutCallback","set","constructor","options","apply","compiler","_backCompat","backCompat","output","strictModuleErrorHandling","runtimeRequirements","module","createAcceptHandler","ParamDependency","expr","state","dep","moduleArgument","callee","range","loc","addPresentationalDependency","buildInfo","moduleConcatenationBailout","arguments","length","arg","evaluateExpression","params","requests","isString","isArray","items","filter","param","forEach","idx","request","string","optional","Object","create","index","addDependency","push","call","i","walkExpression","walkExpressions","createDeclineHandler","createHMRExpressionHandler","applyModuleHot","evaluateIdentifier","for","tap","name","before","expression","applyImportMetaHot","compilation","normalModuleFactory","dependencyFactories","dependencyTemplates","Template","hotIndex","fullHashChunkModuleHashes","chunkModuleHashes","record","records","hash","chunkGraph","chunkHashes","chunkRuntime","chunk","chunks","id","runtime","chunkModuleIds","Array","from","getOrderedChunkModulesIterable","m","getModuleId","updatedModules","fullHashModules","nonCodeGeneratedModules","fullHash","getModuleHash","codeGenerationResults","has","getHash","add","fullHashModulesInThisChunk","getChunkFullHashModulesSet","modules","getChunkModulesIterable","key","identifier","size","update","processAssets","stage","PROCESS_ASSETS_STAGE_ADDITIONAL","hotUpdateMainContentByRuntime","Map","allOldRuntime","keys","path","filename","info","assetInfo","getPathWithInfo","outputOptions","hotUpdateMainFilename","updatedChunkIds","Set","removedChunkIds","removedModules","allModules","completelyRemovedModules","oldRuntime","remainingModules","chunkId","newModules","newRuntimeModules","newFullHashModules","newDependentHashModules","newRuntime","removedFromRuntime","currentChunk","getChunkModules","getChunkRuntimeModulesIterable","getChunkFullHashModulesIterable","dependentHashModules","getChunkDependentHashModulesIterable","moduleKey","oldHash","runtimes","getModuleRuntimes","type","moduleRuntime","hotUpdateChunk","setChunkGraphForChunk","group","groupsIterable","addGroup","attachModules","attachRuntimeModules","attachFullHashModules","attachDependentHashModules","renderManifest","getRenderManifest","moduleTemplates","runtimeTemplate","moduleGraph","entry","filenameTemplate","pathOptions","source","render","additionalChunkAssets","emitAsset","hotModuleReplacement","files","chunkAsset","completelyRemovedModulesArray","hotUpdateMainContentByFilename","values","old","warnings","hotUpdateMainJson","c","r","concat","JSON","stringify","additionalTreeRuntimeRequirements","hmrDownloadManifest","hmrDownloadUpdateHandlers","interceptModuleExecution","moduleCache","addRuntimeModule","getCompilationHooks","loader","context","hot","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { SyncBailHook } = require(\"tapable\");\nconst { RawSource } = require(\"webpack-sources\");\nconst ChunkGraph = require(\"./ChunkGraph\");\nconst Compilation = require(\"./Compilation\");\nconst HotUpdateChunk = require(\"./HotUpdateChunk\");\nconst NormalModule = require(\"./NormalModule\");\nconst RuntimeGlobals = require(\"./RuntimeGlobals\");\nconst WebpackError = require(\"./WebpackError\");\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\nconst ImportMetaHotAcceptDependency = require(\"./dependencies/ImportMetaHotAcceptDependency\");\nconst ImportMetaHotDeclineDependency = require(\"./dependencies/ImportMetaHotDeclineDependency\");\nconst ModuleHotAcceptDependency = require(\"./dependencies/ModuleHotAcceptDependency\");\nconst ModuleHotDeclineDependency = require(\"./dependencies/ModuleHotDeclineDependency\");\nconst HotModuleReplacementRuntimeModule = require(\"./hmr/HotModuleReplacementRuntimeModule\");\nconst JavascriptParser = require(\"./javascript/JavascriptParser\");\nconst {\n\tevaluateToIdentifier\n} = require(\"./javascript/JavascriptParserHelpers\");\nconst { find, isSubset } = require(\"./util/SetHelpers\");\nconst TupleSet = require(\"./util/TupleSet\");\nconst { compareModulesById } = require(\"./util/comparators\");\nconst {\n\tgetRuntimeKey,\n\tkeyToRuntime,\n\tforEachRuntime,\n\tmergeRuntimeOwned,\n\tsubtractRuntime,\n\tintersectRuntime\n} = require(\"./util/runtime\");\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./RuntimeModule\")} RuntimeModule */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {Object} HMRJavascriptParserHooks\n * @property {SyncBailHook<[TODO, string[]], void>} hotAcceptCallback\n * @property {SyncBailHook<[TODO, string[]], void>} hotAcceptWithoutCallback\n */\n\n/** @type {WeakMap<JavascriptParser, HMRJavascriptParserHooks>} */\nconst parserHooksMap = new WeakMap();\n\nclass HotModuleReplacementPlugin {\n\t/**\n\t * @param {JavascriptParser} parser the parser\n\t * @returns {HMRJavascriptParserHooks} the attached hooks\n\t */\n\tstatic getParserHooks(parser) {\n\t\tif (!(parser instanceof JavascriptParser)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t\"The 'parser' argument must be an instance of JavascriptParser\"\n\t\t\t);\n\t\t}\n\t\tlet hooks = parserHooksMap.get(parser);\n\t\tif (hooks === undefined) {\n\t\t\thooks = {\n\t\t\t\thotAcceptCallback: new SyncBailHook([\"expression\", \"requests\"]),\n\t\t\t\thotAcceptWithoutCallback: new SyncBailHook([\"expression\", \"requests\"])\n\t\t\t};\n\t\t\tparserHooksMap.set(parser, hooks);\n\t\t}\n\t\treturn hooks;\n\t}\n\n\tconstructor(options) {\n\t\tthis.options = options || {};\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst { _backCompat: backCompat } = compiler;\n\t\tif (compiler.options.output.strictModuleErrorHandling === undefined)\n\t\t\tcompiler.options.output.strictModuleErrorHandling = true;\n\t\tconst runtimeRequirements = [RuntimeGlobals.module];\n\n\t\tconst createAcceptHandler = (parser, ParamDependency) => {\n\t\t\tconst { hotAcceptCallback, hotAcceptWithoutCallback } =\n\t\t\t\tHotModuleReplacementPlugin.getParserHooks(parser);\n\n\t\t\treturn expr => {\n\t\t\t\tconst module = parser.state.module;\n\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t`${module.moduleArgument}.hot.accept`,\n\t\t\t\t\texpr.callee.range,\n\t\t\t\t\truntimeRequirements\n\t\t\t\t);\n\t\t\t\tdep.loc = expr.loc;\n\t\t\t\tmodule.addPresentationalDependency(dep);\n\t\t\t\tmodule.buildInfo.moduleConcatenationBailout = \"Hot Module Replacement\";\n\t\t\t\tif (expr.arguments.length >= 1) {\n\t\t\t\t\tconst arg = parser.evaluateExpression(expr.arguments[0]);\n\t\t\t\t\tlet params = [];\n\t\t\t\t\tlet requests = [];\n\t\t\t\t\tif (arg.isString()) {\n\t\t\t\t\t\tparams = [arg];\n\t\t\t\t\t} else if (arg.isArray()) {\n\t\t\t\t\t\tparams = arg.items.filter(param => param.isString());\n\t\t\t\t\t}\n\t\t\t\t\tif (params.length > 0) {\n\t\t\t\t\t\tparams.forEach((param, idx) => {\n\t\t\t\t\t\t\tconst request = param.string;\n\t\t\t\t\t\t\tconst dep = new ParamDependency(request, param.range);\n\t\t\t\t\t\t\tdep.optional = true;\n\t\t\t\t\t\t\tdep.loc = Object.create(expr.loc);\n\t\t\t\t\t\t\tdep.loc.index = idx;\n\t\t\t\t\t\t\tmodule.addDependency(dep);\n\t\t\t\t\t\t\trequests.push(request);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (expr.arguments.length > 1) {\n\t\t\t\t\t\t\thotAcceptCallback.call(expr.arguments[1], requests);\n\t\t\t\t\t\t\tfor (let i = 1; i < expr.arguments.length; i++) {\n\t\t\t\t\t\t\t\tparser.walkExpression(expr.arguments[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\thotAcceptWithoutCallback.call(expr, requests);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparser.walkExpressions(expr.arguments);\n\t\t\t\treturn true;\n\t\t\t};\n\t\t};\n\n\t\tconst createDeclineHandler = (parser, ParamDependency) => expr => {\n\t\t\tconst module = parser.state.module;\n\t\t\tconst dep = new ConstDependency(\n\t\t\t\t`${module.moduleArgument}.hot.decline`,\n\t\t\t\texpr.callee.range,\n\t\t\t\truntimeRequirements\n\t\t\t);\n\t\t\tdep.loc = expr.loc;\n\t\t\tmodule.addPresentationalDependency(dep);\n\t\t\tmodule.buildInfo.moduleConcatenationBailout = \"Hot Module Replacement\";\n\t\t\tif (expr.arguments.length === 1) {\n\t\t\t\tconst arg = parser.evaluateExpression(expr.arguments[0]);\n\t\t\t\tlet params = [];\n\t\t\t\tif (arg.isString()) {\n\t\t\t\t\tparams = [arg];\n\t\t\t\t} else if (arg.isArray()) {\n\t\t\t\t\tparams = arg.items.filter(param => param.isString());\n\t\t\t\t}\n\t\t\t\tparams.forEach((param, idx) => {\n\t\t\t\t\tconst dep = new ParamDependency(param.string, param.range);\n\t\t\t\t\tdep.optional = true;\n\t\t\t\t\tdep.loc = Object.create(expr.loc);\n\t\t\t\t\tdep.loc.index = idx;\n\t\t\t\t\tmodule.addDependency(dep);\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t\tconst createHMRExpressionHandler = parser => expr => {\n\t\t\tconst module = parser.state.module;\n\t\t\tconst dep = new ConstDependency(\n\t\t\t\t`${module.moduleArgument}.hot`,\n\t\t\t\texpr.range,\n\t\t\t\truntimeRequirements\n\t\t\t);\n\t\t\tdep.loc = expr.loc;\n\t\t\tmodule.addPresentationalDependency(dep);\n\t\t\tmodule.buildInfo.moduleConcatenationBailout = \"Hot Module Replacement\";\n\t\t\treturn true;\n\t\t};\n\n\t\tconst applyModuleHot = parser => {\n\t\t\tparser.hooks.evaluateIdentifier.for(\"module.hot\").tap(\n\t\t\t\t{\n\t\t\t\t\tname: \"HotModuleReplacementPlugin\",\n\t\t\t\t\tbefore: \"NodeStuffPlugin\"\n\t\t\t\t},\n\t\t\t\texpr => {\n\t\t\t\t\treturn evaluateToIdentifier(\n\t\t\t\t\t\t\"module.hot\",\n\t\t\t\t\t\t\"module\",\n\t\t\t\t\t\t() => [\"hot\"],\n\t\t\t\t\t\ttrue\n\t\t\t\t\t)(expr);\n\t\t\t\t}\n\t\t\t);\n\t\t\tparser.hooks.call\n\t\t\t\t.for(\"module.hot.accept\")\n\t\t\t\t.tap(\n\t\t\t\t\t\"HotModuleReplacementPlugin\",\n\t\t\t\t\tcreateAcceptHandler(parser, ModuleHotAcceptDependency)\n\t\t\t\t);\n\t\t\tparser.hooks.call\n\t\t\t\t.for(\"module.hot.decline\")\n\t\t\t\t.tap(\n\t\t\t\t\t\"HotModuleReplacementPlugin\",\n\t\t\t\t\tcreateDeclineHandler(parser, ModuleHotDeclineDependency)\n\t\t\t\t);\n\t\t\tparser.hooks.expression\n\t\t\t\t.for(\"module.hot\")\n\t\t\t\t.tap(\"HotModuleReplacementPlugin\", createHMRExpressionHandler(parser));\n\t\t};\n\n\t\tconst applyImportMetaHot = parser => {\n\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t.for(\"import.meta.webpackHot\")\n\t\t\t\t.tap(\"HotModuleReplacementPlugin\", expr => {\n\t\t\t\t\treturn evaluateToIdentifier(\n\t\t\t\t\t\t\"import.meta.webpackHot\",\n\t\t\t\t\t\t\"import.meta\",\n\t\t\t\t\t\t() => [\"webpackHot\"],\n\t\t\t\t\t\ttrue\n\t\t\t\t\t)(expr);\n\t\t\t\t});\n\t\t\tparser.hooks.call\n\t\t\t\t.for(\"import.meta.webpackHot.accept\")\n\t\t\t\t.tap(\n\t\t\t\t\t\"HotModuleReplacementPlugin\",\n\t\t\t\t\tcreateAcceptHandler(parser, ImportMetaHotAcceptDependency)\n\t\t\t\t);\n\t\t\tparser.hooks.call\n\t\t\t\t.for(\"import.meta.webpackHot.decline\")\n\t\t\t\t.tap(\n\t\t\t\t\t\"HotModuleReplacementPlugin\",\n\t\t\t\t\tcreateDeclineHandler(parser, ImportMetaHotDeclineDependency)\n\t\t\t\t);\n\t\t\tparser.hooks.expression\n\t\t\t\t.for(\"import.meta.webpackHot\")\n\t\t\t\t.tap(\"HotModuleReplacementPlugin\", createHMRExpressionHandler(parser));\n\t\t};\n\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"HotModuleReplacementPlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\t// This applies the HMR plugin only to the targeted compiler\n\t\t\t\t// It should not affect child compilations\n\t\t\t\tif (compilation.compiler !== compiler) return;\n\n\t\t\t\t//#region module.hot.* API\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tModuleHotAcceptDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tModuleHotAcceptDependency,\n\t\t\t\t\tnew ModuleHotAcceptDependency.Template()\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tModuleHotDeclineDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tModuleHotDeclineDependency,\n\t\t\t\t\tnew ModuleHotDeclineDependency.Template()\n\t\t\t\t);\n\t\t\t\t//#endregion\n\n\t\t\t\t//#region import.meta.webpackHot.* API\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tImportMetaHotAcceptDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tImportMetaHotAcceptDependency,\n\t\t\t\t\tnew ImportMetaHotAcceptDependency.Template()\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tImportMetaHotDeclineDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tImportMetaHotDeclineDependency,\n\t\t\t\t\tnew ImportMetaHotDeclineDependency.Template()\n\t\t\t\t);\n\t\t\t\t//#endregion\n\n\t\t\t\tlet hotIndex = 0;\n\t\t\t\tconst fullHashChunkModuleHashes = {};\n\t\t\t\tconst chunkModuleHashes = {};\n\n\t\t\t\tcompilation.hooks.record.tap(\n\t\t\t\t\t\"HotModuleReplacementPlugin\",\n\t\t\t\t\t(compilation, records) => {\n\t\t\t\t\t\tif (records.hash === compilation.hash) return;\n\t\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\t\trecords.hash = compilation.hash;\n\t\t\t\t\t\trecords.hotIndex = hotIndex;\n\t\t\t\t\t\trecords.fullHashChunkModuleHashes = fullHashChunkModuleHashes;\n\t\t\t\t\t\trecords.chunkModuleHashes = chunkModuleHashes;\n\t\t\t\t\t\trecords.chunkHashes = {};\n\t\t\t\t\t\trecords.chunkRuntime = {};\n\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\trecords.chunkHashes[chunk.id] = chunk.hash;\n\t\t\t\t\t\t\trecords.chunkRuntime[chunk.id] = getRuntimeKey(chunk.runtime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trecords.chunkModuleIds = {};\n\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\trecords.chunkModuleIds[chunk.id] = Array.from(\n\t\t\t\t\t\t\t\tchunkGraph.getOrderedChunkModulesIterable(\n\t\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\t\tcompareModulesById(chunkGraph)\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tm => chunkGraph.getModuleId(m)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\t/** @type {TupleSet<[Module, Chunk]>} */\n\t\t\t\tconst updatedModules = new TupleSet();\n\t\t\t\t/** @type {TupleSet<[Module, Chunk]>} */\n\t\t\t\tconst fullHashModules = new TupleSet();\n\t\t\t\t/** @type {TupleSet<[Module, RuntimeSpec]>} */\n\t\t\t\tconst nonCodeGeneratedModules = new TupleSet();\n\t\t\t\tcompilation.hooks.fullHash.tap(\"HotModuleReplacementPlugin\", hash => {\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\tconst records = compilation.records;\n\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\tconst getModuleHash = module => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcompilation.codeGenerationResults.has(module, chunk.runtime)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\treturn compilation.codeGenerationResults.getHash(\n\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\tchunk.runtime\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnonCodeGeneratedModules.add(module, chunk.runtime);\n\t\t\t\t\t\t\t\treturn chunkGraph.getModuleHash(module, chunk.runtime);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst fullHashModulesInThisChunk =\n\t\t\t\t\t\t\tchunkGraph.getChunkFullHashModulesSet(chunk);\n\t\t\t\t\t\tif (fullHashModulesInThisChunk !== undefined) {\n\t\t\t\t\t\t\tfor (const module of fullHashModulesInThisChunk) {\n\t\t\t\t\t\t\t\tfullHashModules.add(module, chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst modules = chunkGraph.getChunkModulesIterable(chunk);\n\t\t\t\t\t\tif (modules !== undefined) {\n\t\t\t\t\t\t\tif (records.chunkModuleHashes) {\n\t\t\t\t\t\t\t\tif (fullHashModulesInThisChunk !== undefined) {\n\t\t\t\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\t\t\t\tconst key = `${chunk.id}|${module.identifier()}`;\n\t\t\t\t\t\t\t\t\t\tconst hash = getModuleHash(module);\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\tfullHashModulesInThisChunk.has(\n\t\t\t\t\t\t\t\t\t\t\t\t/** @type {RuntimeModule} */ (module)\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tif (records.fullHashChunkModuleHashes[key] !== hash) {\n\t\t\t\t\t\t\t\t\t\t\t\tupdatedModules.add(module, chunk);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tfullHashChunkModuleHashes[key] = hash;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tif (records.chunkModuleHashes[key] !== hash) {\n\t\t\t\t\t\t\t\t\t\t\t\tupdatedModules.add(module, chunk);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tchunkModuleHashes[key] = hash;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\t\t\t\tconst key = `${chunk.id}|${module.identifier()}`;\n\t\t\t\t\t\t\t\t\t\tconst hash = getModuleHash(module);\n\t\t\t\t\t\t\t\t\t\tif (records.chunkModuleHashes[key] !== hash) {\n\t\t\t\t\t\t\t\t\t\t\tupdatedModules.add(module, chunk);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tchunkModuleHashes[key] = hash;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (fullHashModulesInThisChunk !== undefined) {\n\t\t\t\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\t\t\t\tconst key = `${chunk.id}|${module.identifier()}`;\n\t\t\t\t\t\t\t\t\t\tconst hash = getModuleHash(module);\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\tfullHashModulesInThisChunk.has(\n\t\t\t\t\t\t\t\t\t\t\t\t/** @type {RuntimeModule} */ (module)\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tfullHashChunkModuleHashes[key] = hash;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tchunkModuleHashes[key] = hash;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\t\t\t\tconst key = `${chunk.id}|${module.identifier()}`;\n\t\t\t\t\t\t\t\t\t\tconst hash = getModuleHash(module);\n\t\t\t\t\t\t\t\t\t\tchunkModuleHashes[key] = hash;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\thotIndex = records.hotIndex || 0;\n\t\t\t\t\tif (updatedModules.size > 0) hotIndex++;\n\n\t\t\t\t\thash.update(`${hotIndex}`);\n\t\t\t\t});\n\t\t\t\tcompilation.hooks.processAssets.tap(\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"HotModuleReplacementPlugin\",\n\t\t\t\t\t\tstage: Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL\n\t\t\t\t\t},\n\t\t\t\t\t() => {\n\t\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\t\tconst records = compilation.records;\n\t\t\t\t\t\tif (records.hash === compilation.hash) return;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!records.chunkModuleHashes ||\n\t\t\t\t\t\t\t!records.chunkHashes ||\n\t\t\t\t\t\t\t!records.chunkModuleIds\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const [module, chunk] of fullHashModules) {\n\t\t\t\t\t\t\tconst key = `${chunk.id}|${module.identifier()}`;\n\t\t\t\t\t\t\tconst hash = nonCodeGeneratedModules.has(module, chunk.runtime)\n\t\t\t\t\t\t\t\t? chunkGraph.getModuleHash(module, chunk.runtime)\n\t\t\t\t\t\t\t\t: compilation.codeGenerationResults.getHash(\n\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\tchunk.runtime\n\t\t\t\t\t\t\t\t  );\n\t\t\t\t\t\t\tif (records.chunkModuleHashes[key] !== hash) {\n\t\t\t\t\t\t\t\tupdatedModules.add(module, chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchunkModuleHashes[key] = hash;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/** @type {Map<string, { updatedChunkIds: Set<string|number>, removedChunkIds: Set<string|number>, removedModules: Set<Module>, filename: string, assetInfo: AssetInfo }>} */\n\t\t\t\t\t\tconst hotUpdateMainContentByRuntime = new Map();\n\t\t\t\t\t\tlet allOldRuntime;\n\t\t\t\t\t\tfor (const key of Object.keys(records.chunkRuntime)) {\n\t\t\t\t\t\t\tconst runtime = keyToRuntime(records.chunkRuntime[key]);\n\t\t\t\t\t\t\tallOldRuntime = mergeRuntimeOwned(allOldRuntime, runtime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforEachRuntime(allOldRuntime, runtime => {\n\t\t\t\t\t\t\tconst { path: filename, info: assetInfo } =\n\t\t\t\t\t\t\t\tcompilation.getPathWithInfo(\n\t\t\t\t\t\t\t\t\tcompilation.outputOptions.hotUpdateMainFilename,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\thash: records.hash,\n\t\t\t\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\thotUpdateMainContentByRuntime.set(runtime, {\n\t\t\t\t\t\t\t\tupdatedChunkIds: new Set(),\n\t\t\t\t\t\t\t\tremovedChunkIds: new Set(),\n\t\t\t\t\t\t\t\tremovedModules: new Set(),\n\t\t\t\t\t\t\t\tfilename,\n\t\t\t\t\t\t\t\tassetInfo\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (hotUpdateMainContentByRuntime.size === 0) return;\n\n\t\t\t\t\t\t// Create a list of all active modules to verify which modules are removed completely\n\t\t\t\t\t\t/** @type {Map<number|string, Module>} */\n\t\t\t\t\t\tconst allModules = new Map();\n\t\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t\tconst id = chunkGraph.getModuleId(module);\n\t\t\t\t\t\t\tallModules.set(id, module);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// List of completely removed modules\n\t\t\t\t\t\t/** @type {Set<string | number>} */\n\t\t\t\t\t\tconst completelyRemovedModules = new Set();\n\n\t\t\t\t\t\tfor (const key of Object.keys(records.chunkHashes)) {\n\t\t\t\t\t\t\tconst oldRuntime = keyToRuntime(records.chunkRuntime[key]);\n\t\t\t\t\t\t\t/** @type {Module[]} */\n\t\t\t\t\t\t\tconst remainingModules = [];\n\t\t\t\t\t\t\t// Check which modules are removed\n\t\t\t\t\t\t\tfor (const id of records.chunkModuleIds[key]) {\n\t\t\t\t\t\t\t\tconst module = allModules.get(id);\n\t\t\t\t\t\t\t\tif (module === undefined) {\n\t\t\t\t\t\t\t\t\tcompletelyRemovedModules.add(id);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tremainingModules.push(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlet chunkId;\n\t\t\t\t\t\t\tlet newModules;\n\t\t\t\t\t\t\tlet newRuntimeModules;\n\t\t\t\t\t\t\tlet newFullHashModules;\n\t\t\t\t\t\t\tlet newDependentHashModules;\n\t\t\t\t\t\t\tlet newRuntime;\n\t\t\t\t\t\t\tlet removedFromRuntime;\n\t\t\t\t\t\t\tconst currentChunk = find(\n\t\t\t\t\t\t\t\tcompilation.chunks,\n\t\t\t\t\t\t\t\tchunk => `${chunk.id}` === key\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (currentChunk) {\n\t\t\t\t\t\t\t\tchunkId = currentChunk.id;\n\t\t\t\t\t\t\t\tnewRuntime = intersectRuntime(\n\t\t\t\t\t\t\t\t\tcurrentChunk.runtime,\n\t\t\t\t\t\t\t\t\tallOldRuntime\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (newRuntime === undefined) continue;\n\t\t\t\t\t\t\t\tnewModules = chunkGraph\n\t\t\t\t\t\t\t\t\t.getChunkModules(currentChunk)\n\t\t\t\t\t\t\t\t\t.filter(module => updatedModules.has(module, currentChunk));\n\t\t\t\t\t\t\t\tnewRuntimeModules = Array.from(\n\t\t\t\t\t\t\t\t\tchunkGraph.getChunkRuntimeModulesIterable(currentChunk)\n\t\t\t\t\t\t\t\t).filter(module => updatedModules.has(module, currentChunk));\n\t\t\t\t\t\t\t\tconst fullHashModules =\n\t\t\t\t\t\t\t\t\tchunkGraph.getChunkFullHashModulesIterable(currentChunk);\n\t\t\t\t\t\t\t\tnewFullHashModules =\n\t\t\t\t\t\t\t\t\tfullHashModules &&\n\t\t\t\t\t\t\t\t\tArray.from(fullHashModules).filter(module =>\n\t\t\t\t\t\t\t\t\t\tupdatedModules.has(module, currentChunk)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tconst dependentHashModules =\n\t\t\t\t\t\t\t\t\tchunkGraph.getChunkDependentHashModulesIterable(currentChunk);\n\t\t\t\t\t\t\t\tnewDependentHashModules =\n\t\t\t\t\t\t\t\t\tdependentHashModules &&\n\t\t\t\t\t\t\t\t\tArray.from(dependentHashModules).filter(module =>\n\t\t\t\t\t\t\t\t\t\tupdatedModules.has(module, currentChunk)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tremovedFromRuntime = subtractRuntime(oldRuntime, newRuntime);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// chunk has completely removed\n\t\t\t\t\t\t\t\tchunkId = `${+key}` === key ? +key : key;\n\t\t\t\t\t\t\t\tremovedFromRuntime = oldRuntime;\n\t\t\t\t\t\t\t\tnewRuntime = oldRuntime;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (removedFromRuntime) {\n\t\t\t\t\t\t\t\t// chunk was removed from some runtimes\n\t\t\t\t\t\t\t\tforEachRuntime(removedFromRuntime, runtime => {\n\t\t\t\t\t\t\t\t\thotUpdateMainContentByRuntime\n\t\t\t\t\t\t\t\t\t\t.get(runtime)\n\t\t\t\t\t\t\t\t\t\t.removedChunkIds.add(chunkId);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t// dispose modules from the chunk in these runtimes\n\t\t\t\t\t\t\t\t// where they are no longer in this runtime\n\t\t\t\t\t\t\t\tfor (const module of remainingModules) {\n\t\t\t\t\t\t\t\t\tconst moduleKey = `${key}|${module.identifier()}`;\n\t\t\t\t\t\t\t\t\tconst oldHash = records.chunkModuleHashes[moduleKey];\n\t\t\t\t\t\t\t\t\tconst runtimes = chunkGraph.getModuleRuntimes(module);\n\t\t\t\t\t\t\t\t\tif (oldRuntime === newRuntime && runtimes.has(newRuntime)) {\n\t\t\t\t\t\t\t\t\t\t// Module is still in the same runtime combination\n\t\t\t\t\t\t\t\t\t\tconst hash = nonCodeGeneratedModules.has(module, newRuntime)\n\t\t\t\t\t\t\t\t\t\t\t? chunkGraph.getModuleHash(module, newRuntime)\n\t\t\t\t\t\t\t\t\t\t\t: compilation.codeGenerationResults.getHash(\n\t\t\t\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnewRuntime\n\t\t\t\t\t\t\t\t\t\t\t  );\n\t\t\t\t\t\t\t\t\t\tif (hash !== oldHash) {\n\t\t\t\t\t\t\t\t\t\t\tif (module.type === \"runtime\") {\n\t\t\t\t\t\t\t\t\t\t\t\tnewRuntimeModules = newRuntimeModules || [];\n\t\t\t\t\t\t\t\t\t\t\t\tnewRuntimeModules.push(\n\t\t\t\t\t\t\t\t\t\t\t\t\t/** @type {RuntimeModule} */ (module)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tnewModules = newModules || [];\n\t\t\t\t\t\t\t\t\t\t\t\tnewModules.push(module);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t// module is no longer in this runtime combination\n\t\t\t\t\t\t\t\t\t\t// We (incorrectly) assume that it's not in an overlapping runtime combination\n\t\t\t\t\t\t\t\t\t\t// and dispose it from the main runtimes the chunk was removed from\n\t\t\t\t\t\t\t\t\t\tforEachRuntime(removedFromRuntime, runtime => {\n\t\t\t\t\t\t\t\t\t\t\t// If the module is still used in this runtime, do not dispose it\n\t\t\t\t\t\t\t\t\t\t\t// This could create a bad runtime state where the module is still loaded,\n\t\t\t\t\t\t\t\t\t\t\t// but no chunk which contains it. This means we don't receive further HMR updates\n\t\t\t\t\t\t\t\t\t\t\t// to this module and that's bad.\n\t\t\t\t\t\t\t\t\t\t\t// TODO force load one of the chunks which contains the module\n\t\t\t\t\t\t\t\t\t\t\tfor (const moduleRuntime of runtimes) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (typeof moduleRuntime === \"string\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (moduleRuntime === runtime) return;\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (moduleRuntime !== undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (moduleRuntime.has(runtime)) return;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\thotUpdateMainContentByRuntime\n\t\t\t\t\t\t\t\t\t\t\t\t.get(runtime)\n\t\t\t\t\t\t\t\t\t\t\t\t.removedModules.add(module);\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t(newModules && newModules.length > 0) ||\n\t\t\t\t\t\t\t\t(newRuntimeModules && newRuntimeModules.length > 0)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst hotUpdateChunk = new HotUpdateChunk();\n\t\t\t\t\t\t\t\tif (backCompat)\n\t\t\t\t\t\t\t\t\tChunkGraph.setChunkGraphForChunk(hotUpdateChunk, chunkGraph);\n\t\t\t\t\t\t\t\thotUpdateChunk.id = chunkId;\n\t\t\t\t\t\t\t\thotUpdateChunk.runtime = newRuntime;\n\t\t\t\t\t\t\t\tif (currentChunk) {\n\t\t\t\t\t\t\t\t\tfor (const group of currentChunk.groupsIterable)\n\t\t\t\t\t\t\t\t\t\thotUpdateChunk.addGroup(group);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tchunkGraph.attachModules(hotUpdateChunk, newModules || []);\n\t\t\t\t\t\t\t\tchunkGraph.attachRuntimeModules(\n\t\t\t\t\t\t\t\t\thotUpdateChunk,\n\t\t\t\t\t\t\t\t\tnewRuntimeModules || []\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (newFullHashModules) {\n\t\t\t\t\t\t\t\t\tchunkGraph.attachFullHashModules(\n\t\t\t\t\t\t\t\t\t\thotUpdateChunk,\n\t\t\t\t\t\t\t\t\t\tnewFullHashModules\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (newDependentHashModules) {\n\t\t\t\t\t\t\t\t\tchunkGraph.attachDependentHashModules(\n\t\t\t\t\t\t\t\t\t\thotUpdateChunk,\n\t\t\t\t\t\t\t\t\t\tnewDependentHashModules\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst renderManifest = compilation.getRenderManifest({\n\t\t\t\t\t\t\t\t\tchunk: hotUpdateChunk,\n\t\t\t\t\t\t\t\t\thash: records.hash,\n\t\t\t\t\t\t\t\t\tfullHash: records.hash,\n\t\t\t\t\t\t\t\t\toutputOptions: compilation.outputOptions,\n\t\t\t\t\t\t\t\t\tmoduleTemplates: compilation.moduleTemplates,\n\t\t\t\t\t\t\t\t\tdependencyTemplates: compilation.dependencyTemplates,\n\t\t\t\t\t\t\t\t\tcodeGenerationResults: compilation.codeGenerationResults,\n\t\t\t\t\t\t\t\t\truntimeTemplate: compilation.runtimeTemplate,\n\t\t\t\t\t\t\t\t\tmoduleGraph: compilation.moduleGraph,\n\t\t\t\t\t\t\t\t\tchunkGraph\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tfor (const entry of renderManifest) {\n\t\t\t\t\t\t\t\t\t/** @type {string} */\n\t\t\t\t\t\t\t\t\tlet filename;\n\t\t\t\t\t\t\t\t\t/** @type {AssetInfo} */\n\t\t\t\t\t\t\t\t\tlet assetInfo;\n\t\t\t\t\t\t\t\t\tif (\"filename\" in entry) {\n\t\t\t\t\t\t\t\t\t\tfilename = entry.filename;\n\t\t\t\t\t\t\t\t\t\tassetInfo = entry.info;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t({ path: filename, info: assetInfo } =\n\t\t\t\t\t\t\t\t\t\t\tcompilation.getPathWithInfo(\n\t\t\t\t\t\t\t\t\t\t\t\tentry.filenameTemplate,\n\t\t\t\t\t\t\t\t\t\t\t\tentry.pathOptions\n\t\t\t\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst source = entry.render();\n\t\t\t\t\t\t\t\t\tcompilation.additionalChunkAssets.push(filename);\n\t\t\t\t\t\t\t\t\tcompilation.emitAsset(filename, source, {\n\t\t\t\t\t\t\t\t\t\thotModuleReplacement: true,\n\t\t\t\t\t\t\t\t\t\t...assetInfo\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tif (currentChunk) {\n\t\t\t\t\t\t\t\t\t\tcurrentChunk.files.add(filename);\n\t\t\t\t\t\t\t\t\t\tcompilation.hooks.chunkAsset.call(currentChunk, filename);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tforEachRuntime(newRuntime, runtime => {\n\t\t\t\t\t\t\t\t\thotUpdateMainContentByRuntime\n\t\t\t\t\t\t\t\t\t\t.get(runtime)\n\t\t\t\t\t\t\t\t\t\t.updatedChunkIds.add(chunkId);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst completelyRemovedModulesArray = Array.from(\n\t\t\t\t\t\t\tcompletelyRemovedModules\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst hotUpdateMainContentByFilename = new Map();\n\t\t\t\t\t\tfor (const {\n\t\t\t\t\t\t\tremovedChunkIds,\n\t\t\t\t\t\t\tremovedModules,\n\t\t\t\t\t\t\tupdatedChunkIds,\n\t\t\t\t\t\t\tfilename,\n\t\t\t\t\t\t\tassetInfo\n\t\t\t\t\t\t} of hotUpdateMainContentByRuntime.values()) {\n\t\t\t\t\t\t\tconst old = hotUpdateMainContentByFilename.get(filename);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\told &&\n\t\t\t\t\t\t\t\t(!isSubset(old.removedChunkIds, removedChunkIds) ||\n\t\t\t\t\t\t\t\t\t!isSubset(old.removedModules, removedModules) ||\n\t\t\t\t\t\t\t\t\t!isSubset(old.updatedChunkIds, updatedChunkIds))\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tcompilation.warnings.push(\n\t\t\t\t\t\t\t\t\tnew WebpackError(`HotModuleReplacementPlugin\nThe configured output.hotUpdateMainFilename doesn't lead to unique filenames per runtime and HMR update differs between runtimes.\nThis might lead to incorrect runtime behavior of the applied update.\nTo fix this, make sure to include [runtime] in the output.hotUpdateMainFilename option, or use the default config.`)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tfor (const chunkId of removedChunkIds)\n\t\t\t\t\t\t\t\t\told.removedChunkIds.add(chunkId);\n\t\t\t\t\t\t\t\tfor (const chunkId of removedModules)\n\t\t\t\t\t\t\t\t\told.removedModules.add(chunkId);\n\t\t\t\t\t\t\t\tfor (const chunkId of updatedChunkIds)\n\t\t\t\t\t\t\t\t\told.updatedChunkIds.add(chunkId);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thotUpdateMainContentByFilename.set(filename, {\n\t\t\t\t\t\t\t\tremovedChunkIds,\n\t\t\t\t\t\t\t\tremovedModules,\n\t\t\t\t\t\t\t\tupdatedChunkIds,\n\t\t\t\t\t\t\t\tassetInfo\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const [\n\t\t\t\t\t\t\tfilename,\n\t\t\t\t\t\t\t{ removedChunkIds, removedModules, updatedChunkIds, assetInfo }\n\t\t\t\t\t\t] of hotUpdateMainContentByFilename) {\n\t\t\t\t\t\t\tconst hotUpdateMainJson = {\n\t\t\t\t\t\t\t\tc: Array.from(updatedChunkIds),\n\t\t\t\t\t\t\t\tr: Array.from(removedChunkIds),\n\t\t\t\t\t\t\t\tm:\n\t\t\t\t\t\t\t\t\tremovedModules.size === 0\n\t\t\t\t\t\t\t\t\t\t? completelyRemovedModulesArray\n\t\t\t\t\t\t\t\t\t\t: completelyRemovedModulesArray.concat(\n\t\t\t\t\t\t\t\t\t\t\t\tArray.from(removedModules, m =>\n\t\t\t\t\t\t\t\t\t\t\t\t\tchunkGraph.getModuleId(m)\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tconst source = new RawSource(JSON.stringify(hotUpdateMainJson));\n\t\t\t\t\t\t\tcompilation.emitAsset(filename, source, {\n\t\t\t\t\t\t\t\thotModuleReplacement: true,\n\t\t\t\t\t\t\t\t...assetInfo\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tcompilation.hooks.additionalTreeRuntimeRequirements.tap(\n\t\t\t\t\t\"HotModuleReplacementPlugin\",\n\t\t\t\t\t(chunk, runtimeRequirements) => {\n\t\t\t\t\t\truntimeRequirements.add(RuntimeGlobals.hmrDownloadManifest);\n\t\t\t\t\t\truntimeRequirements.add(RuntimeGlobals.hmrDownloadUpdateHandlers);\n\t\t\t\t\t\truntimeRequirements.add(RuntimeGlobals.interceptModuleExecution);\n\t\t\t\t\t\truntimeRequirements.add(RuntimeGlobals.moduleCache);\n\t\t\t\t\t\tcompilation.addRuntimeModule(\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tnew HotModuleReplacementRuntimeModule()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/auto\")\n\t\t\t\t\t.tap(\"HotModuleReplacementPlugin\", parser => {\n\t\t\t\t\t\tapplyModuleHot(parser);\n\t\t\t\t\t\tapplyImportMetaHot(parser);\n\t\t\t\t\t});\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/dynamic\")\n\t\t\t\t\t.tap(\"HotModuleReplacementPlugin\", parser => {\n\t\t\t\t\t\tapplyModuleHot(parser);\n\t\t\t\t\t});\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/esm\")\n\t\t\t\t\t.tap(\"HotModuleReplacementPlugin\", parser => {\n\t\t\t\t\t\tapplyImportMetaHot(parser);\n\t\t\t\t\t});\n\n\t\t\t\tNormalModule.getCompilationHooks(compilation).loader.tap(\n\t\t\t\t\t\"HotModuleReplacementPlugin\",\n\t\t\t\t\tcontext => {\n\t\t\t\t\t\tcontext.hot = true;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = HotModuleReplacementPlugin;\n"]},"metadata":{},"sourceType":"script"}