{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Hash = require(\"./Hash\");\n\nconst BULK_SIZE = 2000; // We are using an object instead of a Map as this will stay static during the runtime\n// so access to it can be optimized by v8\n\nconst digestCaches = {};\n\nclass BulkUpdateDecorator extends Hash {\n  /**\n   * @param {Hash | function(): Hash} hashOrFactory function to create a hash\n   * @param {string=} hashKey key for caching\n   */\n  constructor(hashOrFactory, hashKey) {\n    super();\n    this.hashKey = hashKey;\n\n    if (typeof hashOrFactory === \"function\") {\n      this.hashFactory = hashOrFactory;\n      this.hash = undefined;\n    } else {\n      this.hashFactory = undefined;\n      this.hash = hashOrFactory;\n    }\n\n    this.buffer = \"\";\n  }\n  /**\n   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n   * @param {string|Buffer} data data\n   * @param {string=} inputEncoding data encoding\n   * @returns {this} updated hash\n   */\n\n\n  update(data, inputEncoding) {\n    if (inputEncoding !== undefined || typeof data !== \"string\" || data.length > BULK_SIZE) {\n      if (this.hash === undefined) this.hash = this.hashFactory();\n\n      if (this.buffer.length > 0) {\n        this.hash.update(this.buffer);\n        this.buffer = \"\";\n      }\n\n      this.hash.update(data, inputEncoding);\n    } else {\n      this.buffer += data;\n\n      if (this.buffer.length > BULK_SIZE) {\n        if (this.hash === undefined) this.hash = this.hashFactory();\n        this.hash.update(this.buffer);\n        this.buffer = \"\";\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n   * @param {string=} encoding encoding of the return value\n   * @returns {string|Buffer} digest\n   */\n\n\n  digest(encoding) {\n    let digestCache;\n    const buffer = this.buffer;\n\n    if (this.hash === undefined) {\n      // short data for hash, we can use caching\n      const cacheKey = `${this.hashKey}-${encoding}`;\n      digestCache = digestCaches[cacheKey];\n\n      if (digestCache === undefined) {\n        digestCache = digestCaches[cacheKey] = new Map();\n      }\n\n      const cacheEntry = digestCache.get(buffer);\n      if (cacheEntry !== undefined) return cacheEntry;\n      this.hash = this.hashFactory();\n    }\n\n    if (buffer.length > 0) {\n      this.hash.update(buffer);\n    }\n\n    const digestResult = this.hash.digest(encoding);\n    const result = typeof digestResult === \"string\" ? digestResult : digestResult.toString();\n\n    if (digestCache !== undefined) {\n      digestCache.set(buffer, result);\n    }\n\n    return result;\n  }\n\n}\n/* istanbul ignore next */\n\n\nclass DebugHash extends Hash {\n  constructor() {\n    super();\n    this.string = \"\";\n  }\n  /**\n   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n   * @param {string|Buffer} data data\n   * @param {string=} inputEncoding data encoding\n   * @returns {this} updated hash\n   */\n\n\n  update(data, inputEncoding) {\n    if (typeof data !== \"string\") data = data.toString(\"utf-8\");\n\n    if (data.startsWith(\"debug-digest-\")) {\n      data = Buffer.from(data.slice(\"debug-digest-\".length), \"hex\").toString();\n    }\n\n    this.string += `[${data}](${new Error().stack.split(\"\\n\", 3)[2]})\\n`;\n    return this;\n  }\n  /**\n   * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n   * @param {string=} encoding encoding of the return value\n   * @returns {string|Buffer} digest\n   */\n\n\n  digest(encoding) {\n    return \"debug-digest-\" + Buffer.from(this.string).toString(\"hex\");\n  }\n\n}\n\nlet crypto = undefined;\nlet createXXHash64 = undefined;\nlet createMd4 = undefined;\nlet BatchedHash = undefined;\n/**\n * Creates a hash by name or function\n * @param {string | typeof Hash} algorithm the algorithm name or a constructor creating a hash\n * @returns {Hash} the hash\n */\n\nmodule.exports = algorithm => {\n  if (typeof algorithm === \"function\") {\n    return new BulkUpdateDecorator(() => new algorithm());\n  }\n\n  switch (algorithm) {\n    // TODO add non-cryptographic algorithm here\n    case \"debug\":\n      return new DebugHash();\n\n    case \"xxhash64\":\n      if (createXXHash64 === undefined) {\n        createXXHash64 = require(\"./hash/xxhash64\");\n\n        if (BatchedHash === undefined) {\n          BatchedHash = require(\"./hash/BatchedHash\");\n        }\n      }\n\n      return new BatchedHash(createXXHash64());\n\n    case \"md4\":\n      if (createMd4 === undefined) {\n        createMd4 = require(\"./hash/md4\");\n\n        if (BatchedHash === undefined) {\n          BatchedHash = require(\"./hash/BatchedHash\");\n        }\n      }\n\n      return new BatchedHash(createMd4());\n\n    case \"native-md4\":\n      if (crypto === undefined) crypto = require(\"crypto\");\n      return new BulkUpdateDecorator(() => crypto.createHash(\"md4\"), \"md4\");\n\n    default:\n      if (crypto === undefined) crypto = require(\"crypto\");\n      return new BulkUpdateDecorator(() => crypto.createHash(algorithm), algorithm);\n  }\n};","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/util/createHash.js"],"names":["Hash","require","BULK_SIZE","digestCaches","BulkUpdateDecorator","constructor","hashOrFactory","hashKey","hashFactory","hash","undefined","buffer","update","data","inputEncoding","length","digest","encoding","digestCache","cacheKey","Map","cacheEntry","get","digestResult","result","toString","set","DebugHash","string","startsWith","Buffer","from","slice","Error","stack","split","crypto","createXXHash64","createMd4","BatchedHash","module","exports","algorithm","createHash"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Hash = require(\"./Hash\");\n\nconst BULK_SIZE = 2000;\n\n// We are using an object instead of a Map as this will stay static during the runtime\n// so access to it can be optimized by v8\nconst digestCaches = {};\n\nclass BulkUpdateDecorator extends Hash {\n\t/**\n\t * @param {Hash | function(): Hash} hashOrFactory function to create a hash\n\t * @param {string=} hashKey key for caching\n\t */\n\tconstructor(hashOrFactory, hashKey) {\n\t\tsuper();\n\t\tthis.hashKey = hashKey;\n\t\tif (typeof hashOrFactory === \"function\") {\n\t\t\tthis.hashFactory = hashOrFactory;\n\t\t\tthis.hash = undefined;\n\t\t} else {\n\t\t\tthis.hashFactory = undefined;\n\t\t\tthis.hash = hashOrFactory;\n\t\t}\n\t\tthis.buffer = \"\";\n\t}\n\n\t/**\n\t * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n\t * @param {string|Buffer} data data\n\t * @param {string=} inputEncoding data encoding\n\t * @returns {this} updated hash\n\t */\n\tupdate(data, inputEncoding) {\n\t\tif (\n\t\t\tinputEncoding !== undefined ||\n\t\t\ttypeof data !== \"string\" ||\n\t\t\tdata.length > BULK_SIZE\n\t\t) {\n\t\t\tif (this.hash === undefined) this.hash = this.hashFactory();\n\t\t\tif (this.buffer.length > 0) {\n\t\t\t\tthis.hash.update(this.buffer);\n\t\t\t\tthis.buffer = \"\";\n\t\t\t}\n\t\t\tthis.hash.update(data, inputEncoding);\n\t\t} else {\n\t\t\tthis.buffer += data;\n\t\t\tif (this.buffer.length > BULK_SIZE) {\n\t\t\t\tif (this.hash === undefined) this.hash = this.hashFactory();\n\t\t\t\tthis.hash.update(this.buffer);\n\t\t\t\tthis.buffer = \"\";\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n\t * @param {string=} encoding encoding of the return value\n\t * @returns {string|Buffer} digest\n\t */\n\tdigest(encoding) {\n\t\tlet digestCache;\n\t\tconst buffer = this.buffer;\n\t\tif (this.hash === undefined) {\n\t\t\t// short data for hash, we can use caching\n\t\t\tconst cacheKey = `${this.hashKey}-${encoding}`;\n\t\t\tdigestCache = digestCaches[cacheKey];\n\t\t\tif (digestCache === undefined) {\n\t\t\t\tdigestCache = digestCaches[cacheKey] = new Map();\n\t\t\t}\n\t\t\tconst cacheEntry = digestCache.get(buffer);\n\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\tthis.hash = this.hashFactory();\n\t\t}\n\t\tif (buffer.length > 0) {\n\t\t\tthis.hash.update(buffer);\n\t\t}\n\t\tconst digestResult = this.hash.digest(encoding);\n\t\tconst result =\n\t\t\ttypeof digestResult === \"string\" ? digestResult : digestResult.toString();\n\t\tif (digestCache !== undefined) {\n\t\t\tdigestCache.set(buffer, result);\n\t\t}\n\t\treturn result;\n\t}\n}\n\n/* istanbul ignore next */\nclass DebugHash extends Hash {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.string = \"\";\n\t}\n\n\t/**\n\t * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n\t * @param {string|Buffer} data data\n\t * @param {string=} inputEncoding data encoding\n\t * @returns {this} updated hash\n\t */\n\tupdate(data, inputEncoding) {\n\t\tif (typeof data !== \"string\") data = data.toString(\"utf-8\");\n\t\tif (data.startsWith(\"debug-digest-\")) {\n\t\t\tdata = Buffer.from(data.slice(\"debug-digest-\".length), \"hex\").toString();\n\t\t}\n\t\tthis.string += `[${data}](${new Error().stack.split(\"\\n\", 3)[2]})\\n`;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n\t * @param {string=} encoding encoding of the return value\n\t * @returns {string|Buffer} digest\n\t */\n\tdigest(encoding) {\n\t\treturn \"debug-digest-\" + Buffer.from(this.string).toString(\"hex\");\n\t}\n}\n\nlet crypto = undefined;\nlet createXXHash64 = undefined;\nlet createMd4 = undefined;\nlet BatchedHash = undefined;\n\n/**\n * Creates a hash by name or function\n * @param {string | typeof Hash} algorithm the algorithm name or a constructor creating a hash\n * @returns {Hash} the hash\n */\nmodule.exports = algorithm => {\n\tif (typeof algorithm === \"function\") {\n\t\treturn new BulkUpdateDecorator(() => new algorithm());\n\t}\n\tswitch (algorithm) {\n\t\t// TODO add non-cryptographic algorithm here\n\t\tcase \"debug\":\n\t\t\treturn new DebugHash();\n\t\tcase \"xxhash64\":\n\t\t\tif (createXXHash64 === undefined) {\n\t\t\t\tcreateXXHash64 = require(\"./hash/xxhash64\");\n\t\t\t\tif (BatchedHash === undefined) {\n\t\t\t\t\tBatchedHash = require(\"./hash/BatchedHash\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new BatchedHash(createXXHash64());\n\t\tcase \"md4\":\n\t\t\tif (createMd4 === undefined) {\n\t\t\t\tcreateMd4 = require(\"./hash/md4\");\n\t\t\t\tif (BatchedHash === undefined) {\n\t\t\t\t\tBatchedHash = require(\"./hash/BatchedHash\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new BatchedHash(createMd4());\n\t\tcase \"native-md4\":\n\t\t\tif (crypto === undefined) crypto = require(\"crypto\");\n\t\t\treturn new BulkUpdateDecorator(() => crypto.createHash(\"md4\"), \"md4\");\n\t\tdefault:\n\t\t\tif (crypto === undefined) crypto = require(\"crypto\");\n\t\t\treturn new BulkUpdateDecorator(\n\t\t\t\t() => crypto.createHash(algorithm),\n\t\t\t\talgorithm\n\t\t\t);\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}