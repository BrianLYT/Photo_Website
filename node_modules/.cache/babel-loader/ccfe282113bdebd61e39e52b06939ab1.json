{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\"use strict\";\n\nconst {\n  constants\n} = require(\"buffer\");\n\nconst {\n  pipeline\n} = require(\"stream\");\n\nconst {\n  createBrotliCompress,\n  createBrotliDecompress,\n  createGzip,\n  createGunzip,\n  constants: zConstants\n} = require(\"zlib\");\n\nconst createHash = require(\"../util/createHash\");\n\nconst {\n  dirname,\n  join,\n  mkdirp\n} = require(\"../util/fs\");\n\nconst memoize = require(\"../util/memoize\");\n\nconst SerializerMiddleware = require(\"./SerializerMiddleware\");\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\n/** @typedef {import(\"./types\").BufferSerializableType} BufferSerializableType */\n\n/*\nFormat:\n\nFile -> Header Section*\n\nVersion -> u32\nAmountOfSections -> u32\nSectionSize -> i32 (if less than zero represents lazy value)\n\nHeader -> Version AmountOfSections SectionSize*\n\nBuffer -> n bytes\nSection -> Buffer\n\n*/\n// \"wpc\" + 1 in little-endian\n\n\nconst VERSION = 0x01637077;\nconst WRITE_LIMIT_TOTAL = 0x7fff0000;\nconst WRITE_LIMIT_CHUNK = 511 * 1024 * 1024;\n/**\n * @param {Buffer[]} buffers buffers\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} hash\n */\n\nconst hashForName = (buffers, hashFunction) => {\n  const hash = createHash(hashFunction);\n\n  for (const buf of buffers) hash.update(buf);\n\n  return (\n    /** @type {string} */\n    hash.digest(\"hex\")\n  );\n};\n\nconst COMPRESSION_CHUNK_SIZE = 100 * 1024 * 1024;\nconst DECOMPRESSION_CHUNK_SIZE = 100 * 1024 * 1024;\nconst writeUInt64LE = Buffer.prototype.writeBigUInt64LE ? (buf, value, offset) => {\n  buf.writeBigUInt64LE(BigInt(value), offset);\n} : (buf, value, offset) => {\n  const low = value % 0x100000000;\n  const high = (value - low) / 0x100000000;\n  buf.writeUInt32LE(low, offset);\n  buf.writeUInt32LE(high, offset + 4);\n};\nconst readUInt64LE = Buffer.prototype.readBigUInt64LE ? (buf, offset) => {\n  return Number(buf.readBigUInt64LE(offset));\n} : (buf, offset) => {\n  const low = buf.readUInt32LE(offset);\n  const high = buf.readUInt32LE(offset + 4);\n  return high * 0x100000000 + low;\n};\n/**\n * @typedef {Object} SerializeResult\n * @property {string | false} name\n * @property {number} size\n * @property {Promise=} backgroundJob\n */\n\n/**\n * @param {FileMiddleware} middleware this\n * @param {BufferSerializableType[] | Promise<BufferSerializableType[]>} data data to be serialized\n * @param {string | boolean} name file base name\n * @param {function(string | false, Buffer[], number): Promise<void>} writeFile writes a file\n * @param {string | Hash} hashFunction hash function to use\n * @returns {Promise<SerializeResult>} resulting file pointer and promise\n */\n\nconst serialize = async function (middleware, data, name, writeFile) {\n  let hashFunction = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"md4\";\n\n  /** @type {(Buffer[] | Buffer | SerializeResult | Promise<SerializeResult>)[]} */\n  const processedData = [];\n  /** @type {WeakMap<SerializeResult, function(): any | Promise<any>>} */\n\n  const resultToLazy = new WeakMap();\n  /** @type {Buffer[]} */\n\n  let lastBuffers = undefined;\n\n  for (const item of await data) {\n    if (typeof item === \"function\") {\n      if (!SerializerMiddleware.isLazy(item)) throw new Error(\"Unexpected function\");\n\n      if (!SerializerMiddleware.isLazy(item, middleware)) {\n        throw new Error(\"Unexpected lazy value with non-this target (can't pass through lazy values)\");\n      }\n\n      lastBuffers = undefined;\n      const serializedInfo = SerializerMiddleware.getLazySerializedValue(item);\n\n      if (serializedInfo) {\n        if (typeof serializedInfo === \"function\") {\n          throw new Error(\"Unexpected lazy value with non-this target (can't pass through lazy values)\");\n        } else {\n          processedData.push(serializedInfo);\n        }\n      } else {\n        const content = item();\n\n        if (content) {\n          const options = SerializerMiddleware.getLazyOptions(item);\n          processedData.push(serialize(middleware, content, options && options.name || true, writeFile, hashFunction).then(result => {\n            /** @type {any} */\n            item.options.size = result.size;\n            resultToLazy.set(result, item);\n            return result;\n          }));\n        } else {\n          throw new Error(\"Unexpected falsy value returned by lazy value function\");\n        }\n      }\n    } else if (item) {\n      if (lastBuffers) {\n        lastBuffers.push(item);\n      } else {\n        lastBuffers = [item];\n        processedData.push(lastBuffers);\n      }\n    } else {\n      throw new Error(\"Unexpected falsy value in items array\");\n    }\n  }\n  /** @type {Promise<any>[]} */\n\n\n  const backgroundJobs = [];\n  const resolvedData = (await Promise.all(\n  /** @type {Promise<Buffer[] | Buffer | SerializeResult>[]} */\n  processedData)).map(item => {\n    if (Array.isArray(item) || Buffer.isBuffer(item)) return item;\n    backgroundJobs.push(item.backgroundJob); // create pointer buffer from size and name\n\n    const name =\n    /** @type {string} */\n    item.name;\n    const nameBuffer = Buffer.from(name);\n    const buf = Buffer.allocUnsafe(8 + nameBuffer.length);\n    writeUInt64LE(buf, item.size, 0);\n    nameBuffer.copy(buf, 8, 0);\n    const lazy = resultToLazy.get(item);\n    SerializerMiddleware.setLazySerializedValue(lazy, buf);\n    return buf;\n  });\n  const lengths = [];\n\n  for (const item of resolvedData) {\n    if (Array.isArray(item)) {\n      let l = 0;\n\n      for (const b of item) l += b.length;\n\n      while (l > 0x7fffffff) {\n        lengths.push(0x7fffffff);\n        l -= 0x7fffffff;\n      }\n\n      lengths.push(l);\n    } else if (item) {\n      lengths.push(-item.length);\n    } else {\n      throw new Error(\"Unexpected falsy value in resolved data \" + item);\n    }\n  }\n\n  const header = Buffer.allocUnsafe(8 + lengths.length * 4);\n  header.writeUInt32LE(VERSION, 0);\n  header.writeUInt32LE(lengths.length, 4);\n\n  for (let i = 0; i < lengths.length; i++) {\n    header.writeInt32LE(lengths[i], 8 + i * 4);\n  }\n\n  const buf = [header];\n\n  for (const item of resolvedData) {\n    if (Array.isArray(item)) {\n      for (const b of item) buf.push(b);\n    } else if (item) {\n      buf.push(item);\n    }\n  }\n\n  if (name === true) {\n    name = hashForName(buf, hashFunction);\n  }\n\n  let size = 0;\n\n  for (const b of buf) size += b.length;\n\n  backgroundJobs.push(writeFile(name, buf, size));\n  return {\n    size,\n    name,\n    backgroundJob: backgroundJobs.length === 1 ? backgroundJobs[0] : Promise.all(backgroundJobs)\n  };\n};\n/**\n * @param {FileMiddleware} middleware this\n * @param {string | false} name filename\n * @param {function(string | false): Promise<Buffer[]>} readFile read content of a file\n * @returns {Promise<BufferSerializableType[]>} deserialized data\n */\n\n\nconst deserialize = async (middleware, name, readFile) => {\n  const contents = await readFile(name);\n  if (contents.length === 0) throw new Error(\"Empty file \" + name);\n  let contentsIndex = 0;\n  let contentItem = contents[0];\n  let contentItemLength = contentItem.length;\n  let contentPosition = 0;\n  if (contentItemLength === 0) throw new Error(\"Empty file \" + name);\n\n  const nextContent = () => {\n    contentsIndex++;\n    contentItem = contents[contentsIndex];\n    contentItemLength = contentItem.length;\n    contentPosition = 0;\n  };\n\n  const ensureData = n => {\n    if (contentPosition === contentItemLength) {\n      nextContent();\n    }\n\n    while (contentItemLength - contentPosition < n) {\n      const remaining = contentItem.slice(contentPosition);\n      let lengthFromNext = n - remaining.length;\n      const buffers = [remaining];\n\n      for (let i = contentsIndex + 1; i < contents.length; i++) {\n        const l = contents[i].length;\n\n        if (l > lengthFromNext) {\n          buffers.push(contents[i].slice(0, lengthFromNext));\n          contents[i] = contents[i].slice(lengthFromNext);\n          lengthFromNext = 0;\n          break;\n        } else {\n          buffers.push(contents[i]);\n          contentsIndex = i;\n          lengthFromNext -= l;\n        }\n      }\n\n      if (lengthFromNext > 0) throw new Error(\"Unexpected end of data\");\n      contentItem = Buffer.concat(buffers, n);\n      contentItemLength = n;\n      contentPosition = 0;\n    }\n  };\n\n  const readUInt32LE = () => {\n    ensureData(4);\n    const value = contentItem.readUInt32LE(contentPosition);\n    contentPosition += 4;\n    return value;\n  };\n\n  const readInt32LE = () => {\n    ensureData(4);\n    const value = contentItem.readInt32LE(contentPosition);\n    contentPosition += 4;\n    return value;\n  };\n\n  const readSlice = l => {\n    ensureData(l);\n\n    if (contentPosition === 0 && contentItemLength === l) {\n      const result = contentItem;\n\n      if (contentsIndex + 1 < contents.length) {\n        nextContent();\n      } else {\n        contentPosition = l;\n      }\n\n      return result;\n    }\n\n    const result = contentItem.slice(contentPosition, contentPosition + l);\n    contentPosition += l; // we clone the buffer here to allow the original content to be garbage collected\n\n    return l * 2 < contentItem.buffer.byteLength ? Buffer.from(result) : result;\n  };\n\n  const version = readUInt32LE();\n\n  if (version !== VERSION) {\n    throw new Error(\"Invalid file version\");\n  }\n\n  const sectionCount = readUInt32LE();\n  const lengths = [];\n  let lastLengthPositive = false;\n\n  for (let i = 0; i < sectionCount; i++) {\n    const value = readInt32LE();\n    const valuePositive = value >= 0;\n\n    if (lastLengthPositive && valuePositive) {\n      lengths[lengths.length - 1] += value;\n    } else {\n      lengths.push(value);\n      lastLengthPositive = valuePositive;\n    }\n  }\n\n  const result = [];\n\n  for (let length of lengths) {\n    if (length < 0) {\n      const slice = readSlice(-length);\n      const size = Number(readUInt64LE(slice, 0));\n      const nameBuffer = slice.slice(8);\n      const name = nameBuffer.toString();\n      result.push(SerializerMiddleware.createLazy(memoize(() => deserialize(middleware, name, readFile)), middleware, {\n        name,\n        size\n      }, slice));\n    } else {\n      if (contentPosition === contentItemLength) {\n        nextContent();\n      } else if (contentPosition !== 0) {\n        if (length <= contentItemLength - contentPosition) {\n          result.push(Buffer.from(contentItem.buffer, contentItem.byteOffset + contentPosition, length));\n          contentPosition += length;\n          length = 0;\n        } else {\n          const l = contentItemLength - contentPosition;\n          result.push(Buffer.from(contentItem.buffer, contentItem.byteOffset + contentPosition, l));\n          length -= l;\n          contentPosition = contentItemLength;\n        }\n      } else {\n        if (length >= contentItemLength) {\n          result.push(contentItem);\n          length -= contentItemLength;\n          contentPosition = contentItemLength;\n        } else {\n          result.push(Buffer.from(contentItem.buffer, contentItem.byteOffset, length));\n          contentPosition += length;\n          length = 0;\n        }\n      }\n\n      while (length > 0) {\n        nextContent();\n\n        if (length >= contentItemLength) {\n          result.push(contentItem);\n          length -= contentItemLength;\n          contentPosition = contentItemLength;\n        } else {\n          result.push(Buffer.from(contentItem.buffer, contentItem.byteOffset, length));\n          contentPosition += length;\n          length = 0;\n        }\n      }\n    }\n  }\n\n  return result;\n};\n/**\n * @typedef {BufferSerializableType[]} DeserializedType\n * @typedef {true} SerializedType\n * @extends {SerializerMiddleware<DeserializedType, SerializedType>}\n */\n\n\nclass FileMiddleware extends SerializerMiddleware {\n  /**\n   * @param {IntermediateFileSystem} fs filesystem\n   * @param {string | Hash} hashFunction hash function to use\n   */\n  constructor(fs) {\n    let hashFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"md4\";\n    super();\n    this.fs = fs;\n    this._hashFunction = hashFunction;\n  }\n  /**\n   * @param {DeserializedType} data data\n   * @param {Object} context context object\n   * @returns {SerializedType|Promise<SerializedType>} serialized data\n   */\n\n\n  serialize(data, context) {\n    const {\n      filename,\n      extension = \"\"\n    } = context;\n    return new Promise((resolve, reject) => {\n      mkdirp(this.fs, dirname(this.fs, filename), err => {\n        if (err) return reject(err); // It's important that we don't touch existing files during serialization\n        // because serialize may read existing files (when deserializing)\n\n        const allWrittenFiles = new Set();\n\n        const writeFile = async (name, content, size) => {\n          const file = name ? join(this.fs, filename, `../${name}${extension}`) : filename;\n          await new Promise((resolve, reject) => {\n            let stream = this.fs.createWriteStream(file + \"_\");\n            let compression;\n\n            if (file.endsWith(\".gz\")) {\n              compression = createGzip({\n                chunkSize: COMPRESSION_CHUNK_SIZE,\n                level: zConstants.Z_BEST_SPEED\n              });\n            } else if (file.endsWith(\".br\")) {\n              compression = createBrotliCompress({\n                chunkSize: COMPRESSION_CHUNK_SIZE,\n                params: {\n                  [zConstants.BROTLI_PARAM_MODE]: zConstants.BROTLI_MODE_TEXT,\n                  [zConstants.BROTLI_PARAM_QUALITY]: 2,\n                  [zConstants.BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING]: true,\n                  [zConstants.BROTLI_PARAM_SIZE_HINT]: size\n                }\n              });\n            }\n\n            if (compression) {\n              pipeline(compression, stream, reject);\n              stream = compression;\n              stream.on(\"finish\", () => resolve());\n            } else {\n              stream.on(\"error\", err => reject(err));\n              stream.on(\"finish\", () => resolve());\n            } // split into chunks for WRITE_LIMIT_CHUNK size\n\n\n            const chunks = [];\n\n            for (const b of content) {\n              if (b.length < WRITE_LIMIT_CHUNK) {\n                chunks.push(b);\n              } else {\n                for (let i = 0; i < b.length; i += WRITE_LIMIT_CHUNK) {\n                  chunks.push(b.slice(i, i + WRITE_LIMIT_CHUNK));\n                }\n              }\n            }\n\n            const len = chunks.length;\n            let i = 0;\n\n            const batchWrite = err => {\n              // will be handled in \"on\" error handler\n              if (err) return;\n\n              if (i === len) {\n                stream.end();\n                return;\n              } // queue up a batch of chunks up to the write limit\n              // end is exclusive\n\n\n              let end = i;\n              let sum = chunks[end++].length;\n\n              while (end < len) {\n                sum += chunks[end].length;\n                if (sum > WRITE_LIMIT_TOTAL) break;\n                end++;\n              }\n\n              while (i < end - 1) {\n                stream.write(chunks[i++]);\n              }\n\n              stream.write(chunks[i++], batchWrite);\n            };\n\n            batchWrite();\n          });\n          if (name) allWrittenFiles.add(file);\n        };\n\n        resolve(serialize(this, data, false, writeFile, this._hashFunction).then(async _ref => {\n          let {\n            backgroundJob\n          } = _ref;\n          await backgroundJob; // Rename the index file to disallow access during inconsistent file state\n\n          await new Promise(resolve => this.fs.rename(filename, filename + \".old\", err => {\n            resolve();\n          })); // update all written files\n\n          await Promise.all(Array.from(allWrittenFiles, file => new Promise((resolve, reject) => {\n            this.fs.rename(file + \"_\", file, err => {\n              if (err) return reject(err);\n              resolve();\n            });\n          }))); // As final step automatically update the index file to have a consistent pack again\n\n          await new Promise(resolve => {\n            this.fs.rename(filename + \"_\", filename, err => {\n              if (err) return reject(err);\n              resolve();\n            });\n          });\n          return (\n            /** @type {true} */\n            true\n          );\n        }));\n      });\n    });\n  }\n  /**\n   * @param {SerializedType} data data\n   * @param {Object} context context object\n   * @returns {DeserializedType|Promise<DeserializedType>} deserialized data\n   */\n\n\n  deserialize(data, context) {\n    const {\n      filename,\n      extension = \"\"\n    } = context;\n\n    const readFile = name => new Promise((resolve, reject) => {\n      const file = name ? join(this.fs, filename, `../${name}${extension}`) : filename;\n      this.fs.stat(file, (err, stats) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n\n        let remaining =\n        /** @type {number} */\n        stats.size;\n        let currentBuffer;\n        let currentBufferUsed;\n        const buf = [];\n        let decompression;\n\n        if (file.endsWith(\".gz\")) {\n          decompression = createGunzip({\n            chunkSize: DECOMPRESSION_CHUNK_SIZE\n          });\n        } else if (file.endsWith(\".br\")) {\n          decompression = createBrotliDecompress({\n            chunkSize: DECOMPRESSION_CHUNK_SIZE\n          });\n        }\n\n        if (decompression) {\n          let newResolve, newReject;\n          resolve(Promise.all([new Promise((rs, rj) => {\n            newResolve = rs;\n            newReject = rj;\n          }), new Promise((resolve, reject) => {\n            decompression.on(\"data\", chunk => buf.push(chunk));\n            decompression.on(\"end\", () => resolve());\n            decompression.on(\"error\", err => reject(err));\n          })]).then(() => buf));\n          resolve = newResolve;\n          reject = newReject;\n        }\n\n        this.fs.open(file, \"r\", (err, fd) => {\n          if (err) {\n            reject(err);\n            return;\n          }\n\n          const read = () => {\n            if (currentBuffer === undefined) {\n              currentBuffer = Buffer.allocUnsafeSlow(Math.min(constants.MAX_LENGTH, remaining, decompression ? DECOMPRESSION_CHUNK_SIZE : Infinity));\n              currentBufferUsed = 0;\n            }\n\n            let readBuffer = currentBuffer;\n            let readOffset = currentBufferUsed;\n            let readLength = currentBuffer.length - currentBufferUsed; // values passed to fs.read must be valid int32 values\n\n            if (readOffset > 0x7fffffff) {\n              readBuffer = currentBuffer.slice(readOffset);\n              readOffset = 0;\n            }\n\n            if (readLength > 0x7fffffff) {\n              readLength = 0x7fffffff;\n            }\n\n            this.fs.read(fd, readBuffer, readOffset, readLength, null, (err, bytesRead) => {\n              if (err) {\n                this.fs.close(fd, () => {\n                  reject(err);\n                });\n                return;\n              }\n\n              currentBufferUsed += bytesRead;\n              remaining -= bytesRead;\n\n              if (currentBufferUsed === currentBuffer.length) {\n                if (decompression) {\n                  decompression.write(currentBuffer);\n                } else {\n                  buf.push(currentBuffer);\n                }\n\n                currentBuffer = undefined;\n\n                if (remaining === 0) {\n                  if (decompression) {\n                    decompression.end();\n                  }\n\n                  this.fs.close(fd, err => {\n                    if (err) {\n                      reject(err);\n                      return;\n                    }\n\n                    resolve(buf);\n                  });\n                  return;\n                }\n              }\n\n              read();\n            });\n          };\n\n          read();\n        });\n      });\n    });\n\n    return deserialize(this, false, readFile);\n  }\n\n}\n\nmodule.exports = FileMiddleware;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/serialization/FileMiddleware.js"],"names":["constants","require","pipeline","createBrotliCompress","createBrotliDecompress","createGzip","createGunzip","zConstants","createHash","dirname","join","mkdirp","memoize","SerializerMiddleware","VERSION","WRITE_LIMIT_TOTAL","WRITE_LIMIT_CHUNK","hashForName","buffers","hashFunction","hash","buf","update","digest","COMPRESSION_CHUNK_SIZE","DECOMPRESSION_CHUNK_SIZE","writeUInt64LE","Buffer","prototype","writeBigUInt64LE","value","offset","BigInt","low","high","writeUInt32LE","readUInt64LE","readBigUInt64LE","Number","readUInt32LE","serialize","middleware","data","name","writeFile","processedData","resultToLazy","WeakMap","lastBuffers","undefined","item","isLazy","Error","serializedInfo","getLazySerializedValue","push","content","options","getLazyOptions","then","result","size","set","backgroundJobs","resolvedData","Promise","all","map","Array","isArray","isBuffer","backgroundJob","nameBuffer","from","allocUnsafe","length","copy","lazy","get","setLazySerializedValue","lengths","l","b","header","i","writeInt32LE","deserialize","readFile","contents","contentsIndex","contentItem","contentItemLength","contentPosition","nextContent","ensureData","n","remaining","slice","lengthFromNext","concat","readInt32LE","readSlice","buffer","byteLength","version","sectionCount","lastLengthPositive","valuePositive","toString","createLazy","byteOffset","FileMiddleware","constructor","fs","_hashFunction","context","filename","extension","resolve","reject","err","allWrittenFiles","Set","file","stream","createWriteStream","compression","endsWith","chunkSize","level","Z_BEST_SPEED","params","BROTLI_PARAM_MODE","BROTLI_MODE_TEXT","BROTLI_PARAM_QUALITY","BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING","BROTLI_PARAM_SIZE_HINT","on","chunks","len","batchWrite","end","sum","write","add","rename","stat","stats","currentBuffer","currentBufferUsed","decompression","newResolve","newReject","rs","rj","chunk","open","fd","read","allocUnsafeSlow","Math","min","MAX_LENGTH","Infinity","readBuffer","readOffset","readLength","bytesRead","close","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst { constants } = require(\"buffer\");\nconst { pipeline } = require(\"stream\");\nconst {\n\tcreateBrotliCompress,\n\tcreateBrotliDecompress,\n\tcreateGzip,\n\tcreateGunzip,\n\tconstants: zConstants\n} = require(\"zlib\");\nconst createHash = require(\"../util/createHash\");\nconst { dirname, join, mkdirp } = require(\"../util/fs\");\nconst memoize = require(\"../util/memoize\");\nconst SerializerMiddleware = require(\"./SerializerMiddleware\");\n\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n/** @typedef {import(\"./types\").BufferSerializableType} BufferSerializableType */\n\n/*\nFormat:\n\nFile -> Header Section*\n\nVersion -> u32\nAmountOfSections -> u32\nSectionSize -> i32 (if less than zero represents lazy value)\n\nHeader -> Version AmountOfSections SectionSize*\n\nBuffer -> n bytes\nSection -> Buffer\n\n*/\n\n// \"wpc\" + 1 in little-endian\nconst VERSION = 0x01637077;\nconst WRITE_LIMIT_TOTAL = 0x7fff0000;\nconst WRITE_LIMIT_CHUNK = 511 * 1024 * 1024;\n\n/**\n * @param {Buffer[]} buffers buffers\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} hash\n */\nconst hashForName = (buffers, hashFunction) => {\n\tconst hash = createHash(hashFunction);\n\tfor (const buf of buffers) hash.update(buf);\n\treturn /** @type {string} */ (hash.digest(\"hex\"));\n};\n\nconst COMPRESSION_CHUNK_SIZE = 100 * 1024 * 1024;\nconst DECOMPRESSION_CHUNK_SIZE = 100 * 1024 * 1024;\n\nconst writeUInt64LE = Buffer.prototype.writeBigUInt64LE\n\t? (buf, value, offset) => {\n\t\t\tbuf.writeBigUInt64LE(BigInt(value), offset);\n\t  }\n\t: (buf, value, offset) => {\n\t\t\tconst low = value % 0x100000000;\n\t\t\tconst high = (value - low) / 0x100000000;\n\t\t\tbuf.writeUInt32LE(low, offset);\n\t\t\tbuf.writeUInt32LE(high, offset + 4);\n\t  };\n\nconst readUInt64LE = Buffer.prototype.readBigUInt64LE\n\t? (buf, offset) => {\n\t\t\treturn Number(buf.readBigUInt64LE(offset));\n\t  }\n\t: (buf, offset) => {\n\t\t\tconst low = buf.readUInt32LE(offset);\n\t\t\tconst high = buf.readUInt32LE(offset + 4);\n\t\t\treturn high * 0x100000000 + low;\n\t  };\n\n/**\n * @typedef {Object} SerializeResult\n * @property {string | false} name\n * @property {number} size\n * @property {Promise=} backgroundJob\n */\n\n/**\n * @param {FileMiddleware} middleware this\n * @param {BufferSerializableType[] | Promise<BufferSerializableType[]>} data data to be serialized\n * @param {string | boolean} name file base name\n * @param {function(string | false, Buffer[], number): Promise<void>} writeFile writes a file\n * @param {string | Hash} hashFunction hash function to use\n * @returns {Promise<SerializeResult>} resulting file pointer and promise\n */\nconst serialize = async (\n\tmiddleware,\n\tdata,\n\tname,\n\twriteFile,\n\thashFunction = \"md4\"\n) => {\n\t/** @type {(Buffer[] | Buffer | SerializeResult | Promise<SerializeResult>)[]} */\n\tconst processedData = [];\n\t/** @type {WeakMap<SerializeResult, function(): any | Promise<any>>} */\n\tconst resultToLazy = new WeakMap();\n\t/** @type {Buffer[]} */\n\tlet lastBuffers = undefined;\n\tfor (const item of await data) {\n\t\tif (typeof item === \"function\") {\n\t\t\tif (!SerializerMiddleware.isLazy(item))\n\t\t\t\tthrow new Error(\"Unexpected function\");\n\t\t\tif (!SerializerMiddleware.isLazy(item, middleware)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Unexpected lazy value with non-this target (can't pass through lazy values)\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tlastBuffers = undefined;\n\t\t\tconst serializedInfo = SerializerMiddleware.getLazySerializedValue(item);\n\t\t\tif (serializedInfo) {\n\t\t\t\tif (typeof serializedInfo === \"function\") {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\"Unexpected lazy value with non-this target (can't pass through lazy values)\"\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tprocessedData.push(serializedInfo);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst content = item();\n\t\t\t\tif (content) {\n\t\t\t\t\tconst options = SerializerMiddleware.getLazyOptions(item);\n\t\t\t\t\tprocessedData.push(\n\t\t\t\t\t\tserialize(\n\t\t\t\t\t\t\tmiddleware,\n\t\t\t\t\t\t\tcontent,\n\t\t\t\t\t\t\t(options && options.name) || true,\n\t\t\t\t\t\t\twriteFile,\n\t\t\t\t\t\t\thashFunction\n\t\t\t\t\t\t).then(result => {\n\t\t\t\t\t\t\t/** @type {any} */ (item).options.size = result.size;\n\t\t\t\t\t\t\tresultToLazy.set(result, item);\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\"Unexpected falsy value returned by lazy value function\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (item) {\n\t\t\tif (lastBuffers) {\n\t\t\t\tlastBuffers.push(item);\n\t\t\t} else {\n\t\t\t\tlastBuffers = [item];\n\t\t\t\tprocessedData.push(lastBuffers);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(\"Unexpected falsy value in items array\");\n\t\t}\n\t}\n\t/** @type {Promise<any>[]} */\n\tconst backgroundJobs = [];\n\tconst resolvedData = (\n\t\tawait Promise.all(\n\t\t\t/** @type {Promise<Buffer[] | Buffer | SerializeResult>[]} */ (\n\t\t\t\tprocessedData\n\t\t\t)\n\t\t)\n\t).map(item => {\n\t\tif (Array.isArray(item) || Buffer.isBuffer(item)) return item;\n\n\t\tbackgroundJobs.push(item.backgroundJob);\n\t\t// create pointer buffer from size and name\n\t\tconst name = /** @type {string} */ (item.name);\n\t\tconst nameBuffer = Buffer.from(name);\n\t\tconst buf = Buffer.allocUnsafe(8 + nameBuffer.length);\n\t\twriteUInt64LE(buf, item.size, 0);\n\t\tnameBuffer.copy(buf, 8, 0);\n\t\tconst lazy = resultToLazy.get(item);\n\t\tSerializerMiddleware.setLazySerializedValue(lazy, buf);\n\t\treturn buf;\n\t});\n\tconst lengths = [];\n\tfor (const item of resolvedData) {\n\t\tif (Array.isArray(item)) {\n\t\t\tlet l = 0;\n\t\t\tfor (const b of item) l += b.length;\n\t\t\twhile (l > 0x7fffffff) {\n\t\t\t\tlengths.push(0x7fffffff);\n\t\t\t\tl -= 0x7fffffff;\n\t\t\t}\n\t\t\tlengths.push(l);\n\t\t} else if (item) {\n\t\t\tlengths.push(-item.length);\n\t\t} else {\n\t\t\tthrow new Error(\"Unexpected falsy value in resolved data \" + item);\n\t\t}\n\t}\n\tconst header = Buffer.allocUnsafe(8 + lengths.length * 4);\n\theader.writeUInt32LE(VERSION, 0);\n\theader.writeUInt32LE(lengths.length, 4);\n\tfor (let i = 0; i < lengths.length; i++) {\n\t\theader.writeInt32LE(lengths[i], 8 + i * 4);\n\t}\n\tconst buf = [header];\n\tfor (const item of resolvedData) {\n\t\tif (Array.isArray(item)) {\n\t\t\tfor (const b of item) buf.push(b);\n\t\t} else if (item) {\n\t\t\tbuf.push(item);\n\t\t}\n\t}\n\tif (name === true) {\n\t\tname = hashForName(buf, hashFunction);\n\t}\n\tlet size = 0;\n\tfor (const b of buf) size += b.length;\n\tbackgroundJobs.push(writeFile(name, buf, size));\n\treturn {\n\t\tsize,\n\t\tname,\n\t\tbackgroundJob:\n\t\t\tbackgroundJobs.length === 1\n\t\t\t\t? backgroundJobs[0]\n\t\t\t\t: Promise.all(backgroundJobs)\n\t};\n};\n\n/**\n * @param {FileMiddleware} middleware this\n * @param {string | false} name filename\n * @param {function(string | false): Promise<Buffer[]>} readFile read content of a file\n * @returns {Promise<BufferSerializableType[]>} deserialized data\n */\nconst deserialize = async (middleware, name, readFile) => {\n\tconst contents = await readFile(name);\n\tif (contents.length === 0) throw new Error(\"Empty file \" + name);\n\tlet contentsIndex = 0;\n\tlet contentItem = contents[0];\n\tlet contentItemLength = contentItem.length;\n\tlet contentPosition = 0;\n\tif (contentItemLength === 0) throw new Error(\"Empty file \" + name);\n\tconst nextContent = () => {\n\t\tcontentsIndex++;\n\t\tcontentItem = contents[contentsIndex];\n\t\tcontentItemLength = contentItem.length;\n\t\tcontentPosition = 0;\n\t};\n\tconst ensureData = n => {\n\t\tif (contentPosition === contentItemLength) {\n\t\t\tnextContent();\n\t\t}\n\t\twhile (contentItemLength - contentPosition < n) {\n\t\t\tconst remaining = contentItem.slice(contentPosition);\n\t\t\tlet lengthFromNext = n - remaining.length;\n\t\t\tconst buffers = [remaining];\n\t\t\tfor (let i = contentsIndex + 1; i < contents.length; i++) {\n\t\t\t\tconst l = contents[i].length;\n\t\t\t\tif (l > lengthFromNext) {\n\t\t\t\t\tbuffers.push(contents[i].slice(0, lengthFromNext));\n\t\t\t\t\tcontents[i] = contents[i].slice(lengthFromNext);\n\t\t\t\t\tlengthFromNext = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tbuffers.push(contents[i]);\n\t\t\t\t\tcontentsIndex = i;\n\t\t\t\t\tlengthFromNext -= l;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lengthFromNext > 0) throw new Error(\"Unexpected end of data\");\n\t\t\tcontentItem = Buffer.concat(buffers, n);\n\t\t\tcontentItemLength = n;\n\t\t\tcontentPosition = 0;\n\t\t}\n\t};\n\tconst readUInt32LE = () => {\n\t\tensureData(4);\n\t\tconst value = contentItem.readUInt32LE(contentPosition);\n\t\tcontentPosition += 4;\n\t\treturn value;\n\t};\n\tconst readInt32LE = () => {\n\t\tensureData(4);\n\t\tconst value = contentItem.readInt32LE(contentPosition);\n\t\tcontentPosition += 4;\n\t\treturn value;\n\t};\n\tconst readSlice = l => {\n\t\tensureData(l);\n\t\tif (contentPosition === 0 && contentItemLength === l) {\n\t\t\tconst result = contentItem;\n\t\t\tif (contentsIndex + 1 < contents.length) {\n\t\t\t\tnextContent();\n\t\t\t} else {\n\t\t\t\tcontentPosition = l;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tconst result = contentItem.slice(contentPosition, contentPosition + l);\n\t\tcontentPosition += l;\n\t\t// we clone the buffer here to allow the original content to be garbage collected\n\t\treturn l * 2 < contentItem.buffer.byteLength ? Buffer.from(result) : result;\n\t};\n\tconst version = readUInt32LE();\n\tif (version !== VERSION) {\n\t\tthrow new Error(\"Invalid file version\");\n\t}\n\tconst sectionCount = readUInt32LE();\n\tconst lengths = [];\n\tlet lastLengthPositive = false;\n\tfor (let i = 0; i < sectionCount; i++) {\n\t\tconst value = readInt32LE();\n\t\tconst valuePositive = value >= 0;\n\t\tif (lastLengthPositive && valuePositive) {\n\t\t\tlengths[lengths.length - 1] += value;\n\t\t} else {\n\t\t\tlengths.push(value);\n\t\t\tlastLengthPositive = valuePositive;\n\t\t}\n\t}\n\tconst result = [];\n\tfor (let length of lengths) {\n\t\tif (length < 0) {\n\t\t\tconst slice = readSlice(-length);\n\t\t\tconst size = Number(readUInt64LE(slice, 0));\n\t\t\tconst nameBuffer = slice.slice(8);\n\t\t\tconst name = nameBuffer.toString();\n\t\t\tresult.push(\n\t\t\t\tSerializerMiddleware.createLazy(\n\t\t\t\t\tmemoize(() => deserialize(middleware, name, readFile)),\n\t\t\t\t\tmiddleware,\n\t\t\t\t\t{\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tsize\n\t\t\t\t\t},\n\t\t\t\t\tslice\n\t\t\t\t)\n\t\t\t);\n\t\t} else {\n\t\t\tif (contentPosition === contentItemLength) {\n\t\t\t\tnextContent();\n\t\t\t} else if (contentPosition !== 0) {\n\t\t\t\tif (length <= contentItemLength - contentPosition) {\n\t\t\t\t\tresult.push(\n\t\t\t\t\t\tBuffer.from(\n\t\t\t\t\t\t\tcontentItem.buffer,\n\t\t\t\t\t\t\tcontentItem.byteOffset + contentPosition,\n\t\t\t\t\t\t\tlength\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\tcontentPosition += length;\n\t\t\t\t\tlength = 0;\n\t\t\t\t} else {\n\t\t\t\t\tconst l = contentItemLength - contentPosition;\n\t\t\t\t\tresult.push(\n\t\t\t\t\t\tBuffer.from(\n\t\t\t\t\t\t\tcontentItem.buffer,\n\t\t\t\t\t\t\tcontentItem.byteOffset + contentPosition,\n\t\t\t\t\t\t\tl\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\tlength -= l;\n\t\t\t\t\tcontentPosition = contentItemLength;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (length >= contentItemLength) {\n\t\t\t\t\tresult.push(contentItem);\n\t\t\t\t\tlength -= contentItemLength;\n\t\t\t\t\tcontentPosition = contentItemLength;\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(\n\t\t\t\t\t\tBuffer.from(contentItem.buffer, contentItem.byteOffset, length)\n\t\t\t\t\t);\n\t\t\t\t\tcontentPosition += length;\n\t\t\t\t\tlength = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (length > 0) {\n\t\t\t\tnextContent();\n\t\t\t\tif (length >= contentItemLength) {\n\t\t\t\t\tresult.push(contentItem);\n\t\t\t\t\tlength -= contentItemLength;\n\t\t\t\t\tcontentPosition = contentItemLength;\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(\n\t\t\t\t\t\tBuffer.from(contentItem.buffer, contentItem.byteOffset, length)\n\t\t\t\t\t);\n\t\t\t\t\tcontentPosition += length;\n\t\t\t\t\tlength = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n};\n\n/**\n * @typedef {BufferSerializableType[]} DeserializedType\n * @typedef {true} SerializedType\n * @extends {SerializerMiddleware<DeserializedType, SerializedType>}\n */\nclass FileMiddleware extends SerializerMiddleware {\n\t/**\n\t * @param {IntermediateFileSystem} fs filesystem\n\t * @param {string | Hash} hashFunction hash function to use\n\t */\n\tconstructor(fs, hashFunction = \"md4\") {\n\t\tsuper();\n\t\tthis.fs = fs;\n\t\tthis._hashFunction = hashFunction;\n\t}\n\t/**\n\t * @param {DeserializedType} data data\n\t * @param {Object} context context object\n\t * @returns {SerializedType|Promise<SerializedType>} serialized data\n\t */\n\tserialize(data, context) {\n\t\tconst { filename, extension = \"\" } = context;\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tmkdirp(this.fs, dirname(this.fs, filename), err => {\n\t\t\t\tif (err) return reject(err);\n\n\t\t\t\t// It's important that we don't touch existing files during serialization\n\t\t\t\t// because serialize may read existing files (when deserializing)\n\t\t\t\tconst allWrittenFiles = new Set();\n\t\t\t\tconst writeFile = async (name, content, size) => {\n\t\t\t\t\tconst file = name\n\t\t\t\t\t\t? join(this.fs, filename, `../${name}${extension}`)\n\t\t\t\t\t\t: filename;\n\t\t\t\t\tawait new Promise((resolve, reject) => {\n\t\t\t\t\t\tlet stream = this.fs.createWriteStream(file + \"_\");\n\t\t\t\t\t\tlet compression;\n\t\t\t\t\t\tif (file.endsWith(\".gz\")) {\n\t\t\t\t\t\t\tcompression = createGzip({\n\t\t\t\t\t\t\t\tchunkSize: COMPRESSION_CHUNK_SIZE,\n\t\t\t\t\t\t\t\tlevel: zConstants.Z_BEST_SPEED\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else if (file.endsWith(\".br\")) {\n\t\t\t\t\t\t\tcompression = createBrotliCompress({\n\t\t\t\t\t\t\t\tchunkSize: COMPRESSION_CHUNK_SIZE,\n\t\t\t\t\t\t\t\tparams: {\n\t\t\t\t\t\t\t\t\t[zConstants.BROTLI_PARAM_MODE]: zConstants.BROTLI_MODE_TEXT,\n\t\t\t\t\t\t\t\t\t[zConstants.BROTLI_PARAM_QUALITY]: 2,\n\t\t\t\t\t\t\t\t\t[zConstants.BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING]: true,\n\t\t\t\t\t\t\t\t\t[zConstants.BROTLI_PARAM_SIZE_HINT]: size\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (compression) {\n\t\t\t\t\t\t\tpipeline(compression, stream, reject);\n\t\t\t\t\t\t\tstream = compression;\n\t\t\t\t\t\t\tstream.on(\"finish\", () => resolve());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstream.on(\"error\", err => reject(err));\n\t\t\t\t\t\t\tstream.on(\"finish\", () => resolve());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// split into chunks for WRITE_LIMIT_CHUNK size\n\t\t\t\t\t\tconst chunks = [];\n\t\t\t\t\t\tfor (const b of content) {\n\t\t\t\t\t\t\tif (b.length < WRITE_LIMIT_CHUNK) {\n\t\t\t\t\t\t\t\tchunks.push(b);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < b.length; i += WRITE_LIMIT_CHUNK) {\n\t\t\t\t\t\t\t\t\tchunks.push(b.slice(i, i + WRITE_LIMIT_CHUNK));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst len = chunks.length;\n\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\tconst batchWrite = err => {\n\t\t\t\t\t\t\t// will be handled in \"on\" error handler\n\t\t\t\t\t\t\tif (err) return;\n\n\t\t\t\t\t\t\tif (i === len) {\n\t\t\t\t\t\t\t\tstream.end();\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// queue up a batch of chunks up to the write limit\n\t\t\t\t\t\t\t// end is exclusive\n\t\t\t\t\t\t\tlet end = i;\n\t\t\t\t\t\t\tlet sum = chunks[end++].length;\n\t\t\t\t\t\t\twhile (end < len) {\n\t\t\t\t\t\t\t\tsum += chunks[end].length;\n\t\t\t\t\t\t\t\tif (sum > WRITE_LIMIT_TOTAL) break;\n\t\t\t\t\t\t\t\tend++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhile (i < end - 1) {\n\t\t\t\t\t\t\t\tstream.write(chunks[i++]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstream.write(chunks[i++], batchWrite);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbatchWrite();\n\t\t\t\t\t});\n\t\t\t\t\tif (name) allWrittenFiles.add(file);\n\t\t\t\t};\n\n\t\t\t\tresolve(\n\t\t\t\t\tserialize(this, data, false, writeFile, this._hashFunction).then(\n\t\t\t\t\t\tasync ({ backgroundJob }) => {\n\t\t\t\t\t\t\tawait backgroundJob;\n\n\t\t\t\t\t\t\t// Rename the index file to disallow access during inconsistent file state\n\t\t\t\t\t\t\tawait new Promise(resolve =>\n\t\t\t\t\t\t\t\tthis.fs.rename(filename, filename + \".old\", err => {\n\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// update all written files\n\t\t\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\t\t\tArray.from(\n\t\t\t\t\t\t\t\t\tallWrittenFiles,\n\t\t\t\t\t\t\t\t\tfile =>\n\t\t\t\t\t\t\t\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\t\t\t\t\t\t\t\tthis.fs.rename(file + \"_\", file, err => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (err) return reject(err);\n\t\t\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// As final step automatically update the index file to have a consistent pack again\n\t\t\t\t\t\t\tawait new Promise(resolve => {\n\t\t\t\t\t\t\t\tthis.fs.rename(filename + \"_\", filename, err => {\n\t\t\t\t\t\t\t\t\tif (err) return reject(err);\n\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn /** @type {true} */ (true);\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @param {SerializedType} data data\n\t * @param {Object} context context object\n\t * @returns {DeserializedType|Promise<DeserializedType>} deserialized data\n\t */\n\tdeserialize(data, context) {\n\t\tconst { filename, extension = \"\" } = context;\n\t\tconst readFile = name =>\n\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\tconst file = name\n\t\t\t\t\t? join(this.fs, filename, `../${name}${extension}`)\n\t\t\t\t\t: filename;\n\t\t\t\tthis.fs.stat(file, (err, stats) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tlet remaining = /** @type {number} */ (stats.size);\n\t\t\t\t\tlet currentBuffer;\n\t\t\t\t\tlet currentBufferUsed;\n\t\t\t\t\tconst buf = [];\n\t\t\t\t\tlet decompression;\n\t\t\t\t\tif (file.endsWith(\".gz\")) {\n\t\t\t\t\t\tdecompression = createGunzip({\n\t\t\t\t\t\t\tchunkSize: DECOMPRESSION_CHUNK_SIZE\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (file.endsWith(\".br\")) {\n\t\t\t\t\t\tdecompression = createBrotliDecompress({\n\t\t\t\t\t\t\tchunkSize: DECOMPRESSION_CHUNK_SIZE\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif (decompression) {\n\t\t\t\t\t\tlet newResolve, newReject;\n\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\tPromise.all([\n\t\t\t\t\t\t\t\tnew Promise((rs, rj) => {\n\t\t\t\t\t\t\t\t\tnewResolve = rs;\n\t\t\t\t\t\t\t\t\tnewReject = rj;\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\t\t\t\t\t\tdecompression.on(\"data\", chunk => buf.push(chunk));\n\t\t\t\t\t\t\t\t\tdecompression.on(\"end\", () => resolve());\n\t\t\t\t\t\t\t\t\tdecompression.on(\"error\", err => reject(err));\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t]).then(() => buf)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tresolve = newResolve;\n\t\t\t\t\t\treject = newReject;\n\t\t\t\t\t}\n\t\t\t\t\tthis.fs.open(file, \"r\", (err, fd) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst read = () => {\n\t\t\t\t\t\t\tif (currentBuffer === undefined) {\n\t\t\t\t\t\t\t\tcurrentBuffer = Buffer.allocUnsafeSlow(\n\t\t\t\t\t\t\t\t\tMath.min(\n\t\t\t\t\t\t\t\t\t\tconstants.MAX_LENGTH,\n\t\t\t\t\t\t\t\t\t\tremaining,\n\t\t\t\t\t\t\t\t\t\tdecompression ? DECOMPRESSION_CHUNK_SIZE : Infinity\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcurrentBufferUsed = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet readBuffer = currentBuffer;\n\t\t\t\t\t\t\tlet readOffset = currentBufferUsed;\n\t\t\t\t\t\t\tlet readLength = currentBuffer.length - currentBufferUsed;\n\t\t\t\t\t\t\t// values passed to fs.read must be valid int32 values\n\t\t\t\t\t\t\tif (readOffset > 0x7fffffff) {\n\t\t\t\t\t\t\t\treadBuffer = currentBuffer.slice(readOffset);\n\t\t\t\t\t\t\t\treadOffset = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (readLength > 0x7fffffff) {\n\t\t\t\t\t\t\t\treadLength = 0x7fffffff;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.fs.read(\n\t\t\t\t\t\t\t\tfd,\n\t\t\t\t\t\t\t\treadBuffer,\n\t\t\t\t\t\t\t\treadOffset,\n\t\t\t\t\t\t\t\treadLength,\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t(err, bytesRead) => {\n\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\tthis.fs.close(fd, () => {\n\t\t\t\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcurrentBufferUsed += bytesRead;\n\t\t\t\t\t\t\t\t\tremaining -= bytesRead;\n\t\t\t\t\t\t\t\t\tif (currentBufferUsed === currentBuffer.length) {\n\t\t\t\t\t\t\t\t\t\tif (decompression) {\n\t\t\t\t\t\t\t\t\t\t\tdecompression.write(currentBuffer);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tbuf.push(currentBuffer);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcurrentBuffer = undefined;\n\t\t\t\t\t\t\t\t\t\tif (remaining === 0) {\n\t\t\t\t\t\t\t\t\t\t\tif (decompression) {\n\t\t\t\t\t\t\t\t\t\t\t\tdecompression.end();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tthis.fs.close(fd, err => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tresolve(buf);\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tread();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tread();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\treturn deserialize(this, false, readFile);\n\t}\n}\n\nmodule.exports = FileMiddleware;\n"]},"metadata":{},"sourceType":"script"}