{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  SyncHook,\n  AsyncSeriesHook\n} = require(\"tapable\");\n\nconst {\n  makeWebpackError\n} = require(\"../HookWebpackError\");\n\nconst WebpackError = require(\"../WebpackError\");\n\nconst ArrayQueue = require(\"./ArrayQueue\");\n\nconst QUEUED_STATE = 0;\nconst PROCESSING_STATE = 1;\nconst DONE_STATE = 2;\nlet inHandleResult = 0;\n/**\n * @template T\n * @callback Callback\n * @param {(WebpackError | null)=} err\n * @param {T=} result\n */\n\n/**\n * @template T\n * @template K\n * @template R\n */\n\nclass AsyncQueueEntry {\n  /**\n   * @param {T} item the item\n   * @param {Callback<R>} callback the callback\n   */\n  constructor(item, callback) {\n    this.item = item;\n    /** @type {typeof QUEUED_STATE | typeof PROCESSING_STATE | typeof DONE_STATE} */\n\n    this.state = QUEUED_STATE;\n    this.callback = callback;\n    /** @type {Callback<R>[] | undefined} */\n\n    this.callbacks = undefined;\n    this.result = undefined;\n    /** @type {WebpackError | undefined} */\n\n    this.error = undefined;\n  }\n\n}\n/**\n * @template T\n * @template K\n * @template R\n */\n\n\nclass AsyncQueue {\n  /**\n   * @param {Object} options options object\n   * @param {string=} options.name name of the queue\n   * @param {number=} options.parallelism how many items should be processed at once\n   * @param {AsyncQueue<any, any, any>=} options.parent parent queue, which will have priority over this queue and with shared parallelism\n   * @param {function(T): K=} options.getKey extract key from item\n   * @param {function(T, Callback<R>): void} options.processor async function to process items\n   */\n  constructor(_ref) {\n    let {\n      name,\n      parallelism,\n      parent,\n      processor,\n      getKey\n    } = _ref;\n    this._name = name;\n    this._parallelism = parallelism || 1;\n    this._processor = processor;\n\n    this._getKey = getKey || (\n    /** @type {(T) => K} */\n    item =>\n    /** @type {any} */\n    item);\n    /** @type {Map<K, AsyncQueueEntry<T, K, R>>} */\n\n\n    this._entries = new Map();\n    /** @type {ArrayQueue<AsyncQueueEntry<T, K, R>>} */\n\n    this._queued = new ArrayQueue();\n    /** @type {AsyncQueue<any, any, any>[]} */\n\n    this._children = undefined;\n    this._activeTasks = 0;\n    this._willEnsureProcessing = false;\n    this._needProcessing = false;\n    this._stopped = false;\n    this._root = parent ? parent._root : this;\n\n    if (parent) {\n      if (this._root._children === undefined) {\n        this._root._children = [this];\n      } else {\n        this._root._children.push(this);\n      }\n    }\n\n    this.hooks = {\n      /** @type {AsyncSeriesHook<[T]>} */\n      beforeAdd: new AsyncSeriesHook([\"item\"]),\n\n      /** @type {SyncHook<[T]>} */\n      added: new SyncHook([\"item\"]),\n\n      /** @type {AsyncSeriesHook<[T]>} */\n      beforeStart: new AsyncSeriesHook([\"item\"]),\n\n      /** @type {SyncHook<[T]>} */\n      started: new SyncHook([\"item\"]),\n\n      /** @type {SyncHook<[T, Error, R]>} */\n      result: new SyncHook([\"item\", \"error\", \"result\"])\n    };\n    this._ensureProcessing = this._ensureProcessing.bind(this);\n  }\n  /**\n   * @param {T} item an item\n   * @param {Callback<R>} callback callback function\n   * @returns {void}\n   */\n\n\n  add(item, callback) {\n    if (this._stopped) return callback(new WebpackError(\"Queue was stopped\"));\n    this.hooks.beforeAdd.callAsync(item, err => {\n      if (err) {\n        callback(makeWebpackError(err, `AsyncQueue(${this._name}).hooks.beforeAdd`));\n        return;\n      }\n\n      const key = this._getKey(item);\n\n      const entry = this._entries.get(key);\n\n      if (entry !== undefined) {\n        if (entry.state === DONE_STATE) {\n          if (inHandleResult++ > 3) {\n            process.nextTick(() => callback(entry.error, entry.result));\n          } else {\n            callback(entry.error, entry.result);\n          }\n\n          inHandleResult--;\n        } else if (entry.callbacks === undefined) {\n          entry.callbacks = [callback];\n        } else {\n          entry.callbacks.push(callback);\n        }\n\n        return;\n      }\n\n      const newEntry = new AsyncQueueEntry(item, callback);\n\n      if (this._stopped) {\n        this.hooks.added.call(item);\n        this._root._activeTasks++;\n        process.nextTick(() => this._handleResult(newEntry, new WebpackError(\"Queue was stopped\")));\n      } else {\n        this._entries.set(key, newEntry);\n\n        this._queued.enqueue(newEntry);\n\n        const root = this._root;\n        root._needProcessing = true;\n\n        if (root._willEnsureProcessing === false) {\n          root._willEnsureProcessing = true;\n          setImmediate(root._ensureProcessing);\n        }\n\n        this.hooks.added.call(item);\n      }\n    });\n  }\n  /**\n   * @param {T} item an item\n   * @returns {void}\n   */\n\n\n  invalidate(item) {\n    const key = this._getKey(item);\n\n    const entry = this._entries.get(key);\n\n    this._entries.delete(key);\n\n    if (entry.state === QUEUED_STATE) {\n      this._queued.delete(entry);\n    }\n  }\n  /**\n   * Waits for an already started item\n   * @param {T} item an item\n   * @param {Callback<R>} callback callback function\n   * @returns {void}\n   */\n\n\n  waitFor(item, callback) {\n    const key = this._getKey(item);\n\n    const entry = this._entries.get(key);\n\n    if (entry === undefined) {\n      return callback(new WebpackError(\"waitFor can only be called for an already started item\"));\n    }\n\n    if (entry.state === DONE_STATE) {\n      process.nextTick(() => callback(entry.error, entry.result));\n    } else if (entry.callbacks === undefined) {\n      entry.callbacks = [callback];\n    } else {\n      entry.callbacks.push(callback);\n    }\n  }\n  /**\n   * @returns {void}\n   */\n\n\n  stop() {\n    this._stopped = true;\n    const queue = this._queued;\n    this._queued = new ArrayQueue();\n    const root = this._root;\n\n    for (const entry of queue) {\n      this._entries.delete(this._getKey(entry.item));\n\n      root._activeTasks++;\n\n      this._handleResult(entry, new WebpackError(\"Queue was stopped\"));\n    }\n  }\n  /**\n   * @returns {void}\n   */\n\n\n  increaseParallelism() {\n    const root = this._root;\n    root._parallelism++;\n    /* istanbul ignore next */\n\n    if (root._willEnsureProcessing === false && root._needProcessing) {\n      root._willEnsureProcessing = true;\n      setImmediate(root._ensureProcessing);\n    }\n  }\n  /**\n   * @returns {void}\n   */\n\n\n  decreaseParallelism() {\n    const root = this._root;\n    root._parallelism--;\n  }\n  /**\n   * @param {T} item an item\n   * @returns {boolean} true, if the item is currently being processed\n   */\n\n\n  isProcessing(item) {\n    const key = this._getKey(item);\n\n    const entry = this._entries.get(key);\n\n    return entry !== undefined && entry.state === PROCESSING_STATE;\n  }\n  /**\n   * @param {T} item an item\n   * @returns {boolean} true, if the item is currently queued\n   */\n\n\n  isQueued(item) {\n    const key = this._getKey(item);\n\n    const entry = this._entries.get(key);\n\n    return entry !== undefined && entry.state === QUEUED_STATE;\n  }\n  /**\n   * @param {T} item an item\n   * @returns {boolean} true, if the item is currently queued\n   */\n\n\n  isDone(item) {\n    const key = this._getKey(item);\n\n    const entry = this._entries.get(key);\n\n    return entry !== undefined && entry.state === DONE_STATE;\n  }\n  /**\n   * @returns {void}\n   */\n\n\n  _ensureProcessing() {\n    while (this._activeTasks < this._parallelism) {\n      const entry = this._queued.dequeue();\n\n      if (entry === undefined) break;\n      this._activeTasks++;\n      entry.state = PROCESSING_STATE;\n\n      this._startProcessing(entry);\n    }\n\n    this._willEnsureProcessing = false;\n    if (this._queued.length > 0) return;\n\n    if (this._children !== undefined) {\n      for (const child of this._children) {\n        while (this._activeTasks < this._parallelism) {\n          const entry = child._queued.dequeue();\n\n          if (entry === undefined) break;\n          this._activeTasks++;\n          entry.state = PROCESSING_STATE;\n\n          child._startProcessing(entry);\n        }\n\n        if (child._queued.length > 0) return;\n      }\n    }\n\n    if (!this._willEnsureProcessing) this._needProcessing = false;\n  }\n  /**\n   * @param {AsyncQueueEntry<T, K, R>} entry the entry\n   * @returns {void}\n   */\n\n\n  _startProcessing(entry) {\n    this.hooks.beforeStart.callAsync(entry.item, err => {\n      if (err) {\n        this._handleResult(entry, makeWebpackError(err, `AsyncQueue(${this._name}).hooks.beforeStart`));\n\n        return;\n      }\n\n      let inCallback = false;\n\n      try {\n        this._processor(entry.item, (e, r) => {\n          inCallback = true;\n\n          this._handleResult(entry, e, r);\n        });\n      } catch (err) {\n        if (inCallback) throw err;\n\n        this._handleResult(entry, err, null);\n      }\n\n      this.hooks.started.call(entry.item);\n    });\n  }\n  /**\n   * @param {AsyncQueueEntry<T, K, R>} entry the entry\n   * @param {WebpackError=} err error, if any\n   * @param {R=} result result, if any\n   * @returns {void}\n   */\n\n\n  _handleResult(entry, err, result) {\n    this.hooks.result.callAsync(entry.item, err, result, hookError => {\n      const error = hookError ? makeWebpackError(hookError, `AsyncQueue(${this._name}).hooks.result`) : err;\n      const callback = entry.callback;\n      const callbacks = entry.callbacks;\n      entry.state = DONE_STATE;\n      entry.callback = undefined;\n      entry.callbacks = undefined;\n      entry.result = result;\n      entry.error = error;\n      const root = this._root;\n      root._activeTasks--;\n\n      if (root._willEnsureProcessing === false && root._needProcessing) {\n        root._willEnsureProcessing = true;\n        setImmediate(root._ensureProcessing);\n      }\n\n      if (inHandleResult++ > 3) {\n        process.nextTick(() => {\n          callback(error, result);\n\n          if (callbacks !== undefined) {\n            for (const callback of callbacks) {\n              callback(error, result);\n            }\n          }\n        });\n      } else {\n        callback(error, result);\n\n        if (callbacks !== undefined) {\n          for (const callback of callbacks) {\n            callback(error, result);\n          }\n        }\n      }\n\n      inHandleResult--;\n    });\n  }\n\n  clear() {\n    this._entries.clear();\n\n    this._queued.clear();\n\n    this._activeTasks = 0;\n    this._willEnsureProcessing = false;\n    this._needProcessing = false;\n    this._stopped = false;\n  }\n\n}\n\nmodule.exports = AsyncQueue;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/util/AsyncQueue.js"],"names":["SyncHook","AsyncSeriesHook","require","makeWebpackError","WebpackError","ArrayQueue","QUEUED_STATE","PROCESSING_STATE","DONE_STATE","inHandleResult","AsyncQueueEntry","constructor","item","callback","state","callbacks","undefined","result","error","AsyncQueue","name","parallelism","parent","processor","getKey","_name","_parallelism","_processor","_getKey","_entries","Map","_queued","_children","_activeTasks","_willEnsureProcessing","_needProcessing","_stopped","_root","push","hooks","beforeAdd","added","beforeStart","started","_ensureProcessing","bind","add","callAsync","err","key","entry","get","process","nextTick","newEntry","call","_handleResult","set","enqueue","root","setImmediate","invalidate","delete","waitFor","stop","queue","increaseParallelism","decreaseParallelism","isProcessing","isQueued","isDone","dequeue","_startProcessing","length","child","inCallback","e","r","hookError","clear","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { SyncHook, AsyncSeriesHook } = require(\"tapable\");\nconst { makeWebpackError } = require(\"../HookWebpackError\");\nconst WebpackError = require(\"../WebpackError\");\nconst ArrayQueue = require(\"./ArrayQueue\");\n\nconst QUEUED_STATE = 0;\nconst PROCESSING_STATE = 1;\nconst DONE_STATE = 2;\n\nlet inHandleResult = 0;\n\n/**\n * @template T\n * @callback Callback\n * @param {(WebpackError | null)=} err\n * @param {T=} result\n */\n\n/**\n * @template T\n * @template K\n * @template R\n */\nclass AsyncQueueEntry {\n\t/**\n\t * @param {T} item the item\n\t * @param {Callback<R>} callback the callback\n\t */\n\tconstructor(item, callback) {\n\t\tthis.item = item;\n\t\t/** @type {typeof QUEUED_STATE | typeof PROCESSING_STATE | typeof DONE_STATE} */\n\t\tthis.state = QUEUED_STATE;\n\t\tthis.callback = callback;\n\t\t/** @type {Callback<R>[] | undefined} */\n\t\tthis.callbacks = undefined;\n\t\tthis.result = undefined;\n\t\t/** @type {WebpackError | undefined} */\n\t\tthis.error = undefined;\n\t}\n}\n\n/**\n * @template T\n * @template K\n * @template R\n */\nclass AsyncQueue {\n\t/**\n\t * @param {Object} options options object\n\t * @param {string=} options.name name of the queue\n\t * @param {number=} options.parallelism how many items should be processed at once\n\t * @param {AsyncQueue<any, any, any>=} options.parent parent queue, which will have priority over this queue and with shared parallelism\n\t * @param {function(T): K=} options.getKey extract key from item\n\t * @param {function(T, Callback<R>): void} options.processor async function to process items\n\t */\n\tconstructor({ name, parallelism, parent, processor, getKey }) {\n\t\tthis._name = name;\n\t\tthis._parallelism = parallelism || 1;\n\t\tthis._processor = processor;\n\t\tthis._getKey =\n\t\t\tgetKey || /** @type {(T) => K} */ (item => /** @type {any} */ (item));\n\t\t/** @type {Map<K, AsyncQueueEntry<T, K, R>>} */\n\t\tthis._entries = new Map();\n\t\t/** @type {ArrayQueue<AsyncQueueEntry<T, K, R>>} */\n\t\tthis._queued = new ArrayQueue();\n\t\t/** @type {AsyncQueue<any, any, any>[]} */\n\t\tthis._children = undefined;\n\t\tthis._activeTasks = 0;\n\t\tthis._willEnsureProcessing = false;\n\t\tthis._needProcessing = false;\n\t\tthis._stopped = false;\n\t\tthis._root = parent ? parent._root : this;\n\t\tif (parent) {\n\t\t\tif (this._root._children === undefined) {\n\t\t\t\tthis._root._children = [this];\n\t\t\t} else {\n\t\t\t\tthis._root._children.push(this);\n\t\t\t}\n\t\t}\n\n\t\tthis.hooks = {\n\t\t\t/** @type {AsyncSeriesHook<[T]>} */\n\t\t\tbeforeAdd: new AsyncSeriesHook([\"item\"]),\n\t\t\t/** @type {SyncHook<[T]>} */\n\t\t\tadded: new SyncHook([\"item\"]),\n\t\t\t/** @type {AsyncSeriesHook<[T]>} */\n\t\t\tbeforeStart: new AsyncSeriesHook([\"item\"]),\n\t\t\t/** @type {SyncHook<[T]>} */\n\t\t\tstarted: new SyncHook([\"item\"]),\n\t\t\t/** @type {SyncHook<[T, Error, R]>} */\n\t\t\tresult: new SyncHook([\"item\", \"error\", \"result\"])\n\t\t};\n\n\t\tthis._ensureProcessing = this._ensureProcessing.bind(this);\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @param {Callback<R>} callback callback function\n\t * @returns {void}\n\t */\n\tadd(item, callback) {\n\t\tif (this._stopped) return callback(new WebpackError(\"Queue was stopped\"));\n\t\tthis.hooks.beforeAdd.callAsync(item, err => {\n\t\t\tif (err) {\n\t\t\t\tcallback(\n\t\t\t\t\tmakeWebpackError(err, `AsyncQueue(${this._name}).hooks.beforeAdd`)\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst key = this._getKey(item);\n\t\t\tconst entry = this._entries.get(key);\n\t\t\tif (entry !== undefined) {\n\t\t\t\tif (entry.state === DONE_STATE) {\n\t\t\t\t\tif (inHandleResult++ > 3) {\n\t\t\t\t\t\tprocess.nextTick(() => callback(entry.error, entry.result));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcallback(entry.error, entry.result);\n\t\t\t\t\t}\n\t\t\t\t\tinHandleResult--;\n\t\t\t\t} else if (entry.callbacks === undefined) {\n\t\t\t\t\tentry.callbacks = [callback];\n\t\t\t\t} else {\n\t\t\t\t\tentry.callbacks.push(callback);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst newEntry = new AsyncQueueEntry(item, callback);\n\t\t\tif (this._stopped) {\n\t\t\t\tthis.hooks.added.call(item);\n\t\t\t\tthis._root._activeTasks++;\n\t\t\t\tprocess.nextTick(() =>\n\t\t\t\t\tthis._handleResult(newEntry, new WebpackError(\"Queue was stopped\"))\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis._entries.set(key, newEntry);\n\t\t\t\tthis._queued.enqueue(newEntry);\n\t\t\t\tconst root = this._root;\n\t\t\t\troot._needProcessing = true;\n\t\t\t\tif (root._willEnsureProcessing === false) {\n\t\t\t\t\troot._willEnsureProcessing = true;\n\t\t\t\t\tsetImmediate(root._ensureProcessing);\n\t\t\t\t}\n\t\t\t\tthis.hooks.added.call(item);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {void}\n\t */\n\tinvalidate(item) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\tthis._entries.delete(key);\n\t\tif (entry.state === QUEUED_STATE) {\n\t\t\tthis._queued.delete(entry);\n\t\t}\n\t}\n\n\t/**\n\t * Waits for an already started item\n\t * @param {T} item an item\n\t * @param {Callback<R>} callback callback function\n\t * @returns {void}\n\t */\n\twaitFor(item, callback) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\tif (entry === undefined) {\n\t\t\treturn callback(\n\t\t\t\tnew WebpackError(\n\t\t\t\t\t\"waitFor can only be called for an already started item\"\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\tif (entry.state === DONE_STATE) {\n\t\t\tprocess.nextTick(() => callback(entry.error, entry.result));\n\t\t} else if (entry.callbacks === undefined) {\n\t\t\tentry.callbacks = [callback];\n\t\t} else {\n\t\t\tentry.callbacks.push(callback);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tstop() {\n\t\tthis._stopped = true;\n\t\tconst queue = this._queued;\n\t\tthis._queued = new ArrayQueue();\n\t\tconst root = this._root;\n\t\tfor (const entry of queue) {\n\t\t\tthis._entries.delete(this._getKey(entry.item));\n\t\t\troot._activeTasks++;\n\t\t\tthis._handleResult(entry, new WebpackError(\"Queue was stopped\"));\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tincreaseParallelism() {\n\t\tconst root = this._root;\n\t\troot._parallelism++;\n\t\t/* istanbul ignore next */\n\t\tif (root._willEnsureProcessing === false && root._needProcessing) {\n\t\t\troot._willEnsureProcessing = true;\n\t\t\tsetImmediate(root._ensureProcessing);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tdecreaseParallelism() {\n\t\tconst root = this._root;\n\t\troot._parallelism--;\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {boolean} true, if the item is currently being processed\n\t */\n\tisProcessing(item) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\treturn entry !== undefined && entry.state === PROCESSING_STATE;\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {boolean} true, if the item is currently queued\n\t */\n\tisQueued(item) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\treturn entry !== undefined && entry.state === QUEUED_STATE;\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {boolean} true, if the item is currently queued\n\t */\n\tisDone(item) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\treturn entry !== undefined && entry.state === DONE_STATE;\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\t_ensureProcessing() {\n\t\twhile (this._activeTasks < this._parallelism) {\n\t\t\tconst entry = this._queued.dequeue();\n\t\t\tif (entry === undefined) break;\n\t\t\tthis._activeTasks++;\n\t\t\tentry.state = PROCESSING_STATE;\n\t\t\tthis._startProcessing(entry);\n\t\t}\n\t\tthis._willEnsureProcessing = false;\n\t\tif (this._queued.length > 0) return;\n\t\tif (this._children !== undefined) {\n\t\t\tfor (const child of this._children) {\n\t\t\t\twhile (this._activeTasks < this._parallelism) {\n\t\t\t\t\tconst entry = child._queued.dequeue();\n\t\t\t\t\tif (entry === undefined) break;\n\t\t\t\t\tthis._activeTasks++;\n\t\t\t\t\tentry.state = PROCESSING_STATE;\n\t\t\t\t\tchild._startProcessing(entry);\n\t\t\t\t}\n\t\t\t\tif (child._queued.length > 0) return;\n\t\t\t}\n\t\t}\n\t\tif (!this._willEnsureProcessing) this._needProcessing = false;\n\t}\n\n\t/**\n\t * @param {AsyncQueueEntry<T, K, R>} entry the entry\n\t * @returns {void}\n\t */\n\t_startProcessing(entry) {\n\t\tthis.hooks.beforeStart.callAsync(entry.item, err => {\n\t\t\tif (err) {\n\t\t\t\tthis._handleResult(\n\t\t\t\t\tentry,\n\t\t\t\t\tmakeWebpackError(err, `AsyncQueue(${this._name}).hooks.beforeStart`)\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet inCallback = false;\n\t\t\ttry {\n\t\t\t\tthis._processor(entry.item, (e, r) => {\n\t\t\t\t\tinCallback = true;\n\t\t\t\t\tthis._handleResult(entry, e, r);\n\t\t\t\t});\n\t\t\t} catch (err) {\n\t\t\t\tif (inCallback) throw err;\n\t\t\t\tthis._handleResult(entry, err, null);\n\t\t\t}\n\t\t\tthis.hooks.started.call(entry.item);\n\t\t});\n\t}\n\n\t/**\n\t * @param {AsyncQueueEntry<T, K, R>} entry the entry\n\t * @param {WebpackError=} err error, if any\n\t * @param {R=} result result, if any\n\t * @returns {void}\n\t */\n\t_handleResult(entry, err, result) {\n\t\tthis.hooks.result.callAsync(entry.item, err, result, hookError => {\n\t\t\tconst error = hookError\n\t\t\t\t? makeWebpackError(hookError, `AsyncQueue(${this._name}).hooks.result`)\n\t\t\t\t: err;\n\n\t\t\tconst callback = entry.callback;\n\t\t\tconst callbacks = entry.callbacks;\n\t\t\tentry.state = DONE_STATE;\n\t\t\tentry.callback = undefined;\n\t\t\tentry.callbacks = undefined;\n\t\t\tentry.result = result;\n\t\t\tentry.error = error;\n\n\t\t\tconst root = this._root;\n\t\t\troot._activeTasks--;\n\t\t\tif (root._willEnsureProcessing === false && root._needProcessing) {\n\t\t\t\troot._willEnsureProcessing = true;\n\t\t\t\tsetImmediate(root._ensureProcessing);\n\t\t\t}\n\n\t\t\tif (inHandleResult++ > 3) {\n\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\tcallback(error, result);\n\t\t\t\t\tif (callbacks !== undefined) {\n\t\t\t\t\t\tfor (const callback of callbacks) {\n\t\t\t\t\t\t\tcallback(error, result);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcallback(error, result);\n\t\t\t\tif (callbacks !== undefined) {\n\t\t\t\t\tfor (const callback of callbacks) {\n\t\t\t\t\t\tcallback(error, result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tinHandleResult--;\n\t\t});\n\t}\n\n\tclear() {\n\t\tthis._entries.clear();\n\t\tthis._queued.clear();\n\t\tthis._activeTasks = 0;\n\t\tthis._willEnsureProcessing = false;\n\t\tthis._needProcessing = false;\n\t\tthis._stopped = false;\n\t}\n}\n\nmodule.exports = AsyncQueue;\n"]},"metadata":{},"sourceType":"script"}