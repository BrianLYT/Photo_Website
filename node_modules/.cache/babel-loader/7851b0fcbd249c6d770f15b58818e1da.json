{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/** @typedef {import(\"./RuleSetCompiler\")} RuleSetCompiler */\n\n/** @typedef {import(\"./RuleSetCompiler\").RuleCondition} RuleCondition */\n\nclass BasicMatcherRulePlugin {\n  constructor(ruleProperty, dataProperty, invert) {\n    this.ruleProperty = ruleProperty;\n    this.dataProperty = dataProperty || ruleProperty;\n    this.invert = invert || false;\n  }\n  /**\n   * @param {RuleSetCompiler} ruleSetCompiler the rule set compiler\n   * @returns {void}\n   */\n\n\n  apply(ruleSetCompiler) {\n    ruleSetCompiler.hooks.rule.tap(\"BasicMatcherRulePlugin\", (path, rule, unhandledProperties, result) => {\n      if (unhandledProperties.has(this.ruleProperty)) {\n        unhandledProperties.delete(this.ruleProperty);\n        const value = rule[this.ruleProperty];\n        const condition = ruleSetCompiler.compileCondition(`${path}.${this.ruleProperty}`, value);\n        const fn = condition.fn;\n        result.conditions.push({\n          property: this.dataProperty,\n          matchWhenEmpty: this.invert ? !condition.matchWhenEmpty : condition.matchWhenEmpty,\n          fn: this.invert ? v => !fn(v) : fn\n        });\n      }\n    });\n  }\n\n}\n\nmodule.exports = BasicMatcherRulePlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/rules/BasicMatcherRulePlugin.js"],"names":["BasicMatcherRulePlugin","constructor","ruleProperty","dataProperty","invert","apply","ruleSetCompiler","hooks","rule","tap","path","unhandledProperties","result","has","delete","value","condition","compileCondition","fn","conditions","push","property","matchWhenEmpty","v","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;AAEA;;AACA;;AAEA,MAAMA,sBAAN,CAA6B;AAC5BC,EAAAA,WAAW,CAACC,YAAD,EAAeC,YAAf,EAA6BC,MAA7B,EAAqC;AAC/C,SAAKF,YAAL,GAAoBA,YAApB;AACA,SAAKC,YAAL,GAAoBA,YAAY,IAAID,YAApC;AACA,SAAKE,MAAL,GAAcA,MAAM,IAAI,KAAxB;AACA;AAED;AACD;AACA;AACA;;;AACCC,EAAAA,KAAK,CAACC,eAAD,EAAkB;AACtBA,IAAAA,eAAe,CAACC,KAAhB,CAAsBC,IAAtB,CAA2BC,GAA3B,CACC,wBADD,EAEC,CAACC,IAAD,EAAOF,IAAP,EAAaG,mBAAb,EAAkCC,MAAlC,KAA6C;AAC5C,UAAID,mBAAmB,CAACE,GAApB,CAAwB,KAAKX,YAA7B,CAAJ,EAAgD;AAC/CS,QAAAA,mBAAmB,CAACG,MAApB,CAA2B,KAAKZ,YAAhC;AACA,cAAMa,KAAK,GAAGP,IAAI,CAAC,KAAKN,YAAN,CAAlB;AACA,cAAMc,SAAS,GAAGV,eAAe,CAACW,gBAAhB,CAChB,GAAEP,IAAK,IAAG,KAAKR,YAAa,EADZ,EAEjBa,KAFiB,CAAlB;AAIA,cAAMG,EAAE,GAAGF,SAAS,CAACE,EAArB;AACAN,QAAAA,MAAM,CAACO,UAAP,CAAkBC,IAAlB,CAAuB;AACtBC,UAAAA,QAAQ,EAAE,KAAKlB,YADO;AAEtBmB,UAAAA,cAAc,EAAE,KAAKlB,MAAL,GACb,CAACY,SAAS,CAACM,cADE,GAEbN,SAAS,CAACM,cAJS;AAKtBJ,UAAAA,EAAE,EAAE,KAAKd,MAAL,GAAcmB,CAAC,IAAI,CAACL,EAAE,CAACK,CAAD,CAAtB,GAA4BL;AALV,SAAvB;AAOA;AACD,KAnBF;AAqBA;;AAjC2B;;AAoC7BM,MAAM,CAACC,OAAP,GAAiBzB,sBAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @typedef {import(\"./RuleSetCompiler\")} RuleSetCompiler */\n/** @typedef {import(\"./RuleSetCompiler\").RuleCondition} RuleCondition */\n\nclass BasicMatcherRulePlugin {\n\tconstructor(ruleProperty, dataProperty, invert) {\n\t\tthis.ruleProperty = ruleProperty;\n\t\tthis.dataProperty = dataProperty || ruleProperty;\n\t\tthis.invert = invert || false;\n\t}\n\n\t/**\n\t * @param {RuleSetCompiler} ruleSetCompiler the rule set compiler\n\t * @returns {void}\n\t */\n\tapply(ruleSetCompiler) {\n\t\truleSetCompiler.hooks.rule.tap(\n\t\t\t\"BasicMatcherRulePlugin\",\n\t\t\t(path, rule, unhandledProperties, result) => {\n\t\t\t\tif (unhandledProperties.has(this.ruleProperty)) {\n\t\t\t\t\tunhandledProperties.delete(this.ruleProperty);\n\t\t\t\t\tconst value = rule[this.ruleProperty];\n\t\t\t\t\tconst condition = ruleSetCompiler.compileCondition(\n\t\t\t\t\t\t`${path}.${this.ruleProperty}`,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t);\n\t\t\t\t\tconst fn = condition.fn;\n\t\t\t\t\tresult.conditions.push({\n\t\t\t\t\t\tproperty: this.dataProperty,\n\t\t\t\t\t\tmatchWhenEmpty: this.invert\n\t\t\t\t\t\t\t? !condition.matchWhenEmpty\n\t\t\t\t\t\t\t: condition.matchWhenEmpty,\n\t\t\t\t\t\tfn: this.invert ? v => !fn(v) : fn\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = BasicMatcherRulePlugin;\n"]},"metadata":{},"sourceType":"script"}