{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  HookMap,\n  SyncBailHook,\n  SyncWaterfallHook\n} = require(\"tapable\");\n\nconst {\n  concatComparators,\n  keepOriginalOrder\n} = require(\"../util/comparators\");\n\nconst smartGrouping = require(\"../util/smartGrouping\");\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../WebpackError\")} WebpackError */\n\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @typedef {import(\"../util/smartGrouping\").GroupConfig<any, object>} GroupConfig */\n\n/**\n * @typedef {Object} KnownStatsFactoryContext\n * @property {string} type\n * @property {function(string): string=} makePathsRelative\n * @property {Compilation=} compilation\n * @property {Set<Module>=} rootModules\n * @property {Map<string,Chunk[]>=} compilationFileToChunks\n * @property {Map<string,Chunk[]>=} compilationAuxiliaryFileToChunks\n * @property {RuntimeSpec=} runtime\n * @property {function(Compilation): WebpackError[]=} cachedGetErrors\n * @property {function(Compilation): WebpackError[]=} cachedGetWarnings\n */\n\n/** @typedef {KnownStatsFactoryContext & Record<string, any>} StatsFactoryContext */\n\n\nclass StatsFactory {\n  constructor() {\n    this.hooks = Object.freeze({\n      /** @type {HookMap<SyncBailHook<[Object, any, StatsFactoryContext]>>} */\n      extract: new HookMap(() => new SyncBailHook([\"object\", \"data\", \"context\"])),\n\n      /** @type {HookMap<SyncBailHook<[any, StatsFactoryContext, number, number]>>} */\n      filter: new HookMap(() => new SyncBailHook([\"item\", \"context\", \"index\", \"unfilteredIndex\"])),\n\n      /** @type {HookMap<SyncBailHook<[(function(any, any): number)[], StatsFactoryContext]>>} */\n      sort: new HookMap(() => new SyncBailHook([\"comparators\", \"context\"])),\n\n      /** @type {HookMap<SyncBailHook<[any, StatsFactoryContext, number, number]>>} */\n      filterSorted: new HookMap(() => new SyncBailHook([\"item\", \"context\", \"index\", \"unfilteredIndex\"])),\n\n      /** @type {HookMap<SyncBailHook<[GroupConfig[], StatsFactoryContext]>>} */\n      groupResults: new HookMap(() => new SyncBailHook([\"groupConfigs\", \"context\"])),\n\n      /** @type {HookMap<SyncBailHook<[(function(any, any): number)[], StatsFactoryContext]>>} */\n      sortResults: new HookMap(() => new SyncBailHook([\"comparators\", \"context\"])),\n\n      /** @type {HookMap<SyncBailHook<[any, StatsFactoryContext, number, number]>>} */\n      filterResults: new HookMap(() => new SyncBailHook([\"item\", \"context\", \"index\", \"unfilteredIndex\"])),\n\n      /** @type {HookMap<SyncBailHook<[any[], StatsFactoryContext]>>} */\n      merge: new HookMap(() => new SyncBailHook([\"items\", \"context\"])),\n\n      /** @type {HookMap<SyncBailHook<[any[], StatsFactoryContext]>>} */\n      result: new HookMap(() => new SyncWaterfallHook([\"result\", \"context\"])),\n\n      /** @type {HookMap<SyncBailHook<[any, StatsFactoryContext]>>} */\n      getItemName: new HookMap(() => new SyncBailHook([\"item\", \"context\"])),\n\n      /** @type {HookMap<SyncBailHook<[any, StatsFactoryContext]>>} */\n      getItemFactory: new HookMap(() => new SyncBailHook([\"item\", \"context\"]))\n    });\n    const hooks = this.hooks;\n    this._caches =\n    /** @type {Record<keyof typeof hooks, Map<string, SyncBailHook<[any[], StatsFactoryContext]>[]>>} */\n    {};\n\n    for (const key of Object.keys(hooks)) {\n      this._caches[key] = new Map();\n    }\n\n    this._inCreate = false;\n  }\n\n  _getAllLevelHooks(hookMap, cache, type) {\n    const cacheEntry = cache.get(type);\n\n    if (cacheEntry !== undefined) {\n      return cacheEntry;\n    }\n\n    const hooks = [];\n    const typeParts = type.split(\".\");\n\n    for (let i = 0; i < typeParts.length; i++) {\n      const hook = hookMap.get(typeParts.slice(i).join(\".\"));\n\n      if (hook) {\n        hooks.push(hook);\n      }\n    }\n\n    cache.set(type, hooks);\n    return hooks;\n  }\n\n  _forEachLevel(hookMap, cache, type, fn) {\n    for (const hook of this._getAllLevelHooks(hookMap, cache, type)) {\n      const result = fn(hook);\n      if (result !== undefined) return result;\n    }\n  }\n\n  _forEachLevelWaterfall(hookMap, cache, type, data, fn) {\n    for (const hook of this._getAllLevelHooks(hookMap, cache, type)) {\n      data = fn(hook, data);\n    }\n\n    return data;\n  }\n\n  _forEachLevelFilter(hookMap, cache, type, items, fn, forceClone) {\n    const hooks = this._getAllLevelHooks(hookMap, cache, type);\n\n    if (hooks.length === 0) return forceClone ? items.slice() : items;\n    let i = 0;\n    return items.filter((item, idx) => {\n      for (const hook of hooks) {\n        const r = fn(hook, item, idx, i);\n\n        if (r !== undefined) {\n          if (r) i++;\n          return r;\n        }\n      }\n\n      i++;\n      return true;\n    });\n  }\n  /**\n   * @param {string} type type\n   * @param {any} data factory data\n   * @param {Omit<StatsFactoryContext, \"type\">} baseContext context used as base\n   * @returns {any} created object\n   */\n\n\n  create(type, data, baseContext) {\n    if (this._inCreate) {\n      return this._create(type, data, baseContext);\n    } else {\n      try {\n        this._inCreate = true;\n        return this._create(type, data, baseContext);\n      } finally {\n        for (const key of Object.keys(this._caches)) this._caches[key].clear();\n\n        this._inCreate = false;\n      }\n    }\n  }\n\n  _create(type, data, baseContext) {\n    const context = { ...baseContext,\n      type,\n      [type]: data\n    };\n\n    if (Array.isArray(data)) {\n      // run filter on unsorted items\n      const items = this._forEachLevelFilter(this.hooks.filter, this._caches.filter, type, data, (h, r, idx, i) => h.call(r, context, idx, i), true); // sort items\n\n\n      const comparators = [];\n\n      this._forEachLevel(this.hooks.sort, this._caches.sort, type, h => h.call(comparators, context));\n\n      if (comparators.length > 0) {\n        items.sort( // @ts-expect-error number of arguments is correct\n        concatComparators(...comparators, keepOriginalOrder(items)));\n      } // run filter on sorted items\n\n\n      const items2 = this._forEachLevelFilter(this.hooks.filterSorted, this._caches.filterSorted, type, items, (h, r, idx, i) => h.call(r, context, idx, i), false); // for each item\n\n\n      let resultItems = items2.map((item, i) => {\n        const itemContext = { ...context,\n          _index: i\n        }; // run getItemName\n\n        const itemName = this._forEachLevel(this.hooks.getItemName, this._caches.getItemName, `${type}[]`, h => h.call(item, itemContext));\n\n        if (itemName) itemContext[itemName] = item;\n        const innerType = itemName ? `${type}[].${itemName}` : `${type}[]`; // run getItemFactory\n\n        const itemFactory = this._forEachLevel(this.hooks.getItemFactory, this._caches.getItemFactory, innerType, h => h.call(item, itemContext)) || this; // run item factory\n\n        return itemFactory.create(innerType, item, itemContext);\n      }); // sort result items\n\n      const comparators2 = [];\n\n      this._forEachLevel(this.hooks.sortResults, this._caches.sortResults, type, h => h.call(comparators2, context));\n\n      if (comparators2.length > 0) {\n        resultItems.sort( // @ts-expect-error number of arguments is correct\n        concatComparators(...comparators2, keepOriginalOrder(resultItems)));\n      } // group result items\n\n\n      const groupConfigs = [];\n\n      this._forEachLevel(this.hooks.groupResults, this._caches.groupResults, type, h => h.call(groupConfigs, context));\n\n      if (groupConfigs.length > 0) {\n        resultItems = smartGrouping(resultItems, groupConfigs);\n      } // run filter on sorted result items\n\n\n      const finalResultItems = this._forEachLevelFilter(this.hooks.filterResults, this._caches.filterResults, type, resultItems, (h, r, idx, i) => h.call(r, context, idx, i), false); // run merge on mapped items\n\n\n      let result = this._forEachLevel(this.hooks.merge, this._caches.merge, type, h => h.call(finalResultItems, context));\n\n      if (result === undefined) result = finalResultItems; // run result on merged items\n\n      return this._forEachLevelWaterfall(this.hooks.result, this._caches.result, type, result, (h, r) => h.call(r, context));\n    } else {\n      const object = {}; // run extract on value\n\n      this._forEachLevel(this.hooks.extract, this._caches.extract, type, h => h.call(object, data, context)); // run result on extracted object\n\n\n      return this._forEachLevelWaterfall(this.hooks.result, this._caches.result, type, object, (h, r) => h.call(r, context));\n    }\n  }\n\n}\n\nmodule.exports = StatsFactory;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/stats/StatsFactory.js"],"names":["HookMap","SyncBailHook","SyncWaterfallHook","require","concatComparators","keepOriginalOrder","smartGrouping","StatsFactory","constructor","hooks","Object","freeze","extract","filter","sort","filterSorted","groupResults","sortResults","filterResults","merge","result","getItemName","getItemFactory","_caches","key","keys","Map","_inCreate","_getAllLevelHooks","hookMap","cache","type","cacheEntry","get","undefined","typeParts","split","i","length","hook","slice","join","push","set","_forEachLevel","fn","_forEachLevelWaterfall","data","_forEachLevelFilter","items","forceClone","item","idx","r","create","baseContext","_create","clear","context","Array","isArray","h","call","comparators","items2","resultItems","map","itemContext","_index","itemName","innerType","itemFactory","comparators2","groupConfigs","finalResultItems","object","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { HookMap, SyncBailHook, SyncWaterfallHook } = require(\"tapable\");\nconst { concatComparators, keepOriginalOrder } = require(\"../util/comparators\");\nconst smartGrouping = require(\"../util/smartGrouping\");\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../WebpackError\")} WebpackError */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @typedef {import(\"../util/smartGrouping\").GroupConfig<any, object>} GroupConfig */\n\n/**\n * @typedef {Object} KnownStatsFactoryContext\n * @property {string} type\n * @property {function(string): string=} makePathsRelative\n * @property {Compilation=} compilation\n * @property {Set<Module>=} rootModules\n * @property {Map<string,Chunk[]>=} compilationFileToChunks\n * @property {Map<string,Chunk[]>=} compilationAuxiliaryFileToChunks\n * @property {RuntimeSpec=} runtime\n * @property {function(Compilation): WebpackError[]=} cachedGetErrors\n * @property {function(Compilation): WebpackError[]=} cachedGetWarnings\n */\n\n/** @typedef {KnownStatsFactoryContext & Record<string, any>} StatsFactoryContext */\n\nclass StatsFactory {\n\tconstructor() {\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {HookMap<SyncBailHook<[Object, any, StatsFactoryContext]>>} */\n\t\t\textract: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"object\", \"data\", \"context\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[any, StatsFactoryContext, number, number]>>} */\n\t\t\tfilter: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"item\", \"context\", \"index\", \"unfilteredIndex\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[(function(any, any): number)[], StatsFactoryContext]>>} */\n\t\t\tsort: new HookMap(() => new SyncBailHook([\"comparators\", \"context\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[any, StatsFactoryContext, number, number]>>} */\n\t\t\tfilterSorted: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"item\", \"context\", \"index\", \"unfilteredIndex\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[GroupConfig[], StatsFactoryContext]>>} */\n\t\t\tgroupResults: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"groupConfigs\", \"context\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[(function(any, any): number)[], StatsFactoryContext]>>} */\n\t\t\tsortResults: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"comparators\", \"context\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[any, StatsFactoryContext, number, number]>>} */\n\t\t\tfilterResults: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"item\", \"context\", \"index\", \"unfilteredIndex\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[any[], StatsFactoryContext]>>} */\n\t\t\tmerge: new HookMap(() => new SyncBailHook([\"items\", \"context\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[any[], StatsFactoryContext]>>} */\n\t\t\tresult: new HookMap(() => new SyncWaterfallHook([\"result\", \"context\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[any, StatsFactoryContext]>>} */\n\t\t\tgetItemName: new HookMap(() => new SyncBailHook([\"item\", \"context\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[any, StatsFactoryContext]>>} */\n\t\t\tgetItemFactory: new HookMap(() => new SyncBailHook([\"item\", \"context\"]))\n\t\t});\n\t\tconst hooks = this.hooks;\n\t\tthis._caches =\n\t\t\t/** @type {Record<keyof typeof hooks, Map<string, SyncBailHook<[any[], StatsFactoryContext]>[]>>} */ ({});\n\t\tfor (const key of Object.keys(hooks)) {\n\t\t\tthis._caches[key] = new Map();\n\t\t}\n\t\tthis._inCreate = false;\n\t}\n\n\t_getAllLevelHooks(hookMap, cache, type) {\n\t\tconst cacheEntry = cache.get(type);\n\t\tif (cacheEntry !== undefined) {\n\t\t\treturn cacheEntry;\n\t\t}\n\t\tconst hooks = [];\n\t\tconst typeParts = type.split(\".\");\n\t\tfor (let i = 0; i < typeParts.length; i++) {\n\t\t\tconst hook = hookMap.get(typeParts.slice(i).join(\".\"));\n\t\t\tif (hook) {\n\t\t\t\thooks.push(hook);\n\t\t\t}\n\t\t}\n\t\tcache.set(type, hooks);\n\t\treturn hooks;\n\t}\n\n\t_forEachLevel(hookMap, cache, type, fn) {\n\t\tfor (const hook of this._getAllLevelHooks(hookMap, cache, type)) {\n\t\t\tconst result = fn(hook);\n\t\t\tif (result !== undefined) return result;\n\t\t}\n\t}\n\n\t_forEachLevelWaterfall(hookMap, cache, type, data, fn) {\n\t\tfor (const hook of this._getAllLevelHooks(hookMap, cache, type)) {\n\t\t\tdata = fn(hook, data);\n\t\t}\n\t\treturn data;\n\t}\n\n\t_forEachLevelFilter(hookMap, cache, type, items, fn, forceClone) {\n\t\tconst hooks = this._getAllLevelHooks(hookMap, cache, type);\n\t\tif (hooks.length === 0) return forceClone ? items.slice() : items;\n\t\tlet i = 0;\n\t\treturn items.filter((item, idx) => {\n\t\t\tfor (const hook of hooks) {\n\t\t\t\tconst r = fn(hook, item, idx, i);\n\t\t\t\tif (r !== undefined) {\n\t\t\t\t\tif (r) i++;\n\t\t\t\t\treturn r;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\treturn true;\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} type type\n\t * @param {any} data factory data\n\t * @param {Omit<StatsFactoryContext, \"type\">} baseContext context used as base\n\t * @returns {any} created object\n\t */\n\tcreate(type, data, baseContext) {\n\t\tif (this._inCreate) {\n\t\t\treturn this._create(type, data, baseContext);\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tthis._inCreate = true;\n\t\t\t\treturn this._create(type, data, baseContext);\n\t\t\t} finally {\n\t\t\t\tfor (const key of Object.keys(this._caches)) this._caches[key].clear();\n\t\t\t\tthis._inCreate = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t_create(type, data, baseContext) {\n\t\tconst context = {\n\t\t\t...baseContext,\n\t\t\ttype,\n\t\t\t[type]: data\n\t\t};\n\t\tif (Array.isArray(data)) {\n\t\t\t// run filter on unsorted items\n\t\t\tconst items = this._forEachLevelFilter(\n\t\t\t\tthis.hooks.filter,\n\t\t\t\tthis._caches.filter,\n\t\t\t\ttype,\n\t\t\t\tdata,\n\t\t\t\t(h, r, idx, i) => h.call(r, context, idx, i),\n\t\t\t\ttrue\n\t\t\t);\n\n\t\t\t// sort items\n\t\t\tconst comparators = [];\n\t\t\tthis._forEachLevel(this.hooks.sort, this._caches.sort, type, h =>\n\t\t\t\th.call(comparators, context)\n\t\t\t);\n\t\t\tif (comparators.length > 0) {\n\t\t\t\titems.sort(\n\t\t\t\t\t// @ts-expect-error number of arguments is correct\n\t\t\t\t\tconcatComparators(...comparators, keepOriginalOrder(items))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// run filter on sorted items\n\t\t\tconst items2 = this._forEachLevelFilter(\n\t\t\t\tthis.hooks.filterSorted,\n\t\t\t\tthis._caches.filterSorted,\n\t\t\t\ttype,\n\t\t\t\titems,\n\t\t\t\t(h, r, idx, i) => h.call(r, context, idx, i),\n\t\t\t\tfalse\n\t\t\t);\n\n\t\t\t// for each item\n\t\t\tlet resultItems = items2.map((item, i) => {\n\t\t\t\tconst itemContext = {\n\t\t\t\t\t...context,\n\t\t\t\t\t_index: i\n\t\t\t\t};\n\n\t\t\t\t// run getItemName\n\t\t\t\tconst itemName = this._forEachLevel(\n\t\t\t\t\tthis.hooks.getItemName,\n\t\t\t\t\tthis._caches.getItemName,\n\t\t\t\t\t`${type}[]`,\n\t\t\t\t\th => h.call(item, itemContext)\n\t\t\t\t);\n\t\t\t\tif (itemName) itemContext[itemName] = item;\n\t\t\t\tconst innerType = itemName ? `${type}[].${itemName}` : `${type}[]`;\n\n\t\t\t\t// run getItemFactory\n\t\t\t\tconst itemFactory =\n\t\t\t\t\tthis._forEachLevel(\n\t\t\t\t\t\tthis.hooks.getItemFactory,\n\t\t\t\t\t\tthis._caches.getItemFactory,\n\t\t\t\t\t\tinnerType,\n\t\t\t\t\t\th => h.call(item, itemContext)\n\t\t\t\t\t) || this;\n\n\t\t\t\t// run item factory\n\t\t\t\treturn itemFactory.create(innerType, item, itemContext);\n\t\t\t});\n\n\t\t\t// sort result items\n\t\t\tconst comparators2 = [];\n\t\t\tthis._forEachLevel(\n\t\t\t\tthis.hooks.sortResults,\n\t\t\t\tthis._caches.sortResults,\n\t\t\t\ttype,\n\t\t\t\th => h.call(comparators2, context)\n\t\t\t);\n\t\t\tif (comparators2.length > 0) {\n\t\t\t\tresultItems.sort(\n\t\t\t\t\t// @ts-expect-error number of arguments is correct\n\t\t\t\t\tconcatComparators(...comparators2, keepOriginalOrder(resultItems))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// group result items\n\t\t\tconst groupConfigs = [];\n\t\t\tthis._forEachLevel(\n\t\t\t\tthis.hooks.groupResults,\n\t\t\t\tthis._caches.groupResults,\n\t\t\t\ttype,\n\t\t\t\th => h.call(groupConfigs, context)\n\t\t\t);\n\t\t\tif (groupConfigs.length > 0) {\n\t\t\t\tresultItems = smartGrouping(resultItems, groupConfigs);\n\t\t\t}\n\n\t\t\t// run filter on sorted result items\n\t\t\tconst finalResultItems = this._forEachLevelFilter(\n\t\t\t\tthis.hooks.filterResults,\n\t\t\t\tthis._caches.filterResults,\n\t\t\t\ttype,\n\t\t\t\tresultItems,\n\t\t\t\t(h, r, idx, i) => h.call(r, context, idx, i),\n\t\t\t\tfalse\n\t\t\t);\n\n\t\t\t// run merge on mapped items\n\t\t\tlet result = this._forEachLevel(\n\t\t\t\tthis.hooks.merge,\n\t\t\t\tthis._caches.merge,\n\t\t\t\ttype,\n\t\t\t\th => h.call(finalResultItems, context)\n\t\t\t);\n\t\t\tif (result === undefined) result = finalResultItems;\n\n\t\t\t// run result on merged items\n\t\t\treturn this._forEachLevelWaterfall(\n\t\t\t\tthis.hooks.result,\n\t\t\t\tthis._caches.result,\n\t\t\t\ttype,\n\t\t\t\tresult,\n\t\t\t\t(h, r) => h.call(r, context)\n\t\t\t);\n\t\t} else {\n\t\t\tconst object = {};\n\n\t\t\t// run extract on value\n\t\t\tthis._forEachLevel(this.hooks.extract, this._caches.extract, type, h =>\n\t\t\t\th.call(object, data, context)\n\t\t\t);\n\n\t\t\t// run result on extracted object\n\t\t\treturn this._forEachLevelWaterfall(\n\t\t\t\tthis.hooks.result,\n\t\t\t\tthis._caches.result,\n\t\t\t\ttype,\n\t\t\t\tobject,\n\t\t\t\t(h, r) => h.call(r, context)\n\t\t\t);\n\t\t}\n\t}\n}\nmodule.exports = StatsFactory;\n"]},"metadata":{},"sourceType":"script"}