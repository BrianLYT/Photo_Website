{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  create: createResolver\n} = require(\"enhanced-resolve\");\n\nconst asyncLib = require(\"neo-async\");\n\nconst AsyncQueue = require(\"./util/AsyncQueue\");\n\nconst StackedCacheMap = require(\"./util/StackedCacheMap\");\n\nconst createHash = require(\"./util/createHash\");\n\nconst {\n  join,\n  dirname,\n  relative,\n  lstatReadlinkAbsolute\n} = require(\"./util/fs\");\n\nconst makeSerializable = require(\"./util/makeSerializable\");\n\nconst processAsyncTree = require(\"./util/processAsyncTree\");\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n\n/** @typedef {import(\"./util/fs\").IStats} IStats */\n\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n\n\nconst supportsEsm = +process.versions.modules >= 83;\nlet FS_ACCURACY = 2000;\nconst EMPTY_SET = new Set();\nconst RBDT_RESOLVE_CJS = 0;\nconst RBDT_RESOLVE_ESM = 1;\nconst RBDT_RESOLVE_DIRECTORY = 2;\nconst RBDT_RESOLVE_CJS_FILE = 3;\nconst RBDT_RESOLVE_CJS_FILE_AS_CHILD = 4;\nconst RBDT_RESOLVE_ESM_FILE = 5;\nconst RBDT_DIRECTORY = 6;\nconst RBDT_FILE = 7;\nconst RBDT_DIRECTORY_DEPENDENCIES = 8;\nconst RBDT_FILE_DEPENDENCIES = 9;\nconst INVALID = Symbol(\"invalid\");\n/**\n * @typedef {Object} FileSystemInfoEntry\n * @property {number} safeTime\n * @property {number=} timestamp\n */\n\n/**\n * @typedef {Object} ResolvedContextFileSystemInfoEntry\n * @property {number} safeTime\n * @property {string=} timestampHash\n */\n\n/**\n * @typedef {Object} ContextFileSystemInfoEntry\n * @property {number} safeTime\n * @property {string=} timestampHash\n * @property {ResolvedContextFileSystemInfoEntry=} resolved\n * @property {Set<string>=} symlinks\n */\n\n/**\n * @typedef {Object} TimestampAndHash\n * @property {number} safeTime\n * @property {number=} timestamp\n * @property {string} hash\n */\n\n/**\n * @typedef {Object} ResolvedContextTimestampAndHash\n * @property {number} safeTime\n * @property {string=} timestampHash\n * @property {string} hash\n */\n\n/**\n * @typedef {Object} ContextTimestampAndHash\n * @property {number} safeTime\n * @property {string=} timestampHash\n * @property {string} hash\n * @property {ResolvedContextTimestampAndHash=} resolved\n * @property {Set<string>=} symlinks\n */\n\n/**\n * @typedef {Object} ContextHash\n * @property {string} hash\n * @property {string=} resolved\n * @property {Set<string>=} symlinks\n */\n\n/**\n * @typedef {Object} SnapshotOptimizationEntry\n * @property {Snapshot} snapshot\n * @property {number} shared\n * @property {Set<string>} snapshotContent\n * @property {Set<SnapshotOptimizationEntry>} children\n */\n\n/**\n * @typedef {Object} ResolveBuildDependenciesResult\n * @property {Set<string>} files list of files\n * @property {Set<string>} directories list of directories\n * @property {Set<string>} missing list of missing entries\n * @property {Map<string, string | false>} resolveResults stored resolve results\n * @property {Object} resolveDependencies dependencies of the resolving\n * @property {Set<string>} resolveDependencies.files list of files\n * @property {Set<string>} resolveDependencies.directories list of directories\n * @property {Set<string>} resolveDependencies.missing list of missing entries\n */\n\nconst DONE_ITERATOR_RESULT = new Set().keys().next(); // cspell:word tshs\n// Tsh = Timestamp + Hash\n// Tshs = Timestamp + Hash combinations\n\nclass SnapshotIterator {\n  constructor(next) {\n    this.next = next;\n  }\n\n}\n\nclass SnapshotIterable {\n  constructor(snapshot, getMaps) {\n    this.snapshot = snapshot;\n    this.getMaps = getMaps;\n  }\n\n  [Symbol.iterator]() {\n    let state = 0;\n    /** @type {IterableIterator<string>} */\n\n    let it;\n    /** @type {(Snapshot) => (Map<string, any> | Set<string>)[]} */\n\n    let getMaps;\n    /** @type {(Map<string, any> | Set<string>)[]} */\n\n    let maps;\n    /** @type {Snapshot} */\n\n    let snapshot;\n    let queue;\n    return new SnapshotIterator(() => {\n      for (;;) {\n        switch (state) {\n          case 0:\n            snapshot = this.snapshot;\n            getMaps = this.getMaps;\n            maps = getMaps(snapshot);\n            state = 1;\n\n          /* falls through */\n\n          case 1:\n            if (maps.length > 0) {\n              const map = maps.pop();\n\n              if (map !== undefined) {\n                it = map.keys();\n                state = 2;\n              } else {\n                break;\n              }\n            } else {\n              state = 3;\n              break;\n            }\n\n          /* falls through */\n\n          case 2:\n            {\n              const result = it.next();\n              if (!result.done) return result;\n              state = 1;\n              break;\n            }\n\n          case 3:\n            {\n              const children = snapshot.children;\n\n              if (children !== undefined) {\n                if (children.size === 1) {\n                  // shortcut for a single child\n                  // avoids allocation of queue\n                  for (const child of children) snapshot = child;\n\n                  maps = getMaps(snapshot);\n                  state = 1;\n                  break;\n                }\n\n                if (queue === undefined) queue = [];\n\n                for (const child of children) {\n                  queue.push(child);\n                }\n              }\n\n              if (queue !== undefined && queue.length > 0) {\n                snapshot = queue.pop();\n                maps = getMaps(snapshot);\n                state = 1;\n                break;\n              } else {\n                state = 4;\n              }\n            }\n\n          /* falls through */\n\n          case 4:\n            return DONE_ITERATOR_RESULT;\n        }\n      }\n    });\n  }\n\n}\n\nclass Snapshot {\n  constructor() {\n    this._flags = 0;\n    /** @type {number | undefined} */\n\n    this.startTime = undefined;\n    /** @type {Map<string, FileSystemInfoEntry | null> | undefined} */\n\n    this.fileTimestamps = undefined;\n    /** @type {Map<string, string | null> | undefined} */\n\n    this.fileHashes = undefined;\n    /** @type {Map<string, TimestampAndHash | string | null> | undefined} */\n\n    this.fileTshs = undefined;\n    /** @type {Map<string, ResolvedContextFileSystemInfoEntry | null> | undefined} */\n\n    this.contextTimestamps = undefined;\n    /** @type {Map<string, string | null> | undefined} */\n\n    this.contextHashes = undefined;\n    /** @type {Map<string, ResolvedContextTimestampAndHash | null> | undefined} */\n\n    this.contextTshs = undefined;\n    /** @type {Map<string, boolean> | undefined} */\n\n    this.missingExistence = undefined;\n    /** @type {Map<string, string> | undefined} */\n\n    this.managedItemInfo = undefined;\n    /** @type {Set<string> | undefined} */\n\n    this.managedFiles = undefined;\n    /** @type {Set<string> | undefined} */\n\n    this.managedContexts = undefined;\n    /** @type {Set<string> | undefined} */\n\n    this.managedMissing = undefined;\n    /** @type {Set<Snapshot> | undefined} */\n\n    this.children = undefined;\n  }\n\n  hasStartTime() {\n    return (this._flags & 1) !== 0;\n  }\n\n  setStartTime(value) {\n    this._flags = this._flags | 1;\n    this.startTime = value;\n  }\n\n  setMergedStartTime(value, snapshot) {\n    if (value) {\n      if (snapshot.hasStartTime()) {\n        this.setStartTime(Math.min(value, snapshot.startTime));\n      } else {\n        this.setStartTime(value);\n      }\n    } else {\n      if (snapshot.hasStartTime()) this.setStartTime(snapshot.startTime);\n    }\n  }\n\n  hasFileTimestamps() {\n    return (this._flags & 2) !== 0;\n  }\n\n  setFileTimestamps(value) {\n    this._flags = this._flags | 2;\n    this.fileTimestamps = value;\n  }\n\n  hasFileHashes() {\n    return (this._flags & 4) !== 0;\n  }\n\n  setFileHashes(value) {\n    this._flags = this._flags | 4;\n    this.fileHashes = value;\n  }\n\n  hasFileTshs() {\n    return (this._flags & 8) !== 0;\n  }\n\n  setFileTshs(value) {\n    this._flags = this._flags | 8;\n    this.fileTshs = value;\n  }\n\n  hasContextTimestamps() {\n    return (this._flags & 0x10) !== 0;\n  }\n\n  setContextTimestamps(value) {\n    this._flags = this._flags | 0x10;\n    this.contextTimestamps = value;\n  }\n\n  hasContextHashes() {\n    return (this._flags & 0x20) !== 0;\n  }\n\n  setContextHashes(value) {\n    this._flags = this._flags | 0x20;\n    this.contextHashes = value;\n  }\n\n  hasContextTshs() {\n    return (this._flags & 0x40) !== 0;\n  }\n\n  setContextTshs(value) {\n    this._flags = this._flags | 0x40;\n    this.contextTshs = value;\n  }\n\n  hasMissingExistence() {\n    return (this._flags & 0x80) !== 0;\n  }\n\n  setMissingExistence(value) {\n    this._flags = this._flags | 0x80;\n    this.missingExistence = value;\n  }\n\n  hasManagedItemInfo() {\n    return (this._flags & 0x100) !== 0;\n  }\n\n  setManagedItemInfo(value) {\n    this._flags = this._flags | 0x100;\n    this.managedItemInfo = value;\n  }\n\n  hasManagedFiles() {\n    return (this._flags & 0x200) !== 0;\n  }\n\n  setManagedFiles(value) {\n    this._flags = this._flags | 0x200;\n    this.managedFiles = value;\n  }\n\n  hasManagedContexts() {\n    return (this._flags & 0x400) !== 0;\n  }\n\n  setManagedContexts(value) {\n    this._flags = this._flags | 0x400;\n    this.managedContexts = value;\n  }\n\n  hasManagedMissing() {\n    return (this._flags & 0x800) !== 0;\n  }\n\n  setManagedMissing(value) {\n    this._flags = this._flags | 0x800;\n    this.managedMissing = value;\n  }\n\n  hasChildren() {\n    return (this._flags & 0x1000) !== 0;\n  }\n\n  setChildren(value) {\n    this._flags = this._flags | 0x1000;\n    this.children = value;\n  }\n\n  addChild(child) {\n    if (!this.hasChildren()) {\n      this.setChildren(new Set());\n    }\n\n    this.children.add(child);\n  }\n\n  serialize(_ref) {\n    let {\n      write\n    } = _ref;\n    write(this._flags);\n    if (this.hasStartTime()) write(this.startTime);\n    if (this.hasFileTimestamps()) write(this.fileTimestamps);\n    if (this.hasFileHashes()) write(this.fileHashes);\n    if (this.hasFileTshs()) write(this.fileTshs);\n    if (this.hasContextTimestamps()) write(this.contextTimestamps);\n    if (this.hasContextHashes()) write(this.contextHashes);\n    if (this.hasContextTshs()) write(this.contextTshs);\n    if (this.hasMissingExistence()) write(this.missingExistence);\n    if (this.hasManagedItemInfo()) write(this.managedItemInfo);\n    if (this.hasManagedFiles()) write(this.managedFiles);\n    if (this.hasManagedContexts()) write(this.managedContexts);\n    if (this.hasManagedMissing()) write(this.managedMissing);\n    if (this.hasChildren()) write(this.children);\n  }\n\n  deserialize(_ref2) {\n    let {\n      read\n    } = _ref2;\n    this._flags = read();\n    if (this.hasStartTime()) this.startTime = read();\n    if (this.hasFileTimestamps()) this.fileTimestamps = read();\n    if (this.hasFileHashes()) this.fileHashes = read();\n    if (this.hasFileTshs()) this.fileTshs = read();\n    if (this.hasContextTimestamps()) this.contextTimestamps = read();\n    if (this.hasContextHashes()) this.contextHashes = read();\n    if (this.hasContextTshs()) this.contextTshs = read();\n    if (this.hasMissingExistence()) this.missingExistence = read();\n    if (this.hasManagedItemInfo()) this.managedItemInfo = read();\n    if (this.hasManagedFiles()) this.managedFiles = read();\n    if (this.hasManagedContexts()) this.managedContexts = read();\n    if (this.hasManagedMissing()) this.managedMissing = read();\n    if (this.hasChildren()) this.children = read();\n  }\n  /**\n   * @param {function(Snapshot): (ReadonlyMap<string, any> | ReadonlySet<string>)[]} getMaps first\n   * @returns {Iterable<string>} iterable\n   */\n\n\n  _createIterable(getMaps) {\n    return new SnapshotIterable(this, getMaps);\n  }\n  /**\n   * @returns {Iterable<string>} iterable\n   */\n\n\n  getFileIterable() {\n    return this._createIterable(s => [s.fileTimestamps, s.fileHashes, s.fileTshs, s.managedFiles]);\n  }\n  /**\n   * @returns {Iterable<string>} iterable\n   */\n\n\n  getContextIterable() {\n    return this._createIterable(s => [s.contextTimestamps, s.contextHashes, s.contextTshs, s.managedContexts]);\n  }\n  /**\n   * @returns {Iterable<string>} iterable\n   */\n\n\n  getMissingIterable() {\n    return this._createIterable(s => [s.missingExistence, s.managedMissing]);\n  }\n\n}\n\nmakeSerializable(Snapshot, \"webpack/lib/FileSystemInfo\", \"Snapshot\");\nconst MIN_COMMON_SNAPSHOT_SIZE = 3;\n/**\n * @template T\n */\n\nclass SnapshotOptimization {\n  /**\n   * @param {function(Snapshot): boolean} has has value\n   * @param {function(Snapshot): Map<string, T> | Set<string>} get get value\n   * @param {function(Snapshot, Map<string, T> | Set<string>): void} set set value\n   * @param {boolean=} useStartTime use the start time of snapshots\n   * @param {boolean=} isSet value is an Set instead of a Map\n   */\n  constructor(has, get, set) {\n    let useStartTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    let isSet = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    this._has = has;\n    this._get = get;\n    this._set = set;\n    this._useStartTime = useStartTime;\n    this._isSet = isSet;\n    /** @type {Map<string, SnapshotOptimizationEntry>} */\n\n    this._map = new Map();\n    this._statItemsShared = 0;\n    this._statItemsUnshared = 0;\n    this._statSharedSnapshots = 0;\n    this._statReusedSharedSnapshots = 0;\n  }\n\n  getStatisticMessage() {\n    const total = this._statItemsShared + this._statItemsUnshared;\n    if (total === 0) return undefined;\n    return `${this._statItemsShared && Math.round(this._statItemsShared * 100 / total)}% (${this._statItemsShared}/${total}) entries shared via ${this._statSharedSnapshots} shared snapshots (${this._statReusedSharedSnapshots + this._statSharedSnapshots} times referenced)`;\n  }\n\n  clear() {\n    this._map.clear();\n\n    this._statItemsShared = 0;\n    this._statItemsUnshared = 0;\n    this._statSharedSnapshots = 0;\n    this._statReusedSharedSnapshots = 0;\n  }\n  /**\n   * @param {Snapshot} newSnapshot snapshot\n   * @param {Set<string>} capturedFiles files to snapshot/share\n   * @returns {void}\n   */\n\n\n  optimize(newSnapshot, capturedFiles) {\n    /**\n     * @param {SnapshotOptimizationEntry} entry optimization entry\n     * @returns {void}\n     */\n    const increaseSharedAndStoreOptimizationEntry = entry => {\n      if (entry.children !== undefined) {\n        entry.children.forEach(increaseSharedAndStoreOptimizationEntry);\n      }\n\n      entry.shared++;\n      storeOptimizationEntry(entry);\n    };\n    /**\n     * @param {SnapshotOptimizationEntry} entry optimization entry\n     * @returns {void}\n     */\n\n\n    const storeOptimizationEntry = entry => {\n      for (const path of entry.snapshotContent) {\n        const old = this._map.get(path);\n\n        if (old.shared < entry.shared) {\n          this._map.set(path, entry);\n        }\n\n        capturedFiles.delete(path);\n      }\n    };\n    /** @type {SnapshotOptimizationEntry} */\n\n\n    let newOptimizationEntry = undefined;\n    const capturedFilesSize = capturedFiles.size;\n    /** @type {Set<SnapshotOptimizationEntry> | undefined} */\n\n    const optimizationEntries = new Set();\n\n    for (const path of capturedFiles) {\n      const optimizationEntry = this._map.get(path);\n\n      if (optimizationEntry === undefined) {\n        if (newOptimizationEntry === undefined) {\n          newOptimizationEntry = {\n            snapshot: newSnapshot,\n            shared: 0,\n            snapshotContent: undefined,\n            children: undefined\n          };\n        }\n\n        this._map.set(path, newOptimizationEntry);\n\n        continue;\n      } else {\n        optimizationEntries.add(optimizationEntry);\n      }\n    }\n\n    optimizationEntries: for (const optimizationEntry of optimizationEntries) {\n      const snapshot = optimizationEntry.snapshot;\n\n      if (optimizationEntry.shared > 0) {\n        // It's a shared snapshot\n        // We can't change it, so we can only use it when all files match\n        // and startTime is compatible\n        if (this._useStartTime && newSnapshot.startTime && (!snapshot.startTime || snapshot.startTime > newSnapshot.startTime)) {\n          continue;\n        }\n\n        const nonSharedFiles = new Set();\n        const snapshotContent = optimizationEntry.snapshotContent;\n\n        const snapshotEntries = this._get(snapshot);\n\n        for (const path of snapshotContent) {\n          if (!capturedFiles.has(path)) {\n            if (!snapshotEntries.has(path)) {\n              // File is not shared and can't be removed from the snapshot\n              // because it's in a child of the snapshot\n              continue optimizationEntries;\n            }\n\n            nonSharedFiles.add(path);\n            continue;\n          }\n        }\n\n        if (nonSharedFiles.size === 0) {\n          // The complete snapshot is shared\n          // add it as child\n          newSnapshot.addChild(snapshot);\n          increaseSharedAndStoreOptimizationEntry(optimizationEntry);\n          this._statReusedSharedSnapshots++;\n        } else {\n          // Only a part of the snapshot is shared\n          const sharedCount = snapshotContent.size - nonSharedFiles.size;\n\n          if (sharedCount < MIN_COMMON_SNAPSHOT_SIZE) {\n            // Common part it too small\n            continue optimizationEntries;\n          } // Extract common timestamps from both snapshots\n\n\n          let commonMap;\n\n          if (this._isSet) {\n            commonMap = new Set();\n\n            for (const path of\n            /** @type {Set<string>} */\n            snapshotEntries) {\n              if (nonSharedFiles.has(path)) continue;\n              commonMap.add(path);\n              snapshotEntries.delete(path);\n            }\n          } else {\n            commonMap = new Map();\n            const map =\n            /** @type {Map<string, T>} */\n            snapshotEntries;\n\n            for (const [path, value] of map) {\n              if (nonSharedFiles.has(path)) continue;\n              commonMap.set(path, value);\n              snapshotEntries.delete(path);\n            }\n          } // Create and attach snapshot\n\n\n          const commonSnapshot = new Snapshot();\n\n          if (this._useStartTime) {\n            commonSnapshot.setMergedStartTime(newSnapshot.startTime, snapshot);\n          }\n\n          this._set(commonSnapshot, commonMap);\n\n          newSnapshot.addChild(commonSnapshot);\n          snapshot.addChild(commonSnapshot); // Create optimization entry\n\n          const newEntry = {\n            snapshot: commonSnapshot,\n            shared: optimizationEntry.shared + 1,\n            snapshotContent: new Set(commonMap.keys()),\n            children: undefined\n          };\n          if (optimizationEntry.children === undefined) optimizationEntry.children = new Set();\n          optimizationEntry.children.add(newEntry);\n          storeOptimizationEntry(newEntry);\n          this._statSharedSnapshots++;\n        }\n      } else {\n        // It's a unshared snapshot\n        // We can extract a common shared snapshot\n        // with all common files\n        const snapshotEntries = this._get(snapshot);\n\n        if (snapshotEntries === undefined) {\n          // Incomplete snapshot, that can't be used\n          continue optimizationEntries;\n        }\n\n        let commonMap;\n\n        if (this._isSet) {\n          commonMap = new Set();\n          const set =\n          /** @type {Set<string>} */\n          snapshotEntries;\n\n          if (capturedFiles.size < set.size) {\n            for (const path of capturedFiles) {\n              if (set.has(path)) commonMap.add(path);\n            }\n          } else {\n            for (const path of set) {\n              if (capturedFiles.has(path)) commonMap.add(path);\n            }\n          }\n        } else {\n          commonMap = new Map();\n          const map =\n          /** @type {Map<string, T>} */\n          snapshotEntries;\n\n          for (const path of capturedFiles) {\n            const ts = map.get(path);\n            if (ts === undefined) continue;\n            commonMap.set(path, ts);\n          }\n        }\n\n        if (commonMap.size < MIN_COMMON_SNAPSHOT_SIZE) {\n          // Common part it too small\n          continue optimizationEntries;\n        } // Create and attach snapshot\n\n\n        const commonSnapshot = new Snapshot();\n\n        if (this._useStartTime) {\n          commonSnapshot.setMergedStartTime(newSnapshot.startTime, snapshot);\n        }\n\n        this._set(commonSnapshot, commonMap);\n\n        newSnapshot.addChild(commonSnapshot);\n        snapshot.addChild(commonSnapshot); // Remove files from snapshot\n\n        for (const path of commonMap.keys()) snapshotEntries.delete(path);\n\n        const sharedCount = commonMap.size;\n        this._statItemsUnshared -= sharedCount;\n        this._statItemsShared += sharedCount; // Create optimization entry\n\n        storeOptimizationEntry({\n          snapshot: commonSnapshot,\n          shared: 2,\n          snapshotContent: new Set(commonMap.keys()),\n          children: undefined\n        });\n        this._statSharedSnapshots++;\n      }\n    }\n\n    const unshared = capturedFiles.size;\n    this._statItemsUnshared += unshared;\n    this._statItemsShared += capturedFilesSize - unshared;\n  }\n\n}\n\nconst parseString = str => {\n  if (str[0] === \"'\") str = `\"${str.slice(1, -1).replace(/\"/g, '\\\\\"')}\"`;\n  return JSON.parse(str);\n};\n/* istanbul ignore next */\n\n/**\n * @param {number} mtime mtime\n */\n\n\nconst applyMtime = mtime => {\n  if (FS_ACCURACY > 1 && mtime % 2 !== 0) FS_ACCURACY = 1;else if (FS_ACCURACY > 10 && mtime % 20 !== 0) FS_ACCURACY = 10;else if (FS_ACCURACY > 100 && mtime % 200 !== 0) FS_ACCURACY = 100;else if (FS_ACCURACY > 1000 && mtime % 2000 !== 0) FS_ACCURACY = 1000;\n};\n/**\n * @template T\n * @template K\n * @param {Map<T, K>} a source map\n * @param {Map<T, K>} b joining map\n * @returns {Map<T, K>} joined map\n */\n\n\nconst mergeMaps = (a, b) => {\n  if (!b || b.size === 0) return a;\n  if (!a || a.size === 0) return b;\n  const map = new Map(a);\n\n  for (const [key, value] of b) {\n    map.set(key, value);\n  }\n\n  return map;\n};\n/**\n * @template T\n * @template K\n * @param {Set<T, K>} a source map\n * @param {Set<T, K>} b joining map\n * @returns {Set<T, K>} joined map\n */\n\n\nconst mergeSets = (a, b) => {\n  if (!b || b.size === 0) return a;\n  if (!a || a.size === 0) return b;\n  const map = new Set(a);\n\n  for (const item of b) {\n    map.add(item);\n  }\n\n  return map;\n};\n/**\n * Finding file or directory to manage\n * @param {string} managedPath path that is managing by {@link FileSystemInfo}\n * @param {string} path path to file or directory\n * @returns {string|null} managed item\n * @example\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/package/index.js'\n * ) === '/Users/user/my-project/node_modules/package'\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/package1/node_modules/package2'\n * ) === '/Users/user/my-project/node_modules/package1/node_modules/package2'\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/.bin/script.js'\n * ) === null // hidden files are disallowed as managed items\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/package'\n * ) === '/Users/user/my-project/node_modules/package'\n */\n\n\nconst getManagedItem = (managedPath, path) => {\n  let i = managedPath.length;\n  let slashes = 1;\n  let startingPosition = true;\n\n  loop: while (i < path.length) {\n    switch (path.charCodeAt(i)) {\n      case 47: // slash\n\n      case 92:\n        // backslash\n        if (--slashes === 0) break loop;\n        startingPosition = true;\n        break;\n\n      case 46:\n        // .\n        // hidden files are disallowed as managed items\n        // it's probably .yarn-integrity or .cache\n        if (startingPosition) return null;\n        break;\n\n      case 64:\n        // @\n        if (!startingPosition) return null;\n        slashes++;\n        break;\n\n      default:\n        startingPosition = false;\n        break;\n    }\n\n    i++;\n  }\n\n  if (i === path.length) slashes--; // return null when path is incomplete\n\n  if (slashes !== 0) return null; // if (path.slice(i + 1, i + 13) === \"node_modules\")\n\n  if (path.length >= i + 13 && path.charCodeAt(i + 1) === 110 && path.charCodeAt(i + 2) === 111 && path.charCodeAt(i + 3) === 100 && path.charCodeAt(i + 4) === 101 && path.charCodeAt(i + 5) === 95 && path.charCodeAt(i + 6) === 109 && path.charCodeAt(i + 7) === 111 && path.charCodeAt(i + 8) === 100 && path.charCodeAt(i + 9) === 117 && path.charCodeAt(i + 10) === 108 && path.charCodeAt(i + 11) === 101 && path.charCodeAt(i + 12) === 115) {\n    // if this is the end of the path\n    if (path.length === i + 13) {\n      // return the node_modules directory\n      // it's special\n      return path;\n    }\n\n    const c = path.charCodeAt(i + 13); // if next symbol is slash or backslash\n\n    if (c === 47 || c === 92) {\n      // Managed subpath\n      return getManagedItem(path.slice(0, i + 14), path);\n    }\n  }\n\n  return path.slice(0, i);\n};\n/**\n * @template {ContextFileSystemInfoEntry | ContextTimestampAndHash} T\n * @param {T} entry entry\n * @returns {T[\"resolved\"] | undefined} the resolved entry\n */\n\n\nconst getResolvedTimestamp = entry => {\n  if (entry === null) return null;\n  if (entry.resolved !== undefined) return entry.resolved;\n  return entry.symlinks === undefined ? entry : undefined;\n};\n/**\n * @param {ContextHash} entry entry\n * @returns {string | undefined} the resolved entry\n */\n\n\nconst getResolvedHash = entry => {\n  if (entry === null) return null;\n  if (entry.resolved !== undefined) return entry.resolved;\n  return entry.symlinks === undefined ? entry.hash : undefined;\n};\n\nconst addAll = (source, target) => {\n  for (const key of source) target.add(key);\n};\n/**\n * Used to access information about the filesystem in a cached way\n */\n\n\nclass FileSystemInfo {\n  /**\n   * @param {InputFileSystem} fs file system\n   * @param {Object} options options\n   * @param {Iterable<string | RegExp>=} options.managedPaths paths that are only managed by a package manager\n   * @param {Iterable<string | RegExp>=} options.immutablePaths paths that are immutable\n   * @param {Logger=} options.logger logger used to log invalid snapshots\n   * @param {string | Hash=} options.hashFunction the hash function to use\n   */\n  constructor(fs) {\n    let {\n      managedPaths = [],\n      immutablePaths = [],\n      logger,\n      hashFunction = \"md4\"\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.fs = fs;\n    this.logger = logger;\n    this._remainingLogs = logger ? 40 : 0;\n    this._loggedPaths = logger ? new Set() : undefined;\n    this._hashFunction = hashFunction;\n    /** @type {WeakMap<Snapshot, boolean | (function(WebpackError=, boolean=): void)[]>} */\n\n    this._snapshotCache = new WeakMap();\n    this._fileTimestampsOptimization = new SnapshotOptimization(s => s.hasFileTimestamps(), s => s.fileTimestamps, (s, v) => s.setFileTimestamps(v));\n    this._fileHashesOptimization = new SnapshotOptimization(s => s.hasFileHashes(), s => s.fileHashes, (s, v) => s.setFileHashes(v), false);\n    this._fileTshsOptimization = new SnapshotOptimization(s => s.hasFileTshs(), s => s.fileTshs, (s, v) => s.setFileTshs(v));\n    this._contextTimestampsOptimization = new SnapshotOptimization(s => s.hasContextTimestamps(), s => s.contextTimestamps, (s, v) => s.setContextTimestamps(v));\n    this._contextHashesOptimization = new SnapshotOptimization(s => s.hasContextHashes(), s => s.contextHashes, (s, v) => s.setContextHashes(v), false);\n    this._contextTshsOptimization = new SnapshotOptimization(s => s.hasContextTshs(), s => s.contextTshs, (s, v) => s.setContextTshs(v));\n    this._missingExistenceOptimization = new SnapshotOptimization(s => s.hasMissingExistence(), s => s.missingExistence, (s, v) => s.setMissingExistence(v), false);\n    this._managedItemInfoOptimization = new SnapshotOptimization(s => s.hasManagedItemInfo(), s => s.managedItemInfo, (s, v) => s.setManagedItemInfo(v), false);\n    this._managedFilesOptimization = new SnapshotOptimization(s => s.hasManagedFiles(), s => s.managedFiles, (s, v) => s.setManagedFiles(v), false, true);\n    this._managedContextsOptimization = new SnapshotOptimization(s => s.hasManagedContexts(), s => s.managedContexts, (s, v) => s.setManagedContexts(v), false, true);\n    this._managedMissingOptimization = new SnapshotOptimization(s => s.hasManagedMissing(), s => s.managedMissing, (s, v) => s.setManagedMissing(v), false, true);\n    /** @type {StackedCacheMap<string, FileSystemInfoEntry | \"ignore\" | null>} */\n\n    this._fileTimestamps = new StackedCacheMap();\n    /** @type {Map<string, string>} */\n\n    this._fileHashes = new Map();\n    /** @type {Map<string, TimestampAndHash | string>} */\n\n    this._fileTshs = new Map();\n    /** @type {StackedCacheMap<string, ContextFileSystemInfoEntry | \"ignore\" | null>} */\n\n    this._contextTimestamps = new StackedCacheMap();\n    /** @type {Map<string, ContextHash>} */\n\n    this._contextHashes = new Map();\n    /** @type {Map<string, ContextTimestampAndHash>} */\n\n    this._contextTshs = new Map();\n    /** @type {Map<string, string>} */\n\n    this._managedItems = new Map();\n    /** @type {AsyncQueue<string, string, FileSystemInfoEntry | null>} */\n\n    this.fileTimestampQueue = new AsyncQueue({\n      name: \"file timestamp\",\n      parallelism: 30,\n      processor: this._readFileTimestamp.bind(this)\n    });\n    /** @type {AsyncQueue<string, string, string | null>} */\n\n    this.fileHashQueue = new AsyncQueue({\n      name: \"file hash\",\n      parallelism: 10,\n      processor: this._readFileHash.bind(this)\n    });\n    /** @type {AsyncQueue<string, string, ContextFileSystemInfoEntry | null>} */\n\n    this.contextTimestampQueue = new AsyncQueue({\n      name: \"context timestamp\",\n      parallelism: 2,\n      processor: this._readContextTimestamp.bind(this)\n    });\n    /** @type {AsyncQueue<string, string, ContextHash | null>} */\n\n    this.contextHashQueue = new AsyncQueue({\n      name: \"context hash\",\n      parallelism: 2,\n      processor: this._readContextHash.bind(this)\n    });\n    /** @type {AsyncQueue<string, string, ContextTimestampAndHash | null>} */\n\n    this.contextTshQueue = new AsyncQueue({\n      name: \"context hash and timestamp\",\n      parallelism: 2,\n      processor: this._readContextTimestampAndHash.bind(this)\n    });\n    /** @type {AsyncQueue<string, string, string | null>} */\n\n    this.managedItemQueue = new AsyncQueue({\n      name: \"managed item info\",\n      parallelism: 10,\n      processor: this._getManagedItemInfo.bind(this)\n    });\n    /** @type {AsyncQueue<string, string, Set<string>>} */\n\n    this.managedItemDirectoryQueue = new AsyncQueue({\n      name: \"managed item directory info\",\n      parallelism: 10,\n      processor: this._getManagedItemDirectoryInfo.bind(this)\n    });\n    this.managedPaths = Array.from(managedPaths);\n    this.managedPathsWithSlash =\n    /** @type {string[]} */\n    this.managedPaths.filter(p => typeof p === \"string\").map(p => join(fs, p, \"_\").slice(0, -1));\n    this.managedPathsRegExps =\n    /** @type {RegExp[]} */\n    this.managedPaths.filter(p => typeof p !== \"string\");\n    this.immutablePaths = Array.from(immutablePaths);\n    this.immutablePathsWithSlash =\n    /** @type {string[]} */\n    this.immutablePaths.filter(p => typeof p === \"string\").map(p => join(fs, p, \"_\").slice(0, -1));\n    this.immutablePathsRegExps =\n    /** @type {RegExp[]} */\n    this.immutablePaths.filter(p => typeof p !== \"string\");\n    this._cachedDeprecatedFileTimestamps = undefined;\n    this._cachedDeprecatedContextTimestamps = undefined;\n    this._warnAboutExperimentalEsmTracking = false;\n    this._statCreatedSnapshots = 0;\n    this._statTestedSnapshotsCached = 0;\n    this._statTestedSnapshotsNotCached = 0;\n    this._statTestedChildrenCached = 0;\n    this._statTestedChildrenNotCached = 0;\n    this._statTestedEntries = 0;\n  }\n\n  logStatistics() {\n    const logWhenMessage = (header, message) => {\n      if (message) {\n        this.logger.log(`${header}: ${message}`);\n      }\n    };\n\n    this.logger.log(`${this._statCreatedSnapshots} new snapshots created`);\n    this.logger.log(`${this._statTestedSnapshotsNotCached && Math.round(this._statTestedSnapshotsNotCached * 100 / (this._statTestedSnapshotsCached + this._statTestedSnapshotsNotCached))}% root snapshot uncached (${this._statTestedSnapshotsNotCached} / ${this._statTestedSnapshotsCached + this._statTestedSnapshotsNotCached})`);\n    this.logger.log(`${this._statTestedChildrenNotCached && Math.round(this._statTestedChildrenNotCached * 100 / (this._statTestedChildrenCached + this._statTestedChildrenNotCached))}% children snapshot uncached (${this._statTestedChildrenNotCached} / ${this._statTestedChildrenCached + this._statTestedChildrenNotCached})`);\n    this.logger.log(`${this._statTestedEntries} entries tested`);\n    this.logger.log(`File info in cache: ${this._fileTimestamps.size} timestamps ${this._fileHashes.size} hashes ${this._fileTshs.size} timestamp hash combinations`);\n    logWhenMessage(`File timestamp snapshot optimization`, this._fileTimestampsOptimization.getStatisticMessage());\n    logWhenMessage(`File hash snapshot optimization`, this._fileHashesOptimization.getStatisticMessage());\n    logWhenMessage(`File timestamp hash combination snapshot optimization`, this._fileTshsOptimization.getStatisticMessage());\n    this.logger.log(`Directory info in cache: ${this._contextTimestamps.size} timestamps ${this._contextHashes.size} hashes ${this._contextTshs.size} timestamp hash combinations`);\n    logWhenMessage(`Directory timestamp snapshot optimization`, this._contextTimestampsOptimization.getStatisticMessage());\n    logWhenMessage(`Directory hash snapshot optimization`, this._contextHashesOptimization.getStatisticMessage());\n    logWhenMessage(`Directory timestamp hash combination snapshot optimization`, this._contextTshsOptimization.getStatisticMessage());\n    logWhenMessage(`Missing items snapshot optimization`, this._missingExistenceOptimization.getStatisticMessage());\n    this.logger.log(`Managed items info in cache: ${this._managedItems.size} items`);\n    logWhenMessage(`Managed items snapshot optimization`, this._managedItemInfoOptimization.getStatisticMessage());\n    logWhenMessage(`Managed files snapshot optimization`, this._managedFilesOptimization.getStatisticMessage());\n    logWhenMessage(`Managed contexts snapshot optimization`, this._managedContextsOptimization.getStatisticMessage());\n    logWhenMessage(`Managed missing snapshot optimization`, this._managedMissingOptimization.getStatisticMessage());\n  }\n\n  _log(path, reason) {\n    const key = path + reason;\n    if (this._loggedPaths.has(key)) return;\n\n    this._loggedPaths.add(key);\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    this.logger.debug(`${path} invalidated because ${reason}`, ...args);\n\n    if (--this._remainingLogs === 0) {\n      this.logger.debug(\"Logging limit has been reached and no further logging will be emitted by FileSystemInfo\");\n    }\n  }\n\n  clear() {\n    this._remainingLogs = this.logger ? 40 : 0;\n    if (this._loggedPaths !== undefined) this._loggedPaths.clear();\n    this._snapshotCache = new WeakMap();\n\n    this._fileTimestampsOptimization.clear();\n\n    this._fileHashesOptimization.clear();\n\n    this._fileTshsOptimization.clear();\n\n    this._contextTimestampsOptimization.clear();\n\n    this._contextHashesOptimization.clear();\n\n    this._contextTshsOptimization.clear();\n\n    this._missingExistenceOptimization.clear();\n\n    this._managedItemInfoOptimization.clear();\n\n    this._managedFilesOptimization.clear();\n\n    this._managedContextsOptimization.clear();\n\n    this._managedMissingOptimization.clear();\n\n    this._fileTimestamps.clear();\n\n    this._fileHashes.clear();\n\n    this._fileTshs.clear();\n\n    this._contextTimestamps.clear();\n\n    this._contextHashes.clear();\n\n    this._contextTshs.clear();\n\n    this._managedItems.clear();\n\n    this._managedItems.clear();\n\n    this._cachedDeprecatedFileTimestamps = undefined;\n    this._cachedDeprecatedContextTimestamps = undefined;\n    this._statCreatedSnapshots = 0;\n    this._statTestedSnapshotsCached = 0;\n    this._statTestedSnapshotsNotCached = 0;\n    this._statTestedChildrenCached = 0;\n    this._statTestedChildrenNotCached = 0;\n    this._statTestedEntries = 0;\n  }\n  /**\n   * @param {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} map timestamps\n   * @param {boolean=} immutable if 'map' is immutable and FileSystemInfo can keep referencing it\n   * @returns {void}\n   */\n\n\n  addFileTimestamps(map, immutable) {\n    this._fileTimestamps.addAll(map, immutable);\n\n    this._cachedDeprecatedFileTimestamps = undefined;\n  }\n  /**\n   * @param {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} map timestamps\n   * @param {boolean=} immutable if 'map' is immutable and FileSystemInfo can keep referencing it\n   * @returns {void}\n   */\n\n\n  addContextTimestamps(map, immutable) {\n    this._contextTimestamps.addAll(map, immutable);\n\n    this._cachedDeprecatedContextTimestamps = undefined;\n  }\n  /**\n   * @param {string} path file path\n   * @param {function((WebpackError | null)=, (FileSystemInfoEntry | \"ignore\" | null)=): void} callback callback function\n   * @returns {void}\n   */\n\n\n  getFileTimestamp(path, callback) {\n    const cache = this._fileTimestamps.get(path);\n\n    if (cache !== undefined) return callback(null, cache);\n    this.fileTimestampQueue.add(path, callback);\n  }\n  /**\n   * @param {string} path context path\n   * @param {function((WebpackError | null)=, (ResolvedContextFileSystemInfoEntry | \"ignore\" | null)=): void} callback callback function\n   * @returns {void}\n   */\n\n\n  getContextTimestamp(path, callback) {\n    const cache = this._contextTimestamps.get(path);\n\n    if (cache !== undefined) {\n      if (cache === \"ignore\") return callback(null, \"ignore\");\n      const resolved = getResolvedTimestamp(cache);\n      if (resolved !== undefined) return callback(null, resolved);\n      return this._resolveContextTimestamp(cache, callback);\n    }\n\n    this.contextTimestampQueue.add(path, (err, entry) => {\n      if (err) return callback(err);\n      const resolved = getResolvedTimestamp(entry);\n      if (resolved !== undefined) return callback(null, resolved);\n\n      this._resolveContextTimestamp(entry, callback);\n    });\n  }\n  /**\n   * @param {string} path context path\n   * @param {function((WebpackError | null)=, (ContextFileSystemInfoEntry | \"ignore\" | null)=): void} callback callback function\n   * @returns {void}\n   */\n\n\n  _getUnresolvedContextTimestamp(path, callback) {\n    const cache = this._contextTimestamps.get(path);\n\n    if (cache !== undefined) return callback(null, cache);\n    this.contextTimestampQueue.add(path, callback);\n  }\n  /**\n   * @param {string} path file path\n   * @param {function((WebpackError | null)=, string=): void} callback callback function\n   * @returns {void}\n   */\n\n\n  getFileHash(path, callback) {\n    const cache = this._fileHashes.get(path);\n\n    if (cache !== undefined) return callback(null, cache);\n    this.fileHashQueue.add(path, callback);\n  }\n  /**\n   * @param {string} path context path\n   * @param {function((WebpackError | null)=, string=): void} callback callback function\n   * @returns {void}\n   */\n\n\n  getContextHash(path, callback) {\n    const cache = this._contextHashes.get(path);\n\n    if (cache !== undefined) {\n      const resolved = getResolvedHash(cache);\n      if (resolved !== undefined) return callback(null, resolved);\n      return this._resolveContextHash(cache, callback);\n    }\n\n    this.contextHashQueue.add(path, (err, entry) => {\n      if (err) return callback(err);\n      const resolved = getResolvedHash(entry);\n      if (resolved !== undefined) return callback(null, resolved);\n\n      this._resolveContextHash(entry, callback);\n    });\n  }\n  /**\n   * @param {string} path context path\n   * @param {function((WebpackError | null)=, ContextHash=): void} callback callback function\n   * @returns {void}\n   */\n\n\n  _getUnresolvedContextHash(path, callback) {\n    const cache = this._contextHashes.get(path);\n\n    if (cache !== undefined) return callback(null, cache);\n    this.contextHashQueue.add(path, callback);\n  }\n  /**\n   * @param {string} path context path\n   * @param {function((WebpackError | null)=, ResolvedContextTimestampAndHash=): void} callback callback function\n   * @returns {void}\n   */\n\n\n  getContextTsh(path, callback) {\n    const cache = this._contextTshs.get(path);\n\n    if (cache !== undefined) {\n      const resolved = getResolvedTimestamp(cache);\n      if (resolved !== undefined) return callback(null, resolved);\n      return this._resolveContextTsh(cache, callback);\n    }\n\n    this.contextTshQueue.add(path, (err, entry) => {\n      if (err) return callback(err);\n      const resolved = getResolvedTimestamp(entry);\n      if (resolved !== undefined) return callback(null, resolved);\n\n      this._resolveContextTsh(entry, callback);\n    });\n  }\n  /**\n   * @param {string} path context path\n   * @param {function((WebpackError | null)=, ContextTimestampAndHash=): void} callback callback function\n   * @returns {void}\n   */\n\n\n  _getUnresolvedContextTsh(path, callback) {\n    const cache = this._contextTshs.get(path);\n\n    if (cache !== undefined) return callback(null, cache);\n    this.contextTshQueue.add(path, callback);\n  }\n\n  _createBuildDependenciesResolvers() {\n    const resolveContext = createResolver({\n      resolveToContext: true,\n      exportsFields: [],\n      fileSystem: this.fs\n    });\n    const resolveCjs = createResolver({\n      extensions: [\".js\", \".json\", \".node\"],\n      conditionNames: [\"require\", \"node\"],\n      exportsFields: [\"exports\"],\n      fileSystem: this.fs\n    });\n    const resolveCjsAsChild = createResolver({\n      extensions: [\".js\", \".json\", \".node\"],\n      conditionNames: [\"require\", \"node\"],\n      exportsFields: [],\n      fileSystem: this.fs\n    });\n    const resolveEsm = createResolver({\n      extensions: [\".js\", \".json\", \".node\"],\n      fullySpecified: true,\n      conditionNames: [\"import\", \"node\"],\n      exportsFields: [\"exports\"],\n      fileSystem: this.fs\n    });\n    return {\n      resolveContext,\n      resolveEsm,\n      resolveCjs,\n      resolveCjsAsChild\n    };\n  }\n  /**\n   * @param {string} context context directory\n   * @param {Iterable<string>} deps dependencies\n   * @param {function((Error | null)=, ResolveBuildDependenciesResult=): void} callback callback function\n   * @returns {void}\n   */\n\n\n  resolveBuildDependencies(context, deps, callback) {\n    const {\n      resolveContext,\n      resolveEsm,\n      resolveCjs,\n      resolveCjsAsChild\n    } = this._createBuildDependenciesResolvers();\n    /** @type {Set<string>} */\n\n\n    const files = new Set();\n    /** @type {Set<string>} */\n\n    const fileSymlinks = new Set();\n    /** @type {Set<string>} */\n\n    const directories = new Set();\n    /** @type {Set<string>} */\n\n    const directorySymlinks = new Set();\n    /** @type {Set<string>} */\n\n    const missing = new Set();\n    /** @type {Set<string>} */\n\n    const resolveFiles = new Set();\n    /** @type {Set<string>} */\n\n    const resolveDirectories = new Set();\n    /** @type {Set<string>} */\n\n    const resolveMissing = new Set();\n    /** @type {Map<string, string | false>} */\n\n    const resolveResults = new Map();\n    const invalidResolveResults = new Set();\n    const resolverContext = {\n      fileDependencies: resolveFiles,\n      contextDependencies: resolveDirectories,\n      missingDependencies: resolveMissing\n    };\n\n    const expectedToString = expected => {\n      return expected ? ` (expected ${expected})` : \"\";\n    };\n\n    const jobToString = job => {\n      switch (job.type) {\n        case RBDT_RESOLVE_CJS:\n          return `resolve commonjs ${job.path}${expectedToString(job.expected)}`;\n\n        case RBDT_RESOLVE_ESM:\n          return `resolve esm ${job.path}${expectedToString(job.expected)}`;\n\n        case RBDT_RESOLVE_DIRECTORY:\n          return `resolve directory ${job.path}`;\n\n        case RBDT_RESOLVE_CJS_FILE:\n          return `resolve commonjs file ${job.path}${expectedToString(job.expected)}`;\n\n        case RBDT_RESOLVE_ESM_FILE:\n          return `resolve esm file ${job.path}${expectedToString(job.expected)}`;\n\n        case RBDT_DIRECTORY:\n          return `directory ${job.path}`;\n\n        case RBDT_FILE:\n          return `file ${job.path}`;\n\n        case RBDT_DIRECTORY_DEPENDENCIES:\n          return `directory dependencies ${job.path}`;\n\n        case RBDT_FILE_DEPENDENCIES:\n          return `file dependencies ${job.path}`;\n      }\n\n      return `unknown ${job.type} ${job.path}`;\n    };\n\n    const pathToString = job => {\n      let result = ` at ${jobToString(job)}`;\n      job = job.issuer;\n\n      while (job !== undefined) {\n        result += `\\n at ${jobToString(job)}`;\n        job = job.issuer;\n      }\n\n      return result;\n    };\n\n    processAsyncTree(Array.from(deps, dep => ({\n      type: RBDT_RESOLVE_CJS,\n      context,\n      path: dep,\n      expected: undefined,\n      issuer: undefined\n    })), 20, (job, push, callback) => {\n      const {\n        type,\n        context,\n        path,\n        expected\n      } = job;\n\n      const resolveDirectory = path => {\n        const key = `d\\n${context}\\n${path}`;\n\n        if (resolveResults.has(key)) {\n          return callback();\n        }\n\n        resolveResults.set(key, undefined);\n        resolveContext(context, path, resolverContext, (err, _, result) => {\n          if (err) {\n            if (expected === false) {\n              resolveResults.set(key, false);\n              return callback();\n            }\n\n            invalidResolveResults.add(key);\n            err.message += `\\nwhile resolving '${path}' in ${context} to a directory`;\n            return callback(err);\n          }\n\n          const resultPath = result.path;\n          resolveResults.set(key, resultPath);\n          push({\n            type: RBDT_DIRECTORY,\n            context: undefined,\n            path: resultPath,\n            expected: undefined,\n            issuer: job\n          });\n          callback();\n        });\n      };\n\n      const resolveFile = (path, symbol, resolve) => {\n        const key = `${symbol}\\n${context}\\n${path}`;\n\n        if (resolveResults.has(key)) {\n          return callback();\n        }\n\n        resolveResults.set(key, undefined);\n        resolve(context, path, resolverContext, (err, _, result) => {\n          if (typeof expected === \"string\") {\n            if (!err && result && result.path === expected) {\n              resolveResults.set(key, result.path);\n            } else {\n              invalidResolveResults.add(key);\n              this.logger.warn(`Resolving '${path}' in ${context} for build dependencies doesn't lead to expected result '${expected}', but to '${err || result && result.path}' instead. Resolving dependencies are ignored for this path.\\n${pathToString(job)}`);\n            }\n          } else {\n            if (err) {\n              if (expected === false) {\n                resolveResults.set(key, false);\n                return callback();\n              }\n\n              invalidResolveResults.add(key);\n              err.message += `\\nwhile resolving '${path}' in ${context} as file\\n${pathToString(job)}`;\n              return callback(err);\n            }\n\n            const resultPath = result.path;\n            resolveResults.set(key, resultPath);\n            push({\n              type: RBDT_FILE,\n              context: undefined,\n              path: resultPath,\n              expected: undefined,\n              issuer: job\n            });\n          }\n\n          callback();\n        });\n      };\n\n      switch (type) {\n        case RBDT_RESOLVE_CJS:\n          {\n            const isDirectory = /[\\\\/]$/.test(path);\n\n            if (isDirectory) {\n              resolveDirectory(path.slice(0, path.length - 1));\n            } else {\n              resolveFile(path, \"f\", resolveCjs);\n            }\n\n            break;\n          }\n\n        case RBDT_RESOLVE_ESM:\n          {\n            const isDirectory = /[\\\\/]$/.test(path);\n\n            if (isDirectory) {\n              resolveDirectory(path.slice(0, path.length - 1));\n            } else {\n              resolveFile(path);\n            }\n\n            break;\n          }\n\n        case RBDT_RESOLVE_DIRECTORY:\n          {\n            resolveDirectory(path);\n            break;\n          }\n\n        case RBDT_RESOLVE_CJS_FILE:\n          {\n            resolveFile(path, \"f\", resolveCjs);\n            break;\n          }\n\n        case RBDT_RESOLVE_CJS_FILE_AS_CHILD:\n          {\n            resolveFile(path, \"c\", resolveCjsAsChild);\n            break;\n          }\n\n        case RBDT_RESOLVE_ESM_FILE:\n          {\n            resolveFile(path, \"e\", resolveEsm);\n            break;\n          }\n\n        case RBDT_FILE:\n          {\n            if (files.has(path)) {\n              callback();\n              break;\n            }\n\n            files.add(path);\n            this.fs.realpath(path, (err, _realPath) => {\n              if (err) return callback(err);\n              const realPath =\n              /** @type {string} */\n              _realPath;\n\n              if (realPath !== path) {\n                fileSymlinks.add(path);\n                resolveFiles.add(path);\n                if (files.has(realPath)) return callback();\n                files.add(realPath);\n              }\n\n              push({\n                type: RBDT_FILE_DEPENDENCIES,\n                context: undefined,\n                path: realPath,\n                expected: undefined,\n                issuer: job\n              });\n              callback();\n            });\n            break;\n          }\n\n        case RBDT_DIRECTORY:\n          {\n            if (directories.has(path)) {\n              callback();\n              break;\n            }\n\n            directories.add(path);\n            this.fs.realpath(path, (err, _realPath) => {\n              if (err) return callback(err);\n              const realPath =\n              /** @type {string} */\n              _realPath;\n\n              if (realPath !== path) {\n                directorySymlinks.add(path);\n                resolveFiles.add(path);\n                if (directories.has(realPath)) return callback();\n                directories.add(realPath);\n              }\n\n              push({\n                type: RBDT_DIRECTORY_DEPENDENCIES,\n                context: undefined,\n                path: realPath,\n                expected: undefined,\n                issuer: job\n              });\n              callback();\n            });\n            break;\n          }\n\n        case RBDT_FILE_DEPENDENCIES:\n          {\n            // Check for known files without dependencies\n            if (/\\.json5?$|\\.yarn-integrity$|yarn\\.lock$|\\.ya?ml/.test(path)) {\n              process.nextTick(callback);\n              break;\n            } // Check commonjs cache for the module\n\n            /** @type {NodeModule} */\n\n\n            const module = require.cache[path];\n\n            if (module && Array.isArray(module.children)) {\n              children: for (const child of module.children) {\n                let childPath = child.filename;\n\n                if (childPath) {\n                  push({\n                    type: RBDT_FILE,\n                    context: undefined,\n                    path: childPath,\n                    expected: undefined,\n                    issuer: job\n                  });\n                  const context = dirname(this.fs, path);\n\n                  for (const modulePath of module.paths) {\n                    if (childPath.startsWith(modulePath)) {\n                      let subPath = childPath.slice(modulePath.length + 1);\n                      const packageMatch = /^(@[^\\\\/]+[\\\\/])[^\\\\/]+/.exec(subPath);\n\n                      if (packageMatch) {\n                        push({\n                          type: RBDT_FILE,\n                          context: undefined,\n                          path: modulePath + childPath[modulePath.length] + packageMatch[0] + childPath[modulePath.length] + \"package.json\",\n                          expected: false,\n                          issuer: job\n                        });\n                      }\n\n                      let request = subPath.replace(/\\\\/g, \"/\");\n                      if (request.endsWith(\".js\")) request = request.slice(0, -3);\n                      push({\n                        type: RBDT_RESOLVE_CJS_FILE_AS_CHILD,\n                        context,\n                        path: request,\n                        expected: child.filename,\n                        issuer: job\n                      });\n                      continue children;\n                    }\n                  }\n\n                  let request = relative(this.fs, context, childPath);\n                  if (request.endsWith(\".js\")) request = request.slice(0, -3);\n                  request = request.replace(/\\\\/g, \"/\");\n                  if (!request.startsWith(\"../\")) request = `./${request}`;\n                  push({\n                    type: RBDT_RESOLVE_CJS_FILE,\n                    context,\n                    path: request,\n                    expected: child.filename,\n                    issuer: job\n                  });\n                }\n              }\n            } else if (supportsEsm && /\\.m?js$/.test(path)) {\n              if (!this._warnAboutExperimentalEsmTracking) {\n                this.logger.log(\"Node.js doesn't offer a (nice) way to introspect the ESM dependency graph yet.\\n\" + \"Until a full solution is available webpack uses an experimental ESM tracking based on parsing.\\n\" + \"As best effort webpack parses the ESM files to guess dependencies. But this can lead to expensive and incorrect tracking.\");\n                this._warnAboutExperimentalEsmTracking = true;\n              }\n\n              const lexer = require(\"es-module-lexer\");\n\n              lexer.init.then(() => {\n                this.fs.readFile(path, (err, content) => {\n                  if (err) return callback(err);\n\n                  try {\n                    const context = dirname(this.fs, path);\n                    const source = content.toString();\n                    const [imports] = lexer.parse(source);\n\n                    for (const imp of imports) {\n                      try {\n                        let dependency;\n\n                        if (imp.d === -1) {\n                          // import ... from \"...\"\n                          dependency = parseString(source.substring(imp.s - 1, imp.e + 1));\n                        } else if (imp.d > -1) {\n                          // import()\n                          let expr = source.substring(imp.s, imp.e).trim();\n                          dependency = parseString(expr);\n                        } else {\n                          // e.g. import.meta\n                          continue;\n                        }\n\n                        push({\n                          type: RBDT_RESOLVE_ESM_FILE,\n                          context,\n                          path: dependency,\n                          expected: undefined,\n                          issuer: job\n                        });\n                      } catch (e) {\n                        this.logger.warn(`Parsing of ${path} for build dependencies failed at 'import(${source.substring(imp.s, imp.e)})'.\\n` + \"Build dependencies behind this expression are ignored and might cause incorrect cache invalidation.\");\n                        this.logger.debug(pathToString(job));\n                        this.logger.debug(e.stack);\n                      }\n                    }\n                  } catch (e) {\n                    this.logger.warn(`Parsing of ${path} for build dependencies failed and all dependencies of this file are ignored, which might cause incorrect cache invalidation..`);\n                    this.logger.debug(pathToString(job));\n                    this.logger.debug(e.stack);\n                  }\n\n                  process.nextTick(callback);\n                });\n              }, callback);\n              break;\n            } else {\n              this.logger.log(`Assuming ${path} has no dependencies as we were unable to assign it to any module system.`);\n              this.logger.debug(pathToString(job));\n            }\n\n            process.nextTick(callback);\n            break;\n          }\n\n        case RBDT_DIRECTORY_DEPENDENCIES:\n          {\n            const match = /(^.+[\\\\/]node_modules[\\\\/](?:@[^\\\\/]+[\\\\/])?[^\\\\/]+)/.exec(path);\n            const packagePath = match ? match[1] : path;\n            const packageJson = join(this.fs, packagePath, \"package.json\");\n            this.fs.readFile(packageJson, (err, content) => {\n              if (err) {\n                if (err.code === \"ENOENT\") {\n                  resolveMissing.add(packageJson);\n                  const parent = dirname(this.fs, packagePath);\n\n                  if (parent !== packagePath) {\n                    push({\n                      type: RBDT_DIRECTORY_DEPENDENCIES,\n                      context: undefined,\n                      path: parent,\n                      expected: undefined,\n                      issuer: job\n                    });\n                  }\n\n                  callback();\n                  return;\n                }\n\n                return callback(err);\n              }\n\n              resolveFiles.add(packageJson);\n              let packageData;\n\n              try {\n                packageData = JSON.parse(content.toString(\"utf-8\"));\n              } catch (e) {\n                return callback(e);\n              }\n\n              const depsObject = packageData.dependencies;\n              const optionalDepsObject = packageData.optionalDependencies;\n              const allDeps = new Set();\n              const optionalDeps = new Set();\n\n              if (typeof depsObject === \"object\" && depsObject) {\n                for (const dep of Object.keys(depsObject)) {\n                  allDeps.add(dep);\n                }\n              }\n\n              if (typeof optionalDepsObject === \"object\" && optionalDepsObject) {\n                for (const dep of Object.keys(optionalDepsObject)) {\n                  allDeps.add(dep);\n                  optionalDeps.add(dep);\n                }\n              }\n\n              for (const dep of allDeps) {\n                push({\n                  type: RBDT_RESOLVE_DIRECTORY,\n                  context: packagePath,\n                  path: dep,\n                  expected: !optionalDeps.has(dep),\n                  issuer: job\n                });\n              }\n\n              callback();\n            });\n            break;\n          }\n      }\n    }, err => {\n      if (err) return callback(err);\n\n      for (const l of fileSymlinks) files.delete(l);\n\n      for (const l of directorySymlinks) directories.delete(l);\n\n      for (const k of invalidResolveResults) resolveResults.delete(k);\n\n      callback(null, {\n        files,\n        directories,\n        missing,\n        resolveResults,\n        resolveDependencies: {\n          files: resolveFiles,\n          directories: resolveDirectories,\n          missing: resolveMissing\n        }\n      });\n    });\n  }\n  /**\n   * @param {Map<string, string | false>} resolveResults results from resolving\n   * @param {function((Error | null)=, boolean=): void} callback callback with true when resolveResults resolve the same way\n   * @returns {void}\n   */\n\n\n  checkResolveResultsValid(resolveResults, callback) {\n    const {\n      resolveCjs,\n      resolveCjsAsChild,\n      resolveEsm,\n      resolveContext\n    } = this._createBuildDependenciesResolvers();\n\n    asyncLib.eachLimit(resolveResults, 20, (_ref3, callback) => {\n      let [key, expectedResult] = _ref3;\n      const [type, context, path] = key.split(\"\\n\");\n\n      switch (type) {\n        case \"d\":\n          resolveContext(context, path, {}, (err, _, result) => {\n            if (expectedResult === false) return callback(err ? undefined : INVALID);\n            if (err) return callback(err);\n            const resultPath = result.path;\n            if (resultPath !== expectedResult) return callback(INVALID);\n            callback();\n          });\n          break;\n\n        case \"f\":\n          resolveCjs(context, path, {}, (err, _, result) => {\n            if (expectedResult === false) return callback(err ? undefined : INVALID);\n            if (err) return callback(err);\n            const resultPath = result.path;\n            if (resultPath !== expectedResult) return callback(INVALID);\n            callback();\n          });\n          break;\n\n        case \"c\":\n          resolveCjsAsChild(context, path, {}, (err, _, result) => {\n            if (expectedResult === false) return callback(err ? undefined : INVALID);\n            if (err) return callback(err);\n            const resultPath = result.path;\n            if (resultPath !== expectedResult) return callback(INVALID);\n            callback();\n          });\n          break;\n\n        case \"e\":\n          resolveEsm(context, path, {}, (err, _, result) => {\n            if (expectedResult === false) return callback(err ? undefined : INVALID);\n            if (err) return callback(err);\n            const resultPath = result.path;\n            if (resultPath !== expectedResult) return callback(INVALID);\n            callback();\n          });\n          break;\n\n        default:\n          callback(new Error(\"Unexpected type in resolve result key\"));\n          break;\n      }\n    },\n    /**\n     * @param {Error | typeof INVALID=} err error or invalid flag\n     * @returns {void}\n     */\n    err => {\n      if (err === INVALID) {\n        return callback(null, false);\n      }\n\n      if (err) {\n        return callback(err);\n      }\n\n      return callback(null, true);\n    });\n  }\n  /**\n   *\n   * @param {number} startTime when processing the files has started\n   * @param {Iterable<string>} files all files\n   * @param {Iterable<string>} directories all directories\n   * @param {Iterable<string>} missing all missing files or directories\n   * @param {Object} options options object (for future extensions)\n   * @param {boolean=} options.hash should use hash to snapshot\n   * @param {boolean=} options.timestamp should use timestamp to snapshot\n   * @param {function((WebpackError | null)=, (Snapshot | null)=): void} callback callback function\n   * @returns {void}\n   */\n\n\n  createSnapshot(startTime, files, directories, missing, options, callback) {\n    /** @type {Map<string, FileSystemInfoEntry | null>} */\n    const fileTimestamps = new Map();\n    /** @type {Map<string, string | null>} */\n\n    const fileHashes = new Map();\n    /** @type {Map<string, TimestampAndHash | string | null>} */\n\n    const fileTshs = new Map();\n    /** @type {Map<string, FileSystemInfoEntry | null>} */\n\n    const contextTimestamps = new Map();\n    /** @type {Map<string, string | null>} */\n\n    const contextHashes = new Map();\n    /** @type {Map<string, ResolvedContextTimestampAndHash | null>} */\n\n    const contextTshs = new Map();\n    /** @type {Map<string, boolean>} */\n\n    const missingExistence = new Map();\n    /** @type {Map<string, string>} */\n\n    const managedItemInfo = new Map();\n    /** @type {Set<string>} */\n\n    const managedFiles = new Set();\n    /** @type {Set<string>} */\n\n    const managedContexts = new Set();\n    /** @type {Set<string>} */\n\n    const managedMissing = new Set();\n    /** @type {Set<Snapshot>} */\n\n    const children = new Set();\n    const snapshot = new Snapshot();\n    if (startTime) snapshot.setStartTime(startTime);\n    /** @type {Set<string>} */\n\n    const managedItems = new Set();\n    /** 1 = timestamp, 2 = hash, 3 = timestamp + hash */\n\n    const mode = options && options.hash ? options.timestamp ? 3 : 2 : 1;\n    let jobs = 1;\n\n    const jobDone = () => {\n      if (--jobs === 0) {\n        if (fileTimestamps.size !== 0) {\n          snapshot.setFileTimestamps(fileTimestamps);\n        }\n\n        if (fileHashes.size !== 0) {\n          snapshot.setFileHashes(fileHashes);\n        }\n\n        if (fileTshs.size !== 0) {\n          snapshot.setFileTshs(fileTshs);\n        }\n\n        if (contextTimestamps.size !== 0) {\n          snapshot.setContextTimestamps(contextTimestamps);\n        }\n\n        if (contextHashes.size !== 0) {\n          snapshot.setContextHashes(contextHashes);\n        }\n\n        if (contextTshs.size !== 0) {\n          snapshot.setContextTshs(contextTshs);\n        }\n\n        if (missingExistence.size !== 0) {\n          snapshot.setMissingExistence(missingExistence);\n        }\n\n        if (managedItemInfo.size !== 0) {\n          snapshot.setManagedItemInfo(managedItemInfo);\n        }\n\n        this._managedFilesOptimization.optimize(snapshot, managedFiles);\n\n        if (managedFiles.size !== 0) {\n          snapshot.setManagedFiles(managedFiles);\n        }\n\n        this._managedContextsOptimization.optimize(snapshot, managedContexts);\n\n        if (managedContexts.size !== 0) {\n          snapshot.setManagedContexts(managedContexts);\n        }\n\n        this._managedMissingOptimization.optimize(snapshot, managedMissing);\n\n        if (managedMissing.size !== 0) {\n          snapshot.setManagedMissing(managedMissing);\n        }\n\n        if (children.size !== 0) {\n          snapshot.setChildren(children);\n        }\n\n        this._snapshotCache.set(snapshot, true);\n\n        this._statCreatedSnapshots++;\n        callback(null, snapshot);\n      }\n    };\n\n    const jobError = () => {\n      if (jobs > 0) {\n        // large negative number instead of NaN or something else to keep jobs to stay a SMI (v8)\n        jobs = -100000000;\n        callback(null, null);\n      }\n    };\n\n    const checkManaged = (path, managedSet) => {\n      for (const immutablePath of this.immutablePathsRegExps) {\n        if (immutablePath.test(path)) {\n          managedSet.add(path);\n          return true;\n        }\n      }\n\n      for (const immutablePath of this.immutablePathsWithSlash) {\n        if (path.startsWith(immutablePath)) {\n          managedSet.add(path);\n          return true;\n        }\n      }\n\n      for (const managedPath of this.managedPathsRegExps) {\n        const match = managedPath.exec(path);\n\n        if (match) {\n          const managedItem = getManagedItem(match[1], path);\n\n          if (managedItem) {\n            managedItems.add(managedItem);\n            managedSet.add(path);\n            return true;\n          }\n        }\n      }\n\n      for (const managedPath of this.managedPathsWithSlash) {\n        if (path.startsWith(managedPath)) {\n          const managedItem = getManagedItem(managedPath, path);\n\n          if (managedItem) {\n            managedItems.add(managedItem);\n            managedSet.add(path);\n            return true;\n          }\n        }\n      }\n\n      return false;\n    };\n\n    const captureNonManaged = (items, managedSet) => {\n      const capturedItems = new Set();\n\n      for (const path of items) {\n        if (!checkManaged(path, managedSet)) capturedItems.add(path);\n      }\n\n      return capturedItems;\n    };\n\n    const processCapturedFiles = capturedFiles => {\n      switch (mode) {\n        case 3:\n          this._fileTshsOptimization.optimize(snapshot, capturedFiles);\n\n          for (const path of capturedFiles) {\n            const cache = this._fileTshs.get(path);\n\n            if (cache !== undefined) {\n              fileTshs.set(path, cache);\n            } else {\n              jobs++;\n\n              this._getFileTimestampAndHash(path, (err, entry) => {\n                if (err) {\n                  if (this.logger) {\n                    this.logger.debug(`Error snapshotting file timestamp hash combination of ${path}: ${err.stack}`);\n                  }\n\n                  jobError();\n                } else {\n                  fileTshs.set(path, entry);\n                  jobDone();\n                }\n              });\n            }\n          }\n\n          break;\n\n        case 2:\n          this._fileHashesOptimization.optimize(snapshot, capturedFiles);\n\n          for (const path of capturedFiles) {\n            const cache = this._fileHashes.get(path);\n\n            if (cache !== undefined) {\n              fileHashes.set(path, cache);\n            } else {\n              jobs++;\n              this.fileHashQueue.add(path, (err, entry) => {\n                if (err) {\n                  if (this.logger) {\n                    this.logger.debug(`Error snapshotting file hash of ${path}: ${err.stack}`);\n                  }\n\n                  jobError();\n                } else {\n                  fileHashes.set(path, entry);\n                  jobDone();\n                }\n              });\n            }\n          }\n\n          break;\n\n        case 1:\n          this._fileTimestampsOptimization.optimize(snapshot, capturedFiles);\n\n          for (const path of capturedFiles) {\n            const cache = this._fileTimestamps.get(path);\n\n            if (cache !== undefined) {\n              if (cache !== \"ignore\") {\n                fileTimestamps.set(path, cache);\n              }\n            } else {\n              jobs++;\n              this.fileTimestampQueue.add(path, (err, entry) => {\n                if (err) {\n                  if (this.logger) {\n                    this.logger.debug(`Error snapshotting file timestamp of ${path}: ${err.stack}`);\n                  }\n\n                  jobError();\n                } else {\n                  fileTimestamps.set(path, entry);\n                  jobDone();\n                }\n              });\n            }\n          }\n\n          break;\n      }\n    };\n\n    if (files) {\n      processCapturedFiles(captureNonManaged(files, managedFiles));\n    }\n\n    const processCapturedDirectories = capturedDirectories => {\n      switch (mode) {\n        case 3:\n          this._contextTshsOptimization.optimize(snapshot, capturedDirectories);\n\n          for (const path of capturedDirectories) {\n            const cache = this._contextTshs.get(path);\n            /** @type {ResolvedContextTimestampAndHash} */\n\n\n            let resolved;\n\n            if (cache !== undefined && (resolved = getResolvedTimestamp(cache)) !== undefined) {\n              contextTshs.set(path, resolved);\n            } else {\n              jobs++;\n              /**\n               * @param {Error=} err error\n               * @param {ResolvedContextTimestampAndHash=} entry entry\n               * @returns {void}\n               */\n\n              const callback = (err, entry) => {\n                if (err) {\n                  if (this.logger) {\n                    this.logger.debug(`Error snapshotting context timestamp hash combination of ${path}: ${err.stack}`);\n                  }\n\n                  jobError();\n                } else {\n                  contextTshs.set(path, entry);\n                  jobDone();\n                }\n              };\n\n              if (cache !== undefined) {\n                this._resolveContextTsh(cache, callback);\n              } else {\n                this.getContextTsh(path, callback);\n              }\n            }\n          }\n\n          break;\n\n        case 2:\n          this._contextHashesOptimization.optimize(snapshot, capturedDirectories);\n\n          for (const path of capturedDirectories) {\n            const cache = this._contextHashes.get(path);\n\n            let resolved;\n\n            if (cache !== undefined && (resolved = getResolvedHash(cache)) !== undefined) {\n              contextHashes.set(path, resolved);\n            } else {\n              jobs++;\n\n              const callback = (err, entry) => {\n                if (err) {\n                  if (this.logger) {\n                    this.logger.debug(`Error snapshotting context hash of ${path}: ${err.stack}`);\n                  }\n\n                  jobError();\n                } else {\n                  contextHashes.set(path, entry);\n                  jobDone();\n                }\n              };\n\n              if (cache !== undefined) {\n                this._resolveContextHash(cache, callback);\n              } else {\n                this.getContextHash(path, callback);\n              }\n            }\n          }\n\n          break;\n\n        case 1:\n          this._contextTimestampsOptimization.optimize(snapshot, capturedDirectories);\n\n          for (const path of capturedDirectories) {\n            const cache = this._contextTimestamps.get(path);\n\n            if (cache === \"ignore\") continue;\n            let resolved;\n\n            if (cache !== undefined && (resolved = getResolvedTimestamp(cache)) !== undefined) {\n              contextTimestamps.set(path, resolved);\n            } else {\n              jobs++;\n              /**\n               * @param {Error=} err error\n               * @param {ResolvedContextFileSystemInfoEntry=} entry entry\n               * @returns {void}\n               */\n\n              const callback = (err, entry) => {\n                if (err) {\n                  if (this.logger) {\n                    this.logger.debug(`Error snapshotting context timestamp of ${path}: ${err.stack}`);\n                  }\n\n                  jobError();\n                } else {\n                  contextTimestamps.set(path, entry);\n                  jobDone();\n                }\n              };\n\n              if (cache !== undefined) {\n                this._resolveContextTimestamp(cache, callback);\n              } else {\n                this.getContextTimestamp(path, callback);\n              }\n            }\n          }\n\n          break;\n      }\n    };\n\n    if (directories) {\n      processCapturedDirectories(captureNonManaged(directories, managedContexts));\n    }\n\n    const processCapturedMissing = capturedMissing => {\n      this._missingExistenceOptimization.optimize(snapshot, capturedMissing);\n\n      for (const path of capturedMissing) {\n        const cache = this._fileTimestamps.get(path);\n\n        if (cache !== undefined) {\n          if (cache !== \"ignore\") {\n            missingExistence.set(path, Boolean(cache));\n          }\n        } else {\n          jobs++;\n          this.fileTimestampQueue.add(path, (err, entry) => {\n            if (err) {\n              if (this.logger) {\n                this.logger.debug(`Error snapshotting missing timestamp of ${path}: ${err.stack}`);\n              }\n\n              jobError();\n            } else {\n              missingExistence.set(path, Boolean(entry));\n              jobDone();\n            }\n          });\n        }\n      }\n    };\n\n    if (missing) {\n      processCapturedMissing(captureNonManaged(missing, managedMissing));\n    }\n\n    this._managedItemInfoOptimization.optimize(snapshot, managedItems);\n\n    for (const path of managedItems) {\n      const cache = this._managedItems.get(path);\n\n      if (cache !== undefined) {\n        if (!cache.startsWith(\"*\")) {\n          managedFiles.add(join(this.fs, path, \"package.json\"));\n        } else if (cache === \"*nested\") {\n          managedMissing.add(join(this.fs, path, \"package.json\"));\n        }\n\n        managedItemInfo.set(path, cache);\n      } else {\n        jobs++;\n        this.managedItemQueue.add(path, (err, entry) => {\n          if (err) {\n            if (this.logger) {\n              this.logger.debug(`Error snapshotting managed item ${path}: ${err.stack}`);\n            }\n\n            jobError();\n          } else if (entry) {\n            if (!entry.startsWith(\"*\")) {\n              managedFiles.add(join(this.fs, path, \"package.json\"));\n            } else if (cache === \"*nested\") {\n              managedMissing.add(join(this.fs, path, \"package.json\"));\n            }\n\n            managedItemInfo.set(path, entry);\n            jobDone();\n          } else {\n            // Fallback to normal snapshotting\n            const process = (set, fn) => {\n              if (set.size === 0) return;\n              const captured = new Set();\n\n              for (const file of set) {\n                if (file.startsWith(path)) captured.add(file);\n              }\n\n              if (captured.size > 0) fn(captured);\n            };\n\n            process(managedFiles, processCapturedFiles);\n            process(managedContexts, processCapturedDirectories);\n            process(managedMissing, processCapturedMissing);\n            jobDone();\n          }\n        });\n      }\n    }\n\n    jobDone();\n  }\n  /**\n   * @param {Snapshot} snapshot1 a snapshot\n   * @param {Snapshot} snapshot2 a snapshot\n   * @returns {Snapshot} merged snapshot\n   */\n\n\n  mergeSnapshots(snapshot1, snapshot2) {\n    const snapshot = new Snapshot();\n    if (snapshot1.hasStartTime() && snapshot2.hasStartTime()) snapshot.setStartTime(Math.min(snapshot1.startTime, snapshot2.startTime));else if (snapshot2.hasStartTime()) snapshot.startTime = snapshot2.startTime;else if (snapshot1.hasStartTime()) snapshot.startTime = snapshot1.startTime;\n\n    if (snapshot1.hasFileTimestamps() || snapshot2.hasFileTimestamps()) {\n      snapshot.setFileTimestamps(mergeMaps(snapshot1.fileTimestamps, snapshot2.fileTimestamps));\n    }\n\n    if (snapshot1.hasFileHashes() || snapshot2.hasFileHashes()) {\n      snapshot.setFileHashes(mergeMaps(snapshot1.fileHashes, snapshot2.fileHashes));\n    }\n\n    if (snapshot1.hasFileTshs() || snapshot2.hasFileTshs()) {\n      snapshot.setFileTshs(mergeMaps(snapshot1.fileTshs, snapshot2.fileTshs));\n    }\n\n    if (snapshot1.hasContextTimestamps() || snapshot2.hasContextTimestamps()) {\n      snapshot.setContextTimestamps(mergeMaps(snapshot1.contextTimestamps, snapshot2.contextTimestamps));\n    }\n\n    if (snapshot1.hasContextHashes() || snapshot2.hasContextHashes()) {\n      snapshot.setContextHashes(mergeMaps(snapshot1.contextHashes, snapshot2.contextHashes));\n    }\n\n    if (snapshot1.hasContextTshs() || snapshot2.hasContextTshs()) {\n      snapshot.setContextTshs(mergeMaps(snapshot1.contextTshs, snapshot2.contextTshs));\n    }\n\n    if (snapshot1.hasMissingExistence() || snapshot2.hasMissingExistence()) {\n      snapshot.setMissingExistence(mergeMaps(snapshot1.missingExistence, snapshot2.missingExistence));\n    }\n\n    if (snapshot1.hasManagedItemInfo() || snapshot2.hasManagedItemInfo()) {\n      snapshot.setManagedItemInfo(mergeMaps(snapshot1.managedItemInfo, snapshot2.managedItemInfo));\n    }\n\n    if (snapshot1.hasManagedFiles() || snapshot2.hasManagedFiles()) {\n      snapshot.setManagedFiles(mergeSets(snapshot1.managedFiles, snapshot2.managedFiles));\n    }\n\n    if (snapshot1.hasManagedContexts() || snapshot2.hasManagedContexts()) {\n      snapshot.setManagedContexts(mergeSets(snapshot1.managedContexts, snapshot2.managedContexts));\n    }\n\n    if (snapshot1.hasManagedMissing() || snapshot2.hasManagedMissing()) {\n      snapshot.setManagedMissing(mergeSets(snapshot1.managedMissing, snapshot2.managedMissing));\n    }\n\n    if (snapshot1.hasChildren() || snapshot2.hasChildren()) {\n      snapshot.setChildren(mergeSets(snapshot1.children, snapshot2.children));\n    }\n\n    if (this._snapshotCache.get(snapshot1) === true && this._snapshotCache.get(snapshot2) === true) {\n      this._snapshotCache.set(snapshot, true);\n    }\n\n    return snapshot;\n  }\n  /**\n   * @param {Snapshot} snapshot the snapshot made\n   * @param {function((WebpackError | null)=, boolean=): void} callback callback function\n   * @returns {void}\n   */\n\n\n  checkSnapshotValid(snapshot, callback) {\n    const cachedResult = this._snapshotCache.get(snapshot);\n\n    if (cachedResult !== undefined) {\n      this._statTestedSnapshotsCached++;\n\n      if (typeof cachedResult === \"boolean\") {\n        callback(null, cachedResult);\n      } else {\n        cachedResult.push(callback);\n      }\n\n      return;\n    }\n\n    this._statTestedSnapshotsNotCached++;\n\n    this._checkSnapshotValidNoCache(snapshot, callback);\n  }\n  /**\n   * @param {Snapshot} snapshot the snapshot made\n   * @param {function((WebpackError | null)=, boolean=): void} callback callback function\n   * @returns {void}\n   */\n\n\n  _checkSnapshotValidNoCache(snapshot, callback) {\n    var _this = this;\n\n    /** @type {number | undefined} */\n    let startTime = undefined;\n\n    if (snapshot.hasStartTime()) {\n      startTime = snapshot.startTime;\n    }\n\n    let jobs = 1;\n\n    const jobDone = () => {\n      if (--jobs === 0) {\n        this._snapshotCache.set(snapshot, true);\n\n        callback(null, true);\n      }\n    };\n\n    const invalid = () => {\n      if (jobs > 0) {\n        // large negative number instead of NaN or something else to keep jobs to stay a SMI (v8)\n        jobs = -100000000;\n\n        this._snapshotCache.set(snapshot, false);\n\n        callback(null, false);\n      }\n    };\n\n    const invalidWithError = (path, err) => {\n      if (this._remainingLogs > 0) {\n        this._log(path, `error occurred: %s`, err);\n      }\n\n      invalid();\n    };\n    /**\n     * @param {string} path file path\n     * @param {string} current current hash\n     * @param {string} snap snapshot hash\n     * @returns {boolean} true, if ok\n     */\n\n\n    const checkHash = (path, current, snap) => {\n      if (current !== snap) {\n        // If hash differ it's invalid\n        if (this._remainingLogs > 0) {\n          this._log(path, `hashes differ (%s != %s)`, current, snap);\n        }\n\n        return false;\n      }\n\n      return true;\n    };\n    /**\n     * @param {string} path file path\n     * @param {boolean} current current entry\n     * @param {boolean} snap entry from snapshot\n     * @returns {boolean} true, if ok\n     */\n\n\n    const checkExistence = (path, current, snap) => {\n      if (!current !== !snap) {\n        // If existence of item differs\n        // it's invalid\n        if (this._remainingLogs > 0) {\n          this._log(path, current ? \"it didn't exist before\" : \"it does no longer exist\");\n        }\n\n        return false;\n      }\n\n      return true;\n    };\n    /**\n     * @param {string} path file path\n     * @param {FileSystemInfoEntry} current current entry\n     * @param {FileSystemInfoEntry} snap entry from snapshot\n     * @param {boolean} log log reason\n     * @returns {boolean} true, if ok\n     */\n\n\n    const checkFile = function (path, current, snap) {\n      let log = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      if (current === snap) return true;\n      if (!checkExistence(path, Boolean(current), Boolean(snap))) return false;\n\n      if (current) {\n        // For existing items only\n        if (typeof startTime === \"number\" && current.safeTime > startTime) {\n          // If a change happened after starting reading the item\n          // this may no longer be valid\n          if (log && _this._remainingLogs > 0) {\n            _this._log(path, `it may have changed (%d) after the start time of the snapshot (%d)`, current.safeTime, startTime);\n          }\n\n          return false;\n        }\n\n        if (snap.timestamp !== undefined && current.timestamp !== snap.timestamp) {\n          // If we have a timestamp (it was a file or symlink) and it differs from current timestamp\n          // it's invalid\n          if (log && _this._remainingLogs > 0) {\n            _this._log(path, `timestamps differ (%d != %d)`, current.timestamp, snap.timestamp);\n          }\n\n          return false;\n        }\n      }\n\n      return true;\n    };\n    /**\n     * @param {string} path file path\n     * @param {ResolvedContextFileSystemInfoEntry} current current entry\n     * @param {ResolvedContextFileSystemInfoEntry} snap entry from snapshot\n     * @param {boolean} log log reason\n     * @returns {boolean} true, if ok\n     */\n\n\n    const checkContext = function (path, current, snap) {\n      let log = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      if (current === snap) return true;\n      if (!checkExistence(path, Boolean(current), Boolean(snap))) return false;\n\n      if (current) {\n        // For existing items only\n        if (typeof startTime === \"number\" && current.safeTime > startTime) {\n          // If a change happened after starting reading the item\n          // this may no longer be valid\n          if (log && _this._remainingLogs > 0) {\n            _this._log(path, `it may have changed (%d) after the start time of the snapshot (%d)`, current.safeTime, startTime);\n          }\n\n          return false;\n        }\n\n        if (snap.timestampHash !== undefined && current.timestampHash !== snap.timestampHash) {\n          // If we have a timestampHash (it was a directory) and it differs from current timestampHash\n          // it's invalid\n          if (log && _this._remainingLogs > 0) {\n            _this._log(path, `timestamps hashes differ (%s != %s)`, current.timestampHash, snap.timestampHash);\n          }\n\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    if (snapshot.hasChildren()) {\n      const childCallback = (err, result) => {\n        if (err || !result) return invalid();else jobDone();\n      };\n\n      for (const child of snapshot.children) {\n        const cache = this._snapshotCache.get(child);\n\n        if (cache !== undefined) {\n          this._statTestedChildrenCached++;\n          /* istanbul ignore else */\n\n          if (typeof cache === \"boolean\") {\n            if (cache === false) {\n              invalid();\n              return;\n            }\n          } else {\n            jobs++;\n            cache.push(childCallback);\n          }\n        } else {\n          this._statTestedChildrenNotCached++;\n          jobs++;\n\n          this._checkSnapshotValidNoCache(child, childCallback);\n        }\n      }\n    }\n\n    if (snapshot.hasFileTimestamps()) {\n      const {\n        fileTimestamps\n      } = snapshot;\n      this._statTestedEntries += fileTimestamps.size;\n\n      for (const [path, ts] of fileTimestamps) {\n        const cache = this._fileTimestamps.get(path);\n\n        if (cache !== undefined) {\n          if (cache !== \"ignore\" && !checkFile(path, cache, ts)) {\n            invalid();\n            return;\n          }\n        } else {\n          jobs++;\n          this.fileTimestampQueue.add(path, (err, entry) => {\n            if (err) return invalidWithError(path, err);\n\n            if (!checkFile(path, entry, ts)) {\n              invalid();\n            } else {\n              jobDone();\n            }\n          });\n        }\n      }\n    }\n\n    const processFileHashSnapshot = (path, hash) => {\n      const cache = this._fileHashes.get(path);\n\n      if (cache !== undefined) {\n        if (cache !== \"ignore\" && !checkHash(path, cache, hash)) {\n          invalid();\n          return;\n        }\n      } else {\n        jobs++;\n        this.fileHashQueue.add(path, (err, entry) => {\n          if (err) return invalidWithError(path, err);\n\n          if (!checkHash(path, entry, hash)) {\n            invalid();\n          } else {\n            jobDone();\n          }\n        });\n      }\n    };\n\n    if (snapshot.hasFileHashes()) {\n      const {\n        fileHashes\n      } = snapshot;\n      this._statTestedEntries += fileHashes.size;\n\n      for (const [path, hash] of fileHashes) {\n        processFileHashSnapshot(path, hash);\n      }\n    }\n\n    if (snapshot.hasFileTshs()) {\n      const {\n        fileTshs\n      } = snapshot;\n      this._statTestedEntries += fileTshs.size;\n\n      for (const [path, tsh] of fileTshs) {\n        if (typeof tsh === \"string\") {\n          processFileHashSnapshot(path, tsh);\n        } else {\n          const cache = this._fileTimestamps.get(path);\n\n          if (cache !== undefined) {\n            if (cache === \"ignore\" || !checkFile(path, cache, tsh, false)) {\n              processFileHashSnapshot(path, tsh && tsh.hash);\n            }\n          } else {\n            jobs++;\n            this.fileTimestampQueue.add(path, (err, entry) => {\n              if (err) return invalidWithError(path, err);\n\n              if (!checkFile(path, entry, tsh, false)) {\n                processFileHashSnapshot(path, tsh && tsh.hash);\n              }\n\n              jobDone();\n            });\n          }\n        }\n      }\n    }\n\n    if (snapshot.hasContextTimestamps()) {\n      const {\n        contextTimestamps\n      } = snapshot;\n      this._statTestedEntries += contextTimestamps.size;\n\n      for (const [path, ts] of contextTimestamps) {\n        const cache = this._contextTimestamps.get(path);\n\n        if (cache === \"ignore\") continue;\n        let resolved;\n\n        if (cache !== undefined && (resolved = getResolvedTimestamp(cache)) !== undefined) {\n          if (!checkContext(path, resolved, ts)) {\n            invalid();\n            return;\n          }\n        } else {\n          jobs++;\n          /**\n           * @param {Error=} err error\n           * @param {ResolvedContextFileSystemInfoEntry=} entry entry\n           * @returns {void}\n           */\n\n          const callback = (err, entry) => {\n            if (err) return invalidWithError(path, err);\n\n            if (!checkContext(path, entry, ts)) {\n              invalid();\n            } else {\n              jobDone();\n            }\n          };\n\n          if (cache !== undefined) {\n            this._resolveContextTimestamp(cache, callback);\n          } else {\n            this.getContextTimestamp(path, callback);\n          }\n        }\n      }\n    }\n\n    const processContextHashSnapshot = (path, hash) => {\n      const cache = this._contextHashes.get(path);\n\n      let resolved;\n\n      if (cache !== undefined && (resolved = getResolvedHash(cache)) !== undefined) {\n        if (!checkHash(path, resolved, hash)) {\n          invalid();\n          return;\n        }\n      } else {\n        jobs++;\n\n        const callback = (err, entry) => {\n          if (err) return invalidWithError(path, err);\n\n          if (!checkHash(path, entry, hash)) {\n            invalid();\n          } else {\n            jobDone();\n          }\n        };\n\n        if (cache !== undefined) {\n          this._resolveContextHash(cache, callback);\n        } else {\n          this.getContextHash(path, callback);\n        }\n      }\n    };\n\n    if (snapshot.hasContextHashes()) {\n      const {\n        contextHashes\n      } = snapshot;\n      this._statTestedEntries += contextHashes.size;\n\n      for (const [path, hash] of contextHashes) {\n        processContextHashSnapshot(path, hash);\n      }\n    }\n\n    if (snapshot.hasContextTshs()) {\n      const {\n        contextTshs\n      } = snapshot;\n      this._statTestedEntries += contextTshs.size;\n\n      for (const [path, tsh] of contextTshs) {\n        if (typeof tsh === \"string\") {\n          processContextHashSnapshot(path, tsh);\n        } else {\n          const cache = this._contextTimestamps.get(path);\n\n          if (cache === \"ignore\") continue;\n          let resolved;\n\n          if (cache !== undefined && (resolved = getResolvedTimestamp(cache)) !== undefined) {\n            if (!checkContext(path, resolved, tsh, false)) {\n              processContextHashSnapshot(path, tsh && tsh.hash);\n            }\n          } else {\n            jobs++;\n            /**\n             * @param {Error=} err error\n             * @param {ResolvedContextFileSystemInfoEntry=} entry entry\n             * @returns {void}\n             */\n\n            const callback = (err, entry) => {\n              if (err) return invalidWithError(path, err);\n\n              if (!checkContext(path, entry, tsh, false)) {\n                processContextHashSnapshot(path, tsh && tsh.hash);\n              }\n\n              jobDone();\n            };\n\n            if (cache !== undefined) {\n              this._resolveContextTimestamp(cache, callback);\n            } else {\n              this.getContextTimestamp(path, callback);\n            }\n          }\n        }\n      }\n    }\n\n    if (snapshot.hasMissingExistence()) {\n      const {\n        missingExistence\n      } = snapshot;\n      this._statTestedEntries += missingExistence.size;\n\n      for (const [path, existence] of missingExistence) {\n        const cache = this._fileTimestamps.get(path);\n\n        if (cache !== undefined) {\n          if (cache !== \"ignore\" && !checkExistence(path, Boolean(cache), Boolean(existence))) {\n            invalid();\n            return;\n          }\n        } else {\n          jobs++;\n          this.fileTimestampQueue.add(path, (err, entry) => {\n            if (err) return invalidWithError(path, err);\n\n            if (!checkExistence(path, Boolean(entry), Boolean(existence))) {\n              invalid();\n            } else {\n              jobDone();\n            }\n          });\n        }\n      }\n    }\n\n    if (snapshot.hasManagedItemInfo()) {\n      const {\n        managedItemInfo\n      } = snapshot;\n      this._statTestedEntries += managedItemInfo.size;\n\n      for (const [path, info] of managedItemInfo) {\n        const cache = this._managedItems.get(path);\n\n        if (cache !== undefined) {\n          if (!checkHash(path, cache, info)) {\n            invalid();\n            return;\n          }\n        } else {\n          jobs++;\n          this.managedItemQueue.add(path, (err, entry) => {\n            if (err) return invalidWithError(path, err);\n\n            if (!checkHash(path, entry, info)) {\n              invalid();\n            } else {\n              jobDone();\n            }\n          });\n        }\n      }\n    }\n\n    jobDone(); // if there was an async action\n    // try to join multiple concurrent request for this snapshot\n\n    if (jobs > 0) {\n      const callbacks = [callback];\n\n      callback = (err, result) => {\n        for (const callback of callbacks) callback(err, result);\n      };\n\n      this._snapshotCache.set(snapshot, callbacks);\n    }\n  }\n\n  _readFileTimestamp(path, callback) {\n    this.fs.stat(path, (err, stat) => {\n      if (err) {\n        if (err.code === \"ENOENT\") {\n          this._fileTimestamps.set(path, null);\n\n          this._cachedDeprecatedFileTimestamps = undefined;\n          return callback(null, null);\n        }\n\n        return callback(err);\n      }\n\n      let ts;\n\n      if (stat.isDirectory()) {\n        ts = {\n          safeTime: 0,\n          timestamp: undefined\n        };\n      } else {\n        const mtime = +stat.mtime;\n        if (mtime) applyMtime(mtime);\n        ts = {\n          safeTime: mtime ? mtime + FS_ACCURACY : Infinity,\n          timestamp: mtime\n        };\n      }\n\n      this._fileTimestamps.set(path, ts);\n\n      this._cachedDeprecatedFileTimestamps = undefined;\n      callback(null, ts);\n    });\n  }\n\n  _readFileHash(path, callback) {\n    this.fs.readFile(path, (err, content) => {\n      if (err) {\n        if (err.code === \"EISDIR\") {\n          this._fileHashes.set(path, \"directory\");\n\n          return callback(null, \"directory\");\n        }\n\n        if (err.code === \"ENOENT\") {\n          this._fileHashes.set(path, null);\n\n          return callback(null, null);\n        }\n\n        if (err.code === \"ERR_FS_FILE_TOO_LARGE\") {\n          this.logger.warn(`Ignoring ${path} for hashing as it's very large`);\n\n          this._fileHashes.set(path, \"too large\");\n\n          return callback(null, \"too large\");\n        }\n\n        return callback(err);\n      }\n\n      const hash = createHash(this._hashFunction);\n      hash.update(content);\n      const digest =\n      /** @type {string} */\n      hash.digest(\"hex\");\n\n      this._fileHashes.set(path, digest);\n\n      callback(null, digest);\n    });\n  }\n\n  _getFileTimestampAndHash(path, callback) {\n    const continueWithHash = hash => {\n      const cache = this._fileTimestamps.get(path);\n\n      if (cache !== undefined) {\n        if (cache !== \"ignore\") {\n          const result = { ...cache,\n            hash\n          };\n\n          this._fileTshs.set(path, result);\n\n          return callback(null, result);\n        } else {\n          this._fileTshs.set(path, hash);\n\n          return callback(null, hash);\n        }\n      } else {\n        this.fileTimestampQueue.add(path, (err, entry) => {\n          if (err) {\n            return callback(err);\n          }\n\n          const result = { ...entry,\n            hash\n          };\n\n          this._fileTshs.set(path, result);\n\n          return callback(null, result);\n        });\n      }\n    };\n\n    const cache = this._fileHashes.get(path);\n\n    if (cache !== undefined) {\n      continueWithHash(cache);\n    } else {\n      this.fileHashQueue.add(path, (err, entry) => {\n        if (err) {\n          return callback(err);\n        }\n\n        continueWithHash(entry);\n      });\n    }\n  }\n  /**\n   * @template T\n   * @template ItemType\n   * @param {Object} options options\n   * @param {string} options.path path\n   * @param {function(string): ItemType} options.fromImmutablePath called when context item is an immutable path\n   * @param {function(string): ItemType} options.fromManagedItem called when context item is a managed path\n   * @param {function(string, string, function(Error=, ItemType=): void): void} options.fromSymlink called when context item is a symlink\n   * @param {function(string, IStats, function(Error=, ItemType=): void): void} options.fromFile called when context item is a file\n   * @param {function(string, IStats, function(Error=, ItemType=): void): void} options.fromDirectory called when context item is a directory\n   * @param {function(string[], ItemType[]): T} options.reduce called from all context items\n   * @param {function((Error | null)=, (T)=): void} callback callback\n   */\n\n\n  _readContext(_ref4, callback) {\n    let {\n      path,\n      fromImmutablePath,\n      fromManagedItem,\n      fromSymlink,\n      fromFile,\n      fromDirectory,\n      reduce\n    } = _ref4;\n    this.fs.readdir(path, (err, _files) => {\n      if (err) {\n        if (err.code === \"ENOENT\") {\n          return callback(null, null);\n        }\n\n        return callback(err);\n      }\n\n      const files =\n      /** @type {string[]} */\n      _files.map(file => file.normalize(\"NFC\")).filter(file => !/^\\./.test(file)).sort();\n\n      asyncLib.map(files, (file, callback) => {\n        const child = join(this.fs, path, file);\n\n        for (const immutablePath of this.immutablePathsRegExps) {\n          if (immutablePath.test(path)) {\n            // ignore any immutable path for timestamping\n            return callback(null, fromImmutablePath(path));\n          }\n        }\n\n        for (const immutablePath of this.immutablePathsWithSlash) {\n          if (path.startsWith(immutablePath)) {\n            // ignore any immutable path for timestamping\n            return callback(null, fromImmutablePath(path));\n          }\n        }\n\n        for (const managedPath of this.managedPathsRegExps) {\n          const match = managedPath.exec(path);\n\n          if (match) {\n            const managedItem = getManagedItem(match[1], path);\n\n            if (managedItem) {\n              // construct timestampHash from managed info\n              return this.managedItemQueue.add(managedItem, (err, info) => {\n                if (err) return callback(err);\n                return callback(null, fromManagedItem(info));\n              });\n            }\n          }\n        }\n\n        for (const managedPath of this.managedPathsWithSlash) {\n          if (path.startsWith(managedPath)) {\n            const managedItem = getManagedItem(managedPath, child);\n\n            if (managedItem) {\n              // construct timestampHash from managed info\n              return this.managedItemQueue.add(managedItem, (err, info) => {\n                if (err) return callback(err);\n                return callback(null, fromManagedItem(info));\n              });\n            }\n          }\n        }\n\n        lstatReadlinkAbsolute(this.fs, child, (err, stat) => {\n          if (err) return callback(err);\n\n          if (typeof stat === \"string\") {\n            return fromSymlink(child, stat, callback);\n          }\n\n          if (stat.isFile()) {\n            return fromFile(child, stat, callback);\n          }\n\n          if (stat.isDirectory()) {\n            return fromDirectory(child, stat, callback);\n          }\n\n          callback(null, null);\n        });\n      }, (err, results) => {\n        if (err) return callback(err);\n        const result = reduce(files, results);\n        callback(null, result);\n      });\n    });\n  }\n\n  _readContextTimestamp(path, callback) {\n    this._readContext({\n      path,\n      fromImmutablePath: () => null,\n      fromManagedItem: info => ({\n        safeTime: 0,\n        timestampHash: info\n      }),\n      fromSymlink: (file, target, callback) => {\n        callback(null, {\n          timestampHash: target,\n          symlinks: new Set([target])\n        });\n      },\n      fromFile: (file, stat, callback) => {\n        // Prefer the cached value over our new stat to report consistent results\n        const cache = this._fileTimestamps.get(file);\n\n        if (cache !== undefined) return callback(null, cache === \"ignore\" ? null : cache);\n        const mtime = +stat.mtime;\n        if (mtime) applyMtime(mtime);\n        const ts = {\n          safeTime: mtime ? mtime + FS_ACCURACY : Infinity,\n          timestamp: mtime\n        };\n\n        this._fileTimestamps.set(file, ts);\n\n        this._cachedDeprecatedFileTimestamps = undefined;\n        callback(null, ts);\n      },\n      fromDirectory: (directory, stat, callback) => {\n        this.contextTimestampQueue.increaseParallelism();\n\n        this._getUnresolvedContextTimestamp(directory, (err, tsEntry) => {\n          this.contextTimestampQueue.decreaseParallelism();\n          callback(err, tsEntry);\n        });\n      },\n      reduce: (files, tsEntries) => {\n        let symlinks = undefined;\n        const hash = createHash(this._hashFunction);\n\n        for (const file of files) hash.update(file);\n\n        let safeTime = 0;\n\n        for (const entry of tsEntries) {\n          if (!entry) {\n            hash.update(\"n\");\n            continue;\n          }\n\n          if (entry.timestamp) {\n            hash.update(\"f\");\n            hash.update(`${entry.timestamp}`);\n          } else if (entry.timestampHash) {\n            hash.update(\"d\");\n            hash.update(`${entry.timestampHash}`);\n          }\n\n          if (entry.symlinks !== undefined) {\n            if (symlinks === undefined) symlinks = new Set();\n            addAll(entry.symlinks, symlinks);\n          }\n\n          if (entry.safeTime) {\n            safeTime = Math.max(safeTime, entry.safeTime);\n          }\n        }\n\n        const digest =\n        /** @type {string} */\n        hash.digest(\"hex\");\n        const result = {\n          safeTime,\n          timestampHash: digest\n        };\n        if (symlinks) result.symlinks = symlinks;\n        return result;\n      }\n    }, (err, result) => {\n      if (err) return callback(err);\n\n      this._contextTimestamps.set(path, result);\n\n      this._cachedDeprecatedContextTimestamps = undefined;\n      callback(null, result);\n    });\n  }\n  /**\n   * @param {ContextFileSystemInfoEntry} entry entry\n   * @param {function((Error | null)=, ResolvedContextFileSystemInfoEntry=): void} callback callback\n   * @returns {void}\n   */\n\n\n  _resolveContextTimestamp(entry, callback) {\n    const hashes = [];\n    let safeTime = 0;\n    processAsyncTree(entry.symlinks, 10, (target, push, callback) => {\n      this._getUnresolvedContextTimestamp(target, (err, entry) => {\n        if (err) return callback(err);\n\n        if (entry && entry !== \"ignore\") {\n          hashes.push(entry.timestampHash);\n\n          if (entry.safeTime) {\n            safeTime = Math.max(safeTime, entry.safeTime);\n          }\n\n          if (entry.symlinks !== undefined) {\n            for (const target of entry.symlinks) push(target);\n          }\n        }\n\n        callback();\n      });\n    }, err => {\n      if (err) return callback(err);\n      const hash = createHash(this._hashFunction);\n      hash.update(entry.timestampHash);\n\n      if (entry.safeTime) {\n        safeTime = Math.max(safeTime, entry.safeTime);\n      }\n\n      hashes.sort();\n\n      for (const h of hashes) {\n        hash.update(h);\n      }\n\n      callback(null, entry.resolved = {\n        safeTime,\n        timestampHash:\n        /** @type {string} */\n        hash.digest(\"hex\")\n      });\n    });\n  }\n\n  _readContextHash(path, callback) {\n    this._readContext({\n      path,\n      fromImmutablePath: () => \"\",\n      fromManagedItem: info => info || \"\",\n      fromSymlink: (file, target, callback) => {\n        callback(null, {\n          hash: target,\n          symlinks: new Set([target])\n        });\n      },\n      fromFile: (file, stat, callback) => this.getFileHash(file, (err, hash) => {\n        callback(err, hash || \"\");\n      }),\n      fromDirectory: (directory, stat, callback) => {\n        this.contextHashQueue.increaseParallelism();\n\n        this._getUnresolvedContextHash(directory, (err, hash) => {\n          this.contextHashQueue.decreaseParallelism();\n          callback(err, hash || \"\");\n        });\n      },\n\n      /**\n       * @param {string[]} files files\n       * @param {(string | ContextHash)[]} fileHashes hashes\n       * @returns {ContextHash} reduced hash\n       */\n      reduce: (files, fileHashes) => {\n        let symlinks = undefined;\n        const hash = createHash(this._hashFunction);\n\n        for (const file of files) hash.update(file);\n\n        for (const entry of fileHashes) {\n          if (typeof entry === \"string\") {\n            hash.update(entry);\n          } else {\n            hash.update(entry.hash);\n\n            if (entry.symlinks) {\n              if (symlinks === undefined) symlinks = new Set();\n              addAll(entry.symlinks, symlinks);\n            }\n          }\n        }\n\n        const result = {\n          hash:\n          /** @type {string} */\n          hash.digest(\"hex\")\n        };\n        if (symlinks) result.symlinks = symlinks;\n        return result;\n      }\n    }, (err, result) => {\n      if (err) return callback(err);\n\n      this._contextHashes.set(path, result);\n\n      return callback(null, result);\n    });\n  }\n  /**\n   * @param {ContextHash} entry context hash\n   * @param {function((Error | null)=, string=): void} callback callback\n   * @returns {void}\n   */\n\n\n  _resolveContextHash(entry, callback) {\n    const hashes = [];\n    processAsyncTree(entry.symlinks, 10, (target, push, callback) => {\n      this._getUnresolvedContextHash(target, (err, hash) => {\n        if (err) return callback(err);\n\n        if (hash) {\n          hashes.push(hash.hash);\n\n          if (hash.symlinks !== undefined) {\n            for (const target of hash.symlinks) push(target);\n          }\n        }\n\n        callback();\n      });\n    }, err => {\n      if (err) return callback(err);\n      const hash = createHash(this._hashFunction);\n      hash.update(entry.hash);\n      hashes.sort();\n\n      for (const h of hashes) {\n        hash.update(h);\n      }\n\n      callback(null, entry.resolved =\n      /** @type {string} */\n      hash.digest(\"hex\"));\n    });\n  }\n\n  _readContextTimestampAndHash(path, callback) {\n    const finalize = (timestamp, hash) => {\n      const result = timestamp === \"ignore\" ? hash : { ...timestamp,\n        ...hash\n      };\n\n      this._contextTshs.set(path, result);\n\n      callback(null, result);\n    };\n\n    const cachedHash = this._contextHashes.get(path);\n\n    const cachedTimestamp = this._contextTimestamps.get(path);\n\n    if (cachedHash !== undefined) {\n      if (cachedTimestamp !== undefined) {\n        finalize(cachedTimestamp, cachedHash);\n      } else {\n        this.contextTimestampQueue.add(path, (err, entry) => {\n          if (err) return callback(err);\n          finalize(entry, cachedHash);\n        });\n      }\n    } else {\n      if (cachedTimestamp !== undefined) {\n        this.contextHashQueue.add(path, (err, entry) => {\n          if (err) return callback(err);\n          finalize(cachedTimestamp, entry);\n        });\n      } else {\n        this._readContext({\n          path,\n          fromImmutablePath: () => null,\n          fromManagedItem: info => ({\n            safeTime: 0,\n            timestampHash: info,\n            hash: info || \"\"\n          }),\n          fromSymlink: (fle, target, callback) => {\n            callback(null, {\n              timestampHash: target,\n              hash: target,\n              symlinks: new Set([target])\n            });\n          },\n          fromFile: (file, stat, callback) => {\n            this._getFileTimestampAndHash(file, callback);\n          },\n          fromDirectory: (directory, stat, callback) => {\n            this.contextTshQueue.increaseParallelism();\n            this.contextTshQueue.add(directory, (err, result) => {\n              this.contextTshQueue.decreaseParallelism();\n              callback(err, result);\n            });\n          },\n\n          /**\n           * @param {string[]} files files\n           * @param {(Partial<TimestampAndHash> & Partial<ContextTimestampAndHash> | string | null)[]} results results\n           * @returns {ContextTimestampAndHash} tsh\n           */\n          reduce: (files, results) => {\n            let symlinks = undefined;\n            const tsHash = createHash(this._hashFunction);\n            const hash = createHash(this._hashFunction);\n\n            for (const file of files) {\n              tsHash.update(file);\n              hash.update(file);\n            }\n\n            let safeTime = 0;\n\n            for (const entry of results) {\n              if (!entry) {\n                tsHash.update(\"n\");\n                continue;\n              }\n\n              if (typeof entry === \"string\") {\n                tsHash.update(\"n\");\n                hash.update(entry);\n                continue;\n              }\n\n              if (entry.timestamp) {\n                tsHash.update(\"f\");\n                tsHash.update(`${entry.timestamp}`);\n              } else if (entry.timestampHash) {\n                tsHash.update(\"d\");\n                tsHash.update(`${entry.timestampHash}`);\n              }\n\n              if (entry.symlinks !== undefined) {\n                if (symlinks === undefined) symlinks = new Set();\n                addAll(entry.symlinks, symlinks);\n              }\n\n              if (entry.safeTime) {\n                safeTime = Math.max(safeTime, entry.safeTime);\n              }\n\n              hash.update(entry.hash);\n            }\n\n            const result = {\n              safeTime,\n              timestampHash:\n              /** @type {string} */\n              tsHash.digest(\"hex\"),\n              hash:\n              /** @type {string} */\n              hash.digest(\"hex\")\n            };\n            if (symlinks) result.symlinks = symlinks;\n            return result;\n          }\n        }, (err, result) => {\n          if (err) return callback(err);\n\n          this._contextTshs.set(path, result);\n\n          return callback(null, result);\n        });\n      }\n    }\n  }\n  /**\n   * @param {ContextTimestampAndHash} entry entry\n   * @param {function((Error | null)=, ResolvedContextTimestampAndHash=): void} callback callback\n   * @returns {void}\n   */\n\n\n  _resolveContextTsh(entry, callback) {\n    const hashes = [];\n    const tsHashes = [];\n    let safeTime = 0;\n    processAsyncTree(entry.symlinks, 10, (target, push, callback) => {\n      this._getUnresolvedContextTsh(target, (err, entry) => {\n        if (err) return callback(err);\n\n        if (entry) {\n          hashes.push(entry.hash);\n          if (entry.timestampHash) tsHashes.push(entry.timestampHash);\n\n          if (entry.safeTime) {\n            safeTime = Math.max(safeTime, entry.safeTime);\n          }\n\n          if (entry.symlinks !== undefined) {\n            for (const target of entry.symlinks) push(target);\n          }\n        }\n\n        callback();\n      });\n    }, err => {\n      if (err) return callback(err);\n      const hash = createHash(this._hashFunction);\n      const tsHash = createHash(this._hashFunction);\n      hash.update(entry.hash);\n      if (entry.timestampHash) tsHash.update(entry.timestampHash);\n\n      if (entry.safeTime) {\n        safeTime = Math.max(safeTime, entry.safeTime);\n      }\n\n      hashes.sort();\n\n      for (const h of hashes) {\n        hash.update(h);\n      }\n\n      tsHashes.sort();\n\n      for (const h of tsHashes) {\n        tsHash.update(h);\n      }\n\n      callback(null, entry.resolved = {\n        safeTime,\n        timestampHash:\n        /** @type {string} */\n        tsHash.digest(\"hex\"),\n        hash:\n        /** @type {string} */\n        hash.digest(\"hex\")\n      });\n    });\n  }\n\n  _getManagedItemDirectoryInfo(path, callback) {\n    this.fs.readdir(path, (err, elements) => {\n      if (err) {\n        if (err.code === \"ENOENT\" || err.code === \"ENOTDIR\") {\n          return callback(null, EMPTY_SET);\n        }\n\n        return callback(err);\n      }\n\n      const set = new Set(\n      /** @type {string[]} */\n      elements.map(element => join(this.fs, path, element)));\n      callback(null, set);\n    });\n  }\n\n  _getManagedItemInfo(path, callback) {\n    const dir = dirname(this.fs, path);\n    this.managedItemDirectoryQueue.add(dir, (err, elements) => {\n      if (err) {\n        return callback(err);\n      }\n\n      if (!elements.has(path)) {\n        // file or directory doesn't exist\n        this._managedItems.set(path, \"*missing\");\n\n        return callback(null, \"*missing\");\n      } // something exists\n      // it may be a file or directory\n\n\n      if (path.endsWith(\"node_modules\") && (path.endsWith(\"/node_modules\") || path.endsWith(\"\\\\node_modules\"))) {\n        // we are only interested in existence of this special directory\n        this._managedItems.set(path, \"*node_modules\");\n\n        return callback(null, \"*node_modules\");\n      } // we assume it's a directory, as files shouldn't occur in managed paths\n\n\n      const packageJsonPath = join(this.fs, path, \"package.json\");\n      this.fs.readFile(packageJsonPath, (err, content) => {\n        if (err) {\n          if (err.code === \"ENOENT\" || err.code === \"ENOTDIR\") {\n            // no package.json or path is not a directory\n            this.fs.readdir(path, (err, elements) => {\n              if (!err && elements.length === 1 && elements[0] === \"node_modules\") {\n                // This is only a grouping folder e. g. used by yarn\n                // we are only interested in existence of this special directory\n                this._managedItems.set(path, \"*nested\");\n\n                return callback(null, \"*nested\");\n              }\n\n              this.logger.warn(`Managed item ${path} isn't a directory or doesn't contain a package.json (see snapshot.managedPaths option)`);\n              return callback();\n            });\n            return;\n          }\n\n          return callback(err);\n        }\n\n        let data;\n\n        try {\n          data = JSON.parse(content.toString(\"utf-8\"));\n        } catch (e) {\n          return callback(e);\n        }\n\n        if (!data.name) {\n          this.logger.warn(`${packageJsonPath} doesn't contain a \"name\" property (see snapshot.managedPaths option)`);\n          return callback();\n        }\n\n        const info = `${data.name || \"\"}@${data.version || \"\"}`;\n\n        this._managedItems.set(path, info);\n\n        callback(null, info);\n      });\n    });\n  }\n\n  getDeprecatedFileTimestamps() {\n    if (this._cachedDeprecatedFileTimestamps !== undefined) return this._cachedDeprecatedFileTimestamps;\n    const map = new Map();\n\n    for (const [path, info] of this._fileTimestamps) {\n      if (info) map.set(path, typeof info === \"object\" ? info.safeTime : null);\n    }\n\n    return this._cachedDeprecatedFileTimestamps = map;\n  }\n\n  getDeprecatedContextTimestamps() {\n    if (this._cachedDeprecatedContextTimestamps !== undefined) return this._cachedDeprecatedContextTimestamps;\n    const map = new Map();\n\n    for (const [path, info] of this._contextTimestamps) {\n      if (info) map.set(path, typeof info === \"object\" ? info.safeTime : null);\n    }\n\n    return this._cachedDeprecatedContextTimestamps = map;\n  }\n\n}\n\nmodule.exports = FileSystemInfo;\nmodule.exports.Snapshot = Snapshot;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/FileSystemInfo.js"],"names":["create","createResolver","require","asyncLib","AsyncQueue","StackedCacheMap","createHash","join","dirname","relative","lstatReadlinkAbsolute","makeSerializable","processAsyncTree","supportsEsm","process","versions","modules","FS_ACCURACY","EMPTY_SET","Set","RBDT_RESOLVE_CJS","RBDT_RESOLVE_ESM","RBDT_RESOLVE_DIRECTORY","RBDT_RESOLVE_CJS_FILE","RBDT_RESOLVE_CJS_FILE_AS_CHILD","RBDT_RESOLVE_ESM_FILE","RBDT_DIRECTORY","RBDT_FILE","RBDT_DIRECTORY_DEPENDENCIES","RBDT_FILE_DEPENDENCIES","INVALID","Symbol","DONE_ITERATOR_RESULT","keys","next","SnapshotIterator","constructor","SnapshotIterable","snapshot","getMaps","iterator","state","it","maps","queue","length","map","pop","undefined","result","done","children","size","child","push","Snapshot","_flags","startTime","fileTimestamps","fileHashes","fileTshs","contextTimestamps","contextHashes","contextTshs","missingExistence","managedItemInfo","managedFiles","managedContexts","managedMissing","hasStartTime","setStartTime","value","setMergedStartTime","Math","min","hasFileTimestamps","setFileTimestamps","hasFileHashes","setFileHashes","hasFileTshs","setFileTshs","hasContextTimestamps","setContextTimestamps","hasContextHashes","setContextHashes","hasContextTshs","setContextTshs","hasMissingExistence","setMissingExistence","hasManagedItemInfo","setManagedItemInfo","hasManagedFiles","setManagedFiles","hasManagedContexts","setManagedContexts","hasManagedMissing","setManagedMissing","hasChildren","setChildren","addChild","add","serialize","write","deserialize","read","_createIterable","getFileIterable","s","getContextIterable","getMissingIterable","MIN_COMMON_SNAPSHOT_SIZE","SnapshotOptimization","has","get","set","useStartTime","isSet","_has","_get","_set","_useStartTime","_isSet","_map","Map","_statItemsShared","_statItemsUnshared","_statSharedSnapshots","_statReusedSharedSnapshots","getStatisticMessage","total","round","clear","optimize","newSnapshot","capturedFiles","increaseSharedAndStoreOptimizationEntry","entry","forEach","shared","storeOptimizationEntry","path","snapshotContent","old","delete","newOptimizationEntry","capturedFilesSize","optimizationEntries","optimizationEntry","nonSharedFiles","snapshotEntries","sharedCount","commonMap","commonSnapshot","newEntry","ts","unshared","parseString","str","slice","replace","JSON","parse","applyMtime","mtime","mergeMaps","a","b","key","mergeSets","item","getManagedItem","managedPath","i","slashes","startingPosition","loop","charCodeAt","c","getResolvedTimestamp","resolved","symlinks","getResolvedHash","hash","addAll","source","target","FileSystemInfo","fs","managedPaths","immutablePaths","logger","hashFunction","_remainingLogs","_loggedPaths","_hashFunction","_snapshotCache","WeakMap","_fileTimestampsOptimization","v","_fileHashesOptimization","_fileTshsOptimization","_contextTimestampsOptimization","_contextHashesOptimization","_contextTshsOptimization","_missingExistenceOptimization","_managedItemInfoOptimization","_managedFilesOptimization","_managedContextsOptimization","_managedMissingOptimization","_fileTimestamps","_fileHashes","_fileTshs","_contextTimestamps","_contextHashes","_contextTshs","_managedItems","fileTimestampQueue","name","parallelism","processor","_readFileTimestamp","bind","fileHashQueue","_readFileHash","contextTimestampQueue","_readContextTimestamp","contextHashQueue","_readContextHash","contextTshQueue","_readContextTimestampAndHash","managedItemQueue","_getManagedItemInfo","managedItemDirectoryQueue","_getManagedItemDirectoryInfo","Array","from","managedPathsWithSlash","filter","p","managedPathsRegExps","immutablePathsWithSlash","immutablePathsRegExps","_cachedDeprecatedFileTimestamps","_cachedDeprecatedContextTimestamps","_warnAboutExperimentalEsmTracking","_statCreatedSnapshots","_statTestedSnapshotsCached","_statTestedSnapshotsNotCached","_statTestedChildrenCached","_statTestedChildrenNotCached","_statTestedEntries","logStatistics","logWhenMessage","header","message","log","_log","reason","args","debug","addFileTimestamps","immutable","addContextTimestamps","getFileTimestamp","callback","cache","getContextTimestamp","_resolveContextTimestamp","err","_getUnresolvedContextTimestamp","getFileHash","getContextHash","_resolveContextHash","_getUnresolvedContextHash","getContextTsh","_resolveContextTsh","_getUnresolvedContextTsh","_createBuildDependenciesResolvers","resolveContext","resolveToContext","exportsFields","fileSystem","resolveCjs","extensions","conditionNames","resolveCjsAsChild","resolveEsm","fullySpecified","resolveBuildDependencies","context","deps","files","fileSymlinks","directories","directorySymlinks","missing","resolveFiles","resolveDirectories","resolveMissing","resolveResults","invalidResolveResults","resolverContext","fileDependencies","contextDependencies","missingDependencies","expectedToString","expected","jobToString","job","type","pathToString","issuer","dep","resolveDirectory","_","resultPath","resolveFile","symbol","resolve","warn","isDirectory","test","realpath","_realPath","realPath","nextTick","module","isArray","childPath","filename","modulePath","paths","startsWith","subPath","packageMatch","exec","request","endsWith","lexer","init","then","readFile","content","toString","imports","imp","dependency","d","substring","e","expr","trim","stack","match","packagePath","packageJson","code","parent","packageData","depsObject","dependencies","optionalDepsObject","optionalDependencies","allDeps","optionalDeps","Object","l","k","resolveDependencies","checkResolveResultsValid","eachLimit","expectedResult","split","Error","createSnapshot","options","managedItems","mode","timestamp","jobs","jobDone","jobError","checkManaged","managedSet","immutablePath","managedItem","captureNonManaged","items","capturedItems","processCapturedFiles","_getFileTimestampAndHash","processCapturedDirectories","capturedDirectories","processCapturedMissing","capturedMissing","Boolean","fn","captured","file","mergeSnapshots","snapshot1","snapshot2","checkSnapshotValid","cachedResult","_checkSnapshotValidNoCache","invalid","invalidWithError","checkHash","current","snap","checkExistence","checkFile","safeTime","checkContext","timestampHash","childCallback","processFileHashSnapshot","tsh","processContextHashSnapshot","existence","info","callbacks","stat","Infinity","update","digest","continueWithHash","_readContext","fromImmutablePath","fromManagedItem","fromSymlink","fromFile","fromDirectory","reduce","readdir","_files","normalize","sort","isFile","results","directory","increaseParallelism","tsEntry","decreaseParallelism","tsEntries","max","hashes","h","finalize","cachedHash","cachedTimestamp","fle","tsHash","tsHashes","elements","element","dir","packageJsonPath","data","version","getDeprecatedFileTimestamps","getDeprecatedContextTimestamps","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { create: createResolver } = require(\"enhanced-resolve\");\nconst asyncLib = require(\"neo-async\");\nconst AsyncQueue = require(\"./util/AsyncQueue\");\nconst StackedCacheMap = require(\"./util/StackedCacheMap\");\nconst createHash = require(\"./util/createHash\");\nconst { join, dirname, relative, lstatReadlinkAbsolute } = require(\"./util/fs\");\nconst makeSerializable = require(\"./util/makeSerializable\");\nconst processAsyncTree = require(\"./util/processAsyncTree\");\n\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/fs\").IStats} IStats */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n\nconst supportsEsm = +process.versions.modules >= 83;\n\nlet FS_ACCURACY = 2000;\n\nconst EMPTY_SET = new Set();\n\nconst RBDT_RESOLVE_CJS = 0;\nconst RBDT_RESOLVE_ESM = 1;\nconst RBDT_RESOLVE_DIRECTORY = 2;\nconst RBDT_RESOLVE_CJS_FILE = 3;\nconst RBDT_RESOLVE_CJS_FILE_AS_CHILD = 4;\nconst RBDT_RESOLVE_ESM_FILE = 5;\nconst RBDT_DIRECTORY = 6;\nconst RBDT_FILE = 7;\nconst RBDT_DIRECTORY_DEPENDENCIES = 8;\nconst RBDT_FILE_DEPENDENCIES = 9;\n\nconst INVALID = Symbol(\"invalid\");\n\n/**\n * @typedef {Object} FileSystemInfoEntry\n * @property {number} safeTime\n * @property {number=} timestamp\n */\n\n/**\n * @typedef {Object} ResolvedContextFileSystemInfoEntry\n * @property {number} safeTime\n * @property {string=} timestampHash\n */\n\n/**\n * @typedef {Object} ContextFileSystemInfoEntry\n * @property {number} safeTime\n * @property {string=} timestampHash\n * @property {ResolvedContextFileSystemInfoEntry=} resolved\n * @property {Set<string>=} symlinks\n */\n\n/**\n * @typedef {Object} TimestampAndHash\n * @property {number} safeTime\n * @property {number=} timestamp\n * @property {string} hash\n */\n\n/**\n * @typedef {Object} ResolvedContextTimestampAndHash\n * @property {number} safeTime\n * @property {string=} timestampHash\n * @property {string} hash\n */\n\n/**\n * @typedef {Object} ContextTimestampAndHash\n * @property {number} safeTime\n * @property {string=} timestampHash\n * @property {string} hash\n * @property {ResolvedContextTimestampAndHash=} resolved\n * @property {Set<string>=} symlinks\n */\n\n/**\n * @typedef {Object} ContextHash\n * @property {string} hash\n * @property {string=} resolved\n * @property {Set<string>=} symlinks\n */\n\n/**\n * @typedef {Object} SnapshotOptimizationEntry\n * @property {Snapshot} snapshot\n * @property {number} shared\n * @property {Set<string>} snapshotContent\n * @property {Set<SnapshotOptimizationEntry>} children\n */\n\n/**\n * @typedef {Object} ResolveBuildDependenciesResult\n * @property {Set<string>} files list of files\n * @property {Set<string>} directories list of directories\n * @property {Set<string>} missing list of missing entries\n * @property {Map<string, string | false>} resolveResults stored resolve results\n * @property {Object} resolveDependencies dependencies of the resolving\n * @property {Set<string>} resolveDependencies.files list of files\n * @property {Set<string>} resolveDependencies.directories list of directories\n * @property {Set<string>} resolveDependencies.missing list of missing entries\n */\n\nconst DONE_ITERATOR_RESULT = new Set().keys().next();\n\n// cspell:word tshs\n// Tsh = Timestamp + Hash\n// Tshs = Timestamp + Hash combinations\n\nclass SnapshotIterator {\n\tconstructor(next) {\n\t\tthis.next = next;\n\t}\n}\n\nclass SnapshotIterable {\n\tconstructor(snapshot, getMaps) {\n\t\tthis.snapshot = snapshot;\n\t\tthis.getMaps = getMaps;\n\t}\n\n\t[Symbol.iterator]() {\n\t\tlet state = 0;\n\t\t/** @type {IterableIterator<string>} */\n\t\tlet it;\n\t\t/** @type {(Snapshot) => (Map<string, any> | Set<string>)[]} */\n\t\tlet getMaps;\n\t\t/** @type {(Map<string, any> | Set<string>)[]} */\n\t\tlet maps;\n\t\t/** @type {Snapshot} */\n\t\tlet snapshot;\n\t\tlet queue;\n\t\treturn new SnapshotIterator(() => {\n\t\t\tfor (;;) {\n\t\t\t\tswitch (state) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tsnapshot = this.snapshot;\n\t\t\t\t\t\tgetMaps = this.getMaps;\n\t\t\t\t\t\tmaps = getMaps(snapshot);\n\t\t\t\t\t\tstate = 1;\n\t\t\t\t\t/* falls through */\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tif (maps.length > 0) {\n\t\t\t\t\t\t\tconst map = maps.pop();\n\t\t\t\t\t\t\tif (map !== undefined) {\n\t\t\t\t\t\t\t\tit = map.keys();\n\t\t\t\t\t\t\t\tstate = 2;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstate = 3;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t/* falls through */\n\t\t\t\t\tcase 2: {\n\t\t\t\t\t\tconst result = it.next();\n\t\t\t\t\t\tif (!result.done) return result;\n\t\t\t\t\t\tstate = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 3: {\n\t\t\t\t\t\tconst children = snapshot.children;\n\t\t\t\t\t\tif (children !== undefined) {\n\t\t\t\t\t\t\tif (children.size === 1) {\n\t\t\t\t\t\t\t\t// shortcut for a single child\n\t\t\t\t\t\t\t\t// avoids allocation of queue\n\t\t\t\t\t\t\t\tfor (const child of children) snapshot = child;\n\t\t\t\t\t\t\t\tmaps = getMaps(snapshot);\n\t\t\t\t\t\t\t\tstate = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (queue === undefined) queue = [];\n\t\t\t\t\t\t\tfor (const child of children) {\n\t\t\t\t\t\t\t\tqueue.push(child);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (queue !== undefined && queue.length > 0) {\n\t\t\t\t\t\t\tsnapshot = queue.pop();\n\t\t\t\t\t\t\tmaps = getMaps(snapshot);\n\t\t\t\t\t\t\tstate = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstate = 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* falls through */\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\treturn DONE_ITERATOR_RESULT;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\nclass Snapshot {\n\tconstructor() {\n\t\tthis._flags = 0;\n\t\t/** @type {number | undefined} */\n\t\tthis.startTime = undefined;\n\t\t/** @type {Map<string, FileSystemInfoEntry | null> | undefined} */\n\t\tthis.fileTimestamps = undefined;\n\t\t/** @type {Map<string, string | null> | undefined} */\n\t\tthis.fileHashes = undefined;\n\t\t/** @type {Map<string, TimestampAndHash | string | null> | undefined} */\n\t\tthis.fileTshs = undefined;\n\t\t/** @type {Map<string, ResolvedContextFileSystemInfoEntry | null> | undefined} */\n\t\tthis.contextTimestamps = undefined;\n\t\t/** @type {Map<string, string | null> | undefined} */\n\t\tthis.contextHashes = undefined;\n\t\t/** @type {Map<string, ResolvedContextTimestampAndHash | null> | undefined} */\n\t\tthis.contextTshs = undefined;\n\t\t/** @type {Map<string, boolean> | undefined} */\n\t\tthis.missingExistence = undefined;\n\t\t/** @type {Map<string, string> | undefined} */\n\t\tthis.managedItemInfo = undefined;\n\t\t/** @type {Set<string> | undefined} */\n\t\tthis.managedFiles = undefined;\n\t\t/** @type {Set<string> | undefined} */\n\t\tthis.managedContexts = undefined;\n\t\t/** @type {Set<string> | undefined} */\n\t\tthis.managedMissing = undefined;\n\t\t/** @type {Set<Snapshot> | undefined} */\n\t\tthis.children = undefined;\n\t}\n\n\thasStartTime() {\n\t\treturn (this._flags & 1) !== 0;\n\t}\n\n\tsetStartTime(value) {\n\t\tthis._flags = this._flags | 1;\n\t\tthis.startTime = value;\n\t}\n\n\tsetMergedStartTime(value, snapshot) {\n\t\tif (value) {\n\t\t\tif (snapshot.hasStartTime()) {\n\t\t\t\tthis.setStartTime(Math.min(value, snapshot.startTime));\n\t\t\t} else {\n\t\t\t\tthis.setStartTime(value);\n\t\t\t}\n\t\t} else {\n\t\t\tif (snapshot.hasStartTime()) this.setStartTime(snapshot.startTime);\n\t\t}\n\t}\n\n\thasFileTimestamps() {\n\t\treturn (this._flags & 2) !== 0;\n\t}\n\n\tsetFileTimestamps(value) {\n\t\tthis._flags = this._flags | 2;\n\t\tthis.fileTimestamps = value;\n\t}\n\n\thasFileHashes() {\n\t\treturn (this._flags & 4) !== 0;\n\t}\n\n\tsetFileHashes(value) {\n\t\tthis._flags = this._flags | 4;\n\t\tthis.fileHashes = value;\n\t}\n\n\thasFileTshs() {\n\t\treturn (this._flags & 8) !== 0;\n\t}\n\n\tsetFileTshs(value) {\n\t\tthis._flags = this._flags | 8;\n\t\tthis.fileTshs = value;\n\t}\n\n\thasContextTimestamps() {\n\t\treturn (this._flags & 0x10) !== 0;\n\t}\n\n\tsetContextTimestamps(value) {\n\t\tthis._flags = this._flags | 0x10;\n\t\tthis.contextTimestamps = value;\n\t}\n\n\thasContextHashes() {\n\t\treturn (this._flags & 0x20) !== 0;\n\t}\n\n\tsetContextHashes(value) {\n\t\tthis._flags = this._flags | 0x20;\n\t\tthis.contextHashes = value;\n\t}\n\n\thasContextTshs() {\n\t\treturn (this._flags & 0x40) !== 0;\n\t}\n\n\tsetContextTshs(value) {\n\t\tthis._flags = this._flags | 0x40;\n\t\tthis.contextTshs = value;\n\t}\n\n\thasMissingExistence() {\n\t\treturn (this._flags & 0x80) !== 0;\n\t}\n\n\tsetMissingExistence(value) {\n\t\tthis._flags = this._flags | 0x80;\n\t\tthis.missingExistence = value;\n\t}\n\n\thasManagedItemInfo() {\n\t\treturn (this._flags & 0x100) !== 0;\n\t}\n\n\tsetManagedItemInfo(value) {\n\t\tthis._flags = this._flags | 0x100;\n\t\tthis.managedItemInfo = value;\n\t}\n\n\thasManagedFiles() {\n\t\treturn (this._flags & 0x200) !== 0;\n\t}\n\n\tsetManagedFiles(value) {\n\t\tthis._flags = this._flags | 0x200;\n\t\tthis.managedFiles = value;\n\t}\n\n\thasManagedContexts() {\n\t\treturn (this._flags & 0x400) !== 0;\n\t}\n\n\tsetManagedContexts(value) {\n\t\tthis._flags = this._flags | 0x400;\n\t\tthis.managedContexts = value;\n\t}\n\n\thasManagedMissing() {\n\t\treturn (this._flags & 0x800) !== 0;\n\t}\n\n\tsetManagedMissing(value) {\n\t\tthis._flags = this._flags | 0x800;\n\t\tthis.managedMissing = value;\n\t}\n\n\thasChildren() {\n\t\treturn (this._flags & 0x1000) !== 0;\n\t}\n\n\tsetChildren(value) {\n\t\tthis._flags = this._flags | 0x1000;\n\t\tthis.children = value;\n\t}\n\n\taddChild(child) {\n\t\tif (!this.hasChildren()) {\n\t\t\tthis.setChildren(new Set());\n\t\t}\n\t\tthis.children.add(child);\n\t}\n\n\tserialize({ write }) {\n\t\twrite(this._flags);\n\t\tif (this.hasStartTime()) write(this.startTime);\n\t\tif (this.hasFileTimestamps()) write(this.fileTimestamps);\n\t\tif (this.hasFileHashes()) write(this.fileHashes);\n\t\tif (this.hasFileTshs()) write(this.fileTshs);\n\t\tif (this.hasContextTimestamps()) write(this.contextTimestamps);\n\t\tif (this.hasContextHashes()) write(this.contextHashes);\n\t\tif (this.hasContextTshs()) write(this.contextTshs);\n\t\tif (this.hasMissingExistence()) write(this.missingExistence);\n\t\tif (this.hasManagedItemInfo()) write(this.managedItemInfo);\n\t\tif (this.hasManagedFiles()) write(this.managedFiles);\n\t\tif (this.hasManagedContexts()) write(this.managedContexts);\n\t\tif (this.hasManagedMissing()) write(this.managedMissing);\n\t\tif (this.hasChildren()) write(this.children);\n\t}\n\n\tdeserialize({ read }) {\n\t\tthis._flags = read();\n\t\tif (this.hasStartTime()) this.startTime = read();\n\t\tif (this.hasFileTimestamps()) this.fileTimestamps = read();\n\t\tif (this.hasFileHashes()) this.fileHashes = read();\n\t\tif (this.hasFileTshs()) this.fileTshs = read();\n\t\tif (this.hasContextTimestamps()) this.contextTimestamps = read();\n\t\tif (this.hasContextHashes()) this.contextHashes = read();\n\t\tif (this.hasContextTshs()) this.contextTshs = read();\n\t\tif (this.hasMissingExistence()) this.missingExistence = read();\n\t\tif (this.hasManagedItemInfo()) this.managedItemInfo = read();\n\t\tif (this.hasManagedFiles()) this.managedFiles = read();\n\t\tif (this.hasManagedContexts()) this.managedContexts = read();\n\t\tif (this.hasManagedMissing()) this.managedMissing = read();\n\t\tif (this.hasChildren()) this.children = read();\n\t}\n\n\t/**\n\t * @param {function(Snapshot): (ReadonlyMap<string, any> | ReadonlySet<string>)[]} getMaps first\n\t * @returns {Iterable<string>} iterable\n\t */\n\t_createIterable(getMaps) {\n\t\treturn new SnapshotIterable(this, getMaps);\n\t}\n\n\t/**\n\t * @returns {Iterable<string>} iterable\n\t */\n\tgetFileIterable() {\n\t\treturn this._createIterable(s => [\n\t\t\ts.fileTimestamps,\n\t\t\ts.fileHashes,\n\t\t\ts.fileTshs,\n\t\t\ts.managedFiles\n\t\t]);\n\t}\n\n\t/**\n\t * @returns {Iterable<string>} iterable\n\t */\n\tgetContextIterable() {\n\t\treturn this._createIterable(s => [\n\t\t\ts.contextTimestamps,\n\t\t\ts.contextHashes,\n\t\t\ts.contextTshs,\n\t\t\ts.managedContexts\n\t\t]);\n\t}\n\n\t/**\n\t * @returns {Iterable<string>} iterable\n\t */\n\tgetMissingIterable() {\n\t\treturn this._createIterable(s => [s.missingExistence, s.managedMissing]);\n\t}\n}\n\nmakeSerializable(Snapshot, \"webpack/lib/FileSystemInfo\", \"Snapshot\");\n\nconst MIN_COMMON_SNAPSHOT_SIZE = 3;\n\n/**\n * @template T\n */\nclass SnapshotOptimization {\n\t/**\n\t * @param {function(Snapshot): boolean} has has value\n\t * @param {function(Snapshot): Map<string, T> | Set<string>} get get value\n\t * @param {function(Snapshot, Map<string, T> | Set<string>): void} set set value\n\t * @param {boolean=} useStartTime use the start time of snapshots\n\t * @param {boolean=} isSet value is an Set instead of a Map\n\t */\n\tconstructor(has, get, set, useStartTime = true, isSet = false) {\n\t\tthis._has = has;\n\t\tthis._get = get;\n\t\tthis._set = set;\n\t\tthis._useStartTime = useStartTime;\n\t\tthis._isSet = isSet;\n\t\t/** @type {Map<string, SnapshotOptimizationEntry>} */\n\t\tthis._map = new Map();\n\t\tthis._statItemsShared = 0;\n\t\tthis._statItemsUnshared = 0;\n\t\tthis._statSharedSnapshots = 0;\n\t\tthis._statReusedSharedSnapshots = 0;\n\t}\n\n\tgetStatisticMessage() {\n\t\tconst total = this._statItemsShared + this._statItemsUnshared;\n\t\tif (total === 0) return undefined;\n\t\treturn `${\n\t\t\tthis._statItemsShared && Math.round((this._statItemsShared * 100) / total)\n\t\t}% (${this._statItemsShared}/${total}) entries shared via ${\n\t\t\tthis._statSharedSnapshots\n\t\t} shared snapshots (${\n\t\t\tthis._statReusedSharedSnapshots + this._statSharedSnapshots\n\t\t} times referenced)`;\n\t}\n\n\tclear() {\n\t\tthis._map.clear();\n\t\tthis._statItemsShared = 0;\n\t\tthis._statItemsUnshared = 0;\n\t\tthis._statSharedSnapshots = 0;\n\t\tthis._statReusedSharedSnapshots = 0;\n\t}\n\n\t/**\n\t * @param {Snapshot} newSnapshot snapshot\n\t * @param {Set<string>} capturedFiles files to snapshot/share\n\t * @returns {void}\n\t */\n\toptimize(newSnapshot, capturedFiles) {\n\t\t/**\n\t\t * @param {SnapshotOptimizationEntry} entry optimization entry\n\t\t * @returns {void}\n\t\t */\n\t\tconst increaseSharedAndStoreOptimizationEntry = entry => {\n\t\t\tif (entry.children !== undefined) {\n\t\t\t\tentry.children.forEach(increaseSharedAndStoreOptimizationEntry);\n\t\t\t}\n\t\t\tentry.shared++;\n\t\t\tstoreOptimizationEntry(entry);\n\t\t};\n\t\t/**\n\t\t * @param {SnapshotOptimizationEntry} entry optimization entry\n\t\t * @returns {void}\n\t\t */\n\t\tconst storeOptimizationEntry = entry => {\n\t\t\tfor (const path of entry.snapshotContent) {\n\t\t\t\tconst old = this._map.get(path);\n\t\t\t\tif (old.shared < entry.shared) {\n\t\t\t\t\tthis._map.set(path, entry);\n\t\t\t\t}\n\t\t\t\tcapturedFiles.delete(path);\n\t\t\t}\n\t\t};\n\n\t\t/** @type {SnapshotOptimizationEntry} */\n\t\tlet newOptimizationEntry = undefined;\n\n\t\tconst capturedFilesSize = capturedFiles.size;\n\n\t\t/** @type {Set<SnapshotOptimizationEntry> | undefined} */\n\t\tconst optimizationEntries = new Set();\n\n\t\tfor (const path of capturedFiles) {\n\t\t\tconst optimizationEntry = this._map.get(path);\n\t\t\tif (optimizationEntry === undefined) {\n\t\t\t\tif (newOptimizationEntry === undefined) {\n\t\t\t\t\tnewOptimizationEntry = {\n\t\t\t\t\t\tsnapshot: newSnapshot,\n\t\t\t\t\t\tshared: 0,\n\t\t\t\t\t\tsnapshotContent: undefined,\n\t\t\t\t\t\tchildren: undefined\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tthis._map.set(path, newOptimizationEntry);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\toptimizationEntries.add(optimizationEntry);\n\t\t\t}\n\t\t}\n\n\t\toptimizationEntries: for (const optimizationEntry of optimizationEntries) {\n\t\t\tconst snapshot = optimizationEntry.snapshot;\n\t\t\tif (optimizationEntry.shared > 0) {\n\t\t\t\t// It's a shared snapshot\n\t\t\t\t// We can't change it, so we can only use it when all files match\n\t\t\t\t// and startTime is compatible\n\t\t\t\tif (\n\t\t\t\t\tthis._useStartTime &&\n\t\t\t\t\tnewSnapshot.startTime &&\n\t\t\t\t\t(!snapshot.startTime || snapshot.startTime > newSnapshot.startTime)\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst nonSharedFiles = new Set();\n\t\t\t\tconst snapshotContent = optimizationEntry.snapshotContent;\n\t\t\t\tconst snapshotEntries = this._get(snapshot);\n\t\t\t\tfor (const path of snapshotContent) {\n\t\t\t\t\tif (!capturedFiles.has(path)) {\n\t\t\t\t\t\tif (!snapshotEntries.has(path)) {\n\t\t\t\t\t\t\t// File is not shared and can't be removed from the snapshot\n\t\t\t\t\t\t\t// because it's in a child of the snapshot\n\t\t\t\t\t\t\tcontinue optimizationEntries;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnonSharedFiles.add(path);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nonSharedFiles.size === 0) {\n\t\t\t\t\t// The complete snapshot is shared\n\t\t\t\t\t// add it as child\n\t\t\t\t\tnewSnapshot.addChild(snapshot);\n\t\t\t\t\tincreaseSharedAndStoreOptimizationEntry(optimizationEntry);\n\t\t\t\t\tthis._statReusedSharedSnapshots++;\n\t\t\t\t} else {\n\t\t\t\t\t// Only a part of the snapshot is shared\n\t\t\t\t\tconst sharedCount = snapshotContent.size - nonSharedFiles.size;\n\t\t\t\t\tif (sharedCount < MIN_COMMON_SNAPSHOT_SIZE) {\n\t\t\t\t\t\t// Common part it too small\n\t\t\t\t\t\tcontinue optimizationEntries;\n\t\t\t\t\t}\n\t\t\t\t\t// Extract common timestamps from both snapshots\n\t\t\t\t\tlet commonMap;\n\t\t\t\t\tif (this._isSet) {\n\t\t\t\t\t\tcommonMap = new Set();\n\t\t\t\t\t\tfor (const path of /** @type {Set<string>} */ (snapshotEntries)) {\n\t\t\t\t\t\t\tif (nonSharedFiles.has(path)) continue;\n\t\t\t\t\t\t\tcommonMap.add(path);\n\t\t\t\t\t\t\tsnapshotEntries.delete(path);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcommonMap = new Map();\n\t\t\t\t\t\tconst map = /** @type {Map<string, T>} */ (snapshotEntries);\n\t\t\t\t\t\tfor (const [path, value] of map) {\n\t\t\t\t\t\t\tif (nonSharedFiles.has(path)) continue;\n\t\t\t\t\t\t\tcommonMap.set(path, value);\n\t\t\t\t\t\t\tsnapshotEntries.delete(path);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Create and attach snapshot\n\t\t\t\t\tconst commonSnapshot = new Snapshot();\n\t\t\t\t\tif (this._useStartTime) {\n\t\t\t\t\t\tcommonSnapshot.setMergedStartTime(newSnapshot.startTime, snapshot);\n\t\t\t\t\t}\n\t\t\t\t\tthis._set(commonSnapshot, commonMap);\n\t\t\t\t\tnewSnapshot.addChild(commonSnapshot);\n\t\t\t\t\tsnapshot.addChild(commonSnapshot);\n\t\t\t\t\t// Create optimization entry\n\t\t\t\t\tconst newEntry = {\n\t\t\t\t\t\tsnapshot: commonSnapshot,\n\t\t\t\t\t\tshared: optimizationEntry.shared + 1,\n\t\t\t\t\t\tsnapshotContent: new Set(commonMap.keys()),\n\t\t\t\t\t\tchildren: undefined\n\t\t\t\t\t};\n\t\t\t\t\tif (optimizationEntry.children === undefined)\n\t\t\t\t\t\toptimizationEntry.children = new Set();\n\t\t\t\t\toptimizationEntry.children.add(newEntry);\n\t\t\t\t\tstoreOptimizationEntry(newEntry);\n\t\t\t\t\tthis._statSharedSnapshots++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// It's a unshared snapshot\n\t\t\t\t// We can extract a common shared snapshot\n\t\t\t\t// with all common files\n\t\t\t\tconst snapshotEntries = this._get(snapshot);\n\t\t\t\tif (snapshotEntries === undefined) {\n\t\t\t\t\t// Incomplete snapshot, that can't be used\n\t\t\t\t\tcontinue optimizationEntries;\n\t\t\t\t}\n\t\t\t\tlet commonMap;\n\t\t\t\tif (this._isSet) {\n\t\t\t\t\tcommonMap = new Set();\n\t\t\t\t\tconst set = /** @type {Set<string>} */ (snapshotEntries);\n\t\t\t\t\tif (capturedFiles.size < set.size) {\n\t\t\t\t\t\tfor (const path of capturedFiles) {\n\t\t\t\t\t\t\tif (set.has(path)) commonMap.add(path);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const path of set) {\n\t\t\t\t\t\t\tif (capturedFiles.has(path)) commonMap.add(path);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcommonMap = new Map();\n\t\t\t\t\tconst map = /** @type {Map<string, T>} */ (snapshotEntries);\n\t\t\t\t\tfor (const path of capturedFiles) {\n\t\t\t\t\t\tconst ts = map.get(path);\n\t\t\t\t\t\tif (ts === undefined) continue;\n\t\t\t\t\t\tcommonMap.set(path, ts);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (commonMap.size < MIN_COMMON_SNAPSHOT_SIZE) {\n\t\t\t\t\t// Common part it too small\n\t\t\t\t\tcontinue optimizationEntries;\n\t\t\t\t}\n\t\t\t\t// Create and attach snapshot\n\t\t\t\tconst commonSnapshot = new Snapshot();\n\t\t\t\tif (this._useStartTime) {\n\t\t\t\t\tcommonSnapshot.setMergedStartTime(newSnapshot.startTime, snapshot);\n\t\t\t\t}\n\t\t\t\tthis._set(commonSnapshot, commonMap);\n\t\t\t\tnewSnapshot.addChild(commonSnapshot);\n\t\t\t\tsnapshot.addChild(commonSnapshot);\n\t\t\t\t// Remove files from snapshot\n\t\t\t\tfor (const path of commonMap.keys()) snapshotEntries.delete(path);\n\t\t\t\tconst sharedCount = commonMap.size;\n\t\t\t\tthis._statItemsUnshared -= sharedCount;\n\t\t\t\tthis._statItemsShared += sharedCount;\n\t\t\t\t// Create optimization entry\n\t\t\t\tstoreOptimizationEntry({\n\t\t\t\t\tsnapshot: commonSnapshot,\n\t\t\t\t\tshared: 2,\n\t\t\t\t\tsnapshotContent: new Set(commonMap.keys()),\n\t\t\t\t\tchildren: undefined\n\t\t\t\t});\n\t\t\t\tthis._statSharedSnapshots++;\n\t\t\t}\n\t\t}\n\t\tconst unshared = capturedFiles.size;\n\t\tthis._statItemsUnshared += unshared;\n\t\tthis._statItemsShared += capturedFilesSize - unshared;\n\t}\n}\n\nconst parseString = str => {\n\tif (str[0] === \"'\") str = `\"${str.slice(1, -1).replace(/\"/g, '\\\\\"')}\"`;\n\treturn JSON.parse(str);\n};\n\n/* istanbul ignore next */\n/**\n * @param {number} mtime mtime\n */\nconst applyMtime = mtime => {\n\tif (FS_ACCURACY > 1 && mtime % 2 !== 0) FS_ACCURACY = 1;\n\telse if (FS_ACCURACY > 10 && mtime % 20 !== 0) FS_ACCURACY = 10;\n\telse if (FS_ACCURACY > 100 && mtime % 200 !== 0) FS_ACCURACY = 100;\n\telse if (FS_ACCURACY > 1000 && mtime % 2000 !== 0) FS_ACCURACY = 1000;\n};\n\n/**\n * @template T\n * @template K\n * @param {Map<T, K>} a source map\n * @param {Map<T, K>} b joining map\n * @returns {Map<T, K>} joined map\n */\nconst mergeMaps = (a, b) => {\n\tif (!b || b.size === 0) return a;\n\tif (!a || a.size === 0) return b;\n\tconst map = new Map(a);\n\tfor (const [key, value] of b) {\n\t\tmap.set(key, value);\n\t}\n\treturn map;\n};\n\n/**\n * @template T\n * @template K\n * @param {Set<T, K>} a source map\n * @param {Set<T, K>} b joining map\n * @returns {Set<T, K>} joined map\n */\nconst mergeSets = (a, b) => {\n\tif (!b || b.size === 0) return a;\n\tif (!a || a.size === 0) return b;\n\tconst map = new Set(a);\n\tfor (const item of b) {\n\t\tmap.add(item);\n\t}\n\treturn map;\n};\n\n/**\n * Finding file or directory to manage\n * @param {string} managedPath path that is managing by {@link FileSystemInfo}\n * @param {string} path path to file or directory\n * @returns {string|null} managed item\n * @example\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/package/index.js'\n * ) === '/Users/user/my-project/node_modules/package'\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/package1/node_modules/package2'\n * ) === '/Users/user/my-project/node_modules/package1/node_modules/package2'\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/.bin/script.js'\n * ) === null // hidden files are disallowed as managed items\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/package'\n * ) === '/Users/user/my-project/node_modules/package'\n */\nconst getManagedItem = (managedPath, path) => {\n\tlet i = managedPath.length;\n\tlet slashes = 1;\n\tlet startingPosition = true;\n\tloop: while (i < path.length) {\n\t\tswitch (path.charCodeAt(i)) {\n\t\t\tcase 47: // slash\n\t\t\tcase 92: // backslash\n\t\t\t\tif (--slashes === 0) break loop;\n\t\t\t\tstartingPosition = true;\n\t\t\t\tbreak;\n\t\t\tcase 46: // .\n\t\t\t\t// hidden files are disallowed as managed items\n\t\t\t\t// it's probably .yarn-integrity or .cache\n\t\t\t\tif (startingPosition) return null;\n\t\t\t\tbreak;\n\t\t\tcase 64: // @\n\t\t\t\tif (!startingPosition) return null;\n\t\t\t\tslashes++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstartingPosition = false;\n\t\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (i === path.length) slashes--;\n\t// return null when path is incomplete\n\tif (slashes !== 0) return null;\n\t// if (path.slice(i + 1, i + 13) === \"node_modules\")\n\tif (\n\t\tpath.length >= i + 13 &&\n\t\tpath.charCodeAt(i + 1) === 110 &&\n\t\tpath.charCodeAt(i + 2) === 111 &&\n\t\tpath.charCodeAt(i + 3) === 100 &&\n\t\tpath.charCodeAt(i + 4) === 101 &&\n\t\tpath.charCodeAt(i + 5) === 95 &&\n\t\tpath.charCodeAt(i + 6) === 109 &&\n\t\tpath.charCodeAt(i + 7) === 111 &&\n\t\tpath.charCodeAt(i + 8) === 100 &&\n\t\tpath.charCodeAt(i + 9) === 117 &&\n\t\tpath.charCodeAt(i + 10) === 108 &&\n\t\tpath.charCodeAt(i + 11) === 101 &&\n\t\tpath.charCodeAt(i + 12) === 115\n\t) {\n\t\t// if this is the end of the path\n\t\tif (path.length === i + 13) {\n\t\t\t// return the node_modules directory\n\t\t\t// it's special\n\t\t\treturn path;\n\t\t}\n\t\tconst c = path.charCodeAt(i + 13);\n\t\t// if next symbol is slash or backslash\n\t\tif (c === 47 || c === 92) {\n\t\t\t// Managed subpath\n\t\t\treturn getManagedItem(path.slice(0, i + 14), path);\n\t\t}\n\t}\n\treturn path.slice(0, i);\n};\n\n/**\n * @template {ContextFileSystemInfoEntry | ContextTimestampAndHash} T\n * @param {T} entry entry\n * @returns {T[\"resolved\"] | undefined} the resolved entry\n */\nconst getResolvedTimestamp = entry => {\n\tif (entry === null) return null;\n\tif (entry.resolved !== undefined) return entry.resolved;\n\treturn entry.symlinks === undefined ? entry : undefined;\n};\n\n/**\n * @param {ContextHash} entry entry\n * @returns {string | undefined} the resolved entry\n */\nconst getResolvedHash = entry => {\n\tif (entry === null) return null;\n\tif (entry.resolved !== undefined) return entry.resolved;\n\treturn entry.symlinks === undefined ? entry.hash : undefined;\n};\n\nconst addAll = (source, target) => {\n\tfor (const key of source) target.add(key);\n};\n\n/**\n * Used to access information about the filesystem in a cached way\n */\nclass FileSystemInfo {\n\t/**\n\t * @param {InputFileSystem} fs file system\n\t * @param {Object} options options\n\t * @param {Iterable<string | RegExp>=} options.managedPaths paths that are only managed by a package manager\n\t * @param {Iterable<string | RegExp>=} options.immutablePaths paths that are immutable\n\t * @param {Logger=} options.logger logger used to log invalid snapshots\n\t * @param {string | Hash=} options.hashFunction the hash function to use\n\t */\n\tconstructor(\n\t\tfs,\n\t\t{\n\t\t\tmanagedPaths = [],\n\t\t\timmutablePaths = [],\n\t\t\tlogger,\n\t\t\thashFunction = \"md4\"\n\t\t} = {}\n\t) {\n\t\tthis.fs = fs;\n\t\tthis.logger = logger;\n\t\tthis._remainingLogs = logger ? 40 : 0;\n\t\tthis._loggedPaths = logger ? new Set() : undefined;\n\t\tthis._hashFunction = hashFunction;\n\t\t/** @type {WeakMap<Snapshot, boolean | (function(WebpackError=, boolean=): void)[]>} */\n\t\tthis._snapshotCache = new WeakMap();\n\t\tthis._fileTimestampsOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasFileTimestamps(),\n\t\t\ts => s.fileTimestamps,\n\t\t\t(s, v) => s.setFileTimestamps(v)\n\t\t);\n\t\tthis._fileHashesOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasFileHashes(),\n\t\t\ts => s.fileHashes,\n\t\t\t(s, v) => s.setFileHashes(v),\n\t\t\tfalse\n\t\t);\n\t\tthis._fileTshsOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasFileTshs(),\n\t\t\ts => s.fileTshs,\n\t\t\t(s, v) => s.setFileTshs(v)\n\t\t);\n\t\tthis._contextTimestampsOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasContextTimestamps(),\n\t\t\ts => s.contextTimestamps,\n\t\t\t(s, v) => s.setContextTimestamps(v)\n\t\t);\n\t\tthis._contextHashesOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasContextHashes(),\n\t\t\ts => s.contextHashes,\n\t\t\t(s, v) => s.setContextHashes(v),\n\t\t\tfalse\n\t\t);\n\t\tthis._contextTshsOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasContextTshs(),\n\t\t\ts => s.contextTshs,\n\t\t\t(s, v) => s.setContextTshs(v)\n\t\t);\n\t\tthis._missingExistenceOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasMissingExistence(),\n\t\t\ts => s.missingExistence,\n\t\t\t(s, v) => s.setMissingExistence(v),\n\t\t\tfalse\n\t\t);\n\t\tthis._managedItemInfoOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasManagedItemInfo(),\n\t\t\ts => s.managedItemInfo,\n\t\t\t(s, v) => s.setManagedItemInfo(v),\n\t\t\tfalse\n\t\t);\n\t\tthis._managedFilesOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasManagedFiles(),\n\t\t\ts => s.managedFiles,\n\t\t\t(s, v) => s.setManagedFiles(v),\n\t\t\tfalse,\n\t\t\ttrue\n\t\t);\n\t\tthis._managedContextsOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasManagedContexts(),\n\t\t\ts => s.managedContexts,\n\t\t\t(s, v) => s.setManagedContexts(v),\n\t\t\tfalse,\n\t\t\ttrue\n\t\t);\n\t\tthis._managedMissingOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasManagedMissing(),\n\t\t\ts => s.managedMissing,\n\t\t\t(s, v) => s.setManagedMissing(v),\n\t\t\tfalse,\n\t\t\ttrue\n\t\t);\n\t\t/** @type {StackedCacheMap<string, FileSystemInfoEntry | \"ignore\" | null>} */\n\t\tthis._fileTimestamps = new StackedCacheMap();\n\t\t/** @type {Map<string, string>} */\n\t\tthis._fileHashes = new Map();\n\t\t/** @type {Map<string, TimestampAndHash | string>} */\n\t\tthis._fileTshs = new Map();\n\t\t/** @type {StackedCacheMap<string, ContextFileSystemInfoEntry | \"ignore\" | null>} */\n\t\tthis._contextTimestamps = new StackedCacheMap();\n\t\t/** @type {Map<string, ContextHash>} */\n\t\tthis._contextHashes = new Map();\n\t\t/** @type {Map<string, ContextTimestampAndHash>} */\n\t\tthis._contextTshs = new Map();\n\t\t/** @type {Map<string, string>} */\n\t\tthis._managedItems = new Map();\n\t\t/** @type {AsyncQueue<string, string, FileSystemInfoEntry | null>} */\n\t\tthis.fileTimestampQueue = new AsyncQueue({\n\t\t\tname: \"file timestamp\",\n\t\t\tparallelism: 30,\n\t\t\tprocessor: this._readFileTimestamp.bind(this)\n\t\t});\n\t\t/** @type {AsyncQueue<string, string, string | null>} */\n\t\tthis.fileHashQueue = new AsyncQueue({\n\t\t\tname: \"file hash\",\n\t\t\tparallelism: 10,\n\t\t\tprocessor: this._readFileHash.bind(this)\n\t\t});\n\t\t/** @type {AsyncQueue<string, string, ContextFileSystemInfoEntry | null>} */\n\t\tthis.contextTimestampQueue = new AsyncQueue({\n\t\t\tname: \"context timestamp\",\n\t\t\tparallelism: 2,\n\t\t\tprocessor: this._readContextTimestamp.bind(this)\n\t\t});\n\t\t/** @type {AsyncQueue<string, string, ContextHash | null>} */\n\t\tthis.contextHashQueue = new AsyncQueue({\n\t\t\tname: \"context hash\",\n\t\t\tparallelism: 2,\n\t\t\tprocessor: this._readContextHash.bind(this)\n\t\t});\n\t\t/** @type {AsyncQueue<string, string, ContextTimestampAndHash | null>} */\n\t\tthis.contextTshQueue = new AsyncQueue({\n\t\t\tname: \"context hash and timestamp\",\n\t\t\tparallelism: 2,\n\t\t\tprocessor: this._readContextTimestampAndHash.bind(this)\n\t\t});\n\t\t/** @type {AsyncQueue<string, string, string | null>} */\n\t\tthis.managedItemQueue = new AsyncQueue({\n\t\t\tname: \"managed item info\",\n\t\t\tparallelism: 10,\n\t\t\tprocessor: this._getManagedItemInfo.bind(this)\n\t\t});\n\t\t/** @type {AsyncQueue<string, string, Set<string>>} */\n\t\tthis.managedItemDirectoryQueue = new AsyncQueue({\n\t\t\tname: \"managed item directory info\",\n\t\t\tparallelism: 10,\n\t\t\tprocessor: this._getManagedItemDirectoryInfo.bind(this)\n\t\t});\n\t\tthis.managedPaths = Array.from(managedPaths);\n\t\tthis.managedPathsWithSlash = /** @type {string[]} */ (\n\t\t\tthis.managedPaths.filter(p => typeof p === \"string\")\n\t\t).map(p => join(fs, p, \"_\").slice(0, -1));\n\n\t\tthis.managedPathsRegExps = /** @type {RegExp[]} */ (\n\t\t\tthis.managedPaths.filter(p => typeof p !== \"string\")\n\t\t);\n\t\tthis.immutablePaths = Array.from(immutablePaths);\n\t\tthis.immutablePathsWithSlash = /** @type {string[]} */ (\n\t\t\tthis.immutablePaths.filter(p => typeof p === \"string\")\n\t\t).map(p => join(fs, p, \"_\").slice(0, -1));\n\t\tthis.immutablePathsRegExps = /** @type {RegExp[]} */ (\n\t\t\tthis.immutablePaths.filter(p => typeof p !== \"string\")\n\t\t);\n\n\t\tthis._cachedDeprecatedFileTimestamps = undefined;\n\t\tthis._cachedDeprecatedContextTimestamps = undefined;\n\n\t\tthis._warnAboutExperimentalEsmTracking = false;\n\n\t\tthis._statCreatedSnapshots = 0;\n\t\tthis._statTestedSnapshotsCached = 0;\n\t\tthis._statTestedSnapshotsNotCached = 0;\n\t\tthis._statTestedChildrenCached = 0;\n\t\tthis._statTestedChildrenNotCached = 0;\n\t\tthis._statTestedEntries = 0;\n\t}\n\n\tlogStatistics() {\n\t\tconst logWhenMessage = (header, message) => {\n\t\t\tif (message) {\n\t\t\t\tthis.logger.log(`${header}: ${message}`);\n\t\t\t}\n\t\t};\n\t\tthis.logger.log(`${this._statCreatedSnapshots} new snapshots created`);\n\t\tthis.logger.log(\n\t\t\t`${\n\t\t\t\tthis._statTestedSnapshotsNotCached &&\n\t\t\t\tMath.round(\n\t\t\t\t\t(this._statTestedSnapshotsNotCached * 100) /\n\t\t\t\t\t\t(this._statTestedSnapshotsCached +\n\t\t\t\t\t\t\tthis._statTestedSnapshotsNotCached)\n\t\t\t\t)\n\t\t\t}% root snapshot uncached (${this._statTestedSnapshotsNotCached} / ${\n\t\t\t\tthis._statTestedSnapshotsCached + this._statTestedSnapshotsNotCached\n\t\t\t})`\n\t\t);\n\t\tthis.logger.log(\n\t\t\t`${\n\t\t\t\tthis._statTestedChildrenNotCached &&\n\t\t\t\tMath.round(\n\t\t\t\t\t(this._statTestedChildrenNotCached * 100) /\n\t\t\t\t\t\t(this._statTestedChildrenCached + this._statTestedChildrenNotCached)\n\t\t\t\t)\n\t\t\t}% children snapshot uncached (${this._statTestedChildrenNotCached} / ${\n\t\t\t\tthis._statTestedChildrenCached + this._statTestedChildrenNotCached\n\t\t\t})`\n\t\t);\n\t\tthis.logger.log(`${this._statTestedEntries} entries tested`);\n\t\tthis.logger.log(\n\t\t\t`File info in cache: ${this._fileTimestamps.size} timestamps ${this._fileHashes.size} hashes ${this._fileTshs.size} timestamp hash combinations`\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t`File timestamp snapshot optimization`,\n\t\t\tthis._fileTimestampsOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t`File hash snapshot optimization`,\n\t\t\tthis._fileHashesOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t`File timestamp hash combination snapshot optimization`,\n\t\t\tthis._fileTshsOptimization.getStatisticMessage()\n\t\t);\n\t\tthis.logger.log(\n\t\t\t`Directory info in cache: ${this._contextTimestamps.size} timestamps ${this._contextHashes.size} hashes ${this._contextTshs.size} timestamp hash combinations`\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t`Directory timestamp snapshot optimization`,\n\t\t\tthis._contextTimestampsOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t`Directory hash snapshot optimization`,\n\t\t\tthis._contextHashesOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t`Directory timestamp hash combination snapshot optimization`,\n\t\t\tthis._contextTshsOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t`Missing items snapshot optimization`,\n\t\t\tthis._missingExistenceOptimization.getStatisticMessage()\n\t\t);\n\t\tthis.logger.log(\n\t\t\t`Managed items info in cache: ${this._managedItems.size} items`\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t`Managed items snapshot optimization`,\n\t\t\tthis._managedItemInfoOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t`Managed files snapshot optimization`,\n\t\t\tthis._managedFilesOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t`Managed contexts snapshot optimization`,\n\t\t\tthis._managedContextsOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t`Managed missing snapshot optimization`,\n\t\t\tthis._managedMissingOptimization.getStatisticMessage()\n\t\t);\n\t}\n\n\t_log(path, reason, ...args) {\n\t\tconst key = path + reason;\n\t\tif (this._loggedPaths.has(key)) return;\n\t\tthis._loggedPaths.add(key);\n\t\tthis.logger.debug(`${path} invalidated because ${reason}`, ...args);\n\t\tif (--this._remainingLogs === 0) {\n\t\t\tthis.logger.debug(\n\t\t\t\t\"Logging limit has been reached and no further logging will be emitted by FileSystemInfo\"\n\t\t\t);\n\t\t}\n\t}\n\n\tclear() {\n\t\tthis._remainingLogs = this.logger ? 40 : 0;\n\t\tif (this._loggedPaths !== undefined) this._loggedPaths.clear();\n\n\t\tthis._snapshotCache = new WeakMap();\n\t\tthis._fileTimestampsOptimization.clear();\n\t\tthis._fileHashesOptimization.clear();\n\t\tthis._fileTshsOptimization.clear();\n\t\tthis._contextTimestampsOptimization.clear();\n\t\tthis._contextHashesOptimization.clear();\n\t\tthis._contextTshsOptimization.clear();\n\t\tthis._missingExistenceOptimization.clear();\n\t\tthis._managedItemInfoOptimization.clear();\n\t\tthis._managedFilesOptimization.clear();\n\t\tthis._managedContextsOptimization.clear();\n\t\tthis._managedMissingOptimization.clear();\n\t\tthis._fileTimestamps.clear();\n\t\tthis._fileHashes.clear();\n\t\tthis._fileTshs.clear();\n\t\tthis._contextTimestamps.clear();\n\t\tthis._contextHashes.clear();\n\t\tthis._contextTshs.clear();\n\t\tthis._managedItems.clear();\n\t\tthis._managedItems.clear();\n\n\t\tthis._cachedDeprecatedFileTimestamps = undefined;\n\t\tthis._cachedDeprecatedContextTimestamps = undefined;\n\n\t\tthis._statCreatedSnapshots = 0;\n\t\tthis._statTestedSnapshotsCached = 0;\n\t\tthis._statTestedSnapshotsNotCached = 0;\n\t\tthis._statTestedChildrenCached = 0;\n\t\tthis._statTestedChildrenNotCached = 0;\n\t\tthis._statTestedEntries = 0;\n\t}\n\n\t/**\n\t * @param {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} map timestamps\n\t * @param {boolean=} immutable if 'map' is immutable and FileSystemInfo can keep referencing it\n\t * @returns {void}\n\t */\n\taddFileTimestamps(map, immutable) {\n\t\tthis._fileTimestamps.addAll(map, immutable);\n\t\tthis._cachedDeprecatedFileTimestamps = undefined;\n\t}\n\n\t/**\n\t * @param {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} map timestamps\n\t * @param {boolean=} immutable if 'map' is immutable and FileSystemInfo can keep referencing it\n\t * @returns {void}\n\t */\n\taddContextTimestamps(map, immutable) {\n\t\tthis._contextTimestamps.addAll(map, immutable);\n\t\tthis._cachedDeprecatedContextTimestamps = undefined;\n\t}\n\n\t/**\n\t * @param {string} path file path\n\t * @param {function((WebpackError | null)=, (FileSystemInfoEntry | \"ignore\" | null)=): void} callback callback function\n\t * @returns {void}\n\t */\n\tgetFileTimestamp(path, callback) {\n\t\tconst cache = this._fileTimestamps.get(path);\n\t\tif (cache !== undefined) return callback(null, cache);\n\t\tthis.fileTimestampQueue.add(path, callback);\n\t}\n\n\t/**\n\t * @param {string} path context path\n\t * @param {function((WebpackError | null)=, (ResolvedContextFileSystemInfoEntry | \"ignore\" | null)=): void} callback callback function\n\t * @returns {void}\n\t */\n\tgetContextTimestamp(path, callback) {\n\t\tconst cache = this._contextTimestamps.get(path);\n\t\tif (cache !== undefined) {\n\t\t\tif (cache === \"ignore\") return callback(null, \"ignore\");\n\t\t\tconst resolved = getResolvedTimestamp(cache);\n\t\t\tif (resolved !== undefined) return callback(null, resolved);\n\t\t\treturn this._resolveContextTimestamp(cache, callback);\n\t\t}\n\t\tthis.contextTimestampQueue.add(path, (err, entry) => {\n\t\t\tif (err) return callback(err);\n\t\t\tconst resolved = getResolvedTimestamp(entry);\n\t\t\tif (resolved !== undefined) return callback(null, resolved);\n\t\t\tthis._resolveContextTimestamp(entry, callback);\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} path context path\n\t * @param {function((WebpackError | null)=, (ContextFileSystemInfoEntry | \"ignore\" | null)=): void} callback callback function\n\t * @returns {void}\n\t */\n\t_getUnresolvedContextTimestamp(path, callback) {\n\t\tconst cache = this._contextTimestamps.get(path);\n\t\tif (cache !== undefined) return callback(null, cache);\n\t\tthis.contextTimestampQueue.add(path, callback);\n\t}\n\n\t/**\n\t * @param {string} path file path\n\t * @param {function((WebpackError | null)=, string=): void} callback callback function\n\t * @returns {void}\n\t */\n\tgetFileHash(path, callback) {\n\t\tconst cache = this._fileHashes.get(path);\n\t\tif (cache !== undefined) return callback(null, cache);\n\t\tthis.fileHashQueue.add(path, callback);\n\t}\n\n\t/**\n\t * @param {string} path context path\n\t * @param {function((WebpackError | null)=, string=): void} callback callback function\n\t * @returns {void}\n\t */\n\tgetContextHash(path, callback) {\n\t\tconst cache = this._contextHashes.get(path);\n\t\tif (cache !== undefined) {\n\t\t\tconst resolved = getResolvedHash(cache);\n\t\t\tif (resolved !== undefined) return callback(null, resolved);\n\t\t\treturn this._resolveContextHash(cache, callback);\n\t\t}\n\t\tthis.contextHashQueue.add(path, (err, entry) => {\n\t\t\tif (err) return callback(err);\n\t\t\tconst resolved = getResolvedHash(entry);\n\t\t\tif (resolved !== undefined) return callback(null, resolved);\n\t\t\tthis._resolveContextHash(entry, callback);\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} path context path\n\t * @param {function((WebpackError | null)=, ContextHash=): void} callback callback function\n\t * @returns {void}\n\t */\n\t_getUnresolvedContextHash(path, callback) {\n\t\tconst cache = this._contextHashes.get(path);\n\t\tif (cache !== undefined) return callback(null, cache);\n\t\tthis.contextHashQueue.add(path, callback);\n\t}\n\n\t/**\n\t * @param {string} path context path\n\t * @param {function((WebpackError | null)=, ResolvedContextTimestampAndHash=): void} callback callback function\n\t * @returns {void}\n\t */\n\tgetContextTsh(path, callback) {\n\t\tconst cache = this._contextTshs.get(path);\n\t\tif (cache !== undefined) {\n\t\t\tconst resolved = getResolvedTimestamp(cache);\n\t\t\tif (resolved !== undefined) return callback(null, resolved);\n\t\t\treturn this._resolveContextTsh(cache, callback);\n\t\t}\n\t\tthis.contextTshQueue.add(path, (err, entry) => {\n\t\t\tif (err) return callback(err);\n\t\t\tconst resolved = getResolvedTimestamp(entry);\n\t\t\tif (resolved !== undefined) return callback(null, resolved);\n\t\t\tthis._resolveContextTsh(entry, callback);\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} path context path\n\t * @param {function((WebpackError | null)=, ContextTimestampAndHash=): void} callback callback function\n\t * @returns {void}\n\t */\n\t_getUnresolvedContextTsh(path, callback) {\n\t\tconst cache = this._contextTshs.get(path);\n\t\tif (cache !== undefined) return callback(null, cache);\n\t\tthis.contextTshQueue.add(path, callback);\n\t}\n\n\t_createBuildDependenciesResolvers() {\n\t\tconst resolveContext = createResolver({\n\t\t\tresolveToContext: true,\n\t\t\texportsFields: [],\n\t\t\tfileSystem: this.fs\n\t\t});\n\t\tconst resolveCjs = createResolver({\n\t\t\textensions: [\".js\", \".json\", \".node\"],\n\t\t\tconditionNames: [\"require\", \"node\"],\n\t\t\texportsFields: [\"exports\"],\n\t\t\tfileSystem: this.fs\n\t\t});\n\t\tconst resolveCjsAsChild = createResolver({\n\t\t\textensions: [\".js\", \".json\", \".node\"],\n\t\t\tconditionNames: [\"require\", \"node\"],\n\t\t\texportsFields: [],\n\t\t\tfileSystem: this.fs\n\t\t});\n\t\tconst resolveEsm = createResolver({\n\t\t\textensions: [\".js\", \".json\", \".node\"],\n\t\t\tfullySpecified: true,\n\t\t\tconditionNames: [\"import\", \"node\"],\n\t\t\texportsFields: [\"exports\"],\n\t\t\tfileSystem: this.fs\n\t\t});\n\t\treturn { resolveContext, resolveEsm, resolveCjs, resolveCjsAsChild };\n\t}\n\n\t/**\n\t * @param {string} context context directory\n\t * @param {Iterable<string>} deps dependencies\n\t * @param {function((Error | null)=, ResolveBuildDependenciesResult=): void} callback callback function\n\t * @returns {void}\n\t */\n\tresolveBuildDependencies(context, deps, callback) {\n\t\tconst { resolveContext, resolveEsm, resolveCjs, resolveCjsAsChild } =\n\t\t\tthis._createBuildDependenciesResolvers();\n\n\t\t/** @type {Set<string>} */\n\t\tconst files = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst fileSymlinks = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst directories = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst directorySymlinks = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst missing = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst resolveFiles = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst resolveDirectories = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst resolveMissing = new Set();\n\t\t/** @type {Map<string, string | false>} */\n\t\tconst resolveResults = new Map();\n\t\tconst invalidResolveResults = new Set();\n\t\tconst resolverContext = {\n\t\t\tfileDependencies: resolveFiles,\n\t\t\tcontextDependencies: resolveDirectories,\n\t\t\tmissingDependencies: resolveMissing\n\t\t};\n\t\tconst expectedToString = expected => {\n\t\t\treturn expected ? ` (expected ${expected})` : \"\";\n\t\t};\n\t\tconst jobToString = job => {\n\t\t\tswitch (job.type) {\n\t\t\t\tcase RBDT_RESOLVE_CJS:\n\t\t\t\t\treturn `resolve commonjs ${job.path}${expectedToString(\n\t\t\t\t\t\tjob.expected\n\t\t\t\t\t)}`;\n\t\t\t\tcase RBDT_RESOLVE_ESM:\n\t\t\t\t\treturn `resolve esm ${job.path}${expectedToString(job.expected)}`;\n\t\t\t\tcase RBDT_RESOLVE_DIRECTORY:\n\t\t\t\t\treturn `resolve directory ${job.path}`;\n\t\t\t\tcase RBDT_RESOLVE_CJS_FILE:\n\t\t\t\t\treturn `resolve commonjs file ${job.path}${expectedToString(\n\t\t\t\t\t\tjob.expected\n\t\t\t\t\t)}`;\n\t\t\t\tcase RBDT_RESOLVE_ESM_FILE:\n\t\t\t\t\treturn `resolve esm file ${job.path}${expectedToString(\n\t\t\t\t\t\tjob.expected\n\t\t\t\t\t)}`;\n\t\t\t\tcase RBDT_DIRECTORY:\n\t\t\t\t\treturn `directory ${job.path}`;\n\t\t\t\tcase RBDT_FILE:\n\t\t\t\t\treturn `file ${job.path}`;\n\t\t\t\tcase RBDT_DIRECTORY_DEPENDENCIES:\n\t\t\t\t\treturn `directory dependencies ${job.path}`;\n\t\t\t\tcase RBDT_FILE_DEPENDENCIES:\n\t\t\t\t\treturn `file dependencies ${job.path}`;\n\t\t\t}\n\t\t\treturn `unknown ${job.type} ${job.path}`;\n\t\t};\n\t\tconst pathToString = job => {\n\t\t\tlet result = ` at ${jobToString(job)}`;\n\t\t\tjob = job.issuer;\n\t\t\twhile (job !== undefined) {\n\t\t\t\tresult += `\\n at ${jobToString(job)}`;\n\t\t\t\tjob = job.issuer;\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t\tprocessAsyncTree(\n\t\t\tArray.from(deps, dep => ({\n\t\t\t\ttype: RBDT_RESOLVE_CJS,\n\t\t\t\tcontext,\n\t\t\t\tpath: dep,\n\t\t\t\texpected: undefined,\n\t\t\t\tissuer: undefined\n\t\t\t})),\n\t\t\t20,\n\t\t\t(job, push, callback) => {\n\t\t\t\tconst { type, context, path, expected } = job;\n\t\t\t\tconst resolveDirectory = path => {\n\t\t\t\t\tconst key = `d\\n${context}\\n${path}`;\n\t\t\t\t\tif (resolveResults.has(key)) {\n\t\t\t\t\t\treturn callback();\n\t\t\t\t\t}\n\t\t\t\t\tresolveResults.set(key, undefined);\n\t\t\t\t\tresolveContext(context, path, resolverContext, (err, _, result) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tif (expected === false) {\n\t\t\t\t\t\t\t\tresolveResults.set(key, false);\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tinvalidResolveResults.add(key);\n\t\t\t\t\t\t\terr.message += `\\nwhile resolving '${path}' in ${context} to a directory`;\n\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst resultPath = result.path;\n\t\t\t\t\t\tresolveResults.set(key, resultPath);\n\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\ttype: RBDT_DIRECTORY,\n\t\t\t\t\t\t\tcontext: undefined,\n\t\t\t\t\t\t\tpath: resultPath,\n\t\t\t\t\t\t\texpected: undefined,\n\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\tconst resolveFile = (path, symbol, resolve) => {\n\t\t\t\t\tconst key = `${symbol}\\n${context}\\n${path}`;\n\t\t\t\t\tif (resolveResults.has(key)) {\n\t\t\t\t\t\treturn callback();\n\t\t\t\t\t}\n\t\t\t\t\tresolveResults.set(key, undefined);\n\t\t\t\t\tresolve(context, path, resolverContext, (err, _, result) => {\n\t\t\t\t\t\tif (typeof expected === \"string\") {\n\t\t\t\t\t\t\tif (!err && result && result.path === expected) {\n\t\t\t\t\t\t\t\tresolveResults.set(key, result.path);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tinvalidResolveResults.add(key);\n\t\t\t\t\t\t\t\tthis.logger.warn(\n\t\t\t\t\t\t\t\t\t`Resolving '${path}' in ${context} for build dependencies doesn't lead to expected result '${expected}', but to '${\n\t\t\t\t\t\t\t\t\t\terr || (result && result.path)\n\t\t\t\t\t\t\t\t\t}' instead. Resolving dependencies are ignored for this path.\\n${pathToString(\n\t\t\t\t\t\t\t\t\t\tjob\n\t\t\t\t\t\t\t\t\t)}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tif (expected === false) {\n\t\t\t\t\t\t\t\t\tresolveResults.set(key, false);\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tinvalidResolveResults.add(key);\n\t\t\t\t\t\t\t\terr.message += `\\nwhile resolving '${path}' in ${context} as file\\n${pathToString(\n\t\t\t\t\t\t\t\t\tjob\n\t\t\t\t\t\t\t\t)}`;\n\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst resultPath = result.path;\n\t\t\t\t\t\t\tresolveResults.set(key, resultPath);\n\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\ttype: RBDT_FILE,\n\t\t\t\t\t\t\t\tcontext: undefined,\n\t\t\t\t\t\t\t\tpath: resultPath,\n\t\t\t\t\t\t\t\texpected: undefined,\n\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase RBDT_RESOLVE_CJS: {\n\t\t\t\t\t\tconst isDirectory = /[\\\\/]$/.test(path);\n\t\t\t\t\t\tif (isDirectory) {\n\t\t\t\t\t\t\tresolveDirectory(path.slice(0, path.length - 1));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolveFile(path, \"f\", resolveCjs);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_RESOLVE_ESM: {\n\t\t\t\t\t\tconst isDirectory = /[\\\\/]$/.test(path);\n\t\t\t\t\t\tif (isDirectory) {\n\t\t\t\t\t\t\tresolveDirectory(path.slice(0, path.length - 1));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolveFile(path);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_RESOLVE_DIRECTORY: {\n\t\t\t\t\t\tresolveDirectory(path);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_RESOLVE_CJS_FILE: {\n\t\t\t\t\t\tresolveFile(path, \"f\", resolveCjs);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_RESOLVE_CJS_FILE_AS_CHILD: {\n\t\t\t\t\t\tresolveFile(path, \"c\", resolveCjsAsChild);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_RESOLVE_ESM_FILE: {\n\t\t\t\t\t\tresolveFile(path, \"e\", resolveEsm);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_FILE: {\n\t\t\t\t\t\tif (files.has(path)) {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfiles.add(path);\n\t\t\t\t\t\tthis.fs.realpath(path, (err, _realPath) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst realPath = /** @type {string} */ (_realPath);\n\t\t\t\t\t\t\tif (realPath !== path) {\n\t\t\t\t\t\t\t\tfileSymlinks.add(path);\n\t\t\t\t\t\t\t\tresolveFiles.add(path);\n\t\t\t\t\t\t\t\tif (files.has(realPath)) return callback();\n\t\t\t\t\t\t\t\tfiles.add(realPath);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\ttype: RBDT_FILE_DEPENDENCIES,\n\t\t\t\t\t\t\t\tcontext: undefined,\n\t\t\t\t\t\t\t\tpath: realPath,\n\t\t\t\t\t\t\t\texpected: undefined,\n\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_DIRECTORY: {\n\t\t\t\t\t\tif (directories.has(path)) {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdirectories.add(path);\n\t\t\t\t\t\tthis.fs.realpath(path, (err, _realPath) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst realPath = /** @type {string} */ (_realPath);\n\t\t\t\t\t\t\tif (realPath !== path) {\n\t\t\t\t\t\t\t\tdirectorySymlinks.add(path);\n\t\t\t\t\t\t\t\tresolveFiles.add(path);\n\t\t\t\t\t\t\t\tif (directories.has(realPath)) return callback();\n\t\t\t\t\t\t\t\tdirectories.add(realPath);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\ttype: RBDT_DIRECTORY_DEPENDENCIES,\n\t\t\t\t\t\t\t\tcontext: undefined,\n\t\t\t\t\t\t\t\tpath: realPath,\n\t\t\t\t\t\t\t\texpected: undefined,\n\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_FILE_DEPENDENCIES: {\n\t\t\t\t\t\t// Check for known files without dependencies\n\t\t\t\t\t\tif (/\\.json5?$|\\.yarn-integrity$|yarn\\.lock$|\\.ya?ml/.test(path)) {\n\t\t\t\t\t\t\tprocess.nextTick(callback);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Check commonjs cache for the module\n\t\t\t\t\t\t/** @type {NodeModule} */\n\t\t\t\t\t\tconst module = require.cache[path];\n\t\t\t\t\t\tif (module && Array.isArray(module.children)) {\n\t\t\t\t\t\t\tchildren: for (const child of module.children) {\n\t\t\t\t\t\t\t\tlet childPath = child.filename;\n\t\t\t\t\t\t\t\tif (childPath) {\n\t\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\t\ttype: RBDT_FILE,\n\t\t\t\t\t\t\t\t\t\tcontext: undefined,\n\t\t\t\t\t\t\t\t\t\tpath: childPath,\n\t\t\t\t\t\t\t\t\t\texpected: undefined,\n\t\t\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tconst context = dirname(this.fs, path);\n\t\t\t\t\t\t\t\t\tfor (const modulePath of module.paths) {\n\t\t\t\t\t\t\t\t\t\tif (childPath.startsWith(modulePath)) {\n\t\t\t\t\t\t\t\t\t\t\tlet subPath = childPath.slice(modulePath.length + 1);\n\t\t\t\t\t\t\t\t\t\t\tconst packageMatch = /^(@[^\\\\/]+[\\\\/])[^\\\\/]+/.exec(\n\t\t\t\t\t\t\t\t\t\t\t\tsubPath\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tif (packageMatch) {\n\t\t\t\t\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: RBDT_FILE,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontext: undefined,\n\t\t\t\t\t\t\t\t\t\t\t\t\tpath:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodulePath +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tchildPath[modulePath.length] +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpackageMatch[0] +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tchildPath[modulePath.length] +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"package.json\",\n\t\t\t\t\t\t\t\t\t\t\t\t\texpected: false,\n\t\t\t\t\t\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tlet request = subPath.replace(/\\\\/g, \"/\");\n\t\t\t\t\t\t\t\t\t\t\tif (request.endsWith(\".js\"))\n\t\t\t\t\t\t\t\t\t\t\t\trequest = request.slice(0, -3);\n\t\t\t\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: RBDT_RESOLVE_CJS_FILE_AS_CHILD,\n\t\t\t\t\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\t\t\t\t\tpath: request,\n\t\t\t\t\t\t\t\t\t\t\t\texpected: child.filename,\n\t\t\t\t\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\tcontinue children;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet request = relative(this.fs, context, childPath);\n\t\t\t\t\t\t\t\t\tif (request.endsWith(\".js\")) request = request.slice(0, -3);\n\t\t\t\t\t\t\t\t\trequest = request.replace(/\\\\/g, \"/\");\n\t\t\t\t\t\t\t\t\tif (!request.startsWith(\"../\")) request = `./${request}`;\n\t\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\t\ttype: RBDT_RESOLVE_CJS_FILE,\n\t\t\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\t\t\tpath: request,\n\t\t\t\t\t\t\t\t\t\texpected: child.filename,\n\t\t\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (supportsEsm && /\\.m?js$/.test(path)) {\n\t\t\t\t\t\t\tif (!this._warnAboutExperimentalEsmTracking) {\n\t\t\t\t\t\t\t\tthis.logger.log(\n\t\t\t\t\t\t\t\t\t\"Node.js doesn't offer a (nice) way to introspect the ESM dependency graph yet.\\n\" +\n\t\t\t\t\t\t\t\t\t\t\"Until a full solution is available webpack uses an experimental ESM tracking based on parsing.\\n\" +\n\t\t\t\t\t\t\t\t\t\t\"As best effort webpack parses the ESM files to guess dependencies. But this can lead to expensive and incorrect tracking.\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tthis._warnAboutExperimentalEsmTracking = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst lexer = require(\"es-module-lexer\");\n\t\t\t\t\t\t\tlexer.init.then(() => {\n\t\t\t\t\t\t\t\tthis.fs.readFile(path, (err, content) => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tconst context = dirname(this.fs, path);\n\t\t\t\t\t\t\t\t\t\tconst source = content.toString();\n\t\t\t\t\t\t\t\t\t\tconst [imports] = lexer.parse(source);\n\t\t\t\t\t\t\t\t\t\tfor (const imp of imports) {\n\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\tlet dependency;\n\t\t\t\t\t\t\t\t\t\t\t\tif (imp.d === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// import ... from \"...\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tdependency = parseString(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsource.substring(imp.s - 1, imp.e + 1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (imp.d > -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// import()\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet expr = source.substring(imp.s, imp.e).trim();\n\t\t\t\t\t\t\t\t\t\t\t\t\tdependency = parseString(expr);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// e.g. import.meta\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: RBDT_RESOLVE_ESM_FILE,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\t\t\t\t\t\tpath: dependency,\n\t\t\t\t\t\t\t\t\t\t\t\t\texpected: undefined,\n\t\t\t\t\t\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\t\t\t\tthis.logger.warn(\n\t\t\t\t\t\t\t\t\t\t\t\t\t`Parsing of ${path} for build dependencies failed at 'import(${source.substring(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\timp.s,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\timp.e\n\t\t\t\t\t\t\t\t\t\t\t\t\t)})'.\\n` +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"Build dependencies behind this expression are ignored and might cause incorrect cache invalidation.\"\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tthis.logger.debug(pathToString(job));\n\t\t\t\t\t\t\t\t\t\t\t\tthis.logger.debug(e.stack);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\t\tthis.logger.warn(\n\t\t\t\t\t\t\t\t\t\t\t`Parsing of ${path} for build dependencies failed and all dependencies of this file are ignored, which might cause incorrect cache invalidation..`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tthis.logger.debug(pathToString(job));\n\t\t\t\t\t\t\t\t\t\tthis.logger.debug(e.stack);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tprocess.nextTick(callback);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}, callback);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.logger.log(\n\t\t\t\t\t\t\t\t`Assuming ${path} has no dependencies as we were unable to assign it to any module system.`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tthis.logger.debug(pathToString(job));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprocess.nextTick(callback);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_DIRECTORY_DEPENDENCIES: {\n\t\t\t\t\t\tconst match =\n\t\t\t\t\t\t\t/(^.+[\\\\/]node_modules[\\\\/](?:@[^\\\\/]+[\\\\/])?[^\\\\/]+)/.exec(path);\n\t\t\t\t\t\tconst packagePath = match ? match[1] : path;\n\t\t\t\t\t\tconst packageJson = join(this.fs, packagePath, \"package.json\");\n\t\t\t\t\t\tthis.fs.readFile(packageJson, (err, content) => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\t\t\t\t\t\tresolveMissing.add(packageJson);\n\t\t\t\t\t\t\t\t\tconst parent = dirname(this.fs, packagePath);\n\t\t\t\t\t\t\t\t\tif (parent !== packagePath) {\n\t\t\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\t\t\ttype: RBDT_DIRECTORY_DEPENDENCIES,\n\t\t\t\t\t\t\t\t\t\t\tcontext: undefined,\n\t\t\t\t\t\t\t\t\t\t\tpath: parent,\n\t\t\t\t\t\t\t\t\t\t\texpected: undefined,\n\t\t\t\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresolveFiles.add(packageJson);\n\t\t\t\t\t\t\tlet packageData;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tpackageData = JSON.parse(content.toString(\"utf-8\"));\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\treturn callback(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst depsObject = packageData.dependencies;\n\t\t\t\t\t\t\tconst optionalDepsObject = packageData.optionalDependencies;\n\t\t\t\t\t\t\tconst allDeps = new Set();\n\t\t\t\t\t\t\tconst optionalDeps = new Set();\n\t\t\t\t\t\t\tif (typeof depsObject === \"object\" && depsObject) {\n\t\t\t\t\t\t\t\tfor (const dep of Object.keys(depsObject)) {\n\t\t\t\t\t\t\t\t\tallDeps.add(dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\ttypeof optionalDepsObject === \"object\" &&\n\t\t\t\t\t\t\t\toptionalDepsObject\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tfor (const dep of Object.keys(optionalDepsObject)) {\n\t\t\t\t\t\t\t\t\tallDeps.add(dep);\n\t\t\t\t\t\t\t\t\toptionalDeps.add(dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const dep of allDeps) {\n\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\ttype: RBDT_RESOLVE_DIRECTORY,\n\t\t\t\t\t\t\t\t\tcontext: packagePath,\n\t\t\t\t\t\t\t\t\tpath: dep,\n\t\t\t\t\t\t\t\t\texpected: !optionalDeps.has(dep),\n\t\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tfor (const l of fileSymlinks) files.delete(l);\n\t\t\t\tfor (const l of directorySymlinks) directories.delete(l);\n\t\t\t\tfor (const k of invalidResolveResults) resolveResults.delete(k);\n\t\t\t\tcallback(null, {\n\t\t\t\t\tfiles,\n\t\t\t\t\tdirectories,\n\t\t\t\t\tmissing,\n\t\t\t\t\tresolveResults,\n\t\t\t\t\tresolveDependencies: {\n\t\t\t\t\t\tfiles: resolveFiles,\n\t\t\t\t\t\tdirectories: resolveDirectories,\n\t\t\t\t\t\tmissing: resolveMissing\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {Map<string, string | false>} resolveResults results from resolving\n\t * @param {function((Error | null)=, boolean=): void} callback callback with true when resolveResults resolve the same way\n\t * @returns {void}\n\t */\n\tcheckResolveResultsValid(resolveResults, callback) {\n\t\tconst { resolveCjs, resolveCjsAsChild, resolveEsm, resolveContext } =\n\t\t\tthis._createBuildDependenciesResolvers();\n\t\tasyncLib.eachLimit(\n\t\t\tresolveResults,\n\t\t\t20,\n\t\t\t([key, expectedResult], callback) => {\n\t\t\t\tconst [type, context, path] = key.split(\"\\n\");\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase \"d\":\n\t\t\t\t\t\tresolveContext(context, path, {}, (err, _, result) => {\n\t\t\t\t\t\t\tif (expectedResult === false)\n\t\t\t\t\t\t\t\treturn callback(err ? undefined : INVALID);\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst resultPath = result.path;\n\t\t\t\t\t\t\tif (resultPath !== expectedResult) return callback(INVALID);\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"f\":\n\t\t\t\t\t\tresolveCjs(context, path, {}, (err, _, result) => {\n\t\t\t\t\t\t\tif (expectedResult === false)\n\t\t\t\t\t\t\t\treturn callback(err ? undefined : INVALID);\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst resultPath = result.path;\n\t\t\t\t\t\t\tif (resultPath !== expectedResult) return callback(INVALID);\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"c\":\n\t\t\t\t\t\tresolveCjsAsChild(context, path, {}, (err, _, result) => {\n\t\t\t\t\t\t\tif (expectedResult === false)\n\t\t\t\t\t\t\t\treturn callback(err ? undefined : INVALID);\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst resultPath = result.path;\n\t\t\t\t\t\t\tif (resultPath !== expectedResult) return callback(INVALID);\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"e\":\n\t\t\t\t\t\tresolveEsm(context, path, {}, (err, _, result) => {\n\t\t\t\t\t\t\tif (expectedResult === false)\n\t\t\t\t\t\t\t\treturn callback(err ? undefined : INVALID);\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst resultPath = result.path;\n\t\t\t\t\t\t\tif (resultPath !== expectedResult) return callback(INVALID);\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcallback(new Error(\"Unexpected type in resolve result key\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t},\n\t\t\t/**\n\t\t\t * @param {Error | typeof INVALID=} err error or invalid flag\n\t\t\t * @returns {void}\n\t\t\t */\n\t\t\terr => {\n\t\t\t\tif (err === INVALID) {\n\t\t\t\t\treturn callback(null, false);\n\t\t\t\t}\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\t\t\t\treturn callback(null, true);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t *\n\t * @param {number} startTime when processing the files has started\n\t * @param {Iterable<string>} files all files\n\t * @param {Iterable<string>} directories all directories\n\t * @param {Iterable<string>} missing all missing files or directories\n\t * @param {Object} options options object (for future extensions)\n\t * @param {boolean=} options.hash should use hash to snapshot\n\t * @param {boolean=} options.timestamp should use timestamp to snapshot\n\t * @param {function((WebpackError | null)=, (Snapshot | null)=): void} callback callback function\n\t * @returns {void}\n\t */\n\tcreateSnapshot(startTime, files, directories, missing, options, callback) {\n\t\t/** @type {Map<string, FileSystemInfoEntry | null>} */\n\t\tconst fileTimestamps = new Map();\n\t\t/** @type {Map<string, string | null>} */\n\t\tconst fileHashes = new Map();\n\t\t/** @type {Map<string, TimestampAndHash | string | null>} */\n\t\tconst fileTshs = new Map();\n\t\t/** @type {Map<string, FileSystemInfoEntry | null>} */\n\t\tconst contextTimestamps = new Map();\n\t\t/** @type {Map<string, string | null>} */\n\t\tconst contextHashes = new Map();\n\t\t/** @type {Map<string, ResolvedContextTimestampAndHash | null>} */\n\t\tconst contextTshs = new Map();\n\t\t/** @type {Map<string, boolean>} */\n\t\tconst missingExistence = new Map();\n\t\t/** @type {Map<string, string>} */\n\t\tconst managedItemInfo = new Map();\n\t\t/** @type {Set<string>} */\n\t\tconst managedFiles = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst managedContexts = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst managedMissing = new Set();\n\t\t/** @type {Set<Snapshot>} */\n\t\tconst children = new Set();\n\n\t\tconst snapshot = new Snapshot();\n\t\tif (startTime) snapshot.setStartTime(startTime);\n\n\t\t/** @type {Set<string>} */\n\t\tconst managedItems = new Set();\n\n\t\t/** 1 = timestamp, 2 = hash, 3 = timestamp + hash */\n\t\tconst mode = options && options.hash ? (options.timestamp ? 3 : 2) : 1;\n\n\t\tlet jobs = 1;\n\t\tconst jobDone = () => {\n\t\t\tif (--jobs === 0) {\n\t\t\t\tif (fileTimestamps.size !== 0) {\n\t\t\t\t\tsnapshot.setFileTimestamps(fileTimestamps);\n\t\t\t\t}\n\t\t\t\tif (fileHashes.size !== 0) {\n\t\t\t\t\tsnapshot.setFileHashes(fileHashes);\n\t\t\t\t}\n\t\t\t\tif (fileTshs.size !== 0) {\n\t\t\t\t\tsnapshot.setFileTshs(fileTshs);\n\t\t\t\t}\n\t\t\t\tif (contextTimestamps.size !== 0) {\n\t\t\t\t\tsnapshot.setContextTimestamps(contextTimestamps);\n\t\t\t\t}\n\t\t\t\tif (contextHashes.size !== 0) {\n\t\t\t\t\tsnapshot.setContextHashes(contextHashes);\n\t\t\t\t}\n\t\t\t\tif (contextTshs.size !== 0) {\n\t\t\t\t\tsnapshot.setContextTshs(contextTshs);\n\t\t\t\t}\n\t\t\t\tif (missingExistence.size !== 0) {\n\t\t\t\t\tsnapshot.setMissingExistence(missingExistence);\n\t\t\t\t}\n\t\t\t\tif (managedItemInfo.size !== 0) {\n\t\t\t\t\tsnapshot.setManagedItemInfo(managedItemInfo);\n\t\t\t\t}\n\t\t\t\tthis._managedFilesOptimization.optimize(snapshot, managedFiles);\n\t\t\t\tif (managedFiles.size !== 0) {\n\t\t\t\t\tsnapshot.setManagedFiles(managedFiles);\n\t\t\t\t}\n\t\t\t\tthis._managedContextsOptimization.optimize(snapshot, managedContexts);\n\t\t\t\tif (managedContexts.size !== 0) {\n\t\t\t\t\tsnapshot.setManagedContexts(managedContexts);\n\t\t\t\t}\n\t\t\t\tthis._managedMissingOptimization.optimize(snapshot, managedMissing);\n\t\t\t\tif (managedMissing.size !== 0) {\n\t\t\t\t\tsnapshot.setManagedMissing(managedMissing);\n\t\t\t\t}\n\t\t\t\tif (children.size !== 0) {\n\t\t\t\t\tsnapshot.setChildren(children);\n\t\t\t\t}\n\t\t\t\tthis._snapshotCache.set(snapshot, true);\n\t\t\t\tthis._statCreatedSnapshots++;\n\n\t\t\t\tcallback(null, snapshot);\n\t\t\t}\n\t\t};\n\t\tconst jobError = () => {\n\t\t\tif (jobs > 0) {\n\t\t\t\t// large negative number instead of NaN or something else to keep jobs to stay a SMI (v8)\n\t\t\t\tjobs = -100000000;\n\t\t\t\tcallback(null, null);\n\t\t\t}\n\t\t};\n\t\tconst checkManaged = (path, managedSet) => {\n\t\t\tfor (const immutablePath of this.immutablePathsRegExps) {\n\t\t\t\tif (immutablePath.test(path)) {\n\t\t\t\t\tmanagedSet.add(path);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const immutablePath of this.immutablePathsWithSlash) {\n\t\t\t\tif (path.startsWith(immutablePath)) {\n\t\t\t\t\tmanagedSet.add(path);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const managedPath of this.managedPathsRegExps) {\n\t\t\t\tconst match = managedPath.exec(path);\n\t\t\t\tif (match) {\n\t\t\t\t\tconst managedItem = getManagedItem(match[1], path);\n\t\t\t\t\tif (managedItem) {\n\t\t\t\t\t\tmanagedItems.add(managedItem);\n\t\t\t\t\t\tmanagedSet.add(path);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const managedPath of this.managedPathsWithSlash) {\n\t\t\t\tif (path.startsWith(managedPath)) {\n\t\t\t\t\tconst managedItem = getManagedItem(managedPath, path);\n\t\t\t\t\tif (managedItem) {\n\t\t\t\t\t\tmanagedItems.add(managedItem);\n\t\t\t\t\t\tmanagedSet.add(path);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tconst captureNonManaged = (items, managedSet) => {\n\t\t\tconst capturedItems = new Set();\n\t\t\tfor (const path of items) {\n\t\t\t\tif (!checkManaged(path, managedSet)) capturedItems.add(path);\n\t\t\t}\n\t\t\treturn capturedItems;\n\t\t};\n\t\tconst processCapturedFiles = capturedFiles => {\n\t\t\tswitch (mode) {\n\t\t\t\tcase 3:\n\t\t\t\t\tthis._fileTshsOptimization.optimize(snapshot, capturedFiles);\n\t\t\t\t\tfor (const path of capturedFiles) {\n\t\t\t\t\t\tconst cache = this._fileTshs.get(path);\n\t\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\t\tfileTshs.set(path, cache);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\t\tthis._getFileTimestampAndHash(path, (err, entry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`Error snapshotting file timestamp hash combination of ${path}: ${err.stack}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tjobError();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfileTshs.set(path, entry);\n\t\t\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tthis._fileHashesOptimization.optimize(snapshot, capturedFiles);\n\t\t\t\t\tfor (const path of capturedFiles) {\n\t\t\t\t\t\tconst cache = this._fileHashes.get(path);\n\t\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\t\tfileHashes.set(path, cache);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\t\tthis.fileHashQueue.add(path, (err, entry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`Error snapshotting file hash of ${path}: ${err.stack}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tjobError();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfileHashes.set(path, entry);\n\t\t\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tthis._fileTimestampsOptimization.optimize(snapshot, capturedFiles);\n\t\t\t\t\tfor (const path of capturedFiles) {\n\t\t\t\t\t\tconst cache = this._fileTimestamps.get(path);\n\t\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\t\tif (cache !== \"ignore\") {\n\t\t\t\t\t\t\t\tfileTimestamps.set(path, cache);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\t\tthis.fileTimestampQueue.add(path, (err, entry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`Error snapshotting file timestamp of ${path}: ${err.stack}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tjobError();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfileTimestamps.set(path, entry);\n\t\t\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\t\tif (files) {\n\t\t\tprocessCapturedFiles(captureNonManaged(files, managedFiles));\n\t\t}\n\t\tconst processCapturedDirectories = capturedDirectories => {\n\t\t\tswitch (mode) {\n\t\t\t\tcase 3:\n\t\t\t\t\tthis._contextTshsOptimization.optimize(snapshot, capturedDirectories);\n\t\t\t\t\tfor (const path of capturedDirectories) {\n\t\t\t\t\t\tconst cache = this._contextTshs.get(path);\n\t\t\t\t\t\t/** @type {ResolvedContextTimestampAndHash} */\n\t\t\t\t\t\tlet resolved;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tcache !== undefined &&\n\t\t\t\t\t\t\t(resolved = getResolvedTimestamp(cache)) !== undefined\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontextTshs.set(path, resolved);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {Error=} err error\n\t\t\t\t\t\t\t * @param {ResolvedContextTimestampAndHash=} entry entry\n\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst callback = (err, entry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`Error snapshotting context timestamp hash combination of ${path}: ${err.stack}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tjobError();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcontextTshs.set(path, entry);\n\t\t\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\t\t\tthis._resolveContextTsh(cache, callback);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.getContextTsh(path, callback);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tthis._contextHashesOptimization.optimize(\n\t\t\t\t\t\tsnapshot,\n\t\t\t\t\t\tcapturedDirectories\n\t\t\t\t\t);\n\t\t\t\t\tfor (const path of capturedDirectories) {\n\t\t\t\t\t\tconst cache = this._contextHashes.get(path);\n\t\t\t\t\t\tlet resolved;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tcache !== undefined &&\n\t\t\t\t\t\t\t(resolved = getResolvedHash(cache)) !== undefined\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontextHashes.set(path, resolved);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\t\tconst callback = (err, entry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`Error snapshotting context hash of ${path}: ${err.stack}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tjobError();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcontextHashes.set(path, entry);\n\t\t\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\t\t\tthis._resolveContextHash(cache, callback);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.getContextHash(path, callback);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tthis._contextTimestampsOptimization.optimize(\n\t\t\t\t\t\tsnapshot,\n\t\t\t\t\t\tcapturedDirectories\n\t\t\t\t\t);\n\t\t\t\t\tfor (const path of capturedDirectories) {\n\t\t\t\t\t\tconst cache = this._contextTimestamps.get(path);\n\t\t\t\t\t\tif (cache === \"ignore\") continue;\n\t\t\t\t\t\tlet resolved;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tcache !== undefined &&\n\t\t\t\t\t\t\t(resolved = getResolvedTimestamp(cache)) !== undefined\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontextTimestamps.set(path, resolved);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {Error=} err error\n\t\t\t\t\t\t\t * @param {ResolvedContextFileSystemInfoEntry=} entry entry\n\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst callback = (err, entry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`Error snapshotting context timestamp of ${path}: ${err.stack}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tjobError();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcontextTimestamps.set(path, entry);\n\t\t\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\t\t\tthis._resolveContextTimestamp(cache, callback);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.getContextTimestamp(path, callback);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\t\tif (directories) {\n\t\t\tprocessCapturedDirectories(\n\t\t\t\tcaptureNonManaged(directories, managedContexts)\n\t\t\t);\n\t\t}\n\t\tconst processCapturedMissing = capturedMissing => {\n\t\t\tthis._missingExistenceOptimization.optimize(snapshot, capturedMissing);\n\t\t\tfor (const path of capturedMissing) {\n\t\t\t\tconst cache = this._fileTimestamps.get(path);\n\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\tif (cache !== \"ignore\") {\n\t\t\t\t\t\tmissingExistence.set(path, Boolean(cache));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tjobs++;\n\t\t\t\t\tthis.fileTimestampQueue.add(path, (err, entry) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t\t`Error snapshotting missing timestamp of ${path}: ${err.stack}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tjobError();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmissingExistence.set(path, Boolean(entry));\n\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif (missing) {\n\t\t\tprocessCapturedMissing(captureNonManaged(missing, managedMissing));\n\t\t}\n\t\tthis._managedItemInfoOptimization.optimize(snapshot, managedItems);\n\t\tfor (const path of managedItems) {\n\t\t\tconst cache = this._managedItems.get(path);\n\t\t\tif (cache !== undefined) {\n\t\t\t\tif (!cache.startsWith(\"*\")) {\n\t\t\t\t\tmanagedFiles.add(join(this.fs, path, \"package.json\"));\n\t\t\t\t} else if (cache === \"*nested\") {\n\t\t\t\t\tmanagedMissing.add(join(this.fs, path, \"package.json\"));\n\t\t\t\t}\n\t\t\t\tmanagedItemInfo.set(path, cache);\n\t\t\t} else {\n\t\t\t\tjobs++;\n\t\t\t\tthis.managedItemQueue.add(path, (err, entry) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t`Error snapshotting managed item ${path}: ${err.stack}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjobError();\n\t\t\t\t\t} else if (entry) {\n\t\t\t\t\t\tif (!entry.startsWith(\"*\")) {\n\t\t\t\t\t\t\tmanagedFiles.add(join(this.fs, path, \"package.json\"));\n\t\t\t\t\t\t} else if (cache === \"*nested\") {\n\t\t\t\t\t\t\tmanagedMissing.add(join(this.fs, path, \"package.json\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmanagedItemInfo.set(path, entry);\n\t\t\t\t\t\tjobDone();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Fallback to normal snapshotting\n\t\t\t\t\t\tconst process = (set, fn) => {\n\t\t\t\t\t\t\tif (set.size === 0) return;\n\t\t\t\t\t\t\tconst captured = new Set();\n\t\t\t\t\t\t\tfor (const file of set) {\n\t\t\t\t\t\t\t\tif (file.startsWith(path)) captured.add(file);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (captured.size > 0) fn(captured);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tprocess(managedFiles, processCapturedFiles);\n\t\t\t\t\t\tprocess(managedContexts, processCapturedDirectories);\n\t\t\t\t\t\tprocess(managedMissing, processCapturedMissing);\n\t\t\t\t\t\tjobDone();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tjobDone();\n\t}\n\n\t/**\n\t * @param {Snapshot} snapshot1 a snapshot\n\t * @param {Snapshot} snapshot2 a snapshot\n\t * @returns {Snapshot} merged snapshot\n\t */\n\tmergeSnapshots(snapshot1, snapshot2) {\n\t\tconst snapshot = new Snapshot();\n\t\tif (snapshot1.hasStartTime() && snapshot2.hasStartTime())\n\t\t\tsnapshot.setStartTime(Math.min(snapshot1.startTime, snapshot2.startTime));\n\t\telse if (snapshot2.hasStartTime()) snapshot.startTime = snapshot2.startTime;\n\t\telse if (snapshot1.hasStartTime()) snapshot.startTime = snapshot1.startTime;\n\t\tif (snapshot1.hasFileTimestamps() || snapshot2.hasFileTimestamps()) {\n\t\t\tsnapshot.setFileTimestamps(\n\t\t\t\tmergeMaps(snapshot1.fileTimestamps, snapshot2.fileTimestamps)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasFileHashes() || snapshot2.hasFileHashes()) {\n\t\t\tsnapshot.setFileHashes(\n\t\t\t\tmergeMaps(snapshot1.fileHashes, snapshot2.fileHashes)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasFileTshs() || snapshot2.hasFileTshs()) {\n\t\t\tsnapshot.setFileTshs(mergeMaps(snapshot1.fileTshs, snapshot2.fileTshs));\n\t\t}\n\t\tif (snapshot1.hasContextTimestamps() || snapshot2.hasContextTimestamps()) {\n\t\t\tsnapshot.setContextTimestamps(\n\t\t\t\tmergeMaps(snapshot1.contextTimestamps, snapshot2.contextTimestamps)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasContextHashes() || snapshot2.hasContextHashes()) {\n\t\t\tsnapshot.setContextHashes(\n\t\t\t\tmergeMaps(snapshot1.contextHashes, snapshot2.contextHashes)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasContextTshs() || snapshot2.hasContextTshs()) {\n\t\t\tsnapshot.setContextTshs(\n\t\t\t\tmergeMaps(snapshot1.contextTshs, snapshot2.contextTshs)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasMissingExistence() || snapshot2.hasMissingExistence()) {\n\t\t\tsnapshot.setMissingExistence(\n\t\t\t\tmergeMaps(snapshot1.missingExistence, snapshot2.missingExistence)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasManagedItemInfo() || snapshot2.hasManagedItemInfo()) {\n\t\t\tsnapshot.setManagedItemInfo(\n\t\t\t\tmergeMaps(snapshot1.managedItemInfo, snapshot2.managedItemInfo)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasManagedFiles() || snapshot2.hasManagedFiles()) {\n\t\t\tsnapshot.setManagedFiles(\n\t\t\t\tmergeSets(snapshot1.managedFiles, snapshot2.managedFiles)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasManagedContexts() || snapshot2.hasManagedContexts()) {\n\t\t\tsnapshot.setManagedContexts(\n\t\t\t\tmergeSets(snapshot1.managedContexts, snapshot2.managedContexts)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasManagedMissing() || snapshot2.hasManagedMissing()) {\n\t\t\tsnapshot.setManagedMissing(\n\t\t\t\tmergeSets(snapshot1.managedMissing, snapshot2.managedMissing)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasChildren() || snapshot2.hasChildren()) {\n\t\t\tsnapshot.setChildren(mergeSets(snapshot1.children, snapshot2.children));\n\t\t}\n\t\tif (\n\t\t\tthis._snapshotCache.get(snapshot1) === true &&\n\t\t\tthis._snapshotCache.get(snapshot2) === true\n\t\t) {\n\t\t\tthis._snapshotCache.set(snapshot, true);\n\t\t}\n\t\treturn snapshot;\n\t}\n\n\t/**\n\t * @param {Snapshot} snapshot the snapshot made\n\t * @param {function((WebpackError | null)=, boolean=): void} callback callback function\n\t * @returns {void}\n\t */\n\tcheckSnapshotValid(snapshot, callback) {\n\t\tconst cachedResult = this._snapshotCache.get(snapshot);\n\t\tif (cachedResult !== undefined) {\n\t\t\tthis._statTestedSnapshotsCached++;\n\t\t\tif (typeof cachedResult === \"boolean\") {\n\t\t\t\tcallback(null, cachedResult);\n\t\t\t} else {\n\t\t\t\tcachedResult.push(callback);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis._statTestedSnapshotsNotCached++;\n\t\tthis._checkSnapshotValidNoCache(snapshot, callback);\n\t}\n\n\t/**\n\t * @param {Snapshot} snapshot the snapshot made\n\t * @param {function((WebpackError | null)=, boolean=): void} callback callback function\n\t * @returns {void}\n\t */\n\t_checkSnapshotValidNoCache(snapshot, callback) {\n\t\t/** @type {number | undefined} */\n\t\tlet startTime = undefined;\n\t\tif (snapshot.hasStartTime()) {\n\t\t\tstartTime = snapshot.startTime;\n\t\t}\n\t\tlet jobs = 1;\n\t\tconst jobDone = () => {\n\t\t\tif (--jobs === 0) {\n\t\t\t\tthis._snapshotCache.set(snapshot, true);\n\t\t\t\tcallback(null, true);\n\t\t\t}\n\t\t};\n\t\tconst invalid = () => {\n\t\t\tif (jobs > 0) {\n\t\t\t\t// large negative number instead of NaN or something else to keep jobs to stay a SMI (v8)\n\t\t\t\tjobs = -100000000;\n\t\t\t\tthis._snapshotCache.set(snapshot, false);\n\t\t\t\tcallback(null, false);\n\t\t\t}\n\t\t};\n\t\tconst invalidWithError = (path, err) => {\n\t\t\tif (this._remainingLogs > 0) {\n\t\t\t\tthis._log(path, `error occurred: %s`, err);\n\t\t\t}\n\t\t\tinvalid();\n\t\t};\n\t\t/**\n\t\t * @param {string} path file path\n\t\t * @param {string} current current hash\n\t\t * @param {string} snap snapshot hash\n\t\t * @returns {boolean} true, if ok\n\t\t */\n\t\tconst checkHash = (path, current, snap) => {\n\t\t\tif (current !== snap) {\n\t\t\t\t// If hash differ it's invalid\n\t\t\t\tif (this._remainingLogs > 0) {\n\t\t\t\t\tthis._log(path, `hashes differ (%s != %s)`, current, snap);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\t/**\n\t\t * @param {string} path file path\n\t\t * @param {boolean} current current entry\n\t\t * @param {boolean} snap entry from snapshot\n\t\t * @returns {boolean} true, if ok\n\t\t */\n\t\tconst checkExistence = (path, current, snap) => {\n\t\t\tif (!current !== !snap) {\n\t\t\t\t// If existence of item differs\n\t\t\t\t// it's invalid\n\t\t\t\tif (this._remainingLogs > 0) {\n\t\t\t\t\tthis._log(\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\tcurrent ? \"it didn't exist before\" : \"it does no longer exist\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\t/**\n\t\t * @param {string} path file path\n\t\t * @param {FileSystemInfoEntry} current current entry\n\t\t * @param {FileSystemInfoEntry} snap entry from snapshot\n\t\t * @param {boolean} log log reason\n\t\t * @returns {boolean} true, if ok\n\t\t */\n\t\tconst checkFile = (path, current, snap, log = true) => {\n\t\t\tif (current === snap) return true;\n\t\t\tif (!checkExistence(path, Boolean(current), Boolean(snap))) return false;\n\t\t\tif (current) {\n\t\t\t\t// For existing items only\n\t\t\t\tif (typeof startTime === \"number\" && current.safeTime > startTime) {\n\t\t\t\t\t// If a change happened after starting reading the item\n\t\t\t\t\t// this may no longer be valid\n\t\t\t\t\tif (log && this._remainingLogs > 0) {\n\t\t\t\t\t\tthis._log(\n\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t`it may have changed (%d) after the start time of the snapshot (%d)`,\n\t\t\t\t\t\t\tcurrent.safeTime,\n\t\t\t\t\t\t\tstartTime\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tsnap.timestamp !== undefined &&\n\t\t\t\t\tcurrent.timestamp !== snap.timestamp\n\t\t\t\t) {\n\t\t\t\t\t// If we have a timestamp (it was a file or symlink) and it differs from current timestamp\n\t\t\t\t\t// it's invalid\n\t\t\t\t\tif (log && this._remainingLogs > 0) {\n\t\t\t\t\t\tthis._log(\n\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t`timestamps differ (%d != %d)`,\n\t\t\t\t\t\t\tcurrent.timestamp,\n\t\t\t\t\t\t\tsnap.timestamp\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\t/**\n\t\t * @param {string} path file path\n\t\t * @param {ResolvedContextFileSystemInfoEntry} current current entry\n\t\t * @param {ResolvedContextFileSystemInfoEntry} snap entry from snapshot\n\t\t * @param {boolean} log log reason\n\t\t * @returns {boolean} true, if ok\n\t\t */\n\t\tconst checkContext = (path, current, snap, log = true) => {\n\t\t\tif (current === snap) return true;\n\t\t\tif (!checkExistence(path, Boolean(current), Boolean(snap))) return false;\n\t\t\tif (current) {\n\t\t\t\t// For existing items only\n\t\t\t\tif (typeof startTime === \"number\" && current.safeTime > startTime) {\n\t\t\t\t\t// If a change happened after starting reading the item\n\t\t\t\t\t// this may no longer be valid\n\t\t\t\t\tif (log && this._remainingLogs > 0) {\n\t\t\t\t\t\tthis._log(\n\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t`it may have changed (%d) after the start time of the snapshot (%d)`,\n\t\t\t\t\t\t\tcurrent.safeTime,\n\t\t\t\t\t\t\tstartTime\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tsnap.timestampHash !== undefined &&\n\t\t\t\t\tcurrent.timestampHash !== snap.timestampHash\n\t\t\t\t) {\n\t\t\t\t\t// If we have a timestampHash (it was a directory) and it differs from current timestampHash\n\t\t\t\t\t// it's invalid\n\t\t\t\t\tif (log && this._remainingLogs > 0) {\n\t\t\t\t\t\tthis._log(\n\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t`timestamps hashes differ (%s != %s)`,\n\t\t\t\t\t\t\tcurrent.timestampHash,\n\t\t\t\t\t\t\tsnap.timestampHash\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\tif (snapshot.hasChildren()) {\n\t\t\tconst childCallback = (err, result) => {\n\t\t\t\tif (err || !result) return invalid();\n\t\t\t\telse jobDone();\n\t\t\t};\n\t\t\tfor (const child of snapshot.children) {\n\t\t\t\tconst cache = this._snapshotCache.get(child);\n\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\tthis._statTestedChildrenCached++;\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif (typeof cache === \"boolean\") {\n\t\t\t\t\t\tif (cache === false) {\n\t\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\tcache.push(childCallback);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._statTestedChildrenNotCached++;\n\t\t\t\t\tjobs++;\n\t\t\t\t\tthis._checkSnapshotValidNoCache(child, childCallback);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (snapshot.hasFileTimestamps()) {\n\t\t\tconst { fileTimestamps } = snapshot;\n\t\t\tthis._statTestedEntries += fileTimestamps.size;\n\t\t\tfor (const [path, ts] of fileTimestamps) {\n\t\t\t\tconst cache = this._fileTimestamps.get(path);\n\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\tif (cache !== \"ignore\" && !checkFile(path, cache, ts)) {\n\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tjobs++;\n\t\t\t\t\tthis.fileTimestampQueue.add(path, (err, entry) => {\n\t\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\t\tif (!checkFile(path, entry, ts)) {\n\t\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst processFileHashSnapshot = (path, hash) => {\n\t\t\tconst cache = this._fileHashes.get(path);\n\t\t\tif (cache !== undefined) {\n\t\t\t\tif (cache !== \"ignore\" && !checkHash(path, cache, hash)) {\n\t\t\t\t\tinvalid();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjobs++;\n\t\t\t\tthis.fileHashQueue.add(path, (err, entry) => {\n\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\tif (!checkHash(path, entry, hash)) {\n\t\t\t\t\t\tinvalid();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjobDone();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t\tif (snapshot.hasFileHashes()) {\n\t\t\tconst { fileHashes } = snapshot;\n\t\t\tthis._statTestedEntries += fileHashes.size;\n\t\t\tfor (const [path, hash] of fileHashes) {\n\t\t\t\tprocessFileHashSnapshot(path, hash);\n\t\t\t}\n\t\t}\n\t\tif (snapshot.hasFileTshs()) {\n\t\t\tconst { fileTshs } = snapshot;\n\t\t\tthis._statTestedEntries += fileTshs.size;\n\t\t\tfor (const [path, tsh] of fileTshs) {\n\t\t\t\tif (typeof tsh === \"string\") {\n\t\t\t\t\tprocessFileHashSnapshot(path, tsh);\n\t\t\t\t} else {\n\t\t\t\t\tconst cache = this._fileTimestamps.get(path);\n\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\tif (cache === \"ignore\" || !checkFile(path, cache, tsh, false)) {\n\t\t\t\t\t\t\tprocessFileHashSnapshot(path, tsh && tsh.hash);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\tthis.fileTimestampQueue.add(path, (err, entry) => {\n\t\t\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\t\t\tif (!checkFile(path, entry, tsh, false)) {\n\t\t\t\t\t\t\t\tprocessFileHashSnapshot(path, tsh && tsh.hash);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (snapshot.hasContextTimestamps()) {\n\t\t\tconst { contextTimestamps } = snapshot;\n\t\t\tthis._statTestedEntries += contextTimestamps.size;\n\t\t\tfor (const [path, ts] of contextTimestamps) {\n\t\t\t\tconst cache = this._contextTimestamps.get(path);\n\t\t\t\tif (cache === \"ignore\") continue;\n\t\t\t\tlet resolved;\n\t\t\t\tif (\n\t\t\t\t\tcache !== undefined &&\n\t\t\t\t\t(resolved = getResolvedTimestamp(cache)) !== undefined\n\t\t\t\t) {\n\t\t\t\t\tif (!checkContext(path, resolved, ts)) {\n\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tjobs++;\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Error=} err error\n\t\t\t\t\t * @param {ResolvedContextFileSystemInfoEntry=} entry entry\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst callback = (err, entry) => {\n\t\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\t\tif (!checkContext(path, entry, ts)) {\n\t\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\tthis._resolveContextTimestamp(cache, callback);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.getContextTimestamp(path, callback);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst processContextHashSnapshot = (path, hash) => {\n\t\t\tconst cache = this._contextHashes.get(path);\n\t\t\tlet resolved;\n\t\t\tif (\n\t\t\t\tcache !== undefined &&\n\t\t\t\t(resolved = getResolvedHash(cache)) !== undefined\n\t\t\t) {\n\t\t\t\tif (!checkHash(path, resolved, hash)) {\n\t\t\t\t\tinvalid();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjobs++;\n\t\t\t\tconst callback = (err, entry) => {\n\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\tif (!checkHash(path, entry, hash)) {\n\t\t\t\t\t\tinvalid();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjobDone();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\tthis._resolveContextHash(cache, callback);\n\t\t\t\t} else {\n\t\t\t\t\tthis.getContextHash(path, callback);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif (snapshot.hasContextHashes()) {\n\t\t\tconst { contextHashes } = snapshot;\n\t\t\tthis._statTestedEntries += contextHashes.size;\n\t\t\tfor (const [path, hash] of contextHashes) {\n\t\t\t\tprocessContextHashSnapshot(path, hash);\n\t\t\t}\n\t\t}\n\t\tif (snapshot.hasContextTshs()) {\n\t\t\tconst { contextTshs } = snapshot;\n\t\t\tthis._statTestedEntries += contextTshs.size;\n\t\t\tfor (const [path, tsh] of contextTshs) {\n\t\t\t\tif (typeof tsh === \"string\") {\n\t\t\t\t\tprocessContextHashSnapshot(path, tsh);\n\t\t\t\t} else {\n\t\t\t\t\tconst cache = this._contextTimestamps.get(path);\n\t\t\t\t\tif (cache === \"ignore\") continue;\n\t\t\t\t\tlet resolved;\n\t\t\t\t\tif (\n\t\t\t\t\t\tcache !== undefined &&\n\t\t\t\t\t\t(resolved = getResolvedTimestamp(cache)) !== undefined\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!checkContext(path, resolved, tsh, false)) {\n\t\t\t\t\t\t\tprocessContextHashSnapshot(path, tsh && tsh.hash);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {Error=} err error\n\t\t\t\t\t\t * @param {ResolvedContextFileSystemInfoEntry=} entry entry\n\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst callback = (err, entry) => {\n\t\t\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\t\t\tif (!checkContext(path, entry, tsh, false)) {\n\t\t\t\t\t\t\t\tprocessContextHashSnapshot(path, tsh && tsh.hash);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\t\tthis._resolveContextTimestamp(cache, callback);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.getContextTimestamp(path, callback);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (snapshot.hasMissingExistence()) {\n\t\t\tconst { missingExistence } = snapshot;\n\t\t\tthis._statTestedEntries += missingExistence.size;\n\t\t\tfor (const [path, existence] of missingExistence) {\n\t\t\t\tconst cache = this._fileTimestamps.get(path);\n\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tcache !== \"ignore\" &&\n\t\t\t\t\t\t!checkExistence(path, Boolean(cache), Boolean(existence))\n\t\t\t\t\t) {\n\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tjobs++;\n\t\t\t\t\tthis.fileTimestampQueue.add(path, (err, entry) => {\n\t\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\t\tif (!checkExistence(path, Boolean(entry), Boolean(existence))) {\n\t\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (snapshot.hasManagedItemInfo()) {\n\t\t\tconst { managedItemInfo } = snapshot;\n\t\t\tthis._statTestedEntries += managedItemInfo.size;\n\t\t\tfor (const [path, info] of managedItemInfo) {\n\t\t\t\tconst cache = this._managedItems.get(path);\n\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\tif (!checkHash(path, cache, info)) {\n\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tjobs++;\n\t\t\t\t\tthis.managedItemQueue.add(path, (err, entry) => {\n\t\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\t\tif (!checkHash(path, entry, info)) {\n\t\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tjobDone();\n\n\t\t// if there was an async action\n\t\t// try to join multiple concurrent request for this snapshot\n\t\tif (jobs > 0) {\n\t\t\tconst callbacks = [callback];\n\t\t\tcallback = (err, result) => {\n\t\t\t\tfor (const callback of callbacks) callback(err, result);\n\t\t\t};\n\t\t\tthis._snapshotCache.set(snapshot, callbacks);\n\t\t}\n\t}\n\n\t_readFileTimestamp(path, callback) {\n\t\tthis.fs.stat(path, (err, stat) => {\n\t\t\tif (err) {\n\t\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\t\tthis._fileTimestamps.set(path, null);\n\t\t\t\t\tthis._cachedDeprecatedFileTimestamps = undefined;\n\t\t\t\t\treturn callback(null, null);\n\t\t\t\t}\n\t\t\t\treturn callback(err);\n\t\t\t}\n\n\t\t\tlet ts;\n\t\t\tif (stat.isDirectory()) {\n\t\t\t\tts = {\n\t\t\t\t\tsafeTime: 0,\n\t\t\t\t\ttimestamp: undefined\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tconst mtime = +stat.mtime;\n\n\t\t\t\tif (mtime) applyMtime(mtime);\n\n\t\t\t\tts = {\n\t\t\t\t\tsafeTime: mtime ? mtime + FS_ACCURACY : Infinity,\n\t\t\t\t\ttimestamp: mtime\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthis._fileTimestamps.set(path, ts);\n\t\t\tthis._cachedDeprecatedFileTimestamps = undefined;\n\n\t\t\tcallback(null, ts);\n\t\t});\n\t}\n\n\t_readFileHash(path, callback) {\n\t\tthis.fs.readFile(path, (err, content) => {\n\t\t\tif (err) {\n\t\t\t\tif (err.code === \"EISDIR\") {\n\t\t\t\t\tthis._fileHashes.set(path, \"directory\");\n\t\t\t\t\treturn callback(null, \"directory\");\n\t\t\t\t}\n\t\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\t\tthis._fileHashes.set(path, null);\n\t\t\t\t\treturn callback(null, null);\n\t\t\t\t}\n\t\t\t\tif (err.code === \"ERR_FS_FILE_TOO_LARGE\") {\n\t\t\t\t\tthis.logger.warn(`Ignoring ${path} for hashing as it's very large`);\n\t\t\t\t\tthis._fileHashes.set(path, \"too large\");\n\t\t\t\t\treturn callback(null, \"too large\");\n\t\t\t\t}\n\t\t\t\treturn callback(err);\n\t\t\t}\n\n\t\t\tconst hash = createHash(this._hashFunction);\n\n\t\t\thash.update(content);\n\n\t\t\tconst digest = /** @type {string} */ (hash.digest(\"hex\"));\n\n\t\t\tthis._fileHashes.set(path, digest);\n\n\t\t\tcallback(null, digest);\n\t\t});\n\t}\n\n\t_getFileTimestampAndHash(path, callback) {\n\t\tconst continueWithHash = hash => {\n\t\t\tconst cache = this._fileTimestamps.get(path);\n\t\t\tif (cache !== undefined) {\n\t\t\t\tif (cache !== \"ignore\") {\n\t\t\t\t\tconst result = {\n\t\t\t\t\t\t...cache,\n\t\t\t\t\t\thash\n\t\t\t\t\t};\n\t\t\t\t\tthis._fileTshs.set(path, result);\n\t\t\t\t\treturn callback(null, result);\n\t\t\t\t} else {\n\t\t\t\t\tthis._fileTshs.set(path, hash);\n\t\t\t\t\treturn callback(null, hash);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.fileTimestampQueue.add(path, (err, entry) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t}\n\t\t\t\t\tconst result = {\n\t\t\t\t\t\t...entry,\n\t\t\t\t\t\thash\n\t\t\t\t\t};\n\t\t\t\t\tthis._fileTshs.set(path, result);\n\t\t\t\t\treturn callback(null, result);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tconst cache = this._fileHashes.get(path);\n\t\tif (cache !== undefined) {\n\t\t\tcontinueWithHash(cache);\n\t\t} else {\n\t\t\tthis.fileHashQueue.add(path, (err, entry) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\t\t\t\tcontinueWithHash(entry);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * @template T\n\t * @template ItemType\n\t * @param {Object} options options\n\t * @param {string} options.path path\n\t * @param {function(string): ItemType} options.fromImmutablePath called when context item is an immutable path\n\t * @param {function(string): ItemType} options.fromManagedItem called when context item is a managed path\n\t * @param {function(string, string, function(Error=, ItemType=): void): void} options.fromSymlink called when context item is a symlink\n\t * @param {function(string, IStats, function(Error=, ItemType=): void): void} options.fromFile called when context item is a file\n\t * @param {function(string, IStats, function(Error=, ItemType=): void): void} options.fromDirectory called when context item is a directory\n\t * @param {function(string[], ItemType[]): T} options.reduce called from all context items\n\t * @param {function((Error | null)=, (T)=): void} callback callback\n\t */\n\t_readContext(\n\t\t{\n\t\t\tpath,\n\t\t\tfromImmutablePath,\n\t\t\tfromManagedItem,\n\t\t\tfromSymlink,\n\t\t\tfromFile,\n\t\t\tfromDirectory,\n\t\t\treduce\n\t\t},\n\t\tcallback\n\t) {\n\t\tthis.fs.readdir(path, (err, _files) => {\n\t\t\tif (err) {\n\t\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\t\treturn callback(null, null);\n\t\t\t\t}\n\t\t\t\treturn callback(err);\n\t\t\t}\n\t\t\tconst files = /** @type {string[]} */ (_files)\n\t\t\t\t.map(file => file.normalize(\"NFC\"))\n\t\t\t\t.filter(file => !/^\\./.test(file))\n\t\t\t\t.sort();\n\t\t\tasyncLib.map(\n\t\t\t\tfiles,\n\t\t\t\t(file, callback) => {\n\t\t\t\t\tconst child = join(this.fs, path, file);\n\t\t\t\t\tfor (const immutablePath of this.immutablePathsRegExps) {\n\t\t\t\t\t\tif (immutablePath.test(path)) {\n\t\t\t\t\t\t\t// ignore any immutable path for timestamping\n\t\t\t\t\t\t\treturn callback(null, fromImmutablePath(path));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const immutablePath of this.immutablePathsWithSlash) {\n\t\t\t\t\t\tif (path.startsWith(immutablePath)) {\n\t\t\t\t\t\t\t// ignore any immutable path for timestamping\n\t\t\t\t\t\t\treturn callback(null, fromImmutablePath(path));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const managedPath of this.managedPathsRegExps) {\n\t\t\t\t\t\tconst match = managedPath.exec(path);\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\tconst managedItem = getManagedItem(match[1], path);\n\t\t\t\t\t\t\tif (managedItem) {\n\t\t\t\t\t\t\t\t// construct timestampHash from managed info\n\t\t\t\t\t\t\t\treturn this.managedItemQueue.add(managedItem, (err, info) => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\treturn callback(null, fromManagedItem(info));\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const managedPath of this.managedPathsWithSlash) {\n\t\t\t\t\t\tif (path.startsWith(managedPath)) {\n\t\t\t\t\t\t\tconst managedItem = getManagedItem(managedPath, child);\n\t\t\t\t\t\t\tif (managedItem) {\n\t\t\t\t\t\t\t\t// construct timestampHash from managed info\n\t\t\t\t\t\t\t\treturn this.managedItemQueue.add(managedItem, (err, info) => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\treturn callback(null, fromManagedItem(info));\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlstatReadlinkAbsolute(this.fs, child, (err, stat) => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\tif (typeof stat === \"string\") {\n\t\t\t\t\t\t\treturn fromSymlink(child, stat, callback);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (stat.isFile()) {\n\t\t\t\t\t\t\treturn fromFile(child, stat, callback);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\t\t\treturn fromDirectory(child, stat, callback);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcallback(null, null);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\t(err, results) => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tconst result = reduce(files, results);\n\t\t\t\t\tcallback(null, result);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t_readContextTimestamp(path, callback) {\n\t\tthis._readContext(\n\t\t\t{\n\t\t\t\tpath,\n\t\t\t\tfromImmutablePath: () => null,\n\t\t\t\tfromManagedItem: info => ({\n\t\t\t\t\tsafeTime: 0,\n\t\t\t\t\ttimestampHash: info\n\t\t\t\t}),\n\t\t\t\tfromSymlink: (file, target, callback) => {\n\t\t\t\t\tcallback(null, {\n\t\t\t\t\t\ttimestampHash: target,\n\t\t\t\t\t\tsymlinks: new Set([target])\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tfromFile: (file, stat, callback) => {\n\t\t\t\t\t// Prefer the cached value over our new stat to report consistent results\n\t\t\t\t\tconst cache = this._fileTimestamps.get(file);\n\t\t\t\t\tif (cache !== undefined)\n\t\t\t\t\t\treturn callback(null, cache === \"ignore\" ? null : cache);\n\n\t\t\t\t\tconst mtime = +stat.mtime;\n\n\t\t\t\t\tif (mtime) applyMtime(mtime);\n\n\t\t\t\t\tconst ts = {\n\t\t\t\t\t\tsafeTime: mtime ? mtime + FS_ACCURACY : Infinity,\n\t\t\t\t\t\ttimestamp: mtime\n\t\t\t\t\t};\n\n\t\t\t\t\tthis._fileTimestamps.set(file, ts);\n\t\t\t\t\tthis._cachedDeprecatedFileTimestamps = undefined;\n\t\t\t\t\tcallback(null, ts);\n\t\t\t\t},\n\t\t\t\tfromDirectory: (directory, stat, callback) => {\n\t\t\t\t\tthis.contextTimestampQueue.increaseParallelism();\n\t\t\t\t\tthis._getUnresolvedContextTimestamp(directory, (err, tsEntry) => {\n\t\t\t\t\t\tthis.contextTimestampQueue.decreaseParallelism();\n\t\t\t\t\t\tcallback(err, tsEntry);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\treduce: (files, tsEntries) => {\n\t\t\t\t\tlet symlinks = undefined;\n\n\t\t\t\t\tconst hash = createHash(this._hashFunction);\n\n\t\t\t\t\tfor (const file of files) hash.update(file);\n\t\t\t\t\tlet safeTime = 0;\n\t\t\t\t\tfor (const entry of tsEntries) {\n\t\t\t\t\t\tif (!entry) {\n\t\t\t\t\t\t\thash.update(\"n\");\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (entry.timestamp) {\n\t\t\t\t\t\t\thash.update(\"f\");\n\t\t\t\t\t\t\thash.update(`${entry.timestamp}`);\n\t\t\t\t\t\t} else if (entry.timestampHash) {\n\t\t\t\t\t\t\thash.update(\"d\");\n\t\t\t\t\t\t\thash.update(`${entry.timestampHash}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (entry.symlinks !== undefined) {\n\t\t\t\t\t\t\tif (symlinks === undefined) symlinks = new Set();\n\t\t\t\t\t\t\taddAll(entry.symlinks, symlinks);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (entry.safeTime) {\n\t\t\t\t\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst digest = /** @type {string} */ (hash.digest(\"hex\"));\n\n\t\t\t\t\tconst result = {\n\t\t\t\t\t\tsafeTime,\n\t\t\t\t\t\ttimestampHash: digest\n\t\t\t\t\t};\n\t\t\t\t\tif (symlinks) result.symlinks = symlinks;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t},\n\t\t\t(err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tthis._contextTimestamps.set(path, result);\n\t\t\t\tthis._cachedDeprecatedContextTimestamps = undefined;\n\n\t\t\t\tcallback(null, result);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {ContextFileSystemInfoEntry} entry entry\n\t * @param {function((Error | null)=, ResolvedContextFileSystemInfoEntry=): void} callback callback\n\t * @returns {void}\n\t */\n\t_resolveContextTimestamp(entry, callback) {\n\t\tconst hashes = [];\n\t\tlet safeTime = 0;\n\t\tprocessAsyncTree(\n\t\t\tentry.symlinks,\n\t\t\t10,\n\t\t\t(target, push, callback) => {\n\t\t\t\tthis._getUnresolvedContextTimestamp(target, (err, entry) => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tif (entry && entry !== \"ignore\") {\n\t\t\t\t\t\thashes.push(entry.timestampHash);\n\t\t\t\t\t\tif (entry.safeTime) {\n\t\t\t\t\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (entry.symlinks !== undefined) {\n\t\t\t\t\t\t\tfor (const target of entry.symlinks) push(target);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcallback();\n\t\t\t\t});\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\t\thash.update(entry.timestampHash);\n\t\t\t\tif (entry.safeTime) {\n\t\t\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\t\t}\n\t\t\t\thashes.sort();\n\t\t\t\tfor (const h of hashes) {\n\t\t\t\t\thash.update(h);\n\t\t\t\t}\n\t\t\t\tcallback(\n\t\t\t\t\tnull,\n\t\t\t\t\t(entry.resolved = {\n\t\t\t\t\t\tsafeTime,\n\t\t\t\t\t\ttimestampHash: /** @type {string} */ (hash.digest(\"hex\"))\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\t_readContextHash(path, callback) {\n\t\tthis._readContext(\n\t\t\t{\n\t\t\t\tpath,\n\t\t\t\tfromImmutablePath: () => \"\",\n\t\t\t\tfromManagedItem: info => info || \"\",\n\t\t\t\tfromSymlink: (file, target, callback) => {\n\t\t\t\t\tcallback(null, {\n\t\t\t\t\t\thash: target,\n\t\t\t\t\t\tsymlinks: new Set([target])\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tfromFile: (file, stat, callback) =>\n\t\t\t\t\tthis.getFileHash(file, (err, hash) => {\n\t\t\t\t\t\tcallback(err, hash || \"\");\n\t\t\t\t\t}),\n\t\t\t\tfromDirectory: (directory, stat, callback) => {\n\t\t\t\t\tthis.contextHashQueue.increaseParallelism();\n\t\t\t\t\tthis._getUnresolvedContextHash(directory, (err, hash) => {\n\t\t\t\t\t\tthis.contextHashQueue.decreaseParallelism();\n\t\t\t\t\t\tcallback(err, hash || \"\");\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * @param {string[]} files files\n\t\t\t\t * @param {(string | ContextHash)[]} fileHashes hashes\n\t\t\t\t * @returns {ContextHash} reduced hash\n\t\t\t\t */\n\t\t\t\treduce: (files, fileHashes) => {\n\t\t\t\t\tlet symlinks = undefined;\n\t\t\t\t\tconst hash = createHash(this._hashFunction);\n\n\t\t\t\t\tfor (const file of files) hash.update(file);\n\t\t\t\t\tfor (const entry of fileHashes) {\n\t\t\t\t\t\tif (typeof entry === \"string\") {\n\t\t\t\t\t\t\thash.update(entry);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\thash.update(entry.hash);\n\t\t\t\t\t\t\tif (entry.symlinks) {\n\t\t\t\t\t\t\t\tif (symlinks === undefined) symlinks = new Set();\n\t\t\t\t\t\t\t\taddAll(entry.symlinks, symlinks);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = {\n\t\t\t\t\t\thash: /** @type {string} */ (hash.digest(\"hex\"))\n\t\t\t\t\t};\n\t\t\t\t\tif (symlinks) result.symlinks = symlinks;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t},\n\t\t\t(err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tthis._contextHashes.set(path, result);\n\t\t\t\treturn callback(null, result);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {ContextHash} entry context hash\n\t * @param {function((Error | null)=, string=): void} callback callback\n\t * @returns {void}\n\t */\n\t_resolveContextHash(entry, callback) {\n\t\tconst hashes = [];\n\t\tprocessAsyncTree(\n\t\t\tentry.symlinks,\n\t\t\t10,\n\t\t\t(target, push, callback) => {\n\t\t\t\tthis._getUnresolvedContextHash(target, (err, hash) => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tif (hash) {\n\t\t\t\t\t\thashes.push(hash.hash);\n\t\t\t\t\t\tif (hash.symlinks !== undefined) {\n\t\t\t\t\t\t\tfor (const target of hash.symlinks) push(target);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcallback();\n\t\t\t\t});\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\t\thash.update(entry.hash);\n\t\t\t\thashes.sort();\n\t\t\t\tfor (const h of hashes) {\n\t\t\t\t\thash.update(h);\n\t\t\t\t}\n\t\t\t\tcallback(\n\t\t\t\t\tnull,\n\t\t\t\t\t(entry.resolved = /** @type {string} */ (hash.digest(\"hex\")))\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\t_readContextTimestampAndHash(path, callback) {\n\t\tconst finalize = (timestamp, hash) => {\n\t\t\tconst result =\n\t\t\t\ttimestamp === \"ignore\"\n\t\t\t\t\t? hash\n\t\t\t\t\t: {\n\t\t\t\t\t\t\t...timestamp,\n\t\t\t\t\t\t\t...hash\n\t\t\t\t\t  };\n\t\t\tthis._contextTshs.set(path, result);\n\t\t\tcallback(null, result);\n\t\t};\n\t\tconst cachedHash = this._contextHashes.get(path);\n\t\tconst cachedTimestamp = this._contextTimestamps.get(path);\n\t\tif (cachedHash !== undefined) {\n\t\t\tif (cachedTimestamp !== undefined) {\n\t\t\t\tfinalize(cachedTimestamp, cachedHash);\n\t\t\t} else {\n\t\t\t\tthis.contextTimestampQueue.add(path, (err, entry) => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tfinalize(entry, cachedHash);\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tif (cachedTimestamp !== undefined) {\n\t\t\t\tthis.contextHashQueue.add(path, (err, entry) => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tfinalize(cachedTimestamp, entry);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis._readContext(\n\t\t\t\t\t{\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\tfromImmutablePath: () => null,\n\t\t\t\t\t\tfromManagedItem: info => ({\n\t\t\t\t\t\t\tsafeTime: 0,\n\t\t\t\t\t\t\ttimestampHash: info,\n\t\t\t\t\t\t\thash: info || \"\"\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tfromSymlink: (fle, target, callback) => {\n\t\t\t\t\t\t\tcallback(null, {\n\t\t\t\t\t\t\t\ttimestampHash: target,\n\t\t\t\t\t\t\t\thash: target,\n\t\t\t\t\t\t\t\tsymlinks: new Set([target])\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfromFile: (file, stat, callback) => {\n\t\t\t\t\t\t\tthis._getFileTimestampAndHash(file, callback);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfromDirectory: (directory, stat, callback) => {\n\t\t\t\t\t\t\tthis.contextTshQueue.increaseParallelism();\n\t\t\t\t\t\t\tthis.contextTshQueue.add(directory, (err, result) => {\n\t\t\t\t\t\t\t\tthis.contextTshQueue.decreaseParallelism();\n\t\t\t\t\t\t\t\tcallback(err, result);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {string[]} files files\n\t\t\t\t\t\t * @param {(Partial<TimestampAndHash> & Partial<ContextTimestampAndHash> | string | null)[]} results results\n\t\t\t\t\t\t * @returns {ContextTimestampAndHash} tsh\n\t\t\t\t\t\t */\n\t\t\t\t\t\treduce: (files, results) => {\n\t\t\t\t\t\t\tlet symlinks = undefined;\n\n\t\t\t\t\t\t\tconst tsHash = createHash(this._hashFunction);\n\t\t\t\t\t\t\tconst hash = createHash(this._hashFunction);\n\n\t\t\t\t\t\t\tfor (const file of files) {\n\t\t\t\t\t\t\t\ttsHash.update(file);\n\t\t\t\t\t\t\t\thash.update(file);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet safeTime = 0;\n\t\t\t\t\t\t\tfor (const entry of results) {\n\t\t\t\t\t\t\t\tif (!entry) {\n\t\t\t\t\t\t\t\t\ttsHash.update(\"n\");\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (typeof entry === \"string\") {\n\t\t\t\t\t\t\t\t\ttsHash.update(\"n\");\n\t\t\t\t\t\t\t\t\thash.update(entry);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (entry.timestamp) {\n\t\t\t\t\t\t\t\t\ttsHash.update(\"f\");\n\t\t\t\t\t\t\t\t\ttsHash.update(`${entry.timestamp}`);\n\t\t\t\t\t\t\t\t} else if (entry.timestampHash) {\n\t\t\t\t\t\t\t\t\ttsHash.update(\"d\");\n\t\t\t\t\t\t\t\t\ttsHash.update(`${entry.timestampHash}`);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (entry.symlinks !== undefined) {\n\t\t\t\t\t\t\t\t\tif (symlinks === undefined) symlinks = new Set();\n\t\t\t\t\t\t\t\t\taddAll(entry.symlinks, symlinks);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (entry.safeTime) {\n\t\t\t\t\t\t\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\thash.update(entry.hash);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst result = {\n\t\t\t\t\t\t\t\tsafeTime,\n\t\t\t\t\t\t\t\ttimestampHash: /** @type {string} */ (tsHash.digest(\"hex\")),\n\t\t\t\t\t\t\t\thash: /** @type {string} */ (hash.digest(\"hex\"))\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (symlinks) result.symlinks = symlinks;\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\tthis._contextTshs.set(path, result);\n\t\t\t\t\t\treturn callback(null, result);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {ContextTimestampAndHash} entry entry\n\t * @param {function((Error | null)=, ResolvedContextTimestampAndHash=): void} callback callback\n\t * @returns {void}\n\t */\n\t_resolveContextTsh(entry, callback) {\n\t\tconst hashes = [];\n\t\tconst tsHashes = [];\n\t\tlet safeTime = 0;\n\t\tprocessAsyncTree(\n\t\t\tentry.symlinks,\n\t\t\t10,\n\t\t\t(target, push, callback) => {\n\t\t\t\tthis._getUnresolvedContextTsh(target, (err, entry) => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tif (entry) {\n\t\t\t\t\t\thashes.push(entry.hash);\n\t\t\t\t\t\tif (entry.timestampHash) tsHashes.push(entry.timestampHash);\n\t\t\t\t\t\tif (entry.safeTime) {\n\t\t\t\t\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (entry.symlinks !== undefined) {\n\t\t\t\t\t\t\tfor (const target of entry.symlinks) push(target);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcallback();\n\t\t\t\t});\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\t\tconst tsHash = createHash(this._hashFunction);\n\t\t\t\thash.update(entry.hash);\n\t\t\t\tif (entry.timestampHash) tsHash.update(entry.timestampHash);\n\t\t\t\tif (entry.safeTime) {\n\t\t\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\t\t}\n\t\t\t\thashes.sort();\n\t\t\t\tfor (const h of hashes) {\n\t\t\t\t\thash.update(h);\n\t\t\t\t}\n\t\t\t\ttsHashes.sort();\n\t\t\t\tfor (const h of tsHashes) {\n\t\t\t\t\ttsHash.update(h);\n\t\t\t\t}\n\t\t\t\tcallback(\n\t\t\t\t\tnull,\n\t\t\t\t\t(entry.resolved = {\n\t\t\t\t\t\tsafeTime,\n\t\t\t\t\t\ttimestampHash: /** @type {string} */ (tsHash.digest(\"hex\")),\n\t\t\t\t\t\thash: /** @type {string} */ (hash.digest(\"hex\"))\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\t_getManagedItemDirectoryInfo(path, callback) {\n\t\tthis.fs.readdir(path, (err, elements) => {\n\t\t\tif (err) {\n\t\t\t\tif (err.code === \"ENOENT\" || err.code === \"ENOTDIR\") {\n\t\t\t\t\treturn callback(null, EMPTY_SET);\n\t\t\t\t}\n\t\t\t\treturn callback(err);\n\t\t\t}\n\t\t\tconst set = new Set(\n\t\t\t\t/** @type {string[]} */ (elements).map(element =>\n\t\t\t\t\tjoin(this.fs, path, element)\n\t\t\t\t)\n\t\t\t);\n\t\t\tcallback(null, set);\n\t\t});\n\t}\n\n\t_getManagedItemInfo(path, callback) {\n\t\tconst dir = dirname(this.fs, path);\n\t\tthis.managedItemDirectoryQueue.add(dir, (err, elements) => {\n\t\t\tif (err) {\n\t\t\t\treturn callback(err);\n\t\t\t}\n\t\t\tif (!elements.has(path)) {\n\t\t\t\t// file or directory doesn't exist\n\t\t\t\tthis._managedItems.set(path, \"*missing\");\n\t\t\t\treturn callback(null, \"*missing\");\n\t\t\t}\n\t\t\t// something exists\n\t\t\t// it may be a file or directory\n\t\t\tif (\n\t\t\t\tpath.endsWith(\"node_modules\") &&\n\t\t\t\t(path.endsWith(\"/node_modules\") || path.endsWith(\"\\\\node_modules\"))\n\t\t\t) {\n\t\t\t\t// we are only interested in existence of this special directory\n\t\t\t\tthis._managedItems.set(path, \"*node_modules\");\n\t\t\t\treturn callback(null, \"*node_modules\");\n\t\t\t}\n\n\t\t\t// we assume it's a directory, as files shouldn't occur in managed paths\n\t\t\tconst packageJsonPath = join(this.fs, path, \"package.json\");\n\t\t\tthis.fs.readFile(packageJsonPath, (err, content) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tif (err.code === \"ENOENT\" || err.code === \"ENOTDIR\") {\n\t\t\t\t\t\t// no package.json or path is not a directory\n\t\t\t\t\t\tthis.fs.readdir(path, (err, elements) => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!err &&\n\t\t\t\t\t\t\t\telements.length === 1 &&\n\t\t\t\t\t\t\t\telements[0] === \"node_modules\"\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t// This is only a grouping folder e. g. used by yarn\n\t\t\t\t\t\t\t\t// we are only interested in existence of this special directory\n\t\t\t\t\t\t\t\tthis._managedItems.set(path, \"*nested\");\n\t\t\t\t\t\t\t\treturn callback(null, \"*nested\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.logger.warn(\n\t\t\t\t\t\t\t\t`Managed item ${path} isn't a directory or doesn't contain a package.json (see snapshot.managedPaths option)`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\t\t\t\tlet data;\n\t\t\t\ttry {\n\t\t\t\t\tdata = JSON.parse(content.toString(\"utf-8\"));\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn callback(e);\n\t\t\t\t}\n\t\t\t\tif (!data.name) {\n\t\t\t\t\tthis.logger.warn(\n\t\t\t\t\t\t`${packageJsonPath} doesn't contain a \"name\" property (see snapshot.managedPaths option)`\n\t\t\t\t\t);\n\t\t\t\t\treturn callback();\n\t\t\t\t}\n\t\t\t\tconst info = `${data.name || \"\"}@${data.version || \"\"}`;\n\t\t\t\tthis._managedItems.set(path, info);\n\t\t\t\tcallback(null, info);\n\t\t\t});\n\t\t});\n\t}\n\n\tgetDeprecatedFileTimestamps() {\n\t\tif (this._cachedDeprecatedFileTimestamps !== undefined)\n\t\t\treturn this._cachedDeprecatedFileTimestamps;\n\t\tconst map = new Map();\n\t\tfor (const [path, info] of this._fileTimestamps) {\n\t\t\tif (info) map.set(path, typeof info === \"object\" ? info.safeTime : null);\n\t\t}\n\t\treturn (this._cachedDeprecatedFileTimestamps = map);\n\t}\n\n\tgetDeprecatedContextTimestamps() {\n\t\tif (this._cachedDeprecatedContextTimestamps !== undefined)\n\t\t\treturn this._cachedDeprecatedContextTimestamps;\n\t\tconst map = new Map();\n\t\tfor (const [path, info] of this._contextTimestamps) {\n\t\t\tif (info) map.set(path, typeof info === \"object\" ? info.safeTime : null);\n\t\t}\n\t\treturn (this._cachedDeprecatedContextTimestamps = map);\n\t}\n}\n\nmodule.exports = FileSystemInfo;\nmodule.exports.Snapshot = Snapshot;\n"]},"metadata":{},"sourceType":"script"}