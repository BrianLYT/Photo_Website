{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst NormalModule = require(\"../NormalModule\");\n\nconst LazySet = require(\"../util/LazySet\");\n\nconst LoaderDependency = require(\"./LoaderDependency\");\n\nconst LoaderImportDependency = require(\"./LoaderImportDependency\");\n/** @typedef {import(\"../Compilation\").DepConstructor} DepConstructor */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/**\n * @callback LoadModuleCallback\n * @param {(Error | null)=} err error object\n * @param {string | Buffer=} source source code\n * @param {object=} map source map\n * @param {Module=} module loaded module if successful\n */\n\n/**\n * @callback ImportModuleCallback\n * @param {(Error | null)=} err error object\n * @param {any=} exports exports of the evaluated module\n */\n\n/**\n * @typedef {Object} ImportModuleOptions\n * @property {string=} layer the target layer\n * @property {string=} publicPath the target public path\n * @property {string=} baseUri target base uri\n */\n\n\nclass LoaderPlugin {\n  /**\n   * @param {Object} options options\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"LoaderPlugin\", (compilation, _ref) => {\n      let {\n        normalModuleFactory\n      } = _ref;\n      compilation.dependencyFactories.set(LoaderDependency, normalModuleFactory);\n      compilation.dependencyFactories.set(LoaderImportDependency, normalModuleFactory);\n    });\n    compiler.hooks.compilation.tap(\"LoaderPlugin\", compilation => {\n      const moduleGraph = compilation.moduleGraph;\n      NormalModule.getCompilationHooks(compilation).loader.tap(\"LoaderPlugin\", loaderContext => {\n        /**\n         * @param {string} request the request string to load the module from\n         * @param {LoadModuleCallback} callback callback returning the loaded module or error\n         * @returns {void}\n         */\n        loaderContext.loadModule = (request, callback) => {\n          const dep = new LoaderDependency(request);\n          dep.loc = {\n            name: request\n          };\n          const factory = compilation.dependencyFactories.get(\n          /** @type {DepConstructor} */\n          dep.constructor);\n\n          if (factory === undefined) {\n            return callback(new Error(`No module factory available for dependency type: ${dep.constructor.name}`));\n          }\n\n          compilation.buildQueue.increaseParallelism();\n          compilation.handleModuleCreation({\n            factory,\n            dependencies: [dep],\n            originModule: loaderContext._module,\n            context: loaderContext.context,\n            recursive: false\n          }, err => {\n            compilation.buildQueue.decreaseParallelism();\n\n            if (err) {\n              return callback(err);\n            }\n\n            const referencedModule = moduleGraph.getModule(dep);\n\n            if (!referencedModule) {\n              return callback(new Error(\"Cannot load the module\"));\n            }\n\n            if (referencedModule.getNumberOfErrors() > 0) {\n              return callback(new Error(\"The loaded module contains errors\"));\n            }\n\n            const moduleSource = referencedModule.originalSource();\n\n            if (!moduleSource) {\n              return callback(new Error(\"The module created for a LoaderDependency must have an original source\"));\n            }\n\n            let source, map;\n\n            if (moduleSource.sourceAndMap) {\n              const sourceAndMap = moduleSource.sourceAndMap();\n              map = sourceAndMap.map;\n              source = sourceAndMap.source;\n            } else {\n              map = moduleSource.map();\n              source = moduleSource.source();\n            }\n\n            const fileDependencies = new LazySet();\n            const contextDependencies = new LazySet();\n            const missingDependencies = new LazySet();\n            const buildDependencies = new LazySet();\n            referencedModule.addCacheDependencies(fileDependencies, contextDependencies, missingDependencies, buildDependencies);\n\n            for (const d of fileDependencies) {\n              loaderContext.addDependency(d);\n            }\n\n            for (const d of contextDependencies) {\n              loaderContext.addContextDependency(d);\n            }\n\n            for (const d of missingDependencies) {\n              loaderContext.addMissingDependency(d);\n            }\n\n            for (const d of buildDependencies) {\n              loaderContext.addBuildDependency(d);\n            }\n\n            return callback(null, source, map, referencedModule);\n          });\n        };\n        /**\n         * @param {string} request the request string to load the module from\n         * @param {ImportModuleOptions=} options options\n         * @param {ImportModuleCallback=} callback callback returning the exports\n         * @returns {void}\n         */\n\n\n        const importModule = (request, options, callback) => {\n          const dep = new LoaderImportDependency(request);\n          dep.loc = {\n            name: request\n          };\n          const factory = compilation.dependencyFactories.get(\n          /** @type {DepConstructor} */\n          dep.constructor);\n\n          if (factory === undefined) {\n            return callback(new Error(`No module factory available for dependency type: ${dep.constructor.name}`));\n          }\n\n          compilation.buildQueue.increaseParallelism();\n          compilation.handleModuleCreation({\n            factory,\n            dependencies: [dep],\n            originModule: loaderContext._module,\n            contextInfo: {\n              issuerLayer: options.layer\n            },\n            context: loaderContext.context,\n            connectOrigin: false\n          }, err => {\n            compilation.buildQueue.decreaseParallelism();\n\n            if (err) {\n              return callback(err);\n            }\n\n            const referencedModule = moduleGraph.getModule(dep);\n\n            if (!referencedModule) {\n              return callback(new Error(\"Cannot load the module\"));\n            }\n\n            compilation.executeModule(referencedModule, {\n              entryOptions: {\n                baseUri: options.baseUri,\n                publicPath: options.publicPath\n              }\n            }, (err, result) => {\n              if (err) return callback(err);\n\n              for (const d of result.fileDependencies) {\n                loaderContext.addDependency(d);\n              }\n\n              for (const d of result.contextDependencies) {\n                loaderContext.addContextDependency(d);\n              }\n\n              for (const d of result.missingDependencies) {\n                loaderContext.addMissingDependency(d);\n              }\n\n              for (const d of result.buildDependencies) {\n                loaderContext.addBuildDependency(d);\n              }\n\n              if (result.cacheable === false) loaderContext.cacheable(false);\n\n              for (const [name, {\n                source,\n                info\n              }] of result.assets) {\n                const {\n                  buildInfo\n                } = loaderContext._module;\n\n                if (!buildInfo.assets) {\n                  buildInfo.assets = Object.create(null);\n                  buildInfo.assetsInfo = new Map();\n                }\n\n                buildInfo.assets[name] = source;\n                buildInfo.assetsInfo.set(name, info);\n              }\n\n              callback(null, result.exports);\n            });\n          });\n        };\n        /**\n         * @param {string} request the request string to load the module from\n         * @param {ImportModuleOptions} options options\n         * @param {ImportModuleCallback=} callback callback returning the exports\n         * @returns {Promise<any> | void} exports\n         */\n\n\n        loaderContext.importModule = (request, options, callback) => {\n          if (!callback) {\n            return new Promise((resolve, reject) => {\n              importModule(request, options || {}, (err, result) => {\n                if (err) reject(err);else resolve(result);\n              });\n            });\n          }\n\n          return importModule(request, options || {}, callback);\n        };\n      });\n    });\n  }\n\n}\n\nmodule.exports = LoaderPlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/dependencies/LoaderPlugin.js"],"names":["NormalModule","require","LazySet","LoaderDependency","LoaderImportDependency","LoaderPlugin","constructor","options","apply","compiler","hooks","compilation","tap","normalModuleFactory","dependencyFactories","set","moduleGraph","getCompilationHooks","loader","loaderContext","loadModule","request","callback","dep","loc","name","factory","get","undefined","Error","buildQueue","increaseParallelism","handleModuleCreation","dependencies","originModule","_module","context","recursive","err","decreaseParallelism","referencedModule","getModule","getNumberOfErrors","moduleSource","originalSource","source","map","sourceAndMap","fileDependencies","contextDependencies","missingDependencies","buildDependencies","addCacheDependencies","d","addDependency","addContextDependency","addMissingDependency","addBuildDependency","importModule","contextInfo","issuerLayer","layer","connectOrigin","executeModule","entryOptions","baseUri","publicPath","result","cacheable","info","assets","buildInfo","Object","create","assetsInfo","Map","exports","Promise","resolve","reject","module"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst NormalModule = require(\"../NormalModule\");\nconst LazySet = require(\"../util/LazySet\");\nconst LoaderDependency = require(\"./LoaderDependency\");\nconst LoaderImportDependency = require(\"./LoaderImportDependency\");\n\n/** @typedef {import(\"../Compilation\").DepConstructor} DepConstructor */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\n/**\n * @callback LoadModuleCallback\n * @param {(Error | null)=} err error object\n * @param {string | Buffer=} source source code\n * @param {object=} map source map\n * @param {Module=} module loaded module if successful\n */\n\n/**\n * @callback ImportModuleCallback\n * @param {(Error | null)=} err error object\n * @param {any=} exports exports of the evaluated module\n */\n\n/**\n * @typedef {Object} ImportModuleOptions\n * @property {string=} layer the target layer\n * @property {string=} publicPath the target public path\n * @property {string=} baseUri target base uri\n */\n\nclass LoaderPlugin {\n\t/**\n\t * @param {Object} options options\n\t */\n\tconstructor(options = {}) {}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"LoaderPlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tLoaderDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tLoaderImportDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\n\t\tcompiler.hooks.compilation.tap(\"LoaderPlugin\", compilation => {\n\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\tNormalModule.getCompilationHooks(compilation).loader.tap(\n\t\t\t\t\"LoaderPlugin\",\n\t\t\t\tloaderContext => {\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} request the request string to load the module from\n\t\t\t\t\t * @param {LoadModuleCallback} callback callback returning the loaded module or error\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tloaderContext.loadModule = (request, callback) => {\n\t\t\t\t\t\tconst dep = new LoaderDependency(request);\n\t\t\t\t\t\tdep.loc = {\n\t\t\t\t\t\t\tname: request\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst factory = compilation.dependencyFactories.get(\n\t\t\t\t\t\t\t/** @type {DepConstructor} */ (dep.constructor)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (factory === undefined) {\n\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t`No module factory available for dependency type: ${dep.constructor.name}`\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcompilation.buildQueue.increaseParallelism();\n\t\t\t\t\t\tcompilation.handleModuleCreation(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfactory,\n\t\t\t\t\t\t\t\tdependencies: [dep],\n\t\t\t\t\t\t\t\toriginModule: loaderContext._module,\n\t\t\t\t\t\t\t\tcontext: loaderContext.context,\n\t\t\t\t\t\t\t\trecursive: false\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\tcompilation.buildQueue.decreaseParallelism();\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst referencedModule = moduleGraph.getModule(dep);\n\t\t\t\t\t\t\t\tif (!referencedModule) {\n\t\t\t\t\t\t\t\t\treturn callback(new Error(\"Cannot load the module\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (referencedModule.getNumberOfErrors() > 0) {\n\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\tnew Error(\"The loaded module contains errors\")\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst moduleSource = referencedModule.originalSource();\n\t\t\t\t\t\t\t\tif (!moduleSource) {\n\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\"The module created for a LoaderDependency must have an original source\"\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet source, map;\n\t\t\t\t\t\t\t\tif (moduleSource.sourceAndMap) {\n\t\t\t\t\t\t\t\t\tconst sourceAndMap = moduleSource.sourceAndMap();\n\t\t\t\t\t\t\t\t\tmap = sourceAndMap.map;\n\t\t\t\t\t\t\t\t\tsource = sourceAndMap.source;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmap = moduleSource.map();\n\t\t\t\t\t\t\t\t\tsource = moduleSource.source();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst fileDependencies = new LazySet();\n\t\t\t\t\t\t\t\tconst contextDependencies = new LazySet();\n\t\t\t\t\t\t\t\tconst missingDependencies = new LazySet();\n\t\t\t\t\t\t\t\tconst buildDependencies = new LazySet();\n\t\t\t\t\t\t\t\treferencedModule.addCacheDependencies(\n\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\tcontextDependencies,\n\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\tbuildDependencies\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tfor (const d of fileDependencies) {\n\t\t\t\t\t\t\t\t\tloaderContext.addDependency(d);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const d of contextDependencies) {\n\t\t\t\t\t\t\t\t\tloaderContext.addContextDependency(d);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const d of missingDependencies) {\n\t\t\t\t\t\t\t\t\tloaderContext.addMissingDependency(d);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const d of buildDependencies) {\n\t\t\t\t\t\t\t\t\tloaderContext.addBuildDependency(d);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn callback(null, source, map, referencedModule);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} request the request string to load the module from\n\t\t\t\t\t * @param {ImportModuleOptions=} options options\n\t\t\t\t\t * @param {ImportModuleCallback=} callback callback returning the exports\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst importModule = (request, options, callback) => {\n\t\t\t\t\t\tconst dep = new LoaderImportDependency(request);\n\t\t\t\t\t\tdep.loc = {\n\t\t\t\t\t\t\tname: request\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst factory = compilation.dependencyFactories.get(\n\t\t\t\t\t\t\t/** @type {DepConstructor} */ (dep.constructor)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (factory === undefined) {\n\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t`No module factory available for dependency type: ${dep.constructor.name}`\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcompilation.buildQueue.increaseParallelism();\n\t\t\t\t\t\tcompilation.handleModuleCreation(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfactory,\n\t\t\t\t\t\t\t\tdependencies: [dep],\n\t\t\t\t\t\t\t\toriginModule: loaderContext._module,\n\t\t\t\t\t\t\t\tcontextInfo: {\n\t\t\t\t\t\t\t\t\tissuerLayer: options.layer\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tcontext: loaderContext.context,\n\t\t\t\t\t\t\t\tconnectOrigin: false\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\tcompilation.buildQueue.decreaseParallelism();\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst referencedModule = moduleGraph.getModule(dep);\n\t\t\t\t\t\t\t\tif (!referencedModule) {\n\t\t\t\t\t\t\t\t\treturn callback(new Error(\"Cannot load the module\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcompilation.executeModule(\n\t\t\t\t\t\t\t\t\treferencedModule,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tentryOptions: {\n\t\t\t\t\t\t\t\t\t\t\tbaseUri: options.baseUri,\n\t\t\t\t\t\t\t\t\t\t\tpublicPath: options.publicPath\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\tfor (const d of result.fileDependencies) {\n\t\t\t\t\t\t\t\t\t\t\tloaderContext.addDependency(d);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfor (const d of result.contextDependencies) {\n\t\t\t\t\t\t\t\t\t\t\tloaderContext.addContextDependency(d);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfor (const d of result.missingDependencies) {\n\t\t\t\t\t\t\t\t\t\t\tloaderContext.addMissingDependency(d);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfor (const d of result.buildDependencies) {\n\t\t\t\t\t\t\t\t\t\t\tloaderContext.addBuildDependency(d);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (result.cacheable === false)\n\t\t\t\t\t\t\t\t\t\t\tloaderContext.cacheable(false);\n\t\t\t\t\t\t\t\t\t\tfor (const [name, { source, info }] of result.assets) {\n\t\t\t\t\t\t\t\t\t\t\tconst { buildInfo } = loaderContext._module;\n\t\t\t\t\t\t\t\t\t\t\tif (!buildInfo.assets) {\n\t\t\t\t\t\t\t\t\t\t\t\tbuildInfo.assets = Object.create(null);\n\t\t\t\t\t\t\t\t\t\t\t\tbuildInfo.assetsInfo = new Map();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tbuildInfo.assets[name] = source;\n\t\t\t\t\t\t\t\t\t\t\tbuildInfo.assetsInfo.set(name, info);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcallback(null, result.exports);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} request the request string to load the module from\n\t\t\t\t\t * @param {ImportModuleOptions} options options\n\t\t\t\t\t * @param {ImportModuleCallback=} callback callback returning the exports\n\t\t\t\t\t * @returns {Promise<any> | void} exports\n\t\t\t\t\t */\n\t\t\t\t\tloaderContext.importModule = (request, options, callback) => {\n\t\t\t\t\t\tif (!callback) {\n\t\t\t\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\t\t\t\timportModule(request, options || {}, (err, result) => {\n\t\t\t\t\t\t\t\t\tif (err) reject(err);\n\t\t\t\t\t\t\t\t\telse resolve(result);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn importModule(request, options || {}, callback);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = LoaderPlugin;\n"]},"metadata":{},"sourceType":"script"}