{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Florent Cailhol @ooflorent\n*/\n\"use strict\";\n\nconst {\n  ConcatSource\n} = require(\"webpack-sources\");\n\nconst makeSerializable = require(\"./util/makeSerializable\");\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"./Generator\").GenerateContext} GenerateContext */\n\n/**\n * @param {InitFragment} fragment the init fragment\n * @param {number} index index\n * @returns {[InitFragment, number]} tuple with both\n */\n\n\nconst extractFragmentIndex = (fragment, index) => [fragment, index];\n/**\n * @param {[InitFragment, number]} a first pair\n * @param {[InitFragment, number]} b second pair\n * @returns {number} sort value\n */\n\n\nconst sortFragmentWithIndex = (_ref, _ref2) => {\n  let [a, i] = _ref;\n  let [b, j] = _ref2;\n  const stageCmp = a.stage - b.stage;\n  if (stageCmp !== 0) return stageCmp;\n  const positionCmp = a.position - b.position;\n  if (positionCmp !== 0) return positionCmp;\n  return i - j;\n};\n/**\n * @template Context\n */\n\n\nclass InitFragment {\n  /**\n   * @param {string|Source} content the source code that will be included as initialization code\n   * @param {number} stage category of initialization code (contribute to order)\n   * @param {number} position position in the category (contribute to order)\n   * @param {string=} key unique key to avoid emitting the same initialization code twice\n   * @param {string|Source=} endContent the source code that will be included at the end of the module\n   */\n  constructor(content, stage, position, key, endContent) {\n    this.content = content;\n    this.stage = stage;\n    this.position = position;\n    this.key = key;\n    this.endContent = endContent;\n  }\n  /**\n   * @param {Context} context context\n   * @returns {string|Source} the source code that will be included as initialization code\n   */\n\n\n  getContent(context) {\n    return this.content;\n  }\n  /**\n   * @param {Context} context context\n   * @returns {string|Source=} the source code that will be included at the end of the module\n   */\n\n\n  getEndContent(context) {\n    return this.endContent;\n  }\n\n  static addToSource(source, initFragments, context) {\n    if (initFragments.length > 0) {\n      // Sort fragments by position. If 2 fragments have the same position,\n      // use their index.\n      const sortedFragments = initFragments.map(extractFragmentIndex).sort(sortFragmentWithIndex); // Deduplicate fragments. If a fragment has no key, it is always included.\n\n      const keyedFragments = new Map();\n\n      for (const [fragment] of sortedFragments) {\n        if (typeof fragment.mergeAll === \"function\") {\n          if (!fragment.key) {\n            throw new Error(`InitFragment with mergeAll function must have a valid key: ${fragment.constructor.name}`);\n          }\n\n          const oldValue = keyedFragments.get(fragment.key);\n\n          if (oldValue === undefined) {\n            keyedFragments.set(fragment.key, fragment);\n          } else if (Array.isArray(oldValue)) {\n            oldValue.push(fragment);\n          } else {\n            keyedFragments.set(fragment.key, [oldValue, fragment]);\n          }\n\n          continue;\n        } else if (typeof fragment.merge === \"function\") {\n          const oldValue = keyedFragments.get(fragment.key);\n\n          if (oldValue !== undefined) {\n            keyedFragments.set(fragment.key, fragment.merge(oldValue));\n            continue;\n          }\n        }\n\n        keyedFragments.set(fragment.key || Symbol(), fragment);\n      }\n\n      const concatSource = new ConcatSource();\n      const endContents = [];\n\n      for (let fragment of keyedFragments.values()) {\n        if (Array.isArray(fragment)) {\n          fragment = fragment[0].mergeAll(fragment);\n        }\n\n        concatSource.add(fragment.getContent(context));\n        const endContent = fragment.getEndContent(context);\n\n        if (endContent) {\n          endContents.push(endContent);\n        }\n      }\n\n      concatSource.add(source);\n\n      for (const content of endContents.reverse()) {\n        concatSource.add(content);\n      }\n\n      return concatSource;\n    } else {\n      return source;\n    }\n  }\n\n  serialize(context) {\n    const {\n      write\n    } = context;\n    write(this.content);\n    write(this.stage);\n    write(this.position);\n    write(this.key);\n    write(this.endContent);\n  }\n\n  deserialize(context) {\n    const {\n      read\n    } = context;\n    this.content = read();\n    this.stage = read();\n    this.position = read();\n    this.key = read();\n    this.endContent = read();\n  }\n\n}\n\nmakeSerializable(InitFragment, \"webpack/lib/InitFragment\");\nInitFragment.prototype.merge = undefined;\nInitFragment.STAGE_CONSTANTS = 10;\nInitFragment.STAGE_ASYNC_BOUNDARY = 20;\nInitFragment.STAGE_HARMONY_EXPORTS = 30;\nInitFragment.STAGE_HARMONY_IMPORTS = 40;\nInitFragment.STAGE_PROVIDES = 50;\nInitFragment.STAGE_ASYNC_DEPENDENCIES = 60;\nInitFragment.STAGE_ASYNC_HARMONY_IMPORTS = 70;\nmodule.exports = InitFragment;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/InitFragment.js"],"names":["ConcatSource","require","makeSerializable","extractFragmentIndex","fragment","index","sortFragmentWithIndex","a","i","b","j","stageCmp","stage","positionCmp","position","InitFragment","constructor","content","key","endContent","getContent","context","getEndContent","addToSource","source","initFragments","length","sortedFragments","map","sort","keyedFragments","Map","mergeAll","Error","name","oldValue","get","undefined","set","Array","isArray","push","merge","Symbol","concatSource","endContents","values","add","reverse","serialize","write","deserialize","read","prototype","STAGE_CONSTANTS","STAGE_ASYNC_BOUNDARY","STAGE_HARMONY_EXPORTS","STAGE_HARMONY_IMPORTS","STAGE_PROVIDES","STAGE_ASYNC_DEPENDENCIES","STAGE_ASYNC_HARMONY_IMPORTS","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAmBC,OAAO,CAAC,iBAAD,CAAhC;;AACA,MAAMC,gBAAgB,GAAGD,OAAO,CAAC,yBAAD,CAAhC;AAEA;;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAME,oBAAoB,GAAG,CAACC,QAAD,EAAWC,KAAX,KAAqB,CAACD,QAAD,EAAWC,KAAX,CAAlD;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,qBAAqB,GAAG,iBAAoB;AAAA,MAAnB,CAACC,CAAD,EAAIC,CAAJ,CAAmB;AAAA,MAAX,CAACC,CAAD,EAAIC,CAAJ,CAAW;AACjD,QAAMC,QAAQ,GAAGJ,CAAC,CAACK,KAAF,GAAUH,CAAC,CAACG,KAA7B;AACA,MAAID,QAAQ,KAAK,CAAjB,EAAoB,OAAOA,QAAP;AACpB,QAAME,WAAW,GAAGN,CAAC,CAACO,QAAF,GAAaL,CAAC,CAACK,QAAnC;AACA,MAAID,WAAW,KAAK,CAApB,EAAuB,OAAOA,WAAP;AACvB,SAAOL,CAAC,GAAGE,CAAX;AACA,CAND;AAQA;AACA;AACA;;;AACA,MAAMK,YAAN,CAAmB;AAClB;AACD;AACA;AACA;AACA;AACA;AACA;AACCC,EAAAA,WAAW,CAACC,OAAD,EAAUL,KAAV,EAAiBE,QAAjB,EAA2BI,GAA3B,EAAgCC,UAAhC,EAA4C;AACtD,SAAKF,OAAL,GAAeA,OAAf;AACA,SAAKL,KAAL,GAAaA,KAAb;AACA,SAAKE,QAAL,GAAgBA,QAAhB;AACA,SAAKI,GAAL,GAAWA,GAAX;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACA;AAED;AACD;AACA;AACA;;;AACCC,EAAAA,UAAU,CAACC,OAAD,EAAU;AACnB,WAAO,KAAKJ,OAAZ;AACA;AAED;AACD;AACA;AACA;;;AACCK,EAAAA,aAAa,CAACD,OAAD,EAAU;AACtB,WAAO,KAAKF,UAAZ;AACA;;AAEiB,SAAXI,WAAW,CAACC,MAAD,EAASC,aAAT,EAAwBJ,OAAxB,EAAiC;AAClD,QAAII,aAAa,CAACC,MAAd,GAAuB,CAA3B,EAA8B;AAC7B;AACA;AACA,YAAMC,eAAe,GAAGF,aAAa,CACnCG,GADsB,CAClBzB,oBADkB,EAEtB0B,IAFsB,CAEjBvB,qBAFiB,CAAxB,CAH6B,CAO7B;;AACA,YAAMwB,cAAc,GAAG,IAAIC,GAAJ,EAAvB;;AACA,WAAK,MAAM,CAAC3B,QAAD,CAAX,IAAyBuB,eAAzB,EAA0C;AACzC,YAAI,OAAOvB,QAAQ,CAAC4B,QAAhB,KAA6B,UAAjC,EAA6C;AAC5C,cAAI,CAAC5B,QAAQ,CAACc,GAAd,EAAmB;AAClB,kBAAM,IAAIe,KAAJ,CACJ,8DAA6D7B,QAAQ,CAACY,WAAT,CAAqBkB,IAAK,EADnF,CAAN;AAGA;;AACD,gBAAMC,QAAQ,GAAGL,cAAc,CAACM,GAAf,CAAmBhC,QAAQ,CAACc,GAA5B,CAAjB;;AACA,cAAIiB,QAAQ,KAAKE,SAAjB,EAA4B;AAC3BP,YAAAA,cAAc,CAACQ,GAAf,CAAmBlC,QAAQ,CAACc,GAA5B,EAAiCd,QAAjC;AACA,WAFD,MAEO,IAAImC,KAAK,CAACC,OAAN,CAAcL,QAAd,CAAJ,EAA6B;AACnCA,YAAAA,QAAQ,CAACM,IAAT,CAAcrC,QAAd;AACA,WAFM,MAEA;AACN0B,YAAAA,cAAc,CAACQ,GAAf,CAAmBlC,QAAQ,CAACc,GAA5B,EAAiC,CAACiB,QAAD,EAAW/B,QAAX,CAAjC;AACA;;AACD;AACA,SAfD,MAeO,IAAI,OAAOA,QAAQ,CAACsC,KAAhB,KAA0B,UAA9B,EAA0C;AAChD,gBAAMP,QAAQ,GAAGL,cAAc,CAACM,GAAf,CAAmBhC,QAAQ,CAACc,GAA5B,CAAjB;;AACA,cAAIiB,QAAQ,KAAKE,SAAjB,EAA4B;AAC3BP,YAAAA,cAAc,CAACQ,GAAf,CAAmBlC,QAAQ,CAACc,GAA5B,EAAiCd,QAAQ,CAACsC,KAAT,CAAeP,QAAf,CAAjC;AACA;AACA;AACD;;AACDL,QAAAA,cAAc,CAACQ,GAAf,CAAmBlC,QAAQ,CAACc,GAAT,IAAgByB,MAAM,EAAzC,EAA6CvC,QAA7C;AACA;;AAED,YAAMwC,YAAY,GAAG,IAAI5C,YAAJ,EAArB;AACA,YAAM6C,WAAW,GAAG,EAApB;;AACA,WAAK,IAAIzC,QAAT,IAAqB0B,cAAc,CAACgB,MAAf,EAArB,EAA8C;AAC7C,YAAIP,KAAK,CAACC,OAAN,CAAcpC,QAAd,CAAJ,EAA6B;AAC5BA,UAAAA,QAAQ,GAAGA,QAAQ,CAAC,CAAD,CAAR,CAAY4B,QAAZ,CAAqB5B,QAArB,CAAX;AACA;;AACDwC,QAAAA,YAAY,CAACG,GAAb,CAAiB3C,QAAQ,CAACgB,UAAT,CAAoBC,OAApB,CAAjB;AACA,cAAMF,UAAU,GAAGf,QAAQ,CAACkB,aAAT,CAAuBD,OAAvB,CAAnB;;AACA,YAAIF,UAAJ,EAAgB;AACf0B,UAAAA,WAAW,CAACJ,IAAZ,CAAiBtB,UAAjB;AACA;AACD;;AAEDyB,MAAAA,YAAY,CAACG,GAAb,CAAiBvB,MAAjB;;AACA,WAAK,MAAMP,OAAX,IAAsB4B,WAAW,CAACG,OAAZ,EAAtB,EAA6C;AAC5CJ,QAAAA,YAAY,CAACG,GAAb,CAAiB9B,OAAjB;AACA;;AACD,aAAO2B,YAAP;AACA,KArDD,MAqDO;AACN,aAAOpB,MAAP;AACA;AACD;;AAEDyB,EAAAA,SAAS,CAAC5B,OAAD,EAAU;AAClB,UAAM;AAAE6B,MAAAA;AAAF,QAAY7B,OAAlB;AAEA6B,IAAAA,KAAK,CAAC,KAAKjC,OAAN,CAAL;AACAiC,IAAAA,KAAK,CAAC,KAAKtC,KAAN,CAAL;AACAsC,IAAAA,KAAK,CAAC,KAAKpC,QAAN,CAAL;AACAoC,IAAAA,KAAK,CAAC,KAAKhC,GAAN,CAAL;AACAgC,IAAAA,KAAK,CAAC,KAAK/B,UAAN,CAAL;AACA;;AAEDgC,EAAAA,WAAW,CAAC9B,OAAD,EAAU;AACpB,UAAM;AAAE+B,MAAAA;AAAF,QAAW/B,OAAjB;AAEA,SAAKJ,OAAL,GAAemC,IAAI,EAAnB;AACA,SAAKxC,KAAL,GAAawC,IAAI,EAAjB;AACA,SAAKtC,QAAL,GAAgBsC,IAAI,EAApB;AACA,SAAKlC,GAAL,GAAWkC,IAAI,EAAf;AACA,SAAKjC,UAAL,GAAkBiC,IAAI,EAAtB;AACA;;AA7GiB;;AAgHnBlD,gBAAgB,CAACa,YAAD,EAAe,0BAAf,CAAhB;AAEAA,YAAY,CAACsC,SAAb,CAAuBX,KAAvB,GAA+BL,SAA/B;AAEAtB,YAAY,CAACuC,eAAb,GAA+B,EAA/B;AACAvC,YAAY,CAACwC,oBAAb,GAAoC,EAApC;AACAxC,YAAY,CAACyC,qBAAb,GAAqC,EAArC;AACAzC,YAAY,CAAC0C,qBAAb,GAAqC,EAArC;AACA1C,YAAY,CAAC2C,cAAb,GAA8B,EAA9B;AACA3C,YAAY,CAAC4C,wBAAb,GAAwC,EAAxC;AACA5C,YAAY,CAAC6C,2BAAb,GAA2C,EAA3C;AAEAC,MAAM,CAACC,OAAP,GAAiB/C,YAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Florent Cailhol @ooflorent\n*/\n\n\"use strict\";\n\nconst { ConcatSource } = require(\"webpack-sources\");\nconst makeSerializable = require(\"./util/makeSerializable\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./Generator\").GenerateContext} GenerateContext */\n\n/**\n * @param {InitFragment} fragment the init fragment\n * @param {number} index index\n * @returns {[InitFragment, number]} tuple with both\n */\nconst extractFragmentIndex = (fragment, index) => [fragment, index];\n\n/**\n * @param {[InitFragment, number]} a first pair\n * @param {[InitFragment, number]} b second pair\n * @returns {number} sort value\n */\nconst sortFragmentWithIndex = ([a, i], [b, j]) => {\n\tconst stageCmp = a.stage - b.stage;\n\tif (stageCmp !== 0) return stageCmp;\n\tconst positionCmp = a.position - b.position;\n\tif (positionCmp !== 0) return positionCmp;\n\treturn i - j;\n};\n\n/**\n * @template Context\n */\nclass InitFragment {\n\t/**\n\t * @param {string|Source} content the source code that will be included as initialization code\n\t * @param {number} stage category of initialization code (contribute to order)\n\t * @param {number} position position in the category (contribute to order)\n\t * @param {string=} key unique key to avoid emitting the same initialization code twice\n\t * @param {string|Source=} endContent the source code that will be included at the end of the module\n\t */\n\tconstructor(content, stage, position, key, endContent) {\n\t\tthis.content = content;\n\t\tthis.stage = stage;\n\t\tthis.position = position;\n\t\tthis.key = key;\n\t\tthis.endContent = endContent;\n\t}\n\n\t/**\n\t * @param {Context} context context\n\t * @returns {string|Source} the source code that will be included as initialization code\n\t */\n\tgetContent(context) {\n\t\treturn this.content;\n\t}\n\n\t/**\n\t * @param {Context} context context\n\t * @returns {string|Source=} the source code that will be included at the end of the module\n\t */\n\tgetEndContent(context) {\n\t\treturn this.endContent;\n\t}\n\n\tstatic addToSource(source, initFragments, context) {\n\t\tif (initFragments.length > 0) {\n\t\t\t// Sort fragments by position. If 2 fragments have the same position,\n\t\t\t// use their index.\n\t\t\tconst sortedFragments = initFragments\n\t\t\t\t.map(extractFragmentIndex)\n\t\t\t\t.sort(sortFragmentWithIndex);\n\n\t\t\t// Deduplicate fragments. If a fragment has no key, it is always included.\n\t\t\tconst keyedFragments = new Map();\n\t\t\tfor (const [fragment] of sortedFragments) {\n\t\t\t\tif (typeof fragment.mergeAll === \"function\") {\n\t\t\t\t\tif (!fragment.key) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`InitFragment with mergeAll function must have a valid key: ${fragment.constructor.name}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tconst oldValue = keyedFragments.get(fragment.key);\n\t\t\t\t\tif (oldValue === undefined) {\n\t\t\t\t\t\tkeyedFragments.set(fragment.key, fragment);\n\t\t\t\t\t} else if (Array.isArray(oldValue)) {\n\t\t\t\t\t\toldValue.push(fragment);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkeyedFragments.set(fragment.key, [oldValue, fragment]);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (typeof fragment.merge === \"function\") {\n\t\t\t\t\tconst oldValue = keyedFragments.get(fragment.key);\n\t\t\t\t\tif (oldValue !== undefined) {\n\t\t\t\t\t\tkeyedFragments.set(fragment.key, fragment.merge(oldValue));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tkeyedFragments.set(fragment.key || Symbol(), fragment);\n\t\t\t}\n\n\t\t\tconst concatSource = new ConcatSource();\n\t\t\tconst endContents = [];\n\t\t\tfor (let fragment of keyedFragments.values()) {\n\t\t\t\tif (Array.isArray(fragment)) {\n\t\t\t\t\tfragment = fragment[0].mergeAll(fragment);\n\t\t\t\t}\n\t\t\t\tconcatSource.add(fragment.getContent(context));\n\t\t\t\tconst endContent = fragment.getEndContent(context);\n\t\t\t\tif (endContent) {\n\t\t\t\t\tendContents.push(endContent);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconcatSource.add(source);\n\t\t\tfor (const content of endContents.reverse()) {\n\t\t\t\tconcatSource.add(content);\n\t\t\t}\n\t\t\treturn concatSource;\n\t\t} else {\n\t\t\treturn source;\n\t\t}\n\t}\n\n\tserialize(context) {\n\t\tconst { write } = context;\n\n\t\twrite(this.content);\n\t\twrite(this.stage);\n\t\twrite(this.position);\n\t\twrite(this.key);\n\t\twrite(this.endContent);\n\t}\n\n\tdeserialize(context) {\n\t\tconst { read } = context;\n\n\t\tthis.content = read();\n\t\tthis.stage = read();\n\t\tthis.position = read();\n\t\tthis.key = read();\n\t\tthis.endContent = read();\n\t}\n}\n\nmakeSerializable(InitFragment, \"webpack/lib/InitFragment\");\n\nInitFragment.prototype.merge = undefined;\n\nInitFragment.STAGE_CONSTANTS = 10;\nInitFragment.STAGE_ASYNC_BOUNDARY = 20;\nInitFragment.STAGE_HARMONY_EXPORTS = 30;\nInitFragment.STAGE_HARMONY_IMPORTS = 40;\nInitFragment.STAGE_PROVIDES = 50;\nInitFragment.STAGE_ASYNC_DEPENDENCIES = 60;\nInitFragment.STAGE_ASYNC_HARMONY_IMPORTS = 70;\n\nmodule.exports = InitFragment;\n"]},"metadata":{},"sourceType":"script"}