{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst TOMBSTONE = Symbol(\"tombstone\");\nconst UNDEFINED_MARKER = Symbol(\"undefined\");\n/**\n * @template T\n * @typedef {T | undefined} Cell<T>\n */\n\n/**\n * @template T\n * @typedef {T | typeof TOMBSTONE | typeof UNDEFINED_MARKER} InternalCell<T>\n */\n\n/**\n * @template K\n * @template V\n * @param {[K, InternalCell<V>]} pair the internal cell\n * @returns {[K, Cell<V>]} its “safe” representation\n */\n\nconst extractPair = pair => {\n  const key = pair[0];\n  const val = pair[1];\n\n  if (val === UNDEFINED_MARKER || val === TOMBSTONE) {\n    return [key, undefined];\n  } else {\n    return (\n      /** @type {[K, Cell<V>]} */\n      pair\n    );\n  }\n};\n/**\n * @template K\n * @template V\n */\n\n\nclass StackedMap {\n  /**\n   * @param {Map<K, InternalCell<V>>[]=} parentStack an optional parent\n   */\n  constructor(parentStack) {\n    /** @type {Map<K, InternalCell<V>>} */\n    this.map = new Map();\n    /** @type {Map<K, InternalCell<V>>[]} */\n\n    this.stack = parentStack === undefined ? [] : parentStack.slice();\n    this.stack.push(this.map);\n  }\n  /**\n   * @param {K} item the key of the element to add\n   * @param {V} value the value of the element to add\n   * @returns {void}\n   */\n\n\n  set(item, value) {\n    this.map.set(item, value === undefined ? UNDEFINED_MARKER : value);\n  }\n  /**\n   * @param {K} item the item to delete\n   * @returns {void}\n   */\n\n\n  delete(item) {\n    if (this.stack.length > 1) {\n      this.map.set(item, TOMBSTONE);\n    } else {\n      this.map.delete(item);\n    }\n  }\n  /**\n   * @param {K} item the item to test\n   * @returns {boolean} true if the item exists in this set\n   */\n\n\n  has(item) {\n    const topValue = this.map.get(item);\n\n    if (topValue !== undefined) {\n      return topValue !== TOMBSTONE;\n    }\n\n    if (this.stack.length > 1) {\n      for (let i = this.stack.length - 2; i >= 0; i--) {\n        const value = this.stack[i].get(item);\n\n        if (value !== undefined) {\n          this.map.set(item, value);\n          return value !== TOMBSTONE;\n        }\n      }\n\n      this.map.set(item, TOMBSTONE);\n    }\n\n    return false;\n  }\n  /**\n   * @param {K} item the key of the element to return\n   * @returns {Cell<V>} the value of the element\n   */\n\n\n  get(item) {\n    const topValue = this.map.get(item);\n\n    if (topValue !== undefined) {\n      return topValue === TOMBSTONE || topValue === UNDEFINED_MARKER ? undefined : topValue;\n    }\n\n    if (this.stack.length > 1) {\n      for (let i = this.stack.length - 2; i >= 0; i--) {\n        const value = this.stack[i].get(item);\n\n        if (value !== undefined) {\n          this.map.set(item, value);\n          return value === TOMBSTONE || value === UNDEFINED_MARKER ? undefined : value;\n        }\n      }\n\n      this.map.set(item, TOMBSTONE);\n    }\n\n    return undefined;\n  }\n\n  _compress() {\n    if (this.stack.length === 1) return;\n    this.map = new Map();\n\n    for (const data of this.stack) {\n      for (const pair of data) {\n        if (pair[1] === TOMBSTONE) {\n          this.map.delete(pair[0]);\n        } else {\n          this.map.set(pair[0], pair[1]);\n        }\n      }\n    }\n\n    this.stack = [this.map];\n  }\n\n  asArray() {\n    this._compress();\n\n    return Array.from(this.map.keys());\n  }\n\n  asSet() {\n    this._compress();\n\n    return new Set(this.map.keys());\n  }\n\n  asPairArray() {\n    this._compress();\n\n    return Array.from(this.map.entries(), extractPair);\n  }\n\n  asMap() {\n    return new Map(this.asPairArray());\n  }\n\n  get size() {\n    this._compress();\n\n    return this.map.size;\n  }\n\n  createChild() {\n    return new StackedMap(this.stack);\n  }\n\n}\n\nmodule.exports = StackedMap;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/util/StackedMap.js"],"names":["TOMBSTONE","Symbol","UNDEFINED_MARKER","extractPair","pair","key","val","undefined","StackedMap","constructor","parentStack","map","Map","stack","slice","push","set","item","value","delete","length","has","topValue","get","i","_compress","data","asArray","Array","from","keys","asSet","Set","asPairArray","entries","asMap","size","createChild","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst TOMBSTONE = Symbol(\"tombstone\");\nconst UNDEFINED_MARKER = Symbol(\"undefined\");\n\n/**\n * @template T\n * @typedef {T | undefined} Cell<T>\n */\n\n/**\n * @template T\n * @typedef {T | typeof TOMBSTONE | typeof UNDEFINED_MARKER} InternalCell<T>\n */\n\n/**\n * @template K\n * @template V\n * @param {[K, InternalCell<V>]} pair the internal cell\n * @returns {[K, Cell<V>]} its “safe” representation\n */\nconst extractPair = pair => {\n\tconst key = pair[0];\n\tconst val = pair[1];\n\tif (val === UNDEFINED_MARKER || val === TOMBSTONE) {\n\t\treturn [key, undefined];\n\t} else {\n\t\treturn /** @type {[K, Cell<V>]} */ (pair);\n\t}\n};\n\n/**\n * @template K\n * @template V\n */\nclass StackedMap {\n\t/**\n\t * @param {Map<K, InternalCell<V>>[]=} parentStack an optional parent\n\t */\n\tconstructor(parentStack) {\n\t\t/** @type {Map<K, InternalCell<V>>} */\n\t\tthis.map = new Map();\n\t\t/** @type {Map<K, InternalCell<V>>[]} */\n\t\tthis.stack = parentStack === undefined ? [] : parentStack.slice();\n\t\tthis.stack.push(this.map);\n\t}\n\n\t/**\n\t * @param {K} item the key of the element to add\n\t * @param {V} value the value of the element to add\n\t * @returns {void}\n\t */\n\tset(item, value) {\n\t\tthis.map.set(item, value === undefined ? UNDEFINED_MARKER : value);\n\t}\n\n\t/**\n\t * @param {K} item the item to delete\n\t * @returns {void}\n\t */\n\tdelete(item) {\n\t\tif (this.stack.length > 1) {\n\t\t\tthis.map.set(item, TOMBSTONE);\n\t\t} else {\n\t\t\tthis.map.delete(item);\n\t\t}\n\t}\n\n\t/**\n\t * @param {K} item the item to test\n\t * @returns {boolean} true if the item exists in this set\n\t */\n\thas(item) {\n\t\tconst topValue = this.map.get(item);\n\t\tif (topValue !== undefined) {\n\t\t\treturn topValue !== TOMBSTONE;\n\t\t}\n\t\tif (this.stack.length > 1) {\n\t\t\tfor (let i = this.stack.length - 2; i >= 0; i--) {\n\t\t\t\tconst value = this.stack[i].get(item);\n\t\t\t\tif (value !== undefined) {\n\t\t\t\t\tthis.map.set(item, value);\n\t\t\t\t\treturn value !== TOMBSTONE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.map.set(item, TOMBSTONE);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {K} item the key of the element to return\n\t * @returns {Cell<V>} the value of the element\n\t */\n\tget(item) {\n\t\tconst topValue = this.map.get(item);\n\t\tif (topValue !== undefined) {\n\t\t\treturn topValue === TOMBSTONE || topValue === UNDEFINED_MARKER\n\t\t\t\t? undefined\n\t\t\t\t: topValue;\n\t\t}\n\t\tif (this.stack.length > 1) {\n\t\t\tfor (let i = this.stack.length - 2; i >= 0; i--) {\n\t\t\t\tconst value = this.stack[i].get(item);\n\t\t\t\tif (value !== undefined) {\n\t\t\t\t\tthis.map.set(item, value);\n\t\t\t\t\treturn value === TOMBSTONE || value === UNDEFINED_MARKER\n\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t: value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.map.set(item, TOMBSTONE);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t_compress() {\n\t\tif (this.stack.length === 1) return;\n\t\tthis.map = new Map();\n\t\tfor (const data of this.stack) {\n\t\t\tfor (const pair of data) {\n\t\t\t\tif (pair[1] === TOMBSTONE) {\n\t\t\t\t\tthis.map.delete(pair[0]);\n\t\t\t\t} else {\n\t\t\t\t\tthis.map.set(pair[0], pair[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.stack = [this.map];\n\t}\n\n\tasArray() {\n\t\tthis._compress();\n\t\treturn Array.from(this.map.keys());\n\t}\n\n\tasSet() {\n\t\tthis._compress();\n\t\treturn new Set(this.map.keys());\n\t}\n\n\tasPairArray() {\n\t\tthis._compress();\n\t\treturn Array.from(this.map.entries(), extractPair);\n\t}\n\n\tasMap() {\n\t\treturn new Map(this.asPairArray());\n\t}\n\n\tget size() {\n\t\tthis._compress();\n\t\treturn this.map.size;\n\t}\n\n\tcreateChild() {\n\t\treturn new StackedMap(this.stack);\n\t}\n}\n\nmodule.exports = StackedMap;\n"]},"metadata":{},"sourceType":"script"}