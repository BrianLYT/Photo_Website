{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Cache = require(\"../Cache\");\n\nconst ProgressPlugin = require(\"../ProgressPlugin\");\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n\nconst BUILD_DEPENDENCIES_KEY = Symbol();\n\nclass IdleFileCachePlugin {\n  /**\n   * @param {TODO} strategy cache strategy\n   * @param {number} idleTimeout timeout\n   * @param {number} idleTimeoutForInitialStore initial timeout\n   * @param {number} idleTimeoutAfterLargeChanges timeout after changes\n   */\n  constructor(strategy, idleTimeout, idleTimeoutForInitialStore, idleTimeoutAfterLargeChanges) {\n    this.strategy = strategy;\n    this.idleTimeout = idleTimeout;\n    this.idleTimeoutForInitialStore = idleTimeoutForInitialStore;\n    this.idleTimeoutAfterLargeChanges = idleTimeoutAfterLargeChanges;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    let strategy = this.strategy;\n    const idleTimeout = this.idleTimeout;\n    const idleTimeoutForInitialStore = Math.min(idleTimeout, this.idleTimeoutForInitialStore);\n    const idleTimeoutAfterLargeChanges = this.idleTimeoutAfterLargeChanges;\n    const resolvedPromise = Promise.resolve();\n    let timeSpendInBuild = 0;\n    let timeSpendInStore = 0;\n    let avgTimeSpendInStore = 0;\n    /** @type {Map<string | typeof BUILD_DEPENDENCIES_KEY, () => Promise>} */\n\n    const pendingIdleTasks = new Map();\n    compiler.cache.hooks.store.tap({\n      name: \"IdleFileCachePlugin\",\n      stage: Cache.STAGE_DISK\n    }, (identifier, etag, data) => {\n      pendingIdleTasks.set(identifier, () => strategy.store(identifier, etag, data));\n    });\n    compiler.cache.hooks.get.tapPromise({\n      name: \"IdleFileCachePlugin\",\n      stage: Cache.STAGE_DISK\n    }, (identifier, etag, gotHandlers) => {\n      const restore = () => strategy.restore(identifier, etag).then(cacheEntry => {\n        if (cacheEntry === undefined) {\n          gotHandlers.push((result, callback) => {\n            if (result !== undefined) {\n              pendingIdleTasks.set(identifier, () => strategy.store(identifier, etag, result));\n            }\n\n            callback();\n          });\n        } else {\n          return cacheEntry;\n        }\n      });\n\n      const pendingTask = pendingIdleTasks.get(identifier);\n\n      if (pendingTask !== undefined) {\n        pendingIdleTasks.delete(identifier);\n        return pendingTask().then(restore);\n      }\n\n      return restore();\n    });\n    compiler.cache.hooks.storeBuildDependencies.tap({\n      name: \"IdleFileCachePlugin\",\n      stage: Cache.STAGE_DISK\n    }, dependencies => {\n      pendingIdleTasks.set(BUILD_DEPENDENCIES_KEY, () => strategy.storeBuildDependencies(dependencies));\n    });\n    compiler.cache.hooks.shutdown.tapPromise({\n      name: \"IdleFileCachePlugin\",\n      stage: Cache.STAGE_DISK\n    }, () => {\n      if (idleTimer) {\n        clearTimeout(idleTimer);\n        idleTimer = undefined;\n      }\n\n      isIdle = false;\n      const reportProgress = ProgressPlugin.getReporter(compiler);\n      const jobs = Array.from(pendingIdleTasks.values());\n      if (reportProgress) reportProgress(0, \"process pending cache items\");\n      const promises = jobs.map(fn => fn());\n      pendingIdleTasks.clear();\n      promises.push(currentIdlePromise);\n      const promise = Promise.all(promises);\n      currentIdlePromise = promise.then(() => strategy.afterAllStored());\n\n      if (reportProgress) {\n        currentIdlePromise = currentIdlePromise.then(() => {\n          reportProgress(1, `stored`);\n        });\n      }\n\n      return currentIdlePromise.then(() => {\n        // Reset strategy\n        if (strategy.clear) strategy.clear();\n      });\n    });\n    /** @type {Promise<any>} */\n\n    let currentIdlePromise = resolvedPromise;\n    let isIdle = false;\n    let isInitialStore = true;\n\n    const processIdleTasks = () => {\n      if (isIdle) {\n        const startTime = Date.now();\n\n        if (pendingIdleTasks.size > 0) {\n          const promises = [currentIdlePromise];\n          const maxTime = startTime + 100;\n          let maxCount = 100;\n\n          for (const [filename, factory] of pendingIdleTasks) {\n            pendingIdleTasks.delete(filename);\n            promises.push(factory());\n            if (maxCount-- <= 0 || Date.now() > maxTime) break;\n          }\n\n          currentIdlePromise = Promise.all(promises);\n          currentIdlePromise.then(() => {\n            timeSpendInStore += Date.now() - startTime; // Allow to exit the process between\n\n            idleTimer = setTimeout(processIdleTasks, 0);\n            idleTimer.unref();\n          });\n          return;\n        }\n\n        currentIdlePromise = currentIdlePromise.then(async () => {\n          await strategy.afterAllStored();\n          timeSpendInStore += Date.now() - startTime;\n          avgTimeSpendInStore = Math.max(avgTimeSpendInStore, timeSpendInStore) * 0.9 + timeSpendInStore * 0.1;\n          timeSpendInStore = 0;\n          timeSpendInBuild = 0;\n        }).catch(err => {\n          const logger = compiler.getInfrastructureLogger(\"IdleFileCachePlugin\");\n          logger.warn(`Background tasks during idle failed: ${err.message}`);\n          logger.debug(err.stack);\n        });\n        isInitialStore = false;\n      }\n    };\n\n    let idleTimer = undefined;\n    compiler.cache.hooks.beginIdle.tap({\n      name: \"IdleFileCachePlugin\",\n      stage: Cache.STAGE_DISK\n    }, () => {\n      const isLargeChange = timeSpendInBuild > avgTimeSpendInStore * 2;\n\n      if (isInitialStore && idleTimeoutForInitialStore < idleTimeout) {\n        compiler.getInfrastructureLogger(\"IdleFileCachePlugin\").log(`Initial cache was generated and cache will be persisted in ${idleTimeoutForInitialStore / 1000}s.`);\n      } else if (isLargeChange && idleTimeoutAfterLargeChanges < idleTimeout) {\n        compiler.getInfrastructureLogger(\"IdleFileCachePlugin\").log(`Spend ${Math.round(timeSpendInBuild) / 1000}s in build and ${Math.round(avgTimeSpendInStore) / 1000}s in average in cache store. This is considered as large change and cache will be persisted in ${idleTimeoutAfterLargeChanges / 1000}s.`);\n      }\n\n      idleTimer = setTimeout(() => {\n        idleTimer = undefined;\n        isIdle = true;\n        resolvedPromise.then(processIdleTasks);\n      }, Math.min(isInitialStore ? idleTimeoutForInitialStore : Infinity, isLargeChange ? idleTimeoutAfterLargeChanges : Infinity, idleTimeout));\n      idleTimer.unref();\n    });\n    compiler.cache.hooks.endIdle.tap({\n      name: \"IdleFileCachePlugin\",\n      stage: Cache.STAGE_DISK\n    }, () => {\n      if (idleTimer) {\n        clearTimeout(idleTimer);\n        idleTimer = undefined;\n      }\n\n      isIdle = false;\n    });\n    compiler.hooks.done.tap(\"IdleFileCachePlugin\", stats => {\n      // 10% build overhead is ignored, as it's not cacheable\n      timeSpendInBuild *= 0.9;\n      timeSpendInBuild += stats.endTime - stats.startTime;\n    });\n  }\n\n}\n\nmodule.exports = IdleFileCachePlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/cache/IdleFileCachePlugin.js"],"names":["Cache","require","ProgressPlugin","BUILD_DEPENDENCIES_KEY","Symbol","IdleFileCachePlugin","constructor","strategy","idleTimeout","idleTimeoutForInitialStore","idleTimeoutAfterLargeChanges","apply","compiler","Math","min","resolvedPromise","Promise","resolve","timeSpendInBuild","timeSpendInStore","avgTimeSpendInStore","pendingIdleTasks","Map","cache","hooks","store","tap","name","stage","STAGE_DISK","identifier","etag","data","set","get","tapPromise","gotHandlers","restore","then","cacheEntry","undefined","push","result","callback","pendingTask","delete","storeBuildDependencies","dependencies","shutdown","idleTimer","clearTimeout","isIdle","reportProgress","getReporter","jobs","Array","from","values","promises","map","fn","clear","currentIdlePromise","promise","all","afterAllStored","isInitialStore","processIdleTasks","startTime","Date","now","size","maxTime","maxCount","filename","factory","setTimeout","unref","max","catch","err","logger","getInfrastructureLogger","warn","message","debug","stack","beginIdle","isLargeChange","log","round","Infinity","endIdle","done","stats","endTime","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Cache = require(\"../Cache\");\nconst ProgressPlugin = require(\"../ProgressPlugin\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nconst BUILD_DEPENDENCIES_KEY = Symbol();\n\nclass IdleFileCachePlugin {\n\t/**\n\t * @param {TODO} strategy cache strategy\n\t * @param {number} idleTimeout timeout\n\t * @param {number} idleTimeoutForInitialStore initial timeout\n\t * @param {number} idleTimeoutAfterLargeChanges timeout after changes\n\t */\n\tconstructor(\n\t\tstrategy,\n\t\tidleTimeout,\n\t\tidleTimeoutForInitialStore,\n\t\tidleTimeoutAfterLargeChanges\n\t) {\n\t\tthis.strategy = strategy;\n\t\tthis.idleTimeout = idleTimeout;\n\t\tthis.idleTimeoutForInitialStore = idleTimeoutForInitialStore;\n\t\tthis.idleTimeoutAfterLargeChanges = idleTimeoutAfterLargeChanges;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tlet strategy = this.strategy;\n\t\tconst idleTimeout = this.idleTimeout;\n\t\tconst idleTimeoutForInitialStore = Math.min(\n\t\t\tidleTimeout,\n\t\t\tthis.idleTimeoutForInitialStore\n\t\t);\n\t\tconst idleTimeoutAfterLargeChanges = this.idleTimeoutAfterLargeChanges;\n\t\tconst resolvedPromise = Promise.resolve();\n\n\t\tlet timeSpendInBuild = 0;\n\t\tlet timeSpendInStore = 0;\n\t\tlet avgTimeSpendInStore = 0;\n\n\t\t/** @type {Map<string | typeof BUILD_DEPENDENCIES_KEY, () => Promise>} */\n\t\tconst pendingIdleTasks = new Map();\n\n\t\tcompiler.cache.hooks.store.tap(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\t(identifier, etag, data) => {\n\t\t\t\tpendingIdleTasks.set(identifier, () =>\n\t\t\t\t\tstrategy.store(identifier, etag, data)\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\n\t\tcompiler.cache.hooks.get.tapPromise(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\t(identifier, etag, gotHandlers) => {\n\t\t\t\tconst restore = () =>\n\t\t\t\t\tstrategy.restore(identifier, etag).then(cacheEntry => {\n\t\t\t\t\t\tif (cacheEntry === undefined) {\n\t\t\t\t\t\t\tgotHandlers.push((result, callback) => {\n\t\t\t\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\t\t\t\tpendingIdleTasks.set(identifier, () =>\n\t\t\t\t\t\t\t\t\t\tstrategy.store(identifier, etag, result)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn cacheEntry;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\tconst pendingTask = pendingIdleTasks.get(identifier);\n\t\t\t\tif (pendingTask !== undefined) {\n\t\t\t\t\tpendingIdleTasks.delete(identifier);\n\t\t\t\t\treturn pendingTask().then(restore);\n\t\t\t\t}\n\t\t\t\treturn restore();\n\t\t\t}\n\t\t);\n\n\t\tcompiler.cache.hooks.storeBuildDependencies.tap(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\tdependencies => {\n\t\t\t\tpendingIdleTasks.set(BUILD_DEPENDENCIES_KEY, () =>\n\t\t\t\t\tstrategy.storeBuildDependencies(dependencies)\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\n\t\tcompiler.cache.hooks.shutdown.tapPromise(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\t() => {\n\t\t\t\tif (idleTimer) {\n\t\t\t\t\tclearTimeout(idleTimer);\n\t\t\t\t\tidleTimer = undefined;\n\t\t\t\t}\n\t\t\t\tisIdle = false;\n\t\t\t\tconst reportProgress = ProgressPlugin.getReporter(compiler);\n\t\t\t\tconst jobs = Array.from(pendingIdleTasks.values());\n\t\t\t\tif (reportProgress) reportProgress(0, \"process pending cache items\");\n\t\t\t\tconst promises = jobs.map(fn => fn());\n\t\t\t\tpendingIdleTasks.clear();\n\t\t\t\tpromises.push(currentIdlePromise);\n\t\t\t\tconst promise = Promise.all(promises);\n\t\t\t\tcurrentIdlePromise = promise.then(() => strategy.afterAllStored());\n\t\t\t\tif (reportProgress) {\n\t\t\t\t\tcurrentIdlePromise = currentIdlePromise.then(() => {\n\t\t\t\t\t\treportProgress(1, `stored`);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn currentIdlePromise.then(() => {\n\t\t\t\t\t// Reset strategy\n\t\t\t\t\tif (strategy.clear) strategy.clear();\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\n\t\t/** @type {Promise<any>} */\n\t\tlet currentIdlePromise = resolvedPromise;\n\t\tlet isIdle = false;\n\t\tlet isInitialStore = true;\n\t\tconst processIdleTasks = () => {\n\t\t\tif (isIdle) {\n\t\t\t\tconst startTime = Date.now();\n\t\t\t\tif (pendingIdleTasks.size > 0) {\n\t\t\t\t\tconst promises = [currentIdlePromise];\n\t\t\t\t\tconst maxTime = startTime + 100;\n\t\t\t\t\tlet maxCount = 100;\n\t\t\t\t\tfor (const [filename, factory] of pendingIdleTasks) {\n\t\t\t\t\t\tpendingIdleTasks.delete(filename);\n\t\t\t\t\t\tpromises.push(factory());\n\t\t\t\t\t\tif (maxCount-- <= 0 || Date.now() > maxTime) break;\n\t\t\t\t\t}\n\t\t\t\t\tcurrentIdlePromise = Promise.all(promises);\n\t\t\t\t\tcurrentIdlePromise.then(() => {\n\t\t\t\t\t\ttimeSpendInStore += Date.now() - startTime;\n\t\t\t\t\t\t// Allow to exit the process between\n\t\t\t\t\t\tidleTimer = setTimeout(processIdleTasks, 0);\n\t\t\t\t\t\tidleTimer.unref();\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentIdlePromise = currentIdlePromise\n\t\t\t\t\t.then(async () => {\n\t\t\t\t\t\tawait strategy.afterAllStored();\n\t\t\t\t\t\ttimeSpendInStore += Date.now() - startTime;\n\t\t\t\t\t\tavgTimeSpendInStore =\n\t\t\t\t\t\t\tMath.max(avgTimeSpendInStore, timeSpendInStore) * 0.9 +\n\t\t\t\t\t\t\ttimeSpendInStore * 0.1;\n\t\t\t\t\t\ttimeSpendInStore = 0;\n\t\t\t\t\t\ttimeSpendInBuild = 0;\n\t\t\t\t\t})\n\t\t\t\t\t.catch(err => {\n\t\t\t\t\t\tconst logger = compiler.getInfrastructureLogger(\n\t\t\t\t\t\t\t\"IdleFileCachePlugin\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\tlogger.warn(`Background tasks during idle failed: ${err.message}`);\n\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t});\n\t\t\t\tisInitialStore = false;\n\t\t\t}\n\t\t};\n\t\tlet idleTimer = undefined;\n\t\tcompiler.cache.hooks.beginIdle.tap(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\t() => {\n\t\t\t\tconst isLargeChange = timeSpendInBuild > avgTimeSpendInStore * 2;\n\t\t\t\tif (isInitialStore && idleTimeoutForInitialStore < idleTimeout) {\n\t\t\t\t\tcompiler\n\t\t\t\t\t\t.getInfrastructureLogger(\"IdleFileCachePlugin\")\n\t\t\t\t\t\t.log(\n\t\t\t\t\t\t\t`Initial cache was generated and cache will be persisted in ${\n\t\t\t\t\t\t\t\tidleTimeoutForInitialStore / 1000\n\t\t\t\t\t\t\t}s.`\n\t\t\t\t\t\t);\n\t\t\t\t} else if (\n\t\t\t\t\tisLargeChange &&\n\t\t\t\t\tidleTimeoutAfterLargeChanges < idleTimeout\n\t\t\t\t) {\n\t\t\t\t\tcompiler\n\t\t\t\t\t\t.getInfrastructureLogger(\"IdleFileCachePlugin\")\n\t\t\t\t\t\t.log(\n\t\t\t\t\t\t\t`Spend ${Math.round(timeSpendInBuild) / 1000}s in build and ${\n\t\t\t\t\t\t\t\tMath.round(avgTimeSpendInStore) / 1000\n\t\t\t\t\t\t\t}s in average in cache store. This is considered as large change and cache will be persisted in ${\n\t\t\t\t\t\t\t\tidleTimeoutAfterLargeChanges / 1000\n\t\t\t\t\t\t\t}s.`\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tidleTimer = setTimeout(() => {\n\t\t\t\t\tidleTimer = undefined;\n\t\t\t\t\tisIdle = true;\n\t\t\t\t\tresolvedPromise.then(processIdleTasks);\n\t\t\t\t}, Math.min(isInitialStore ? idleTimeoutForInitialStore : Infinity, isLargeChange ? idleTimeoutAfterLargeChanges : Infinity, idleTimeout));\n\t\t\t\tidleTimer.unref();\n\t\t\t}\n\t\t);\n\t\tcompiler.cache.hooks.endIdle.tap(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\t() => {\n\t\t\t\tif (idleTimer) {\n\t\t\t\t\tclearTimeout(idleTimer);\n\t\t\t\t\tidleTimer = undefined;\n\t\t\t\t}\n\t\t\t\tisIdle = false;\n\t\t\t}\n\t\t);\n\t\tcompiler.hooks.done.tap(\"IdleFileCachePlugin\", stats => {\n\t\t\t// 10% build overhead is ignored, as it's not cacheable\n\t\t\ttimeSpendInBuild *= 0.9;\n\t\t\ttimeSpendInBuild += stats.endTime - stats.startTime;\n\t\t});\n\t}\n}\n\nmodule.exports = IdleFileCachePlugin;\n"]},"metadata":{},"sourceType":"script"}