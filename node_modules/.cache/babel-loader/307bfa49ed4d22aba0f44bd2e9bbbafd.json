{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Cache = require(\"../Cache\");\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../Cache\").Etag} Etag */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Module\")} Module */\n\n\nclass MemoryCachePlugin {\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    /** @type {Map<string, { etag: Etag | null, data: any }>} */\n    const cache = new Map();\n    compiler.cache.hooks.store.tap({\n      name: \"MemoryCachePlugin\",\n      stage: Cache.STAGE_MEMORY\n    }, (identifier, etag, data) => {\n      cache.set(identifier, {\n        etag,\n        data\n      });\n    });\n    compiler.cache.hooks.get.tap({\n      name: \"MemoryCachePlugin\",\n      stage: Cache.STAGE_MEMORY\n    }, (identifier, etag, gotHandlers) => {\n      const cacheEntry = cache.get(identifier);\n\n      if (cacheEntry === null) {\n        return null;\n      } else if (cacheEntry !== undefined) {\n        return cacheEntry.etag === etag ? cacheEntry.data : null;\n      }\n\n      gotHandlers.push((result, callback) => {\n        if (result === undefined) {\n          cache.set(identifier, null);\n        } else {\n          cache.set(identifier, {\n            etag,\n            data: result\n          });\n        }\n\n        return callback();\n      });\n    });\n    compiler.cache.hooks.shutdown.tap({\n      name: \"MemoryCachePlugin\",\n      stage: Cache.STAGE_MEMORY\n    }, () => {\n      cache.clear();\n    });\n  }\n\n}\n\nmodule.exports = MemoryCachePlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/cache/MemoryCachePlugin.js"],"names":["Cache","require","MemoryCachePlugin","apply","compiler","cache","Map","hooks","store","tap","name","stage","STAGE_MEMORY","identifier","etag","data","set","get","gotHandlers","cacheEntry","undefined","push","result","callback","shutdown","clear","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,UAAD,CAArB;AAEA;;AACA;;AACA;;AACA;;;AAEA,MAAMC,iBAAN,CAAwB;AACvB;AACD;AACA;AACA;AACA;AACCC,EAAAA,KAAK,CAACC,QAAD,EAAW;AACf;AACA,UAAMC,KAAK,GAAG,IAAIC,GAAJ,EAAd;AACAF,IAAAA,QAAQ,CAACC,KAAT,CAAeE,KAAf,CAAqBC,KAArB,CAA2BC,GAA3B,CACC;AAAEC,MAAAA,IAAI,EAAE,mBAAR;AAA6BC,MAAAA,KAAK,EAAEX,KAAK,CAACY;AAA1C,KADD,EAEC,CAACC,UAAD,EAAaC,IAAb,EAAmBC,IAAnB,KAA4B;AAC3BV,MAAAA,KAAK,CAACW,GAAN,CAAUH,UAAV,EAAsB;AAAEC,QAAAA,IAAF;AAAQC,QAAAA;AAAR,OAAtB;AACA,KAJF;AAMAX,IAAAA,QAAQ,CAACC,KAAT,CAAeE,KAAf,CAAqBU,GAArB,CAAyBR,GAAzB,CACC;AAAEC,MAAAA,IAAI,EAAE,mBAAR;AAA6BC,MAAAA,KAAK,EAAEX,KAAK,CAACY;AAA1C,KADD,EAEC,CAACC,UAAD,EAAaC,IAAb,EAAmBI,WAAnB,KAAmC;AAClC,YAAMC,UAAU,GAAGd,KAAK,CAACY,GAAN,CAAUJ,UAAV,CAAnB;;AACA,UAAIM,UAAU,KAAK,IAAnB,EAAyB;AACxB,eAAO,IAAP;AACA,OAFD,MAEO,IAAIA,UAAU,KAAKC,SAAnB,EAA8B;AACpC,eAAOD,UAAU,CAACL,IAAX,KAAoBA,IAApB,GAA2BK,UAAU,CAACJ,IAAtC,GAA6C,IAApD;AACA;;AACDG,MAAAA,WAAW,CAACG,IAAZ,CAAiB,CAACC,MAAD,EAASC,QAAT,KAAsB;AACtC,YAAID,MAAM,KAAKF,SAAf,EAA0B;AACzBf,UAAAA,KAAK,CAACW,GAAN,CAAUH,UAAV,EAAsB,IAAtB;AACA,SAFD,MAEO;AACNR,UAAAA,KAAK,CAACW,GAAN,CAAUH,UAAV,EAAsB;AAAEC,YAAAA,IAAF;AAAQC,YAAAA,IAAI,EAAEO;AAAd,WAAtB;AACA;;AACD,eAAOC,QAAQ,EAAf;AACA,OAPD;AAQA,KAjBF;AAmBAnB,IAAAA,QAAQ,CAACC,KAAT,CAAeE,KAAf,CAAqBiB,QAArB,CAA8Bf,GAA9B,CACC;AAAEC,MAAAA,IAAI,EAAE,mBAAR;AAA6BC,MAAAA,KAAK,EAAEX,KAAK,CAACY;AAA1C,KADD,EAEC,MAAM;AACLP,MAAAA,KAAK,CAACoB,KAAN;AACA,KAJF;AAMA;;AAxCsB;;AA0CxBC,MAAM,CAACC,OAAP,GAAiBzB,iBAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Cache = require(\"../Cache\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Cache\").Etag} Etag */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\nclass MemoryCachePlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\t/** @type {Map<string, { etag: Etag | null, data: any }>} */\n\t\tconst cache = new Map();\n\t\tcompiler.cache.hooks.store.tap(\n\t\t\t{ name: \"MemoryCachePlugin\", stage: Cache.STAGE_MEMORY },\n\t\t\t(identifier, etag, data) => {\n\t\t\t\tcache.set(identifier, { etag, data });\n\t\t\t}\n\t\t);\n\t\tcompiler.cache.hooks.get.tap(\n\t\t\t{ name: \"MemoryCachePlugin\", stage: Cache.STAGE_MEMORY },\n\t\t\t(identifier, etag, gotHandlers) => {\n\t\t\t\tconst cacheEntry = cache.get(identifier);\n\t\t\t\tif (cacheEntry === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (cacheEntry !== undefined) {\n\t\t\t\t\treturn cacheEntry.etag === etag ? cacheEntry.data : null;\n\t\t\t\t}\n\t\t\t\tgotHandlers.push((result, callback) => {\n\t\t\t\t\tif (result === undefined) {\n\t\t\t\t\t\tcache.set(identifier, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcache.set(identifier, { etag, data: result });\n\t\t\t\t\t}\n\t\t\t\t\treturn callback();\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t\tcompiler.cache.hooks.shutdown.tap(\n\t\t\t{ name: \"MemoryCachePlugin\", stage: Cache.STAGE_MEMORY },\n\t\t\t() => {\n\t\t\t\tcache.clear();\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = MemoryCachePlugin;\n"]},"metadata":{},"sourceType":"script"}