{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Sergey Melyukov @smelukov\n*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\n\nconst {\n  SyncBailHook\n} = require(\"tapable\");\n\nconst Compilation = require(\"../lib/Compilation\");\n\nconst createSchemaValidation = require(\"./util/create-schema-validation\");\n\nconst {\n  join\n} = require(\"./util/fs\");\n\nconst processAsyncTree = require(\"./util/processAsyncTree\");\n/** @typedef {import(\"../declarations/WebpackOptions\").CleanOptions} CleanOptions */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n\n/** @typedef {import(\"./util/fs\").StatsCallback} StatsCallback */\n\n/** @typedef {(function(string):boolean)|RegExp} IgnoreItem */\n\n/** @typedef {Map<string, number>} Assets */\n\n/** @typedef {function(IgnoreItem): void} AddToIgnoreCallback */\n\n/**\n * @typedef {Object} CleanPluginCompilationHooks\n * @property {SyncBailHook<[string], boolean>} keep when returning true the file/directory will be kept during cleaning, returning false will clean it and ignore the following plugins and config\n */\n\n\nconst validate = createSchemaValidation(undefined, () => {\n  const {\n    definitions\n  } = require(\"../schemas/WebpackOptions.json\");\n\n  return {\n    definitions,\n    oneOf: [{\n      $ref: \"#/definitions/CleanOptions\"\n    }]\n  };\n}, {\n  name: \"Clean Plugin\",\n  baseDataPath: \"options\"\n});\n\nconst _10sec = 10 * 1000;\n/**\n * marge assets map 2 into map 1\n * @param {Assets} as1 assets\n * @param {Assets} as2 assets\n * @returns {void}\n */\n\n\nconst mergeAssets = (as1, as2) => {\n  for (const [key, value1] of as2) {\n    const value2 = as1.get(key);\n    if (!value2 || value1 > value2) as1.set(key, value1);\n  }\n};\n/**\n * @param {OutputFileSystem} fs filesystem\n * @param {string} outputPath output path\n * @param {Map<string, number>} currentAssets filename of the current assets (must not start with .. or ., must only use / as path separator)\n * @param {function((Error | null)=, Set<string>=): void} callback returns the filenames of the assets that shouldn't be there\n * @returns {void}\n */\n\n\nconst getDiffToFs = (fs, outputPath, currentAssets, callback) => {\n  const directories = new Set(); // get directories of assets\n\n  for (const [asset] of currentAssets) {\n    directories.add(asset.replace(/(^|\\/)[^/]*$/, \"\"));\n  } // and all parent directories\n\n\n  for (const directory of directories) {\n    directories.add(directory.replace(/(^|\\/)[^/]*$/, \"\"));\n  }\n\n  const diff = new Set();\n  asyncLib.forEachLimit(directories, 10, (directory, callback) => {\n    fs.readdir(join(fs, outputPath, directory), (err, entries) => {\n      if (err) {\n        if (err.code === \"ENOENT\") return callback();\n\n        if (err.code === \"ENOTDIR\") {\n          diff.add(directory);\n          return callback();\n        }\n\n        return callback(err);\n      }\n\n      for (const entry of entries) {\n        const file =\n        /** @type {string} */\n        entry;\n        const filename = directory ? `${directory}/${file}` : file;\n\n        if (!directories.has(filename) && !currentAssets.has(filename)) {\n          diff.add(filename);\n        }\n      }\n\n      callback();\n    });\n  }, err => {\n    if (err) return callback(err);\n    callback(null, diff);\n  });\n};\n/**\n * @param {Assets} currentAssets assets list\n * @param {Assets} oldAssets old assets list\n * @returns {Set<string>} diff\n */\n\n\nconst getDiffToOldAssets = (currentAssets, oldAssets) => {\n  const diff = new Set();\n  const now = Date.now();\n\n  for (const [asset, ts] of oldAssets) {\n    if (ts >= now) continue;\n    if (!currentAssets.has(asset)) diff.add(asset);\n  }\n\n  return diff;\n};\n/**\n * @param {OutputFileSystem} fs filesystem\n * @param {string} filename path to file\n * @param {StatsCallback} callback callback for provided filename\n * @returns {void}\n */\n\n\nconst doStat = (fs, filename, callback) => {\n  if (\"lstat\" in fs) {\n    fs.lstat(filename, callback);\n  } else {\n    fs.stat(filename, callback);\n  }\n};\n/**\n * @param {OutputFileSystem} fs filesystem\n * @param {string} outputPath output path\n * @param {boolean} dry only log instead of fs modification\n * @param {Logger} logger logger\n * @param {Set<string>} diff filenames of the assets that shouldn't be there\n * @param {function(string): boolean} isKept check if the entry is ignored\n * @param {function(Error=, Assets=): void} callback callback\n * @returns {void}\n */\n\n\nconst applyDiff = (fs, outputPath, dry, logger, diff, isKept, callback) => {\n  const log = msg => {\n    if (dry) {\n      logger.info(msg);\n    } else {\n      logger.log(msg);\n    }\n  };\n  /** @typedef {{ type: \"check\" | \"unlink\" | \"rmdir\", filename: string, parent: { remaining: number, job: Job } | undefined }} Job */\n\n  /** @type {Job[]} */\n\n\n  const jobs = Array.from(diff.keys(), filename => ({\n    type: \"check\",\n    filename,\n    parent: undefined\n  }));\n  /** @type {Assets} */\n\n  const keptAssets = new Map();\n  processAsyncTree(jobs, 10, (_ref, push, callback) => {\n    let {\n      type,\n      filename,\n      parent\n    } = _ref;\n\n    const handleError = err => {\n      if (err.code === \"ENOENT\") {\n        log(`${filename} was removed during cleaning by something else`);\n        handleParent();\n        return callback();\n      }\n\n      return callback(err);\n    };\n\n    const handleParent = () => {\n      if (parent && --parent.remaining === 0) push(parent.job);\n    };\n\n    const path = join(fs, outputPath, filename);\n\n    switch (type) {\n      case \"check\":\n        if (isKept(filename)) {\n          keptAssets.set(filename, 0); // do not decrement parent entry as we don't want to delete the parent\n\n          log(`${filename} will be kept`);\n          return process.nextTick(callback);\n        }\n\n        doStat(fs, path, (err, stats) => {\n          if (err) return handleError(err);\n\n          if (!stats.isDirectory()) {\n            push({\n              type: \"unlink\",\n              filename,\n              parent\n            });\n            return callback();\n          }\n\n          fs.readdir(path, (err, entries) => {\n            if (err) return handleError(err);\n            /** @type {Job} */\n\n            const deleteJob = {\n              type: \"rmdir\",\n              filename,\n              parent\n            };\n\n            if (entries.length === 0) {\n              push(deleteJob);\n            } else {\n              const parentToken = {\n                remaining: entries.length,\n                job: deleteJob\n              };\n\n              for (const entry of entries) {\n                const file =\n                /** @type {string} */\n                entry;\n\n                if (file.startsWith(\".\")) {\n                  log(`${filename} will be kept (dot-files will never be removed)`);\n                  continue;\n                }\n\n                push({\n                  type: \"check\",\n                  filename: `${filename}/${file}`,\n                  parent: parentToken\n                });\n              }\n            }\n\n            return callback();\n          });\n        });\n        break;\n\n      case \"rmdir\":\n        log(`${filename} will be removed`);\n\n        if (dry) {\n          handleParent();\n          return process.nextTick(callback);\n        }\n\n        if (!fs.rmdir) {\n          logger.warn(`${filename} can't be removed because output file system doesn't support removing directories (rmdir)`);\n          return process.nextTick(callback);\n        }\n\n        fs.rmdir(path, err => {\n          if (err) return handleError(err);\n          handleParent();\n          callback();\n        });\n        break;\n\n      case \"unlink\":\n        log(`${filename} will be removed`);\n\n        if (dry) {\n          handleParent();\n          return process.nextTick(callback);\n        }\n\n        if (!fs.unlink) {\n          logger.warn(`${filename} can't be removed because output file system doesn't support removing files (rmdir)`);\n          return process.nextTick(callback);\n        }\n\n        fs.unlink(path, err => {\n          if (err) return handleError(err);\n          handleParent();\n          callback();\n        });\n        break;\n    }\n  }, err => {\n    if (err) return callback(err);\n    callback(undefined, keptAssets);\n  });\n};\n/** @type {WeakMap<Compilation, CleanPluginCompilationHooks>} */\n\n\nconst compilationHooksMap = new WeakMap();\n\nclass CleanPlugin {\n  /**\n   * @param {Compilation} compilation the compilation\n   * @returns {CleanPluginCompilationHooks} the attached hooks\n   */\n  static getCompilationHooks(compilation) {\n    if (!(compilation instanceof Compilation)) {\n      throw new TypeError(\"The 'compilation' argument must be an instance of Compilation\");\n    }\n\n    let hooks = compilationHooksMap.get(compilation);\n\n    if (hooks === undefined) {\n      hooks = {\n        /** @type {SyncBailHook<[string], boolean>} */\n        keep: new SyncBailHook([\"ignore\"])\n      };\n      compilationHooksMap.set(compilation, hooks);\n    }\n\n    return hooks;\n  }\n  /** @param {CleanOptions} options options */\n\n\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    validate(options);\n    this.options = {\n      dry: false,\n      ...options\n    };\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const {\n      dry,\n      keep\n    } = this.options;\n    const keepFn = typeof keep === \"function\" ? keep : typeof keep === \"string\" ? path => path.startsWith(keep) : typeof keep === \"object\" && keep.test ? path => keep.test(path) : () => false; // We assume that no external modification happens while the compiler is active\n    // So we can store the old assets and only diff to them to avoid fs access on\n    // incremental builds\n\n    /** @type {undefined|Assets} */\n\n    let oldAssets;\n    compiler.hooks.emit.tapAsync({\n      name: \"CleanPlugin\",\n      stage: 100\n    }, (compilation, callback) => {\n      const hooks = CleanPlugin.getCompilationHooks(compilation);\n      const logger = compilation.getLogger(\"webpack.CleanPlugin\");\n      const fs = compiler.outputFileSystem;\n\n      if (!fs.readdir) {\n        return callback(new Error(\"CleanPlugin: Output filesystem doesn't support listing directories (readdir)\"));\n      }\n      /** @type {Assets} */\n\n\n      const currentAssets = new Map();\n      const now = Date.now();\n\n      for (const asset of Object.keys(compilation.assets)) {\n        if (/^[A-Za-z]:\\\\|^\\/|^\\\\\\\\/.test(asset)) continue;\n        let normalizedAsset;\n        let newNormalizedAsset = asset.replace(/\\\\/g, \"/\");\n\n        do {\n          normalizedAsset = newNormalizedAsset;\n          newNormalizedAsset = normalizedAsset.replace(/(^|\\/)(?!\\.\\.)[^/]+\\/\\.\\.\\//g, \"$1\");\n        } while (newNormalizedAsset !== normalizedAsset);\n\n        if (normalizedAsset.startsWith(\"../\")) continue;\n        const assetInfo = compilation.assetsInfo.get(asset);\n\n        if (assetInfo && assetInfo.hotModuleReplacement) {\n          currentAssets.set(normalizedAsset, now + _10sec);\n        } else {\n          currentAssets.set(normalizedAsset, 0);\n        }\n      }\n\n      const outputPath = compilation.getPath(compiler.outputPath, {});\n\n      const isKept = path => {\n        const result = hooks.keep.call(path);\n        if (result !== undefined) return result;\n        return keepFn(path);\n      };\n      /**\n       * @param {Error=} err err\n       * @param {Set<string>=} diff diff\n       */\n\n\n      const diffCallback = (err, diff) => {\n        if (err) {\n          oldAssets = undefined;\n          callback(err);\n          return;\n        }\n\n        applyDiff(fs, outputPath, dry, logger, diff, isKept, (err, keptAssets) => {\n          if (err) {\n            oldAssets = undefined;\n          } else {\n            if (oldAssets) mergeAssets(currentAssets, oldAssets);\n            oldAssets = currentAssets;\n            if (keptAssets) mergeAssets(oldAssets, keptAssets);\n          }\n\n          callback(err);\n        });\n      };\n\n      if (oldAssets) {\n        diffCallback(null, getDiffToOldAssets(currentAssets, oldAssets));\n      } else {\n        getDiffToFs(fs, outputPath, currentAssets, diffCallback);\n      }\n    });\n  }\n\n}\n\nmodule.exports = CleanPlugin;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/CleanPlugin.js"],"names":["asyncLib","require","SyncBailHook","Compilation","createSchemaValidation","join","processAsyncTree","validate","undefined","definitions","oneOf","$ref","name","baseDataPath","_10sec","mergeAssets","as1","as2","key","value1","value2","get","set","getDiffToFs","fs","outputPath","currentAssets","callback","directories","Set","asset","add","replace","directory","diff","forEachLimit","readdir","err","entries","code","entry","file","filename","has","getDiffToOldAssets","oldAssets","now","Date","ts","doStat","lstat","stat","applyDiff","dry","logger","isKept","log","msg","info","jobs","Array","from","keys","type","parent","keptAssets","Map","push","handleError","handleParent","remaining","job","path","process","nextTick","stats","isDirectory","deleteJob","length","parentToken","startsWith","rmdir","warn","unlink","compilationHooksMap","WeakMap","CleanPlugin","getCompilationHooks","compilation","TypeError","hooks","keep","constructor","options","apply","compiler","keepFn","test","emit","tapAsync","stage","getLogger","outputFileSystem","Error","Object","assets","normalizedAsset","newNormalizedAsset","assetInfo","assetsInfo","hotModuleReplacement","getPath","result","call","diffCallback","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Sergey Melyukov @smelukov\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst { SyncBailHook } = require(\"tapable\");\nconst Compilation = require(\"../lib/Compilation\");\nconst createSchemaValidation = require(\"./util/create-schema-validation\");\nconst { join } = require(\"./util/fs\");\nconst processAsyncTree = require(\"./util/processAsyncTree\");\n\n/** @typedef {import(\"../declarations/WebpackOptions\").CleanOptions} CleanOptions */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n/** @typedef {import(\"./util/fs\").StatsCallback} StatsCallback */\n\n/** @typedef {(function(string):boolean)|RegExp} IgnoreItem */\n/** @typedef {Map<string, number>} Assets */\n/** @typedef {function(IgnoreItem): void} AddToIgnoreCallback */\n\n/**\n * @typedef {Object} CleanPluginCompilationHooks\n * @property {SyncBailHook<[string], boolean>} keep when returning true the file/directory will be kept during cleaning, returning false will clean it and ignore the following plugins and config\n */\n\nconst validate = createSchemaValidation(\n\tundefined,\n\t() => {\n\t\tconst { definitions } = require(\"../schemas/WebpackOptions.json\");\n\t\treturn {\n\t\t\tdefinitions,\n\t\t\toneOf: [{ $ref: \"#/definitions/CleanOptions\" }]\n\t\t};\n\t},\n\t{\n\t\tname: \"Clean Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\nconst _10sec = 10 * 1000;\n\n/**\n * marge assets map 2 into map 1\n * @param {Assets} as1 assets\n * @param {Assets} as2 assets\n * @returns {void}\n */\nconst mergeAssets = (as1, as2) => {\n\tfor (const [key, value1] of as2) {\n\t\tconst value2 = as1.get(key);\n\t\tif (!value2 || value1 > value2) as1.set(key, value1);\n\t}\n};\n\n/**\n * @param {OutputFileSystem} fs filesystem\n * @param {string} outputPath output path\n * @param {Map<string, number>} currentAssets filename of the current assets (must not start with .. or ., must only use / as path separator)\n * @param {function((Error | null)=, Set<string>=): void} callback returns the filenames of the assets that shouldn't be there\n * @returns {void}\n */\nconst getDiffToFs = (fs, outputPath, currentAssets, callback) => {\n\tconst directories = new Set();\n\t// get directories of assets\n\tfor (const [asset] of currentAssets) {\n\t\tdirectories.add(asset.replace(/(^|\\/)[^/]*$/, \"\"));\n\t}\n\t// and all parent directories\n\tfor (const directory of directories) {\n\t\tdirectories.add(directory.replace(/(^|\\/)[^/]*$/, \"\"));\n\t}\n\tconst diff = new Set();\n\tasyncLib.forEachLimit(\n\t\tdirectories,\n\t\t10,\n\t\t(directory, callback) => {\n\t\t\tfs.readdir(join(fs, outputPath, directory), (err, entries) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tif (err.code === \"ENOENT\") return callback();\n\t\t\t\t\tif (err.code === \"ENOTDIR\") {\n\t\t\t\t\t\tdiff.add(directory);\n\t\t\t\t\t\treturn callback();\n\t\t\t\t\t}\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\t\t\t\tfor (const entry of entries) {\n\t\t\t\t\tconst file = /** @type {string} */ (entry);\n\t\t\t\t\tconst filename = directory ? `${directory}/${file}` : file;\n\t\t\t\t\tif (!directories.has(filename) && !currentAssets.has(filename)) {\n\t\t\t\t\t\tdiff.add(filename);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcallback();\n\t\t\t});\n\t\t},\n\t\terr => {\n\t\t\tif (err) return callback(err);\n\n\t\t\tcallback(null, diff);\n\t\t}\n\t);\n};\n\n/**\n * @param {Assets} currentAssets assets list\n * @param {Assets} oldAssets old assets list\n * @returns {Set<string>} diff\n */\nconst getDiffToOldAssets = (currentAssets, oldAssets) => {\n\tconst diff = new Set();\n\tconst now = Date.now();\n\tfor (const [asset, ts] of oldAssets) {\n\t\tif (ts >= now) continue;\n\t\tif (!currentAssets.has(asset)) diff.add(asset);\n\t}\n\treturn diff;\n};\n\n/**\n * @param {OutputFileSystem} fs filesystem\n * @param {string} filename path to file\n * @param {StatsCallback} callback callback for provided filename\n * @returns {void}\n */\nconst doStat = (fs, filename, callback) => {\n\tif (\"lstat\" in fs) {\n\t\tfs.lstat(filename, callback);\n\t} else {\n\t\tfs.stat(filename, callback);\n\t}\n};\n\n/**\n * @param {OutputFileSystem} fs filesystem\n * @param {string} outputPath output path\n * @param {boolean} dry only log instead of fs modification\n * @param {Logger} logger logger\n * @param {Set<string>} diff filenames of the assets that shouldn't be there\n * @param {function(string): boolean} isKept check if the entry is ignored\n * @param {function(Error=, Assets=): void} callback callback\n * @returns {void}\n */\nconst applyDiff = (fs, outputPath, dry, logger, diff, isKept, callback) => {\n\tconst log = msg => {\n\t\tif (dry) {\n\t\t\tlogger.info(msg);\n\t\t} else {\n\t\t\tlogger.log(msg);\n\t\t}\n\t};\n\t/** @typedef {{ type: \"check\" | \"unlink\" | \"rmdir\", filename: string, parent: { remaining: number, job: Job } | undefined }} Job */\n\t/** @type {Job[]} */\n\tconst jobs = Array.from(diff.keys(), filename => ({\n\t\ttype: \"check\",\n\t\tfilename,\n\t\tparent: undefined\n\t}));\n\t/** @type {Assets} */\n\tconst keptAssets = new Map();\n\tprocessAsyncTree(\n\t\tjobs,\n\t\t10,\n\t\t({ type, filename, parent }, push, callback) => {\n\t\t\tconst handleError = err => {\n\t\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\t\tlog(`${filename} was removed during cleaning by something else`);\n\t\t\t\t\thandleParent();\n\t\t\t\t\treturn callback();\n\t\t\t\t}\n\t\t\t\treturn callback(err);\n\t\t\t};\n\t\t\tconst handleParent = () => {\n\t\t\t\tif (parent && --parent.remaining === 0) push(parent.job);\n\t\t\t};\n\t\t\tconst path = join(fs, outputPath, filename);\n\t\t\tswitch (type) {\n\t\t\t\tcase \"check\":\n\t\t\t\t\tif (isKept(filename)) {\n\t\t\t\t\t\tkeptAssets.set(filename, 0);\n\t\t\t\t\t\t// do not decrement parent entry as we don't want to delete the parent\n\t\t\t\t\t\tlog(`${filename} will be kept`);\n\t\t\t\t\t\treturn process.nextTick(callback);\n\t\t\t\t\t}\n\t\t\t\t\tdoStat(fs, path, (err, stats) => {\n\t\t\t\t\t\tif (err) return handleError(err);\n\t\t\t\t\t\tif (!stats.isDirectory()) {\n\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\ttype: \"unlink\",\n\t\t\t\t\t\t\t\tfilename,\n\t\t\t\t\t\t\t\tparent\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfs.readdir(path, (err, entries) => {\n\t\t\t\t\t\t\tif (err) return handleError(err);\n\t\t\t\t\t\t\t/** @type {Job} */\n\t\t\t\t\t\t\tconst deleteJob = {\n\t\t\t\t\t\t\t\ttype: \"rmdir\",\n\t\t\t\t\t\t\t\tfilename,\n\t\t\t\t\t\t\t\tparent\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (entries.length === 0) {\n\t\t\t\t\t\t\t\tpush(deleteJob);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst parentToken = {\n\t\t\t\t\t\t\t\t\tremaining: entries.length,\n\t\t\t\t\t\t\t\t\tjob: deleteJob\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tfor (const entry of entries) {\n\t\t\t\t\t\t\t\t\tconst file = /** @type {string} */ (entry);\n\t\t\t\t\t\t\t\t\tif (file.startsWith(\".\")) {\n\t\t\t\t\t\t\t\t\t\tlog(\n\t\t\t\t\t\t\t\t\t\t\t`${filename} will be kept (dot-files will never be removed)`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\t\ttype: \"check\",\n\t\t\t\t\t\t\t\t\t\tfilename: `${filename}/${file}`,\n\t\t\t\t\t\t\t\t\t\tparent: parentToken\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"rmdir\":\n\t\t\t\t\tlog(`${filename} will be removed`);\n\t\t\t\t\tif (dry) {\n\t\t\t\t\t\thandleParent();\n\t\t\t\t\t\treturn process.nextTick(callback);\n\t\t\t\t\t}\n\t\t\t\t\tif (!fs.rmdir) {\n\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t`${filename} can't be removed because output file system doesn't support removing directories (rmdir)`\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn process.nextTick(callback);\n\t\t\t\t\t}\n\t\t\t\t\tfs.rmdir(path, err => {\n\t\t\t\t\t\tif (err) return handleError(err);\n\t\t\t\t\t\thandleParent();\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"unlink\":\n\t\t\t\t\tlog(`${filename} will be removed`);\n\t\t\t\t\tif (dry) {\n\t\t\t\t\t\thandleParent();\n\t\t\t\t\t\treturn process.nextTick(callback);\n\t\t\t\t\t}\n\t\t\t\t\tif (!fs.unlink) {\n\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t`${filename} can't be removed because output file system doesn't support removing files (rmdir)`\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn process.nextTick(callback);\n\t\t\t\t\t}\n\t\t\t\t\tfs.unlink(path, err => {\n\t\t\t\t\t\tif (err) return handleError(err);\n\t\t\t\t\t\thandleParent();\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t},\n\t\terr => {\n\t\t\tif (err) return callback(err);\n\t\t\tcallback(undefined, keptAssets);\n\t\t}\n\t);\n};\n\n/** @type {WeakMap<Compilation, CleanPluginCompilationHooks>} */\nconst compilationHooksMap = new WeakMap();\n\nclass CleanPlugin {\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @returns {CleanPluginCompilationHooks} the attached hooks\n\t */\n\tstatic getCompilationHooks(compilation) {\n\t\tif (!(compilation instanceof Compilation)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t\"The 'compilation' argument must be an instance of Compilation\"\n\t\t\t);\n\t\t}\n\t\tlet hooks = compilationHooksMap.get(compilation);\n\t\tif (hooks === undefined) {\n\t\t\thooks = {\n\t\t\t\t/** @type {SyncBailHook<[string], boolean>} */\n\t\t\t\tkeep: new SyncBailHook([\"ignore\"])\n\t\t\t};\n\t\t\tcompilationHooksMap.set(compilation, hooks);\n\t\t}\n\t\treturn hooks;\n\t}\n\n\t/** @param {CleanOptions} options options */\n\tconstructor(options = {}) {\n\t\tvalidate(options);\n\t\tthis.options = { dry: false, ...options };\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst { dry, keep } = this.options;\n\n\t\tconst keepFn =\n\t\t\ttypeof keep === \"function\"\n\t\t\t\t? keep\n\t\t\t\t: typeof keep === \"string\"\n\t\t\t\t? path => path.startsWith(keep)\n\t\t\t\t: typeof keep === \"object\" && keep.test\n\t\t\t\t? path => keep.test(path)\n\t\t\t\t: () => false;\n\n\t\t// We assume that no external modification happens while the compiler is active\n\t\t// So we can store the old assets and only diff to them to avoid fs access on\n\t\t// incremental builds\n\t\t/** @type {undefined|Assets} */\n\t\tlet oldAssets;\n\n\t\tcompiler.hooks.emit.tapAsync(\n\t\t\t{\n\t\t\t\tname: \"CleanPlugin\",\n\t\t\t\tstage: 100\n\t\t\t},\n\t\t\t(compilation, callback) => {\n\t\t\t\tconst hooks = CleanPlugin.getCompilationHooks(compilation);\n\t\t\t\tconst logger = compilation.getLogger(\"webpack.CleanPlugin\");\n\t\t\t\tconst fs = compiler.outputFileSystem;\n\n\t\t\t\tif (!fs.readdir) {\n\t\t\t\t\treturn callback(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\"CleanPlugin: Output filesystem doesn't support listing directories (readdir)\"\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t/** @type {Assets} */\n\t\t\t\tconst currentAssets = new Map();\n\t\t\t\tconst now = Date.now();\n\t\t\t\tfor (const asset of Object.keys(compilation.assets)) {\n\t\t\t\t\tif (/^[A-Za-z]:\\\\|^\\/|^\\\\\\\\/.test(asset)) continue;\n\t\t\t\t\tlet normalizedAsset;\n\t\t\t\t\tlet newNormalizedAsset = asset.replace(/\\\\/g, \"/\");\n\t\t\t\t\tdo {\n\t\t\t\t\t\tnormalizedAsset = newNormalizedAsset;\n\t\t\t\t\t\tnewNormalizedAsset = normalizedAsset.replace(\n\t\t\t\t\t\t\t/(^|\\/)(?!\\.\\.)[^/]+\\/\\.\\.\\//g,\n\t\t\t\t\t\t\t\"$1\"\n\t\t\t\t\t\t);\n\t\t\t\t\t} while (newNormalizedAsset !== normalizedAsset);\n\t\t\t\t\tif (normalizedAsset.startsWith(\"../\")) continue;\n\t\t\t\t\tconst assetInfo = compilation.assetsInfo.get(asset);\n\t\t\t\t\tif (assetInfo && assetInfo.hotModuleReplacement) {\n\t\t\t\t\t\tcurrentAssets.set(normalizedAsset, now + _10sec);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentAssets.set(normalizedAsset, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst outputPath = compilation.getPath(compiler.outputPath, {});\n\n\t\t\t\tconst isKept = path => {\n\t\t\t\t\tconst result = hooks.keep.call(path);\n\t\t\t\t\tif (result !== undefined) return result;\n\t\t\t\t\treturn keepFn(path);\n\t\t\t\t};\n\n\t\t\t\t/**\n\t\t\t\t * @param {Error=} err err\n\t\t\t\t * @param {Set<string>=} diff diff\n\t\t\t\t */\n\t\t\t\tconst diffCallback = (err, diff) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\toldAssets = undefined;\n\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tapplyDiff(\n\t\t\t\t\t\tfs,\n\t\t\t\t\t\toutputPath,\n\t\t\t\t\t\tdry,\n\t\t\t\t\t\tlogger,\n\t\t\t\t\t\tdiff,\n\t\t\t\t\t\tisKept,\n\t\t\t\t\t\t(err, keptAssets) => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\toldAssets = undefined;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (oldAssets) mergeAssets(currentAssets, oldAssets);\n\t\t\t\t\t\t\t\toldAssets = currentAssets;\n\t\t\t\t\t\t\t\tif (keptAssets) mergeAssets(oldAssets, keptAssets);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t};\n\n\t\t\t\tif (oldAssets) {\n\t\t\t\t\tdiffCallback(null, getDiffToOldAssets(currentAssets, oldAssets));\n\t\t\t\t} else {\n\t\t\t\t\tgetDiffToFs(fs, outputPath, currentAssets, diffCallback);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = CleanPlugin;\n"]},"metadata":{},"sourceType":"script"}