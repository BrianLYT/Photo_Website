{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Chunk = require(\"../Chunk\");\n\nconst {\n  STAGE_ADVANCED\n} = require(\"../OptimizationStages\");\n\nconst WebpackError = require(\"../WebpackError\");\n\nconst {\n  requestToId\n} = require(\"../ids/IdHelpers\");\n\nconst {\n  isSubset\n} = require(\"../util/SetHelpers\");\n\nconst SortableSet = require(\"../util/SortableSet\");\n\nconst {\n  compareModulesByIdentifier,\n  compareIterables\n} = require(\"../util/comparators\");\n\nconst createHash = require(\"../util/createHash\");\n\nconst deterministicGrouping = require(\"../util/deterministicGrouping\");\n\nconst {\n  makePathsRelative\n} = require(\"../util/identifier\");\n\nconst memoize = require(\"../util/memoize\");\n\nconst MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksCacheGroup} OptimizationSplitChunksCacheGroup */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksGetCacheGroups} OptimizationSplitChunksGetCacheGroups */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksOptions} OptimizationSplitChunksOptions */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksSizes} OptimizationSplitChunksSizes */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").Output} OutputOptions */\n\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n\n/** @typedef {import(\"../Compilation\").PathData} PathData */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n\n/** @typedef {Record<string, number>} SplitChunksSizes */\n\n/**\n * @callback ChunkFilterFunction\n * @param {Chunk} chunk\n * @returns {boolean}\n */\n\n/**\n * @callback CombineSizeFunction\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\n\n/**\n * @typedef {Object} CacheGroupSource\n * @property {string=} key\n * @property {number=} priority\n * @property {GetName=} getName\n * @property {ChunkFilterFunction=} chunksFilter\n * @property {boolean=} enforce\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {number=} minChunks\n * @property {number=} maxAsyncRequests\n * @property {number=} maxInitialRequests\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\n * @property {string=} idHint\n * @property {string} automaticNameDelimiter\n * @property {boolean=} reuseExistingChunk\n * @property {boolean=} usedExports\n */\n\n/**\n * @typedef {Object} CacheGroup\n * @property {string} key\n * @property {number=} priority\n * @property {GetName=} getName\n * @property {ChunkFilterFunction=} chunksFilter\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {number=} minChunks\n * @property {number=} maxAsyncRequests\n * @property {number=} maxInitialRequests\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\n * @property {string=} idHint\n * @property {string} automaticNameDelimiter\n * @property {boolean} reuseExistingChunk\n * @property {boolean} usedExports\n * @property {boolean} _validateSize\n * @property {boolean} _validateRemainingSize\n * @property {SplitChunksSizes} _minSizeForMaxSize\n * @property {boolean} _conditionalEnforce\n */\n\n/**\n * @typedef {Object} FallbackCacheGroup\n * @property {ChunkFilterFunction} chunksFilter\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {string} automaticNameDelimiter\n */\n\n/**\n * @typedef {Object} CacheGroupsContext\n * @property {ModuleGraph} moduleGraph\n * @property {ChunkGraph} chunkGraph\n */\n\n/**\n * @callback GetCacheGroups\n * @param {Module} module\n * @param {CacheGroupsContext} context\n * @returns {CacheGroupSource[]}\n */\n\n/**\n * @callback GetName\n * @param {Module=} module\n * @param {Chunk[]=} chunks\n * @param {string=} key\n * @returns {string=}\n */\n\n/**\n * @typedef {Object} SplitChunksOptions\n * @property {ChunkFilterFunction} chunksFilter\n * @property {string[]} defaultSizeTypes\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxInitialSize\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {number} minChunks\n * @property {number} maxAsyncRequests\n * @property {number} maxInitialRequests\n * @property {boolean} hidePathInfo\n * @property {string | function(PathData, AssetInfo=): string} filename\n * @property {string} automaticNameDelimiter\n * @property {GetCacheGroups} getCacheGroups\n * @property {GetName} getName\n * @property {boolean} usedExports\n * @property {FallbackCacheGroup} fallbackCacheGroup\n */\n\n/**\n * @typedef {Object} ChunksInfoItem\n * @property {SortableSet<Module>} modules\n * @property {CacheGroup} cacheGroup\n * @property {number} cacheGroupIndex\n * @property {string} name\n * @property {Record<string, number>} sizes\n * @property {Set<Chunk>} chunks\n * @property {Set<Chunk>} reuseableChunks\n * @property {Set<bigint | Chunk>} chunksKeys\n */\n\n\nconst defaultGetName =\n/** @type {GetName} */\n() => {};\n\nconst deterministicGroupingForModules =\n/** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */\ndeterministicGrouping;\n/** @type {WeakMap<Module, string>} */\n\nconst getKeyCache = new WeakMap();\n/**\n * @param {string} name a filename to hash\n * @param {OutputOptions} outputOptions hash function used\n * @returns {string} hashed filename\n */\n\nconst hashFilename = (name, outputOptions) => {\n  const digest =\n  /** @type {string} */\n  createHash(outputOptions.hashFunction).update(name).digest(outputOptions.hashDigest);\n  return digest.slice(0, 8);\n};\n/**\n * @param {Chunk} chunk the chunk\n * @returns {number} the number of requests\n */\n\n\nconst getRequests = chunk => {\n  let requests = 0;\n\n  for (const chunkGroup of chunk.groupsIterable) {\n    requests = Math.max(requests, chunkGroup.chunks.length);\n  }\n\n  return requests;\n};\n\nconst mapObject = (obj, fn) => {\n  const newObj = Object.create(null);\n\n  for (const key of Object.keys(obj)) {\n    newObj[key] = fn(obj[key], key);\n  }\n\n  return newObj;\n};\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\n\n\nconst isOverlap = (a, b) => {\n  for (const item of a) {\n    if (b.has(item)) return true;\n  }\n\n  return false;\n};\n\nconst compareModuleIterables = compareIterables(compareModulesByIdentifier);\n/**\n * @param {ChunksInfoItem} a item\n * @param {ChunksInfoItem} b item\n * @returns {number} compare result\n */\n\nconst compareEntries = (a, b) => {\n  // 1. by priority\n  const diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n  if (diffPriority) return diffPriority; // 2. by number of chunks\n\n  const diffCount = a.chunks.size - b.chunks.size;\n  if (diffCount) return diffCount; // 3. by size reduction\n\n  const aSizeReduce = totalSize(a.sizes) * (a.chunks.size - 1);\n  const bSizeReduce = totalSize(b.sizes) * (b.chunks.size - 1);\n  const diffSizeReduce = aSizeReduce - bSizeReduce;\n  if (diffSizeReduce) return diffSizeReduce; // 4. by cache group index\n\n  const indexDiff = b.cacheGroupIndex - a.cacheGroupIndex;\n  if (indexDiff) return indexDiff; // 5. by number of modules (to be able to compare by identifier)\n\n  const modulesA = a.modules;\n  const modulesB = b.modules;\n  const diff = modulesA.size - modulesB.size;\n  if (diff) return diff; // 6. by module identifiers\n\n  modulesA.sort();\n  modulesB.sort();\n  return compareModuleIterables(modulesA, modulesB);\n};\n\nconst INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial();\n\nconst ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial();\n\nconst ALL_CHUNK_FILTER = chunk => true;\n/**\n * @param {OptimizationSplitChunksSizes} value the sizes\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {SplitChunksSizes} normalized representation\n */\n\n\nconst normalizeSizes = (value, defaultSizeTypes) => {\n  if (typeof value === \"number\") {\n    /** @type {Record<string, number>} */\n    const o = {};\n\n    for (const sizeType of defaultSizeTypes) o[sizeType] = value;\n\n    return o;\n  } else if (typeof value === \"object\" && value !== null) {\n    return { ...value\n    };\n  } else {\n    return {};\n  }\n};\n/**\n * @param {...SplitChunksSizes} sizes the sizes\n * @returns {SplitChunksSizes} the merged sizes\n */\n\n\nconst mergeSizes = function () {\n  /** @type {SplitChunksSizes} */\n  let merged = {};\n\n  for (let i = arguments.length - 1; i >= 0; i--) {\n    merged = Object.assign(merged, i < 0 || arguments.length <= i ? undefined : arguments[i]);\n  }\n\n  return merged;\n};\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @returns {boolean} true, if there are sizes > 0\n */\n\n\nconst hasNonZeroSizes = sizes => {\n  for (const key of Object.keys(sizes)) {\n    if (sizes[key] > 0) return true;\n  }\n\n  return false;\n};\n/**\n * @param {SplitChunksSizes} a first sizes\n * @param {SplitChunksSizes} b second sizes\n * @param {CombineSizeFunction} combine a function to combine sizes\n * @returns {SplitChunksSizes} the combine sizes\n */\n\n\nconst combineSizes = (a, b, combine) => {\n  const aKeys = new Set(Object.keys(a));\n  const bKeys = new Set(Object.keys(b));\n  /** @type {SplitChunksSizes} */\n\n  const result = {};\n\n  for (const key of aKeys) {\n    if (bKeys.has(key)) {\n      result[key] = combine(a[key], b[key]);\n    } else {\n      result[key] = a[key];\n    }\n  }\n\n  for (const key of bKeys) {\n    if (!aKeys.has(key)) {\n      result[key] = b[key];\n    }\n  }\n\n  return result;\n};\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSize the min sizes\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSize`\n */\n\n\nconst checkMinSize = (sizes, minSize) => {\n  for (const key of Object.keys(minSize)) {\n    const size = sizes[key];\n    if (size === undefined || size === 0) continue;\n    if (size < minSize[key]) return false;\n  }\n\n  return true;\n};\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSizeReduction the min sizes\n * @param {number} chunkCount number of chunks\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSizeReduction`\n */\n\n\nconst checkMinSizeReduction = (sizes, minSizeReduction, chunkCount) => {\n  for (const key of Object.keys(minSizeReduction)) {\n    const size = sizes[key];\n    if (size === undefined || size === 0) continue;\n    if (size * chunkCount < minSizeReduction[key]) return false;\n  }\n\n  return true;\n};\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSize the min sizes\n * @returns {undefined | string[]} list of size types that are below min size\n */\n\n\nconst getViolatingMinSizes = (sizes, minSize) => {\n  let list;\n\n  for (const key of Object.keys(minSize)) {\n    const size = sizes[key];\n    if (size === undefined || size === 0) continue;\n\n    if (size < minSize[key]) {\n      if (list === undefined) list = [key];else list.push(key);\n    }\n  }\n\n  return list;\n};\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @returns {number} the total size\n */\n\n\nconst totalSize = sizes => {\n  let size = 0;\n\n  for (const key of Object.keys(sizes)) {\n    size += sizes[key];\n  }\n\n  return size;\n};\n/**\n * @param {false|string|Function} name the chunk name\n * @returns {GetName} a function to get the name of the chunk\n */\n\n\nconst normalizeName = name => {\n  if (typeof name === \"string\") {\n    return () => name;\n  }\n\n  if (typeof name === \"function\") {\n    return (\n      /** @type {GetName} */\n      name\n    );\n  }\n};\n/**\n * @param {OptimizationSplitChunksCacheGroup[\"chunks\"]} chunks the chunk filter option\n * @returns {ChunkFilterFunction} the chunk filter function\n */\n\n\nconst normalizeChunksFilter = chunks => {\n  if (chunks === \"initial\") {\n    return INITIAL_CHUNK_FILTER;\n  }\n\n  if (chunks === \"async\") {\n    return ASYNC_CHUNK_FILTER;\n  }\n\n  if (chunks === \"all\") {\n    return ALL_CHUNK_FILTER;\n  }\n\n  if (typeof chunks === \"function\") {\n    return chunks;\n  }\n};\n/**\n * @param {GetCacheGroups | Record<string, false|string|RegExp|OptimizationSplitChunksGetCacheGroups|OptimizationSplitChunksCacheGroup>} cacheGroups the cache group options\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {GetCacheGroups} a function to get the cache groups\n */\n\n\nconst normalizeCacheGroups = (cacheGroups, defaultSizeTypes) => {\n  if (typeof cacheGroups === \"function\") {\n    return cacheGroups;\n  }\n\n  if (typeof cacheGroups === \"object\" && cacheGroups !== null) {\n    /** @type {(function(Module, CacheGroupsContext, CacheGroupSource[]): void)[]} */\n    const handlers = [];\n\n    for (const key of Object.keys(cacheGroups)) {\n      const option = cacheGroups[key];\n\n      if (option === false) {\n        continue;\n      }\n\n      if (typeof option === \"string\" || option instanceof RegExp) {\n        const source = createCacheGroupSource({}, key, defaultSizeTypes);\n        handlers.push((module, context, results) => {\n          if (checkTest(option, module, context)) {\n            results.push(source);\n          }\n        });\n      } else if (typeof option === \"function\") {\n        const cache = new WeakMap();\n        handlers.push((module, context, results) => {\n          const result = option(module);\n\n          if (result) {\n            const groups = Array.isArray(result) ? result : [result];\n\n            for (const group of groups) {\n              const cachedSource = cache.get(group);\n\n              if (cachedSource !== undefined) {\n                results.push(cachedSource);\n              } else {\n                const source = createCacheGroupSource(group, key, defaultSizeTypes);\n                cache.set(group, source);\n                results.push(source);\n              }\n            }\n          }\n        });\n      } else {\n        const source = createCacheGroupSource(option, key, defaultSizeTypes);\n        handlers.push((module, context, results) => {\n          if (checkTest(option.test, module, context) && checkModuleType(option.type, module) && checkModuleLayer(option.layer, module)) {\n            results.push(source);\n          }\n        });\n      }\n    }\n    /**\n     * @param {Module} module the current module\n     * @param {CacheGroupsContext} context the current context\n     * @returns {CacheGroupSource[]} the matching cache groups\n     */\n\n\n    const fn = (module, context) => {\n      /** @type {CacheGroupSource[]} */\n      let results = [];\n\n      for (const fn of handlers) {\n        fn(module, context, results);\n      }\n\n      return results;\n    };\n\n    return fn;\n  }\n\n  return () => null;\n};\n/**\n * @param {undefined|boolean|string|RegExp|Function} test test option\n * @param {Module} module the module\n * @param {CacheGroupsContext} context context object\n * @returns {boolean} true, if the module should be selected\n */\n\n\nconst checkTest = (test, module, context) => {\n  if (test === undefined) return true;\n\n  if (typeof test === \"function\") {\n    return test(module, context);\n  }\n\n  if (typeof test === \"boolean\") return test;\n\n  if (typeof test === \"string\") {\n    const name = module.nameForCondition();\n    return name && name.startsWith(test);\n  }\n\n  if (test instanceof RegExp) {\n    const name = module.nameForCondition();\n    return name && test.test(name);\n  }\n\n  return false;\n};\n/**\n * @param {undefined|string|RegExp|Function} test type option\n * @param {Module} module the module\n * @returns {boolean} true, if the module should be selected\n */\n\n\nconst checkModuleType = (test, module) => {\n  if (test === undefined) return true;\n\n  if (typeof test === \"function\") {\n    return test(module.type);\n  }\n\n  if (typeof test === \"string\") {\n    const type = module.type;\n    return test === type;\n  }\n\n  if (test instanceof RegExp) {\n    const type = module.type;\n    return test.test(type);\n  }\n\n  return false;\n};\n/**\n * @param {undefined|string|RegExp|Function} test type option\n * @param {Module} module the module\n * @returns {boolean} true, if the module should be selected\n */\n\n\nconst checkModuleLayer = (test, module) => {\n  if (test === undefined) return true;\n\n  if (typeof test === \"function\") {\n    return test(module.layer);\n  }\n\n  if (typeof test === \"string\") {\n    const layer = module.layer;\n    return test === \"\" ? !layer : layer && layer.startsWith(test);\n  }\n\n  if (test instanceof RegExp) {\n    const layer = module.layer;\n    return test.test(layer);\n  }\n\n  return false;\n};\n/**\n * @param {OptimizationSplitChunksCacheGroup} options the group options\n * @param {string} key key of cache group\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {CacheGroupSource} the normalized cached group\n */\n\n\nconst createCacheGroupSource = (options, key, defaultSizeTypes) => {\n  const minSize = normalizeSizes(options.minSize, defaultSizeTypes);\n  const minSizeReduction = normalizeSizes(options.minSizeReduction, defaultSizeTypes);\n  const maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\n  return {\n    key,\n    priority: options.priority,\n    getName: normalizeName(options.name),\n    chunksFilter: normalizeChunksFilter(options.chunks),\n    enforce: options.enforce,\n    minSize,\n    minSizeReduction,\n    minRemainingSize: mergeSizes(normalizeSizes(options.minRemainingSize, defaultSizeTypes), minSize),\n    enforceSizeThreshold: normalizeSizes(options.enforceSizeThreshold, defaultSizeTypes),\n    maxAsyncSize: mergeSizes(normalizeSizes(options.maxAsyncSize, defaultSizeTypes), maxSize),\n    maxInitialSize: mergeSizes(normalizeSizes(options.maxInitialSize, defaultSizeTypes), maxSize),\n    minChunks: options.minChunks,\n    maxAsyncRequests: options.maxAsyncRequests,\n    maxInitialRequests: options.maxInitialRequests,\n    filename: options.filename,\n    idHint: options.idHint,\n    automaticNameDelimiter: options.automaticNameDelimiter,\n    reuseExistingChunk: options.reuseExistingChunk,\n    usedExports: options.usedExports\n  };\n};\n\nmodule.exports = class SplitChunksPlugin {\n  /**\n   * @param {OptimizationSplitChunksOptions=} options plugin options\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const defaultSizeTypes = options.defaultSizeTypes || [\"javascript\", \"unknown\"];\n    const fallbackCacheGroup = options.fallbackCacheGroup || {};\n    const minSize = normalizeSizes(options.minSize, defaultSizeTypes);\n    const minSizeReduction = normalizeSizes(options.minSizeReduction, defaultSizeTypes);\n    const maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\n    /** @type {SplitChunksOptions} */\n\n    this.options = {\n      chunksFilter: normalizeChunksFilter(options.chunks || \"all\"),\n      defaultSizeTypes,\n      minSize,\n      minSizeReduction,\n      minRemainingSize: mergeSizes(normalizeSizes(options.minRemainingSize, defaultSizeTypes), minSize),\n      enforceSizeThreshold: normalizeSizes(options.enforceSizeThreshold, defaultSizeTypes),\n      maxAsyncSize: mergeSizes(normalizeSizes(options.maxAsyncSize, defaultSizeTypes), maxSize),\n      maxInitialSize: mergeSizes(normalizeSizes(options.maxInitialSize, defaultSizeTypes), maxSize),\n      minChunks: options.minChunks || 1,\n      maxAsyncRequests: options.maxAsyncRequests || 1,\n      maxInitialRequests: options.maxInitialRequests || 1,\n      hidePathInfo: options.hidePathInfo || false,\n      filename: options.filename || undefined,\n      getCacheGroups: normalizeCacheGroups(options.cacheGroups, defaultSizeTypes),\n      getName: options.name ? normalizeName(options.name) : defaultGetName,\n      automaticNameDelimiter: options.automaticNameDelimiter,\n      usedExports: options.usedExports,\n      fallbackCacheGroup: {\n        chunksFilter: normalizeChunksFilter(fallbackCacheGroup.chunks || options.chunks || \"all\"),\n        minSize: mergeSizes(normalizeSizes(fallbackCacheGroup.minSize, defaultSizeTypes), minSize),\n        maxAsyncSize: mergeSizes(normalizeSizes(fallbackCacheGroup.maxAsyncSize, defaultSizeTypes), normalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes), normalizeSizes(options.maxAsyncSize, defaultSizeTypes), normalizeSizes(options.maxSize, defaultSizeTypes)),\n        maxInitialSize: mergeSizes(normalizeSizes(fallbackCacheGroup.maxInitialSize, defaultSizeTypes), normalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes), normalizeSizes(options.maxInitialSize, defaultSizeTypes), normalizeSizes(options.maxSize, defaultSizeTypes)),\n        automaticNameDelimiter: fallbackCacheGroup.automaticNameDelimiter || options.automaticNameDelimiter || \"~\"\n      }\n    };\n    /** @type {WeakMap<CacheGroupSource, CacheGroup>} */\n\n    this._cacheGroupCache = new WeakMap();\n  }\n  /**\n   * @param {CacheGroupSource} cacheGroupSource source\n   * @returns {CacheGroup} the cache group (cached)\n   */\n\n\n  _getCacheGroup(cacheGroupSource) {\n    const cacheEntry = this._cacheGroupCache.get(cacheGroupSource);\n\n    if (cacheEntry !== undefined) return cacheEntry;\n    const minSize = mergeSizes(cacheGroupSource.minSize, cacheGroupSource.enforce ? undefined : this.options.minSize);\n    const minSizeReduction = mergeSizes(cacheGroupSource.minSizeReduction, cacheGroupSource.enforce ? undefined : this.options.minSizeReduction);\n    const minRemainingSize = mergeSizes(cacheGroupSource.minRemainingSize, cacheGroupSource.enforce ? undefined : this.options.minRemainingSize);\n    const enforceSizeThreshold = mergeSizes(cacheGroupSource.enforceSizeThreshold, cacheGroupSource.enforce ? undefined : this.options.enforceSizeThreshold);\n    const cacheGroup = {\n      key: cacheGroupSource.key,\n      priority: cacheGroupSource.priority || 0,\n      chunksFilter: cacheGroupSource.chunksFilter || this.options.chunksFilter,\n      minSize,\n      minSizeReduction,\n      minRemainingSize,\n      enforceSizeThreshold,\n      maxAsyncSize: mergeSizes(cacheGroupSource.maxAsyncSize, cacheGroupSource.enforce ? undefined : this.options.maxAsyncSize),\n      maxInitialSize: mergeSizes(cacheGroupSource.maxInitialSize, cacheGroupSource.enforce ? undefined : this.options.maxInitialSize),\n      minChunks: cacheGroupSource.minChunks !== undefined ? cacheGroupSource.minChunks : cacheGroupSource.enforce ? 1 : this.options.minChunks,\n      maxAsyncRequests: cacheGroupSource.maxAsyncRequests !== undefined ? cacheGroupSource.maxAsyncRequests : cacheGroupSource.enforce ? Infinity : this.options.maxAsyncRequests,\n      maxInitialRequests: cacheGroupSource.maxInitialRequests !== undefined ? cacheGroupSource.maxInitialRequests : cacheGroupSource.enforce ? Infinity : this.options.maxInitialRequests,\n      getName: cacheGroupSource.getName !== undefined ? cacheGroupSource.getName : this.options.getName,\n      usedExports: cacheGroupSource.usedExports !== undefined ? cacheGroupSource.usedExports : this.options.usedExports,\n      filename: cacheGroupSource.filename !== undefined ? cacheGroupSource.filename : this.options.filename,\n      automaticNameDelimiter: cacheGroupSource.automaticNameDelimiter !== undefined ? cacheGroupSource.automaticNameDelimiter : this.options.automaticNameDelimiter,\n      idHint: cacheGroupSource.idHint !== undefined ? cacheGroupSource.idHint : cacheGroupSource.key,\n      reuseExistingChunk: cacheGroupSource.reuseExistingChunk || false,\n      _validateSize: hasNonZeroSizes(minSize),\n      _validateRemainingSize: hasNonZeroSizes(minRemainingSize),\n      _minSizeForMaxSize: mergeSizes(cacheGroupSource.minSize, this.options.minSize),\n      _conditionalEnforce: hasNonZeroSizes(enforceSizeThreshold)\n    };\n\n    this._cacheGroupCache.set(cacheGroupSource, cacheGroup);\n\n    return cacheGroup;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const cachedMakePathsRelative = makePathsRelative.bindContextCache(compiler.context, compiler.root);\n    compiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", compilation => {\n      const logger = compilation.getLogger(\"webpack.SplitChunksPlugin\");\n      let alreadyOptimized = false;\n      compilation.hooks.unseal.tap(\"SplitChunksPlugin\", () => {\n        alreadyOptimized = false;\n      });\n      compilation.hooks.optimizeChunks.tap({\n        name: \"SplitChunksPlugin\",\n        stage: STAGE_ADVANCED\n      }, chunks => {\n        if (alreadyOptimized) return;\n        alreadyOptimized = true;\n        logger.time(\"prepare\");\n        const chunkGraph = compilation.chunkGraph;\n        const moduleGraph = compilation.moduleGraph; // Give each selected chunk an index (to create strings from chunks)\n\n        /** @type {Map<Chunk, bigint>} */\n\n        const chunkIndexMap = new Map();\n        const ZERO = BigInt(\"0\");\n        const ONE = BigInt(\"1\");\n        const START = ONE << BigInt(\"31\");\n        let index = START;\n\n        for (const chunk of chunks) {\n          chunkIndexMap.set(chunk, index | BigInt(Math.random() * 0x7fffffff | 0));\n          index = index << ONE;\n        }\n        /**\n         * @param {Iterable<Chunk>} chunks list of chunks\n         * @returns {bigint | Chunk} key of the chunks\n         */\n\n\n        const getKey = chunks => {\n          const iterator = chunks[Symbol.iterator]();\n          let result = iterator.next();\n          if (result.done) return ZERO;\n          const first = result.value;\n          result = iterator.next();\n          if (result.done) return first;\n          let key = chunkIndexMap.get(first) | chunkIndexMap.get(result.value);\n\n          while (!(result = iterator.next()).done) {\n            const raw = chunkIndexMap.get(result.value);\n            key = key ^ raw;\n          }\n\n          return key;\n        };\n\n        const keyToString = key => {\n          if (typeof key === \"bigint\") return key.toString(16);\n          return chunkIndexMap.get(key).toString(16);\n        };\n\n        const getChunkSetsInGraph = memoize(() => {\n          /** @type {Map<bigint, Set<Chunk>>} */\n          const chunkSetsInGraph = new Map();\n          /** @type {Set<Chunk>} */\n\n          const singleChunkSets = new Set();\n\n          for (const module of compilation.modules) {\n            const chunks = chunkGraph.getModuleChunksIterable(module);\n            const chunksKey = getKey(chunks);\n\n            if (typeof chunksKey === \"bigint\") {\n              if (!chunkSetsInGraph.has(chunksKey)) {\n                chunkSetsInGraph.set(chunksKey, new Set(chunks));\n              }\n            } else {\n              singleChunkSets.add(chunksKey);\n            }\n          }\n\n          return {\n            chunkSetsInGraph,\n            singleChunkSets\n          };\n        });\n        /**\n         * @param {Module} module the module\n         * @returns {Iterable<Chunk[]>} groups of chunks with equal exports\n         */\n\n        const groupChunksByExports = module => {\n          const exportsInfo = moduleGraph.getExportsInfo(module);\n          const groupedByUsedExports = new Map();\n\n          for (const chunk of chunkGraph.getModuleChunksIterable(module)) {\n            const key = exportsInfo.getUsageKey(chunk.runtime);\n            const list = groupedByUsedExports.get(key);\n\n            if (list !== undefined) {\n              list.push(chunk);\n            } else {\n              groupedByUsedExports.set(key, [chunk]);\n            }\n          }\n\n          return groupedByUsedExports.values();\n        };\n        /** @type {Map<Module, Iterable<Chunk[]>>} */\n\n\n        const groupedByExportsMap = new Map();\n        const getExportsChunkSetsInGraph = memoize(() => {\n          /** @type {Map<bigint, Set<Chunk>>} */\n          const chunkSetsInGraph = new Map();\n          /** @type {Set<Chunk>} */\n\n          const singleChunkSets = new Set();\n\n          for (const module of compilation.modules) {\n            const groupedChunks = Array.from(groupChunksByExports(module));\n            groupedByExportsMap.set(module, groupedChunks);\n\n            for (const chunks of groupedChunks) {\n              if (chunks.length === 1) {\n                singleChunkSets.add(chunks[0]);\n              } else {\n                const chunksKey =\n                /** @type {bigint} */\n                getKey(chunks);\n\n                if (!chunkSetsInGraph.has(chunksKey)) {\n                  chunkSetsInGraph.set(chunksKey, new Set(chunks));\n                }\n              }\n            }\n          }\n\n          return {\n            chunkSetsInGraph,\n            singleChunkSets\n          };\n        }); // group these set of chunks by count\n        // to allow to check less sets via isSubset\n        // (only smaller sets can be subset)\n\n        const groupChunkSetsByCount = chunkSets => {\n          /** @type {Map<number, Array<Set<Chunk>>>} */\n          const chunkSetsByCount = new Map();\n\n          for (const chunksSet of chunkSets) {\n            const count = chunksSet.size;\n            let array = chunkSetsByCount.get(count);\n\n            if (array === undefined) {\n              array = [];\n              chunkSetsByCount.set(count, array);\n            }\n\n            array.push(chunksSet);\n          }\n\n          return chunkSetsByCount;\n        };\n\n        const getChunkSetsByCount = memoize(() => groupChunkSetsByCount(getChunkSetsInGraph().chunkSetsInGraph.values()));\n        const getExportsChunkSetsByCount = memoize(() => groupChunkSetsByCount(getExportsChunkSetsInGraph().chunkSetsInGraph.values())); // Create a list of possible combinations\n\n        const createGetCombinations = (chunkSets, singleChunkSets, chunkSetsByCount) => {\n          /** @type {Map<bigint | Chunk, (Set<Chunk> | Chunk)[]>} */\n          const combinationsCache = new Map();\n          return key => {\n            const cacheEntry = combinationsCache.get(key);\n            if (cacheEntry !== undefined) return cacheEntry;\n\n            if (key instanceof Chunk) {\n              const result = [key];\n              combinationsCache.set(key, result);\n              return result;\n            }\n\n            const chunksSet = chunkSets.get(key);\n            /** @type {(Set<Chunk> | Chunk)[]} */\n\n            const array = [chunksSet];\n\n            for (const [count, setArray] of chunkSetsByCount) {\n              // \"equal\" is not needed because they would have been merge in the first step\n              if (count < chunksSet.size) {\n                for (const set of setArray) {\n                  if (isSubset(chunksSet, set)) {\n                    array.push(set);\n                  }\n                }\n              }\n            }\n\n            for (const chunk of singleChunkSets) {\n              if (chunksSet.has(chunk)) {\n                array.push(chunk);\n              }\n            }\n\n            combinationsCache.set(key, array);\n            return array;\n          };\n        };\n\n        const getCombinationsFactory = memoize(() => {\n          const {\n            chunkSetsInGraph,\n            singleChunkSets\n          } = getChunkSetsInGraph();\n          return createGetCombinations(chunkSetsInGraph, singleChunkSets, getChunkSetsByCount());\n        });\n\n        const getCombinations = key => getCombinationsFactory()(key);\n\n        const getExportsCombinationsFactory = memoize(() => {\n          const {\n            chunkSetsInGraph,\n            singleChunkSets\n          } = getExportsChunkSetsInGraph();\n          return createGetCombinations(chunkSetsInGraph, singleChunkSets, getExportsChunkSetsByCount());\n        });\n\n        const getExportsCombinations = key => getExportsCombinationsFactory()(key);\n        /**\n         * @typedef {Object} SelectedChunksResult\n         * @property {Chunk[]} chunks the list of chunks\n         * @property {bigint | Chunk} key a key of the list\n         */\n\n        /** @type {WeakMap<Set<Chunk> | Chunk, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n\n\n        const selectedChunksCacheByChunksSet = new WeakMap();\n        /**\n         * get list and key by applying the filter function to the list\n         * It is cached for performance reasons\n         * @param {Set<Chunk> | Chunk} chunks list of chunks\n         * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n         * @returns {SelectedChunksResult} list and key\n         */\n\n        const getSelectedChunks = (chunks, chunkFilter) => {\n          let entry = selectedChunksCacheByChunksSet.get(chunks);\n\n          if (entry === undefined) {\n            entry = new WeakMap();\n            selectedChunksCacheByChunksSet.set(chunks, entry);\n          }\n          /** @type {SelectedChunksResult} */\n\n\n          let entry2 = entry.get(chunkFilter);\n\n          if (entry2 === undefined) {\n            /** @type {Chunk[]} */\n            const selectedChunks = [];\n\n            if (chunks instanceof Chunk) {\n              if (chunkFilter(chunks)) selectedChunks.push(chunks);\n            } else {\n              for (const chunk of chunks) {\n                if (chunkFilter(chunk)) selectedChunks.push(chunk);\n              }\n            }\n\n            entry2 = {\n              chunks: selectedChunks,\n              key: getKey(selectedChunks)\n            };\n            entry.set(chunkFilter, entry2);\n          }\n\n          return entry2;\n        };\n        /** @type {Map<string, boolean>} */\n\n\n        const alreadyValidatedParents = new Map();\n        /** @type {Set<string>} */\n\n        const alreadyReportedErrors = new Set(); // Map a list of chunks to a list of modules\n        // For the key the chunk \"index\" is used, the value is a SortableSet of modules\n\n        /** @type {Map<string, ChunksInfoItem>} */\n\n        const chunksInfoMap = new Map();\n        /**\n         * @param {CacheGroup} cacheGroup the current cache group\n         * @param {number} cacheGroupIndex the index of the cache group of ordering\n         * @param {Chunk[]} selectedChunks chunks selected for this module\n         * @param {bigint | Chunk} selectedChunksKey a key of selectedChunks\n         * @param {Module} module the current module\n         * @returns {void}\n         */\n\n        const addModuleToChunksInfoMap = (cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module) => {\n          // Break if minimum number of chunks is not reached\n          if (selectedChunks.length < cacheGroup.minChunks) return; // Determine name for split chunk\n\n          const name = cacheGroup.getName(module, selectedChunks, cacheGroup.key); // Check if the name is ok\n\n          const existingChunk = compilation.namedChunks.get(name);\n\n          if (existingChunk) {\n            const parentValidationKey = `${name}|${typeof selectedChunksKey === \"bigint\" ? selectedChunksKey : selectedChunksKey.debugId}`;\n            const valid = alreadyValidatedParents.get(parentValidationKey);\n            if (valid === false) return;\n\n            if (valid === undefined) {\n              // Module can only be moved into the existing chunk if the existing chunk\n              // is a parent of all selected chunks\n              let isInAllParents = true;\n              /** @type {Set<ChunkGroup>} */\n\n              const queue = new Set();\n\n              for (const chunk of selectedChunks) {\n                for (const group of chunk.groupsIterable) {\n                  queue.add(group);\n                }\n              }\n\n              for (const group of queue) {\n                if (existingChunk.isInGroup(group)) continue;\n                let hasParent = false;\n\n                for (const parent of group.parentsIterable) {\n                  hasParent = true;\n                  queue.add(parent);\n                }\n\n                if (!hasParent) {\n                  isInAllParents = false;\n                }\n              }\n\n              const valid = isInAllParents;\n              alreadyValidatedParents.set(parentValidationKey, valid);\n\n              if (!valid) {\n                if (!alreadyReportedErrors.has(name)) {\n                  alreadyReportedErrors.add(name);\n                  compilation.errors.push(new WebpackError(\"SplitChunksPlugin\\n\" + `Cache group \"${cacheGroup.key}\" conflicts with existing chunk.\\n` + `Both have the same name \"${name}\" and existing chunk is not a parent of the selected modules.\\n` + \"Use a different name for the cache group or make sure that the existing chunk is a parent (e. g. via dependOn).\\n\" + 'HINT: You can omit \"name\" to automatically create a name.\\n' + \"BREAKING CHANGE: webpack < 5 used to allow to use an entrypoint as splitChunk. \" + \"This is no longer allowed when the entrypoint is not a parent of the selected modules.\\n\" + \"Remove this entrypoint and add modules to cache group's 'test' instead. \" + \"If you need modules to be evaluated on startup, add them to the existing entrypoints (make them arrays). \" + \"See migration guide of more info.\"));\n                }\n\n                return;\n              }\n            }\n          } // Create key for maps\n          // When it has a name we use the name as key\n          // Otherwise we create the key from chunks and cache group key\n          // This automatically merges equal names\n\n\n          const key = cacheGroup.key + (name ? ` name:${name}` : ` chunks:${keyToString(selectedChunksKey)}`); // Add module to maps\n\n          let info = chunksInfoMap.get(key);\n\n          if (info === undefined) {\n            chunksInfoMap.set(key, info = {\n              modules: new SortableSet(undefined, compareModulesByIdentifier),\n              cacheGroup,\n              cacheGroupIndex,\n              name,\n              sizes: {},\n              chunks: new Set(),\n              reuseableChunks: new Set(),\n              chunksKeys: new Set()\n            });\n          }\n\n          const oldSize = info.modules.size;\n          info.modules.add(module);\n\n          if (info.modules.size !== oldSize) {\n            for (const type of module.getSourceTypes()) {\n              info.sizes[type] = (info.sizes[type] || 0) + module.size(type);\n            }\n          }\n\n          const oldChunksKeysSize = info.chunksKeys.size;\n          info.chunksKeys.add(selectedChunksKey);\n\n          if (oldChunksKeysSize !== info.chunksKeys.size) {\n            for (const chunk of selectedChunks) {\n              info.chunks.add(chunk);\n            }\n          }\n        };\n\n        const context = {\n          moduleGraph,\n          chunkGraph\n        };\n        logger.timeEnd(\"prepare\");\n        logger.time(\"modules\"); // Walk through all modules\n\n        for (const module of compilation.modules) {\n          // Get cache group\n          let cacheGroups = this.options.getCacheGroups(module, context);\n\n          if (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n            continue;\n          } // Prepare some values (usedExports = false)\n\n\n          const getCombs = memoize(() => {\n            const chunks = chunkGraph.getModuleChunksIterable(module);\n            const chunksKey = getKey(chunks);\n            return getCombinations(chunksKey);\n          }); // Prepare some values (usedExports = true)\n\n          const getCombsByUsedExports = memoize(() => {\n            // fill the groupedByExportsMap\n            getExportsChunkSetsInGraph();\n            /** @type {Set<Set<Chunk> | Chunk>} */\n\n            const set = new Set();\n            const groupedByUsedExports = groupedByExportsMap.get(module);\n\n            for (const chunks of groupedByUsedExports) {\n              const chunksKey = getKey(chunks);\n\n              for (const comb of getExportsCombinations(chunksKey)) set.add(comb);\n            }\n\n            return set;\n          });\n          let cacheGroupIndex = 0;\n\n          for (const cacheGroupSource of cacheGroups) {\n            const cacheGroup = this._getCacheGroup(cacheGroupSource);\n\n            const combs = cacheGroup.usedExports ? getCombsByUsedExports() : getCombs(); // For all combination of chunk selection\n\n            for (const chunkCombination of combs) {\n              // Break if minimum number of chunks is not reached\n              const count = chunkCombination instanceof Chunk ? 1 : chunkCombination.size;\n              if (count < cacheGroup.minChunks) continue; // Select chunks by configuration\n\n              const {\n                chunks: selectedChunks,\n                key: selectedChunksKey\n              } = getSelectedChunks(chunkCombination, cacheGroup.chunksFilter);\n              addModuleToChunksInfoMap(cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module);\n            }\n\n            cacheGroupIndex++;\n          }\n        }\n\n        logger.timeEnd(\"modules\");\n        logger.time(\"queue\");\n        /**\n         * @param {ChunksInfoItem} info entry\n         * @param {string[]} sourceTypes source types to be removed\n         */\n\n        const removeModulesWithSourceType = (info, sourceTypes) => {\n          for (const module of info.modules) {\n            const types = module.getSourceTypes();\n\n            if (sourceTypes.some(type => types.has(type))) {\n              info.modules.delete(module);\n\n              for (const type of types) {\n                info.sizes[type] -= module.size(type);\n              }\n            }\n          }\n        };\n        /**\n         * @param {ChunksInfoItem} info entry\n         * @returns {boolean} true, if entry become empty\n         */\n\n\n        const removeMinSizeViolatingModules = info => {\n          if (!info.cacheGroup._validateSize) return false;\n          const violatingSizes = getViolatingMinSizes(info.sizes, info.cacheGroup.minSize);\n          if (violatingSizes === undefined) return false;\n          removeModulesWithSourceType(info, violatingSizes);\n          return info.modules.size === 0;\n        }; // Filter items were size < minSize\n\n\n        for (const [key, info] of chunksInfoMap) {\n          if (removeMinSizeViolatingModules(info)) {\n            chunksInfoMap.delete(key);\n          } else if (!checkMinSizeReduction(info.sizes, info.cacheGroup.minSizeReduction, info.chunks.size)) {\n            chunksInfoMap.delete(key);\n          }\n        }\n        /**\n         * @typedef {Object} MaxSizeQueueItem\n         * @property {SplitChunksSizes} minSize\n         * @property {SplitChunksSizes} maxAsyncSize\n         * @property {SplitChunksSizes} maxInitialSize\n         * @property {string} automaticNameDelimiter\n         * @property {string[]} keys\n         */\n\n        /** @type {Map<Chunk, MaxSizeQueueItem>} */\n\n\n        const maxSizeQueueMap = new Map();\n\n        while (chunksInfoMap.size > 0) {\n          // Find best matching entry\n          let bestEntryKey;\n          let bestEntry;\n\n          for (const pair of chunksInfoMap) {\n            const key = pair[0];\n            const info = pair[1];\n\n            if (bestEntry === undefined || compareEntries(bestEntry, info) < 0) {\n              bestEntry = info;\n              bestEntryKey = key;\n            }\n          }\n\n          const item = bestEntry;\n          chunksInfoMap.delete(bestEntryKey);\n          let chunkName = item.name; // Variable for the new chunk (lazy created)\n\n          /** @type {Chunk} */\n\n          let newChunk; // When no chunk name, check if we can reuse a chunk instead of creating a new one\n\n          let isExistingChunk = false;\n          let isReusedWithAllModules = false;\n\n          if (chunkName) {\n            const chunkByName = compilation.namedChunks.get(chunkName);\n\n            if (chunkByName !== undefined) {\n              newChunk = chunkByName;\n              const oldSize = item.chunks.size;\n              item.chunks.delete(newChunk);\n              isExistingChunk = item.chunks.size !== oldSize;\n            }\n          } else if (item.cacheGroup.reuseExistingChunk) {\n            outer: for (const chunk of item.chunks) {\n              if (chunkGraph.getNumberOfChunkModules(chunk) !== item.modules.size) {\n                continue;\n              }\n\n              if (item.chunks.size > 1 && chunkGraph.getNumberOfEntryModules(chunk) > 0) {\n                continue;\n              }\n\n              for (const module of item.modules) {\n                if (!chunkGraph.isModuleInChunk(module, chunk)) {\n                  continue outer;\n                }\n              }\n\n              if (!newChunk || !newChunk.name) {\n                newChunk = chunk;\n              } else if (chunk.name && chunk.name.length < newChunk.name.length) {\n                newChunk = chunk;\n              } else if (chunk.name && chunk.name.length === newChunk.name.length && chunk.name < newChunk.name) {\n                newChunk = chunk;\n              }\n            }\n\n            if (newChunk) {\n              item.chunks.delete(newChunk);\n              chunkName = undefined;\n              isExistingChunk = true;\n              isReusedWithAllModules = true;\n            }\n          }\n\n          const enforced = item.cacheGroup._conditionalEnforce && checkMinSize(item.sizes, item.cacheGroup.enforceSizeThreshold);\n          const usedChunks = new Set(item.chunks); // Check if maxRequests condition can be fulfilled\n\n          if (!enforced && (Number.isFinite(item.cacheGroup.maxInitialRequests) || Number.isFinite(item.cacheGroup.maxAsyncRequests))) {\n            for (const chunk of usedChunks) {\n              // respect max requests\n              const maxRequests = chunk.isOnlyInitial() ? item.cacheGroup.maxInitialRequests : chunk.canBeInitial() ? Math.min(item.cacheGroup.maxInitialRequests, item.cacheGroup.maxAsyncRequests) : item.cacheGroup.maxAsyncRequests;\n\n              if (isFinite(maxRequests) && getRequests(chunk) >= maxRequests) {\n                usedChunks.delete(chunk);\n              }\n            }\n          }\n\n          outer: for (const chunk of usedChunks) {\n            for (const module of item.modules) {\n              if (chunkGraph.isModuleInChunk(module, chunk)) continue outer;\n            }\n\n            usedChunks.delete(chunk);\n          } // Were some (invalid) chunks removed from usedChunks?\n          // => readd all modules to the queue, as things could have been changed\n\n\n          if (usedChunks.size < item.chunks.size) {\n            if (isExistingChunk) usedChunks.add(newChunk);\n\n            if (usedChunks.size >= item.cacheGroup.minChunks) {\n              const chunksArr = Array.from(usedChunks);\n\n              for (const module of item.modules) {\n                addModuleToChunksInfoMap(item.cacheGroup, item.cacheGroupIndex, chunksArr, getKey(usedChunks), module);\n              }\n            }\n\n            continue;\n          } // Validate minRemainingSize constraint when a single chunk is left over\n\n\n          if (!enforced && item.cacheGroup._validateRemainingSize && usedChunks.size === 1) {\n            const [chunk] = usedChunks;\n            let chunkSizes = Object.create(null);\n\n            for (const module of chunkGraph.getChunkModulesIterable(chunk)) {\n              if (!item.modules.has(module)) {\n                for (const type of module.getSourceTypes()) {\n                  chunkSizes[type] = (chunkSizes[type] || 0) + module.size(type);\n                }\n              }\n            }\n\n            const violatingSizes = getViolatingMinSizes(chunkSizes, item.cacheGroup.minRemainingSize);\n\n            if (violatingSizes !== undefined) {\n              const oldModulesSize = item.modules.size;\n              removeModulesWithSourceType(item, violatingSizes);\n\n              if (item.modules.size > 0 && item.modules.size !== oldModulesSize) {\n                // queue this item again to be processed again\n                // without violating modules\n                chunksInfoMap.set(bestEntryKey, item);\n              }\n\n              continue;\n            }\n          } // Create the new chunk if not reusing one\n\n\n          if (newChunk === undefined) {\n            newChunk = compilation.addChunk(chunkName);\n          } // Walk through all chunks\n\n\n          for (const chunk of usedChunks) {\n            // Add graph connections for splitted chunk\n            chunk.split(newChunk);\n          } // Add a note to the chunk\n\n\n          newChunk.chunkReason = (newChunk.chunkReason ? newChunk.chunkReason + \", \" : \"\") + (isReusedWithAllModules ? \"reused as split chunk\" : \"split chunk\");\n\n          if (item.cacheGroup.key) {\n            newChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;\n          }\n\n          if (chunkName) {\n            newChunk.chunkReason += ` (name: ${chunkName})`;\n          }\n\n          if (item.cacheGroup.filename) {\n            newChunk.filenameTemplate = item.cacheGroup.filename;\n          }\n\n          if (item.cacheGroup.idHint) {\n            newChunk.idNameHints.add(item.cacheGroup.idHint);\n          }\n\n          if (!isReusedWithAllModules) {\n            // Add all modules to the new chunk\n            for (const module of item.modules) {\n              if (!module.chunkCondition(newChunk, compilation)) continue; // Add module to new chunk\n\n              chunkGraph.connectChunkAndModule(newChunk, module); // Remove module from used chunks\n\n              for (const chunk of usedChunks) {\n                chunkGraph.disconnectChunkAndModule(chunk, module);\n              }\n            }\n          } else {\n            // Remove all modules from used chunks\n            for (const module of item.modules) {\n              for (const chunk of usedChunks) {\n                chunkGraph.disconnectChunkAndModule(chunk, module);\n              }\n            }\n          }\n\n          if (Object.keys(item.cacheGroup.maxAsyncSize).length > 0 || Object.keys(item.cacheGroup.maxInitialSize).length > 0) {\n            const oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n            maxSizeQueueMap.set(newChunk, {\n              minSize: oldMaxSizeSettings ? combineSizes(oldMaxSizeSettings.minSize, item.cacheGroup._minSizeForMaxSize, Math.max) : item.cacheGroup.minSize,\n              maxAsyncSize: oldMaxSizeSettings ? combineSizes(oldMaxSizeSettings.maxAsyncSize, item.cacheGroup.maxAsyncSize, Math.min) : item.cacheGroup.maxAsyncSize,\n              maxInitialSize: oldMaxSizeSettings ? combineSizes(oldMaxSizeSettings.maxInitialSize, item.cacheGroup.maxInitialSize, Math.min) : item.cacheGroup.maxInitialSize,\n              automaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n              keys: oldMaxSizeSettings ? oldMaxSizeSettings.keys.concat(item.cacheGroup.key) : [item.cacheGroup.key]\n            });\n          } // remove all modules from other entries and update size\n\n\n          for (const [key, info] of chunksInfoMap) {\n            if (isOverlap(info.chunks, usedChunks)) {\n              // update modules and total size\n              // may remove it from the map when < minSize\n              let updated = false;\n\n              for (const module of item.modules) {\n                if (info.modules.has(module)) {\n                  // remove module\n                  info.modules.delete(module); // update size\n\n                  for (const key of module.getSourceTypes()) {\n                    info.sizes[key] -= module.size(key);\n                  }\n\n                  updated = true;\n                }\n              }\n\n              if (updated) {\n                if (info.modules.size === 0) {\n                  chunksInfoMap.delete(key);\n                  continue;\n                }\n\n                if (removeMinSizeViolatingModules(info) || !checkMinSizeReduction(info.sizes, info.cacheGroup.minSizeReduction, info.chunks.size)) {\n                  chunksInfoMap.delete(key);\n                  continue;\n                }\n              }\n            }\n          }\n        }\n\n        logger.timeEnd(\"queue\");\n        logger.time(\"maxSize\");\n        /** @type {Set<string>} */\n\n        const incorrectMinMaxSizeSet = new Set();\n        const {\n          outputOptions\n        } = compilation; // Make sure that maxSize is fulfilled\n\n        const {\n          fallbackCacheGroup\n        } = this.options;\n\n        for (const chunk of Array.from(compilation.chunks)) {\n          const chunkConfig = maxSizeQueueMap.get(chunk);\n          const {\n            minSize,\n            maxAsyncSize,\n            maxInitialSize,\n            automaticNameDelimiter\n          } = chunkConfig || fallbackCacheGroup;\n          if (!chunkConfig && !fallbackCacheGroup.chunksFilter(chunk)) continue;\n          /** @type {SplitChunksSizes} */\n\n          let maxSize;\n\n          if (chunk.isOnlyInitial()) {\n            maxSize = maxInitialSize;\n          } else if (chunk.canBeInitial()) {\n            maxSize = combineSizes(maxAsyncSize, maxInitialSize, Math.min);\n          } else {\n            maxSize = maxAsyncSize;\n          }\n\n          if (Object.keys(maxSize).length === 0) {\n            continue;\n          }\n\n          for (const key of Object.keys(maxSize)) {\n            const maxSizeValue = maxSize[key];\n            const minSizeValue = minSize[key];\n\n            if (typeof minSizeValue === \"number\" && minSizeValue > maxSizeValue) {\n              const keys = chunkConfig && chunkConfig.keys;\n              const warningKey = `${keys && keys.join()} ${minSizeValue} ${maxSizeValue}`;\n\n              if (!incorrectMinMaxSizeSet.has(warningKey)) {\n                incorrectMinMaxSizeSet.add(warningKey);\n                compilation.warnings.push(new MinMaxSizeWarning(keys, minSizeValue, maxSizeValue));\n              }\n            }\n          }\n\n          const results = deterministicGroupingForModules({\n            minSize,\n            maxSize: mapObject(maxSize, (value, key) => {\n              const minSizeValue = minSize[key];\n              return typeof minSizeValue === \"number\" ? Math.max(value, minSizeValue) : value;\n            }),\n            items: chunkGraph.getChunkModulesIterable(chunk),\n\n            getKey(module) {\n              const cache = getKeyCache.get(module);\n              if (cache !== undefined) return cache;\n              const ident = cachedMakePathsRelative(module.identifier());\n              const nameForCondition = module.nameForCondition && module.nameForCondition();\n              const name = nameForCondition ? cachedMakePathsRelative(nameForCondition) : ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n              const fullKey = name + automaticNameDelimiter + hashFilename(ident, outputOptions);\n              const key = requestToId(fullKey);\n              getKeyCache.set(module, key);\n              return key;\n            },\n\n            getSize(module) {\n              const size = Object.create(null);\n\n              for (const key of module.getSourceTypes()) {\n                size[key] = module.size(key);\n              }\n\n              return size;\n            }\n\n          });\n\n          if (results.length <= 1) {\n            continue;\n          }\n\n          for (let i = 0; i < results.length; i++) {\n            const group = results[i];\n            const key = this.options.hidePathInfo ? hashFilename(group.key, outputOptions) : group.key;\n            let name = chunk.name ? chunk.name + automaticNameDelimiter + key : null;\n\n            if (name && name.length > 100) {\n              name = name.slice(0, 100) + automaticNameDelimiter + hashFilename(name, outputOptions);\n            }\n\n            if (i !== results.length - 1) {\n              const newPart = compilation.addChunk(name);\n              chunk.split(newPart);\n              newPart.chunkReason = chunk.chunkReason; // Add all modules to the new chunk\n\n              for (const module of group.items) {\n                if (!module.chunkCondition(newPart, compilation)) {\n                  continue;\n                } // Add module to new chunk\n\n\n                chunkGraph.connectChunkAndModule(newPart, module); // Remove module from used chunks\n\n                chunkGraph.disconnectChunkAndModule(chunk, module);\n              }\n            } else {\n              // change the chunk to be a part\n              chunk.name = name;\n            }\n          }\n        }\n\n        logger.timeEnd(\"maxSize\");\n      });\n    });\n  }\n\n};","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/optimize/SplitChunksPlugin.js"],"names":["Chunk","require","STAGE_ADVANCED","WebpackError","requestToId","isSubset","SortableSet","compareModulesByIdentifier","compareIterables","createHash","deterministicGrouping","makePathsRelative","memoize","MinMaxSizeWarning","defaultGetName","deterministicGroupingForModules","getKeyCache","WeakMap","hashFilename","name","outputOptions","digest","hashFunction","update","hashDigest","slice","getRequests","chunk","requests","chunkGroup","groupsIterable","Math","max","chunks","length","mapObject","obj","fn","newObj","Object","create","key","keys","isOverlap","a","b","item","has","compareModuleIterables","compareEntries","diffPriority","cacheGroup","priority","diffCount","size","aSizeReduce","totalSize","sizes","bSizeReduce","diffSizeReduce","indexDiff","cacheGroupIndex","modulesA","modules","modulesB","diff","sort","INITIAL_CHUNK_FILTER","canBeInitial","ASYNC_CHUNK_FILTER","ALL_CHUNK_FILTER","normalizeSizes","value","defaultSizeTypes","o","sizeType","mergeSizes","merged","i","assign","hasNonZeroSizes","combineSizes","combine","aKeys","Set","bKeys","result","checkMinSize","minSize","undefined","checkMinSizeReduction","minSizeReduction","chunkCount","getViolatingMinSizes","list","push","normalizeName","normalizeChunksFilter","normalizeCacheGroups","cacheGroups","handlers","option","RegExp","source","createCacheGroupSource","module","context","results","checkTest","cache","groups","Array","isArray","group","cachedSource","get","set","test","checkModuleType","type","checkModuleLayer","layer","nameForCondition","startsWith","options","maxSize","getName","chunksFilter","enforce","minRemainingSize","enforceSizeThreshold","maxAsyncSize","maxInitialSize","minChunks","maxAsyncRequests","maxInitialRequests","filename","idHint","automaticNameDelimiter","reuseExistingChunk","usedExports","exports","SplitChunksPlugin","constructor","fallbackCacheGroup","hidePathInfo","getCacheGroups","_cacheGroupCache","_getCacheGroup","cacheGroupSource","cacheEntry","Infinity","_validateSize","_validateRemainingSize","_minSizeForMaxSize","_conditionalEnforce","apply","compiler","cachedMakePathsRelative","bindContextCache","root","hooks","thisCompilation","tap","compilation","logger","getLogger","alreadyOptimized","unseal","optimizeChunks","stage","time","chunkGraph","moduleGraph","chunkIndexMap","Map","ZERO","BigInt","ONE","START","index","random","getKey","iterator","Symbol","next","done","first","raw","keyToString","toString","getChunkSetsInGraph","chunkSetsInGraph","singleChunkSets","getModuleChunksIterable","chunksKey","add","groupChunksByExports","exportsInfo","getExportsInfo","groupedByUsedExports","getUsageKey","runtime","values","groupedByExportsMap","getExportsChunkSetsInGraph","groupedChunks","from","groupChunkSetsByCount","chunkSets","chunkSetsByCount","chunksSet","count","array","getChunkSetsByCount","getExportsChunkSetsByCount","createGetCombinations","combinationsCache","setArray","getCombinationsFactory","getCombinations","getExportsCombinationsFactory","getExportsCombinations","selectedChunksCacheByChunksSet","getSelectedChunks","chunkFilter","entry","entry2","selectedChunks","alreadyValidatedParents","alreadyReportedErrors","chunksInfoMap","addModuleToChunksInfoMap","selectedChunksKey","existingChunk","namedChunks","parentValidationKey","debugId","valid","isInAllParents","queue","isInGroup","hasParent","parent","parentsIterable","errors","info","reuseableChunks","chunksKeys","oldSize","getSourceTypes","oldChunksKeysSize","timeEnd","getCombs","getCombsByUsedExports","comb","combs","chunkCombination","removeModulesWithSourceType","sourceTypes","types","some","delete","removeMinSizeViolatingModules","violatingSizes","maxSizeQueueMap","bestEntryKey","bestEntry","pair","chunkName","newChunk","isExistingChunk","isReusedWithAllModules","chunkByName","outer","getNumberOfChunkModules","getNumberOfEntryModules","isModuleInChunk","enforced","usedChunks","Number","isFinite","maxRequests","isOnlyInitial","min","chunksArr","chunkSizes","getChunkModulesIterable","oldModulesSize","addChunk","split","chunkReason","filenameTemplate","idNameHints","chunkCondition","connectChunkAndModule","disconnectChunkAndModule","oldMaxSizeSettings","concat","updated","incorrectMinMaxSizeSet","chunkConfig","maxSizeValue","minSizeValue","warningKey","join","warnings","items","ident","identifier","replace","fullKey","getSize","newPart"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,UAAD,CAArB;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAqBD,OAAO,CAAC,uBAAD,CAAlC;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAC,iBAAD,CAA5B;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAkBH,OAAO,CAAC,kBAAD,CAA/B;;AACA,MAAM;AAAEI,EAAAA;AAAF,IAAeJ,OAAO,CAAC,oBAAD,CAA5B;;AACA,MAAMK,WAAW,GAAGL,OAAO,CAAC,qBAAD,CAA3B;;AACA,MAAM;AACLM,EAAAA,0BADK;AAELC,EAAAA;AAFK,IAGFP,OAAO,CAAC,qBAAD,CAHX;;AAIA,MAAMQ,UAAU,GAAGR,OAAO,CAAC,oBAAD,CAA1B;;AACA,MAAMS,qBAAqB,GAAGT,OAAO,CAAC,+BAAD,CAArC;;AACA,MAAM;AAAEU,EAAAA;AAAF,IAAwBV,OAAO,CAAC,oBAAD,CAArC;;AACA,MAAMW,OAAO,GAAGX,OAAO,CAAC,iBAAD,CAAvB;;AACA,MAAMY,iBAAiB,GAAGZ,OAAO,CAAC,qBAAD,CAAjC;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Chunk = require(\"../Chunk\");\nconst { STAGE_ADVANCED } = require(\"../OptimizationStages\");\nconst WebpackError = require(\"../WebpackError\");\nconst { requestToId } = require(\"../ids/IdHelpers\");\nconst { isSubset } = require(\"../util/SetHelpers\");\nconst SortableSet = require(\"../util/SortableSet\");\nconst {\n\tcompareModulesByIdentifier,\n\tcompareIterables\n} = require(\"../util/comparators\");\nconst createHash = require(\"../util/createHash\");\nconst deterministicGrouping = require(\"../util/deterministicGrouping\");\nconst { makePathsRelative } = require(\"../util/identifier\");\nconst memoize = require(\"../util/memoize\");\nconst MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksCacheGroup} OptimizationSplitChunksCacheGroup */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksGetCacheGroups} OptimizationSplitChunksGetCacheGroups */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksOptions} OptimizationSplitChunksOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksSizes} OptimizationSplitChunksSizes */\n/** @typedef {import(\"../../declarations/WebpackOptions\").Output} OutputOptions */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compilation\").PathData} PathData */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n\n/** @typedef {Record<string, number>} SplitChunksSizes */\n\n/**\n * @callback ChunkFilterFunction\n * @param {Chunk} chunk\n * @returns {boolean}\n */\n\n/**\n * @callback CombineSizeFunction\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\n\n/**\n * @typedef {Object} CacheGroupSource\n * @property {string=} key\n * @property {number=} priority\n * @property {GetName=} getName\n * @property {ChunkFilterFunction=} chunksFilter\n * @property {boolean=} enforce\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {number=} minChunks\n * @property {number=} maxAsyncRequests\n * @property {number=} maxInitialRequests\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\n * @property {string=} idHint\n * @property {string} automaticNameDelimiter\n * @property {boolean=} reuseExistingChunk\n * @property {boolean=} usedExports\n */\n\n/**\n * @typedef {Object} CacheGroup\n * @property {string} key\n * @property {number=} priority\n * @property {GetName=} getName\n * @property {ChunkFilterFunction=} chunksFilter\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {number=} minChunks\n * @property {number=} maxAsyncRequests\n * @property {number=} maxInitialRequests\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\n * @property {string=} idHint\n * @property {string} automaticNameDelimiter\n * @property {boolean} reuseExistingChunk\n * @property {boolean} usedExports\n * @property {boolean} _validateSize\n * @property {boolean} _validateRemainingSize\n * @property {SplitChunksSizes} _minSizeForMaxSize\n * @property {boolean} _conditionalEnforce\n */\n\n/**\n * @typedef {Object} FallbackCacheGroup\n * @property {ChunkFilterFunction} chunksFilter\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {string} automaticNameDelimiter\n */\n\n/**\n * @typedef {Object} CacheGroupsContext\n * @property {ModuleGraph} moduleGraph\n * @property {ChunkGraph} chunkGraph\n */\n\n/**\n * @callback GetCacheGroups\n * @param {Module} module\n * @param {CacheGroupsContext} context\n * @returns {CacheGroupSource[]}\n */\n\n/**\n * @callback GetName\n * @param {Module=} module\n * @param {Chunk[]=} chunks\n * @param {string=} key\n * @returns {string=}\n */\n\n/**\n * @typedef {Object} SplitChunksOptions\n * @property {ChunkFilterFunction} chunksFilter\n * @property {string[]} defaultSizeTypes\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxInitialSize\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {number} minChunks\n * @property {number} maxAsyncRequests\n * @property {number} maxInitialRequests\n * @property {boolean} hidePathInfo\n * @property {string | function(PathData, AssetInfo=): string} filename\n * @property {string} automaticNameDelimiter\n * @property {GetCacheGroups} getCacheGroups\n * @property {GetName} getName\n * @property {boolean} usedExports\n * @property {FallbackCacheGroup} fallbackCacheGroup\n */\n\n/**\n * @typedef {Object} ChunksInfoItem\n * @property {SortableSet<Module>} modules\n * @property {CacheGroup} cacheGroup\n * @property {number} cacheGroupIndex\n * @property {string} name\n * @property {Record<string, number>} sizes\n * @property {Set<Chunk>} chunks\n * @property {Set<Chunk>} reuseableChunks\n * @property {Set<bigint | Chunk>} chunksKeys\n */\n\nconst defaultGetName = /** @type {GetName} */ (() => {});\n\nconst deterministicGroupingForModules =\n\t/** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */ (\n\t\tdeterministicGrouping\n\t);\n\n/** @type {WeakMap<Module, string>} */\nconst getKeyCache = new WeakMap();\n\n/**\n * @param {string} name a filename to hash\n * @param {OutputOptions} outputOptions hash function used\n * @returns {string} hashed filename\n */\nconst hashFilename = (name, outputOptions) => {\n\tconst digest = /** @type {string} */ (\n\t\tcreateHash(outputOptions.hashFunction)\n\t\t\t.update(name)\n\t\t\t.digest(outputOptions.hashDigest)\n\t);\n\treturn digest.slice(0, 8);\n};\n\n/**\n * @param {Chunk} chunk the chunk\n * @returns {number} the number of requests\n */\nconst getRequests = chunk => {\n\tlet requests = 0;\n\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\trequests = Math.max(requests, chunkGroup.chunks.length);\n\t}\n\treturn requests;\n};\n\nconst mapObject = (obj, fn) => {\n\tconst newObj = Object.create(null);\n\tfor (const key of Object.keys(obj)) {\n\t\tnewObj[key] = fn(obj[key], key);\n\t}\n\treturn newObj;\n};\n\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\nconst isOverlap = (a, b) => {\n\tfor (const item of a) {\n\t\tif (b.has(item)) return true;\n\t}\n\treturn false;\n};\n\nconst compareModuleIterables = compareIterables(compareModulesByIdentifier);\n\n/**\n * @param {ChunksInfoItem} a item\n * @param {ChunksInfoItem} b item\n * @returns {number} compare result\n */\nconst compareEntries = (a, b) => {\n\t// 1. by priority\n\tconst diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n\tif (diffPriority) return diffPriority;\n\t// 2. by number of chunks\n\tconst diffCount = a.chunks.size - b.chunks.size;\n\tif (diffCount) return diffCount;\n\t// 3. by size reduction\n\tconst aSizeReduce = totalSize(a.sizes) * (a.chunks.size - 1);\n\tconst bSizeReduce = totalSize(b.sizes) * (b.chunks.size - 1);\n\tconst diffSizeReduce = aSizeReduce - bSizeReduce;\n\tif (diffSizeReduce) return diffSizeReduce;\n\t// 4. by cache group index\n\tconst indexDiff = b.cacheGroupIndex - a.cacheGroupIndex;\n\tif (indexDiff) return indexDiff;\n\t// 5. by number of modules (to be able to compare by identifier)\n\tconst modulesA = a.modules;\n\tconst modulesB = b.modules;\n\tconst diff = modulesA.size - modulesB.size;\n\tif (diff) return diff;\n\t// 6. by module identifiers\n\tmodulesA.sort();\n\tmodulesB.sort();\n\treturn compareModuleIterables(modulesA, modulesB);\n};\n\nconst INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial();\nconst ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial();\nconst ALL_CHUNK_FILTER = chunk => true;\n\n/**\n * @param {OptimizationSplitChunksSizes} value the sizes\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {SplitChunksSizes} normalized representation\n */\nconst normalizeSizes = (value, defaultSizeTypes) => {\n\tif (typeof value === \"number\") {\n\t\t/** @type {Record<string, number>} */\n\t\tconst o = {};\n\t\tfor (const sizeType of defaultSizeTypes) o[sizeType] = value;\n\t\treturn o;\n\t} else if (typeof value === \"object\" && value !== null) {\n\t\treturn { ...value };\n\t} else {\n\t\treturn {};\n\t}\n};\n\n/**\n * @param {...SplitChunksSizes} sizes the sizes\n * @returns {SplitChunksSizes} the merged sizes\n */\nconst mergeSizes = (...sizes) => {\n\t/** @type {SplitChunksSizes} */\n\tlet merged = {};\n\tfor (let i = sizes.length - 1; i >= 0; i--) {\n\t\tmerged = Object.assign(merged, sizes[i]);\n\t}\n\treturn merged;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @returns {boolean} true, if there are sizes > 0\n */\nconst hasNonZeroSizes = sizes => {\n\tfor (const key of Object.keys(sizes)) {\n\t\tif (sizes[key] > 0) return true;\n\t}\n\treturn false;\n};\n\n/**\n * @param {SplitChunksSizes} a first sizes\n * @param {SplitChunksSizes} b second sizes\n * @param {CombineSizeFunction} combine a function to combine sizes\n * @returns {SplitChunksSizes} the combine sizes\n */\nconst combineSizes = (a, b, combine) => {\n\tconst aKeys = new Set(Object.keys(a));\n\tconst bKeys = new Set(Object.keys(b));\n\t/** @type {SplitChunksSizes} */\n\tconst result = {};\n\tfor (const key of aKeys) {\n\t\tif (bKeys.has(key)) {\n\t\t\tresult[key] = combine(a[key], b[key]);\n\t\t} else {\n\t\t\tresult[key] = a[key];\n\t\t}\n\t}\n\tfor (const key of bKeys) {\n\t\tif (!aKeys.has(key)) {\n\t\t\tresult[key] = b[key];\n\t\t}\n\t}\n\treturn result;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSize the min sizes\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSize`\n */\nconst checkMinSize = (sizes, minSize) => {\n\tfor (const key of Object.keys(minSize)) {\n\t\tconst size = sizes[key];\n\t\tif (size === undefined || size === 0) continue;\n\t\tif (size < minSize[key]) return false;\n\t}\n\treturn true;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSizeReduction the min sizes\n * @param {number} chunkCount number of chunks\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSizeReduction`\n */\nconst checkMinSizeReduction = (sizes, minSizeReduction, chunkCount) => {\n\tfor (const key of Object.keys(minSizeReduction)) {\n\t\tconst size = sizes[key];\n\t\tif (size === undefined || size === 0) continue;\n\t\tif (size * chunkCount < minSizeReduction[key]) return false;\n\t}\n\treturn true;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSize the min sizes\n * @returns {undefined | string[]} list of size types that are below min size\n */\nconst getViolatingMinSizes = (sizes, minSize) => {\n\tlet list;\n\tfor (const key of Object.keys(minSize)) {\n\t\tconst size = sizes[key];\n\t\tif (size === undefined || size === 0) continue;\n\t\tif (size < minSize[key]) {\n\t\t\tif (list === undefined) list = [key];\n\t\t\telse list.push(key);\n\t\t}\n\t}\n\treturn list;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @returns {number} the total size\n */\nconst totalSize = sizes => {\n\tlet size = 0;\n\tfor (const key of Object.keys(sizes)) {\n\t\tsize += sizes[key];\n\t}\n\treturn size;\n};\n\n/**\n * @param {false|string|Function} name the chunk name\n * @returns {GetName} a function to get the name of the chunk\n */\nconst normalizeName = name => {\n\tif (typeof name === \"string\") {\n\t\treturn () => name;\n\t}\n\tif (typeof name === \"function\") {\n\t\treturn /** @type {GetName} */ (name);\n\t}\n};\n\n/**\n * @param {OptimizationSplitChunksCacheGroup[\"chunks\"]} chunks the chunk filter option\n * @returns {ChunkFilterFunction} the chunk filter function\n */\nconst normalizeChunksFilter = chunks => {\n\tif (chunks === \"initial\") {\n\t\treturn INITIAL_CHUNK_FILTER;\n\t}\n\tif (chunks === \"async\") {\n\t\treturn ASYNC_CHUNK_FILTER;\n\t}\n\tif (chunks === \"all\") {\n\t\treturn ALL_CHUNK_FILTER;\n\t}\n\tif (typeof chunks === \"function\") {\n\t\treturn chunks;\n\t}\n};\n\n/**\n * @param {GetCacheGroups | Record<string, false|string|RegExp|OptimizationSplitChunksGetCacheGroups|OptimizationSplitChunksCacheGroup>} cacheGroups the cache group options\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {GetCacheGroups} a function to get the cache groups\n */\nconst normalizeCacheGroups = (cacheGroups, defaultSizeTypes) => {\n\tif (typeof cacheGroups === \"function\") {\n\t\treturn cacheGroups;\n\t}\n\tif (typeof cacheGroups === \"object\" && cacheGroups !== null) {\n\t\t/** @type {(function(Module, CacheGroupsContext, CacheGroupSource[]): void)[]} */\n\t\tconst handlers = [];\n\t\tfor (const key of Object.keys(cacheGroups)) {\n\t\t\tconst option = cacheGroups[key];\n\t\t\tif (option === false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (typeof option === \"string\" || option instanceof RegExp) {\n\t\t\t\tconst source = createCacheGroupSource({}, key, defaultSizeTypes);\n\t\t\t\thandlers.push((module, context, results) => {\n\t\t\t\t\tif (checkTest(option, module, context)) {\n\t\t\t\t\t\tresults.push(source);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (typeof option === \"function\") {\n\t\t\t\tconst cache = new WeakMap();\n\t\t\t\thandlers.push((module, context, results) => {\n\t\t\t\t\tconst result = option(module);\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tconst groups = Array.isArray(result) ? result : [result];\n\t\t\t\t\t\tfor (const group of groups) {\n\t\t\t\t\t\t\tconst cachedSource = cache.get(group);\n\t\t\t\t\t\t\tif (cachedSource !== undefined) {\n\t\t\t\t\t\t\t\tresults.push(cachedSource);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst source = createCacheGroupSource(\n\t\t\t\t\t\t\t\t\tgroup,\n\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\tdefaultSizeTypes\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcache.set(group, source);\n\t\t\t\t\t\t\t\tresults.push(source);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst source = createCacheGroupSource(option, key, defaultSizeTypes);\n\t\t\t\thandlers.push((module, context, results) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tcheckTest(option.test, module, context) &&\n\t\t\t\t\t\tcheckModuleType(option.type, module) &&\n\t\t\t\t\t\tcheckModuleLayer(option.layer, module)\n\t\t\t\t\t) {\n\t\t\t\t\t\tresults.push(source);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * @param {Module} module the current module\n\t\t * @param {CacheGroupsContext} context the current context\n\t\t * @returns {CacheGroupSource[]} the matching cache groups\n\t\t */\n\t\tconst fn = (module, context) => {\n\t\t\t/** @type {CacheGroupSource[]} */\n\t\t\tlet results = [];\n\t\t\tfor (const fn of handlers) {\n\t\t\t\tfn(module, context, results);\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\t\treturn fn;\n\t}\n\treturn () => null;\n};\n\n/**\n * @param {undefined|boolean|string|RegExp|Function} test test option\n * @param {Module} module the module\n * @param {CacheGroupsContext} context context object\n * @returns {boolean} true, if the module should be selected\n */\nconst checkTest = (test, module, context) => {\n\tif (test === undefined) return true;\n\tif (typeof test === \"function\") {\n\t\treturn test(module, context);\n\t}\n\tif (typeof test === \"boolean\") return test;\n\tif (typeof test === \"string\") {\n\t\tconst name = module.nameForCondition();\n\t\treturn name && name.startsWith(test);\n\t}\n\tif (test instanceof RegExp) {\n\t\tconst name = module.nameForCondition();\n\t\treturn name && test.test(name);\n\t}\n\treturn false;\n};\n\n/**\n * @param {undefined|string|RegExp|Function} test type option\n * @param {Module} module the module\n * @returns {boolean} true, if the module should be selected\n */\nconst checkModuleType = (test, module) => {\n\tif (test === undefined) return true;\n\tif (typeof test === \"function\") {\n\t\treturn test(module.type);\n\t}\n\tif (typeof test === \"string\") {\n\t\tconst type = module.type;\n\t\treturn test === type;\n\t}\n\tif (test instanceof RegExp) {\n\t\tconst type = module.type;\n\t\treturn test.test(type);\n\t}\n\treturn false;\n};\n\n/**\n * @param {undefined|string|RegExp|Function} test type option\n * @param {Module} module the module\n * @returns {boolean} true, if the module should be selected\n */\nconst checkModuleLayer = (test, module) => {\n\tif (test === undefined) return true;\n\tif (typeof test === \"function\") {\n\t\treturn test(module.layer);\n\t}\n\tif (typeof test === \"string\") {\n\t\tconst layer = module.layer;\n\t\treturn test === \"\" ? !layer : layer && layer.startsWith(test);\n\t}\n\tif (test instanceof RegExp) {\n\t\tconst layer = module.layer;\n\t\treturn test.test(layer);\n\t}\n\treturn false;\n};\n\n/**\n * @param {OptimizationSplitChunksCacheGroup} options the group options\n * @param {string} key key of cache group\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {CacheGroupSource} the normalized cached group\n */\nconst createCacheGroupSource = (options, key, defaultSizeTypes) => {\n\tconst minSize = normalizeSizes(options.minSize, defaultSizeTypes);\n\tconst minSizeReduction = normalizeSizes(\n\t\toptions.minSizeReduction,\n\t\tdefaultSizeTypes\n\t);\n\tconst maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\n\treturn {\n\t\tkey,\n\t\tpriority: options.priority,\n\t\tgetName: normalizeName(options.name),\n\t\tchunksFilter: normalizeChunksFilter(options.chunks),\n\t\tenforce: options.enforce,\n\t\tminSize,\n\t\tminSizeReduction,\n\t\tminRemainingSize: mergeSizes(\n\t\t\tnormalizeSizes(options.minRemainingSize, defaultSizeTypes),\n\t\t\tminSize\n\t\t),\n\t\tenforceSizeThreshold: normalizeSizes(\n\t\t\toptions.enforceSizeThreshold,\n\t\t\tdefaultSizeTypes\n\t\t),\n\t\tmaxAsyncSize: mergeSizes(\n\t\t\tnormalizeSizes(options.maxAsyncSize, defaultSizeTypes),\n\t\t\tmaxSize\n\t\t),\n\t\tmaxInitialSize: mergeSizes(\n\t\t\tnormalizeSizes(options.maxInitialSize, defaultSizeTypes),\n\t\t\tmaxSize\n\t\t),\n\t\tminChunks: options.minChunks,\n\t\tmaxAsyncRequests: options.maxAsyncRequests,\n\t\tmaxInitialRequests: options.maxInitialRequests,\n\t\tfilename: options.filename,\n\t\tidHint: options.idHint,\n\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\n\t\treuseExistingChunk: options.reuseExistingChunk,\n\t\tusedExports: options.usedExports\n\t};\n};\n\nmodule.exports = class SplitChunksPlugin {\n\t/**\n\t * @param {OptimizationSplitChunksOptions=} options plugin options\n\t */\n\tconstructor(options = {}) {\n\t\tconst defaultSizeTypes = options.defaultSizeTypes || [\n\t\t\t\"javascript\",\n\t\t\t\"unknown\"\n\t\t];\n\t\tconst fallbackCacheGroup = options.fallbackCacheGroup || {};\n\t\tconst minSize = normalizeSizes(options.minSize, defaultSizeTypes);\n\t\tconst minSizeReduction = normalizeSizes(\n\t\t\toptions.minSizeReduction,\n\t\t\tdefaultSizeTypes\n\t\t);\n\t\tconst maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\n\n\t\t/** @type {SplitChunksOptions} */\n\t\tthis.options = {\n\t\t\tchunksFilter: normalizeChunksFilter(options.chunks || \"all\"),\n\t\t\tdefaultSizeTypes,\n\t\t\tminSize,\n\t\t\tminSizeReduction,\n\t\t\tminRemainingSize: mergeSizes(\n\t\t\t\tnormalizeSizes(options.minRemainingSize, defaultSizeTypes),\n\t\t\t\tminSize\n\t\t\t),\n\t\t\tenforceSizeThreshold: normalizeSizes(\n\t\t\t\toptions.enforceSizeThreshold,\n\t\t\t\tdefaultSizeTypes\n\t\t\t),\n\t\t\tmaxAsyncSize: mergeSizes(\n\t\t\t\tnormalizeSizes(options.maxAsyncSize, defaultSizeTypes),\n\t\t\t\tmaxSize\n\t\t\t),\n\t\t\tmaxInitialSize: mergeSizes(\n\t\t\t\tnormalizeSizes(options.maxInitialSize, defaultSizeTypes),\n\t\t\t\tmaxSize\n\t\t\t),\n\t\t\tminChunks: options.minChunks || 1,\n\t\t\tmaxAsyncRequests: options.maxAsyncRequests || 1,\n\t\t\tmaxInitialRequests: options.maxInitialRequests || 1,\n\t\t\thidePathInfo: options.hidePathInfo || false,\n\t\t\tfilename: options.filename || undefined,\n\t\t\tgetCacheGroups: normalizeCacheGroups(\n\t\t\t\toptions.cacheGroups,\n\t\t\t\tdefaultSizeTypes\n\t\t\t),\n\t\t\tgetName: options.name ? normalizeName(options.name) : defaultGetName,\n\t\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\n\t\t\tusedExports: options.usedExports,\n\t\t\tfallbackCacheGroup: {\n\t\t\t\tchunksFilter: normalizeChunksFilter(\n\t\t\t\t\tfallbackCacheGroup.chunks || options.chunks || \"all\"\n\t\t\t\t),\n\t\t\t\tminSize: mergeSizes(\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.minSize, defaultSizeTypes),\n\t\t\t\t\tminSize\n\t\t\t\t),\n\t\t\t\tmaxAsyncSize: mergeSizes(\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxAsyncSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(options.maxAsyncSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(options.maxSize, defaultSizeTypes)\n\t\t\t\t),\n\t\t\t\tmaxInitialSize: mergeSizes(\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxInitialSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(options.maxInitialSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(options.maxSize, defaultSizeTypes)\n\t\t\t\t),\n\t\t\t\tautomaticNameDelimiter:\n\t\t\t\t\tfallbackCacheGroup.automaticNameDelimiter ||\n\t\t\t\t\toptions.automaticNameDelimiter ||\n\t\t\t\t\t\"~\"\n\t\t\t}\n\t\t};\n\n\t\t/** @type {WeakMap<CacheGroupSource, CacheGroup>} */\n\t\tthis._cacheGroupCache = new WeakMap();\n\t}\n\n\t/**\n\t * @param {CacheGroupSource} cacheGroupSource source\n\t * @returns {CacheGroup} the cache group (cached)\n\t */\n\t_getCacheGroup(cacheGroupSource) {\n\t\tconst cacheEntry = this._cacheGroupCache.get(cacheGroupSource);\n\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\tconst minSize = mergeSizes(\n\t\t\tcacheGroupSource.minSize,\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.minSize\n\t\t);\n\t\tconst minSizeReduction = mergeSizes(\n\t\t\tcacheGroupSource.minSizeReduction,\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.minSizeReduction\n\t\t);\n\t\tconst minRemainingSize = mergeSizes(\n\t\t\tcacheGroupSource.minRemainingSize,\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.minRemainingSize\n\t\t);\n\t\tconst enforceSizeThreshold = mergeSizes(\n\t\t\tcacheGroupSource.enforceSizeThreshold,\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.enforceSizeThreshold\n\t\t);\n\t\tconst cacheGroup = {\n\t\t\tkey: cacheGroupSource.key,\n\t\t\tpriority: cacheGroupSource.priority || 0,\n\t\t\tchunksFilter: cacheGroupSource.chunksFilter || this.options.chunksFilter,\n\t\t\tminSize,\n\t\t\tminSizeReduction,\n\t\t\tminRemainingSize,\n\t\t\tenforceSizeThreshold,\n\t\t\tmaxAsyncSize: mergeSizes(\n\t\t\t\tcacheGroupSource.maxAsyncSize,\n\t\t\t\tcacheGroupSource.enforce ? undefined : this.options.maxAsyncSize\n\t\t\t),\n\t\t\tmaxInitialSize: mergeSizes(\n\t\t\t\tcacheGroupSource.maxInitialSize,\n\t\t\t\tcacheGroupSource.enforce ? undefined : this.options.maxInitialSize\n\t\t\t),\n\t\t\tminChunks:\n\t\t\t\tcacheGroupSource.minChunks !== undefined\n\t\t\t\t\t? cacheGroupSource.minChunks\n\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t? 1\n\t\t\t\t\t: this.options.minChunks,\n\t\t\tmaxAsyncRequests:\n\t\t\t\tcacheGroupSource.maxAsyncRequests !== undefined\n\t\t\t\t\t? cacheGroupSource.maxAsyncRequests\n\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t? Infinity\n\t\t\t\t\t: this.options.maxAsyncRequests,\n\t\t\tmaxInitialRequests:\n\t\t\t\tcacheGroupSource.maxInitialRequests !== undefined\n\t\t\t\t\t? cacheGroupSource.maxInitialRequests\n\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t? Infinity\n\t\t\t\t\t: this.options.maxInitialRequests,\n\t\t\tgetName:\n\t\t\t\tcacheGroupSource.getName !== undefined\n\t\t\t\t\t? cacheGroupSource.getName\n\t\t\t\t\t: this.options.getName,\n\t\t\tusedExports:\n\t\t\t\tcacheGroupSource.usedExports !== undefined\n\t\t\t\t\t? cacheGroupSource.usedExports\n\t\t\t\t\t: this.options.usedExports,\n\t\t\tfilename:\n\t\t\t\tcacheGroupSource.filename !== undefined\n\t\t\t\t\t? cacheGroupSource.filename\n\t\t\t\t\t: this.options.filename,\n\t\t\tautomaticNameDelimiter:\n\t\t\t\tcacheGroupSource.automaticNameDelimiter !== undefined\n\t\t\t\t\t? cacheGroupSource.automaticNameDelimiter\n\t\t\t\t\t: this.options.automaticNameDelimiter,\n\t\t\tidHint:\n\t\t\t\tcacheGroupSource.idHint !== undefined\n\t\t\t\t\t? cacheGroupSource.idHint\n\t\t\t\t\t: cacheGroupSource.key,\n\t\t\treuseExistingChunk: cacheGroupSource.reuseExistingChunk || false,\n\t\t\t_validateSize: hasNonZeroSizes(minSize),\n\t\t\t_validateRemainingSize: hasNonZeroSizes(minRemainingSize),\n\t\t\t_minSizeForMaxSize: mergeSizes(\n\t\t\t\tcacheGroupSource.minSize,\n\t\t\t\tthis.options.minSize\n\t\t\t),\n\t\t\t_conditionalEnforce: hasNonZeroSizes(enforceSizeThreshold)\n\t\t};\n\t\tthis._cacheGroupCache.set(cacheGroupSource, cacheGroup);\n\t\treturn cacheGroup;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst cachedMakePathsRelative = makePathsRelative.bindContextCache(\n\t\t\tcompiler.context,\n\t\t\tcompiler.root\n\t\t);\n\t\tcompiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", compilation => {\n\t\t\tconst logger = compilation.getLogger(\"webpack.SplitChunksPlugin\");\n\t\t\tlet alreadyOptimized = false;\n\t\t\tcompilation.hooks.unseal.tap(\"SplitChunksPlugin\", () => {\n\t\t\t\talreadyOptimized = false;\n\t\t\t});\n\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t{\n\t\t\t\t\tname: \"SplitChunksPlugin\",\n\t\t\t\t\tstage: STAGE_ADVANCED\n\t\t\t\t},\n\t\t\t\tchunks => {\n\t\t\t\t\tif (alreadyOptimized) return;\n\t\t\t\t\talreadyOptimized = true;\n\t\t\t\t\tlogger.time(\"prepare\");\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\t\t\t// Give each selected chunk an index (to create strings from chunks)\n\t\t\t\t\t/** @type {Map<Chunk, bigint>} */\n\t\t\t\t\tconst chunkIndexMap = new Map();\n\t\t\t\t\tconst ZERO = BigInt(\"0\");\n\t\t\t\t\tconst ONE = BigInt(\"1\");\n\t\t\t\t\tconst START = ONE << BigInt(\"31\");\n\t\t\t\t\tlet index = START;\n\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\tchunkIndexMap.set(\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tindex | BigInt((Math.random() * 0x7fffffff) | 0)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tindex = index << ONE;\n\t\t\t\t\t}\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Iterable<Chunk>} chunks list of chunks\n\t\t\t\t\t * @returns {bigint | Chunk} key of the chunks\n\t\t\t\t\t */\n\t\t\t\t\tconst getKey = chunks => {\n\t\t\t\t\t\tconst iterator = chunks[Symbol.iterator]();\n\t\t\t\t\t\tlet result = iterator.next();\n\t\t\t\t\t\tif (result.done) return ZERO;\n\t\t\t\t\t\tconst first = result.value;\n\t\t\t\t\t\tresult = iterator.next();\n\t\t\t\t\t\tif (result.done) return first;\n\t\t\t\t\t\tlet key =\n\t\t\t\t\t\t\tchunkIndexMap.get(first) | chunkIndexMap.get(result.value);\n\t\t\t\t\t\twhile (!(result = iterator.next()).done) {\n\t\t\t\t\t\t\tconst raw = chunkIndexMap.get(result.value);\n\t\t\t\t\t\t\tkey = key ^ raw;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn key;\n\t\t\t\t\t};\n\t\t\t\t\tconst keyToString = key => {\n\t\t\t\t\t\tif (typeof key === \"bigint\") return key.toString(16);\n\t\t\t\t\t\treturn chunkIndexMap.get(key).toString(16);\n\t\t\t\t\t};\n\n\t\t\t\t\tconst getChunkSetsInGraph = memoize(() => {\n\t\t\t\t\t\t/** @type {Map<bigint, Set<Chunk>>} */\n\t\t\t\t\t\tconst chunkSetsInGraph = new Map();\n\t\t\t\t\t\t/** @type {Set<Chunk>} */\n\t\t\t\t\t\tconst singleChunkSets = new Set();\n\t\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t\tconst chunks = chunkGraph.getModuleChunksIterable(module);\n\t\t\t\t\t\t\tconst chunksKey = getKey(chunks);\n\t\t\t\t\t\t\tif (typeof chunksKey === \"bigint\") {\n\t\t\t\t\t\t\t\tif (!chunkSetsInGraph.has(chunksKey)) {\n\t\t\t\t\t\t\t\t\tchunkSetsInGraph.set(chunksKey, new Set(chunks));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsingleChunkSets.add(chunksKey);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn { chunkSetsInGraph, singleChunkSets };\n\t\t\t\t\t});\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Module} module the module\n\t\t\t\t\t * @returns {Iterable<Chunk[]>} groups of chunks with equal exports\n\t\t\t\t\t */\n\t\t\t\t\tconst groupChunksByExports = module => {\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\tconst groupedByUsedExports = new Map();\n\t\t\t\t\t\tfor (const chunk of chunkGraph.getModuleChunksIterable(module)) {\n\t\t\t\t\t\t\tconst key = exportsInfo.getUsageKey(chunk.runtime);\n\t\t\t\t\t\t\tconst list = groupedByUsedExports.get(key);\n\t\t\t\t\t\t\tif (list !== undefined) {\n\t\t\t\t\t\t\t\tlist.push(chunk);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgroupedByUsedExports.set(key, [chunk]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn groupedByUsedExports.values();\n\t\t\t\t\t};\n\n\t\t\t\t\t/** @type {Map<Module, Iterable<Chunk[]>>} */\n\t\t\t\t\tconst groupedByExportsMap = new Map();\n\n\t\t\t\t\tconst getExportsChunkSetsInGraph = memoize(() => {\n\t\t\t\t\t\t/** @type {Map<bigint, Set<Chunk>>} */\n\t\t\t\t\t\tconst chunkSetsInGraph = new Map();\n\t\t\t\t\t\t/** @type {Set<Chunk>} */\n\t\t\t\t\t\tconst singleChunkSets = new Set();\n\t\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t\tconst groupedChunks = Array.from(groupChunksByExports(module));\n\t\t\t\t\t\t\tgroupedByExportsMap.set(module, groupedChunks);\n\t\t\t\t\t\t\tfor (const chunks of groupedChunks) {\n\t\t\t\t\t\t\t\tif (chunks.length === 1) {\n\t\t\t\t\t\t\t\t\tsingleChunkSets.add(chunks[0]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst chunksKey = /** @type {bigint} */ (getKey(chunks));\n\t\t\t\t\t\t\t\t\tif (!chunkSetsInGraph.has(chunksKey)) {\n\t\t\t\t\t\t\t\t\t\tchunkSetsInGraph.set(chunksKey, new Set(chunks));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn { chunkSetsInGraph, singleChunkSets };\n\t\t\t\t\t});\n\n\t\t\t\t\t// group these set of chunks by count\n\t\t\t\t\t// to allow to check less sets via isSubset\n\t\t\t\t\t// (only smaller sets can be subset)\n\t\t\t\t\tconst groupChunkSetsByCount = chunkSets => {\n\t\t\t\t\t\t/** @type {Map<number, Array<Set<Chunk>>>} */\n\t\t\t\t\t\tconst chunkSetsByCount = new Map();\n\t\t\t\t\t\tfor (const chunksSet of chunkSets) {\n\t\t\t\t\t\t\tconst count = chunksSet.size;\n\t\t\t\t\t\t\tlet array = chunkSetsByCount.get(count);\n\t\t\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\t\t\tchunkSetsByCount.set(count, array);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tarray.push(chunksSet);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn chunkSetsByCount;\n\t\t\t\t\t};\n\t\t\t\t\tconst getChunkSetsByCount = memoize(() =>\n\t\t\t\t\t\tgroupChunkSetsByCount(\n\t\t\t\t\t\t\tgetChunkSetsInGraph().chunkSetsInGraph.values()\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\tconst getExportsChunkSetsByCount = memoize(() =>\n\t\t\t\t\t\tgroupChunkSetsByCount(\n\t\t\t\t\t\t\tgetExportsChunkSetsInGraph().chunkSetsInGraph.values()\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\t// Create a list of possible combinations\n\t\t\t\t\tconst createGetCombinations = (\n\t\t\t\t\t\tchunkSets,\n\t\t\t\t\t\tsingleChunkSets,\n\t\t\t\t\t\tchunkSetsByCount\n\t\t\t\t\t) => {\n\t\t\t\t\t\t/** @type {Map<bigint | Chunk, (Set<Chunk> | Chunk)[]>} */\n\t\t\t\t\t\tconst combinationsCache = new Map();\n\n\t\t\t\t\t\treturn key => {\n\t\t\t\t\t\t\tconst cacheEntry = combinationsCache.get(key);\n\t\t\t\t\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\t\t\t\t\tif (key instanceof Chunk) {\n\t\t\t\t\t\t\t\tconst result = [key];\n\t\t\t\t\t\t\t\tcombinationsCache.set(key, result);\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst chunksSet = chunkSets.get(key);\n\t\t\t\t\t\t\t/** @type {(Set<Chunk> | Chunk)[]} */\n\t\t\t\t\t\t\tconst array = [chunksSet];\n\t\t\t\t\t\t\tfor (const [count, setArray] of chunkSetsByCount) {\n\t\t\t\t\t\t\t\t// \"equal\" is not needed because they would have been merge in the first step\n\t\t\t\t\t\t\t\tif (count < chunksSet.size) {\n\t\t\t\t\t\t\t\t\tfor (const set of setArray) {\n\t\t\t\t\t\t\t\t\t\tif (isSubset(chunksSet, set)) {\n\t\t\t\t\t\t\t\t\t\t\tarray.push(set);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const chunk of singleChunkSets) {\n\t\t\t\t\t\t\t\tif (chunksSet.has(chunk)) {\n\t\t\t\t\t\t\t\t\tarray.push(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcombinationsCache.set(key, array);\n\t\t\t\t\t\t\treturn array;\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\n\t\t\t\t\tconst getCombinationsFactory = memoize(() => {\n\t\t\t\t\t\tconst { chunkSetsInGraph, singleChunkSets } = getChunkSetsInGraph();\n\t\t\t\t\t\treturn createGetCombinations(\n\t\t\t\t\t\t\tchunkSetsInGraph,\n\t\t\t\t\t\t\tsingleChunkSets,\n\t\t\t\t\t\t\tgetChunkSetsByCount()\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\tconst getCombinations = key => getCombinationsFactory()(key);\n\n\t\t\t\t\tconst getExportsCombinationsFactory = memoize(() => {\n\t\t\t\t\t\tconst { chunkSetsInGraph, singleChunkSets } =\n\t\t\t\t\t\t\tgetExportsChunkSetsInGraph();\n\t\t\t\t\t\treturn createGetCombinations(\n\t\t\t\t\t\t\tchunkSetsInGraph,\n\t\t\t\t\t\t\tsingleChunkSets,\n\t\t\t\t\t\t\tgetExportsChunkSetsByCount()\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\tconst getExportsCombinations = key =>\n\t\t\t\t\t\tgetExportsCombinationsFactory()(key);\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {Object} SelectedChunksResult\n\t\t\t\t\t * @property {Chunk[]} chunks the list of chunks\n\t\t\t\t\t * @property {bigint | Chunk} key a key of the list\n\t\t\t\t\t */\n\n\t\t\t\t\t/** @type {WeakMap<Set<Chunk> | Chunk, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n\t\t\t\t\tconst selectedChunksCacheByChunksSet = new WeakMap();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * get list and key by applying the filter function to the list\n\t\t\t\t\t * It is cached for performance reasons\n\t\t\t\t\t * @param {Set<Chunk> | Chunk} chunks list of chunks\n\t\t\t\t\t * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n\t\t\t\t\t * @returns {SelectedChunksResult} list and key\n\t\t\t\t\t */\n\t\t\t\t\tconst getSelectedChunks = (chunks, chunkFilter) => {\n\t\t\t\t\t\tlet entry = selectedChunksCacheByChunksSet.get(chunks);\n\t\t\t\t\t\tif (entry === undefined) {\n\t\t\t\t\t\t\tentry = new WeakMap();\n\t\t\t\t\t\t\tselectedChunksCacheByChunksSet.set(chunks, entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/** @type {SelectedChunksResult} */\n\t\t\t\t\t\tlet entry2 = entry.get(chunkFilter);\n\t\t\t\t\t\tif (entry2 === undefined) {\n\t\t\t\t\t\t\t/** @type {Chunk[]} */\n\t\t\t\t\t\t\tconst selectedChunks = [];\n\t\t\t\t\t\t\tif (chunks instanceof Chunk) {\n\t\t\t\t\t\t\t\tif (chunkFilter(chunks)) selectedChunks.push(chunks);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\t\t\tif (chunkFilter(chunk)) selectedChunks.push(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tentry2 = {\n\t\t\t\t\t\t\t\tchunks: selectedChunks,\n\t\t\t\t\t\t\t\tkey: getKey(selectedChunks)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tentry.set(chunkFilter, entry2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn entry2;\n\t\t\t\t\t};\n\n\t\t\t\t\t/** @type {Map<string, boolean>} */\n\t\t\t\t\tconst alreadyValidatedParents = new Map();\n\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\tconst alreadyReportedErrors = new Set();\n\n\t\t\t\t\t// Map a list of chunks to a list of modules\n\t\t\t\t\t// For the key the chunk \"index\" is used, the value is a SortableSet of modules\n\t\t\t\t\t/** @type {Map<string, ChunksInfoItem>} */\n\t\t\t\t\tconst chunksInfoMap = new Map();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {CacheGroup} cacheGroup the current cache group\n\t\t\t\t\t * @param {number} cacheGroupIndex the index of the cache group of ordering\n\t\t\t\t\t * @param {Chunk[]} selectedChunks chunks selected for this module\n\t\t\t\t\t * @param {bigint | Chunk} selectedChunksKey a key of selectedChunks\n\t\t\t\t\t * @param {Module} module the current module\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst addModuleToChunksInfoMap = (\n\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\tselectedChunksKey,\n\t\t\t\t\t\tmodule\n\t\t\t\t\t) => {\n\t\t\t\t\t\t// Break if minimum number of chunks is not reached\n\t\t\t\t\t\tif (selectedChunks.length < cacheGroup.minChunks) return;\n\t\t\t\t\t\t// Determine name for split chunk\n\t\t\t\t\t\tconst name = cacheGroup.getName(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\t\tcacheGroup.key\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// Check if the name is ok\n\t\t\t\t\t\tconst existingChunk = compilation.namedChunks.get(name);\n\t\t\t\t\t\tif (existingChunk) {\n\t\t\t\t\t\t\tconst parentValidationKey = `${name}|${\n\t\t\t\t\t\t\t\ttypeof selectedChunksKey === \"bigint\"\n\t\t\t\t\t\t\t\t\t? selectedChunksKey\n\t\t\t\t\t\t\t\t\t: selectedChunksKey.debugId\n\t\t\t\t\t\t\t}`;\n\t\t\t\t\t\t\tconst valid = alreadyValidatedParents.get(parentValidationKey);\n\t\t\t\t\t\t\tif (valid === false) return;\n\t\t\t\t\t\t\tif (valid === undefined) {\n\t\t\t\t\t\t\t\t// Module can only be moved into the existing chunk if the existing chunk\n\t\t\t\t\t\t\t\t// is a parent of all selected chunks\n\t\t\t\t\t\t\t\tlet isInAllParents = true;\n\t\t\t\t\t\t\t\t/** @type {Set<ChunkGroup>} */\n\t\t\t\t\t\t\t\tconst queue = new Set();\n\t\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\t\tfor (const group of chunk.groupsIterable) {\n\t\t\t\t\t\t\t\t\t\tqueue.add(group);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const group of queue) {\n\t\t\t\t\t\t\t\t\tif (existingChunk.isInGroup(group)) continue;\n\t\t\t\t\t\t\t\t\tlet hasParent = false;\n\t\t\t\t\t\t\t\t\tfor (const parent of group.parentsIterable) {\n\t\t\t\t\t\t\t\t\t\thasParent = true;\n\t\t\t\t\t\t\t\t\t\tqueue.add(parent);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!hasParent) {\n\t\t\t\t\t\t\t\t\t\tisInAllParents = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst valid = isInAllParents;\n\t\t\t\t\t\t\t\talreadyValidatedParents.set(parentValidationKey, valid);\n\t\t\t\t\t\t\t\tif (!valid) {\n\t\t\t\t\t\t\t\t\tif (!alreadyReportedErrors.has(name)) {\n\t\t\t\t\t\t\t\t\t\talreadyReportedErrors.add(name);\n\t\t\t\t\t\t\t\t\t\tcompilation.errors.push(\n\t\t\t\t\t\t\t\t\t\t\tnew WebpackError(\n\t\t\t\t\t\t\t\t\t\t\t\t\"SplitChunksPlugin\\n\" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t`Cache group \"${cacheGroup.key}\" conflicts with existing chunk.\\n` +\n\t\t\t\t\t\t\t\t\t\t\t\t\t`Both have the same name \"${name}\" and existing chunk is not a parent of the selected modules.\\n` +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Use a different name for the cache group or make sure that the existing chunk is a parent (e. g. via dependOn).\\n\" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t'HINT: You can omit \"name\" to automatically create a name.\\n' +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"BREAKING CHANGE: webpack < 5 used to allow to use an entrypoint as splitChunk. \" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"This is no longer allowed when the entrypoint is not a parent of the selected modules.\\n\" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Remove this entrypoint and add modules to cache group's 'test' instead. \" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"If you need modules to be evaluated on startup, add them to the existing entrypoints (make them arrays). \" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"See migration guide of more info.\"\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Create key for maps\n\t\t\t\t\t\t// When it has a name we use the name as key\n\t\t\t\t\t\t// Otherwise we create the key from chunks and cache group key\n\t\t\t\t\t\t// This automatically merges equal names\n\t\t\t\t\t\tconst key =\n\t\t\t\t\t\t\tcacheGroup.key +\n\t\t\t\t\t\t\t(name\n\t\t\t\t\t\t\t\t? ` name:${name}`\n\t\t\t\t\t\t\t\t: ` chunks:${keyToString(selectedChunksKey)}`);\n\t\t\t\t\t\t// Add module to maps\n\t\t\t\t\t\tlet info = chunksInfoMap.get(key);\n\t\t\t\t\t\tif (info === undefined) {\n\t\t\t\t\t\t\tchunksInfoMap.set(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t(info = {\n\t\t\t\t\t\t\t\t\tmodules: new SortableSet(\n\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t\tcompareModulesByIdentifier\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\t\tsizes: {},\n\t\t\t\t\t\t\t\t\tchunks: new Set(),\n\t\t\t\t\t\t\t\t\treuseableChunks: new Set(),\n\t\t\t\t\t\t\t\t\tchunksKeys: new Set()\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst oldSize = info.modules.size;\n\t\t\t\t\t\tinfo.modules.add(module);\n\t\t\t\t\t\tif (info.modules.size !== oldSize) {\n\t\t\t\t\t\t\tfor (const type of module.getSourceTypes()) {\n\t\t\t\t\t\t\t\tinfo.sizes[type] = (info.sizes[type] || 0) + module.size(type);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst oldChunksKeysSize = info.chunksKeys.size;\n\t\t\t\t\t\tinfo.chunksKeys.add(selectedChunksKey);\n\t\t\t\t\t\tif (oldChunksKeysSize !== info.chunksKeys.size) {\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\tinfo.chunks.add(chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tconst context = {\n\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\tchunkGraph\n\t\t\t\t\t};\n\n\t\t\t\t\tlogger.timeEnd(\"prepare\");\n\n\t\t\t\t\tlogger.time(\"modules\");\n\n\t\t\t\t\t// Walk through all modules\n\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t// Get cache group\n\t\t\t\t\t\tlet cacheGroups = this.options.getCacheGroups(module, context);\n\t\t\t\t\t\tif (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Prepare some values (usedExports = false)\n\t\t\t\t\t\tconst getCombs = memoize(() => {\n\t\t\t\t\t\t\tconst chunks = chunkGraph.getModuleChunksIterable(module);\n\t\t\t\t\t\t\tconst chunksKey = getKey(chunks);\n\t\t\t\t\t\t\treturn getCombinations(chunksKey);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Prepare some values (usedExports = true)\n\t\t\t\t\t\tconst getCombsByUsedExports = memoize(() => {\n\t\t\t\t\t\t\t// fill the groupedByExportsMap\n\t\t\t\t\t\t\tgetExportsChunkSetsInGraph();\n\t\t\t\t\t\t\t/** @type {Set<Set<Chunk> | Chunk>} */\n\t\t\t\t\t\t\tconst set = new Set();\n\t\t\t\t\t\t\tconst groupedByUsedExports = groupedByExportsMap.get(module);\n\t\t\t\t\t\t\tfor (const chunks of groupedByUsedExports) {\n\t\t\t\t\t\t\t\tconst chunksKey = getKey(chunks);\n\t\t\t\t\t\t\t\tfor (const comb of getExportsCombinations(chunksKey))\n\t\t\t\t\t\t\t\t\tset.add(comb);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn set;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tlet cacheGroupIndex = 0;\n\t\t\t\t\t\tfor (const cacheGroupSource of cacheGroups) {\n\t\t\t\t\t\t\tconst cacheGroup = this._getCacheGroup(cacheGroupSource);\n\n\t\t\t\t\t\t\tconst combs = cacheGroup.usedExports\n\t\t\t\t\t\t\t\t? getCombsByUsedExports()\n\t\t\t\t\t\t\t\t: getCombs();\n\t\t\t\t\t\t\t// For all combination of chunk selection\n\t\t\t\t\t\t\tfor (const chunkCombination of combs) {\n\t\t\t\t\t\t\t\t// Break if minimum number of chunks is not reached\n\t\t\t\t\t\t\t\tconst count =\n\t\t\t\t\t\t\t\t\tchunkCombination instanceof Chunk ? 1 : chunkCombination.size;\n\t\t\t\t\t\t\t\tif (count < cacheGroup.minChunks) continue;\n\t\t\t\t\t\t\t\t// Select chunks by configuration\n\t\t\t\t\t\t\t\tconst { chunks: selectedChunks, key: selectedChunksKey } =\n\t\t\t\t\t\t\t\t\tgetSelectedChunks(chunkCombination, cacheGroup.chunksFilter);\n\n\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\n\t\t\t\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\t\t\t\tselectedChunksKey,\n\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcacheGroupIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlogger.timeEnd(\"modules\");\n\n\t\t\t\t\tlogger.time(\"queue\");\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {ChunksInfoItem} info entry\n\t\t\t\t\t * @param {string[]} sourceTypes source types to be removed\n\t\t\t\t\t */\n\t\t\t\t\tconst removeModulesWithSourceType = (info, sourceTypes) => {\n\t\t\t\t\t\tfor (const module of info.modules) {\n\t\t\t\t\t\t\tconst types = module.getSourceTypes();\n\t\t\t\t\t\t\tif (sourceTypes.some(type => types.has(type))) {\n\t\t\t\t\t\t\t\tinfo.modules.delete(module);\n\t\t\t\t\t\t\t\tfor (const type of types) {\n\t\t\t\t\t\t\t\t\tinfo.sizes[type] -= module.size(type);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {ChunksInfoItem} info entry\n\t\t\t\t\t * @returns {boolean} true, if entry become empty\n\t\t\t\t\t */\n\t\t\t\t\tconst removeMinSizeViolatingModules = info => {\n\t\t\t\t\t\tif (!info.cacheGroup._validateSize) return false;\n\t\t\t\t\t\tconst violatingSizes = getViolatingMinSizes(\n\t\t\t\t\t\t\tinfo.sizes,\n\t\t\t\t\t\t\tinfo.cacheGroup.minSize\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (violatingSizes === undefined) return false;\n\t\t\t\t\t\tremoveModulesWithSourceType(info, violatingSizes);\n\t\t\t\t\t\treturn info.modules.size === 0;\n\t\t\t\t\t};\n\n\t\t\t\t\t// Filter items were size < minSize\n\t\t\t\t\tfor (const [key, info] of chunksInfoMap) {\n\t\t\t\t\t\tif (removeMinSizeViolatingModules(info)) {\n\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t!checkMinSizeReduction(\n\t\t\t\t\t\t\t\tinfo.sizes,\n\t\t\t\t\t\t\t\tinfo.cacheGroup.minSizeReduction,\n\t\t\t\t\t\t\t\tinfo.chunks.size\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {Object} MaxSizeQueueItem\n\t\t\t\t\t * @property {SplitChunksSizes} minSize\n\t\t\t\t\t * @property {SplitChunksSizes} maxAsyncSize\n\t\t\t\t\t * @property {SplitChunksSizes} maxInitialSize\n\t\t\t\t\t * @property {string} automaticNameDelimiter\n\t\t\t\t\t * @property {string[]} keys\n\t\t\t\t\t */\n\n\t\t\t\t\t/** @type {Map<Chunk, MaxSizeQueueItem>} */\n\t\t\t\t\tconst maxSizeQueueMap = new Map();\n\n\t\t\t\t\twhile (chunksInfoMap.size > 0) {\n\t\t\t\t\t\t// Find best matching entry\n\t\t\t\t\t\tlet bestEntryKey;\n\t\t\t\t\t\tlet bestEntry;\n\t\t\t\t\t\tfor (const pair of chunksInfoMap) {\n\t\t\t\t\t\t\tconst key = pair[0];\n\t\t\t\t\t\t\tconst info = pair[1];\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tbestEntry === undefined ||\n\t\t\t\t\t\t\t\tcompareEntries(bestEntry, info) < 0\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tbestEntry = info;\n\t\t\t\t\t\t\t\tbestEntryKey = key;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst item = bestEntry;\n\t\t\t\t\t\tchunksInfoMap.delete(bestEntryKey);\n\n\t\t\t\t\t\tlet chunkName = item.name;\n\t\t\t\t\t\t// Variable for the new chunk (lazy created)\n\t\t\t\t\t\t/** @type {Chunk} */\n\t\t\t\t\t\tlet newChunk;\n\t\t\t\t\t\t// When no chunk name, check if we can reuse a chunk instead of creating a new one\n\t\t\t\t\t\tlet isExistingChunk = false;\n\t\t\t\t\t\tlet isReusedWithAllModules = false;\n\t\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\t\tconst chunkByName = compilation.namedChunks.get(chunkName);\n\t\t\t\t\t\t\tif (chunkByName !== undefined) {\n\t\t\t\t\t\t\t\tnewChunk = chunkByName;\n\t\t\t\t\t\t\t\tconst oldSize = item.chunks.size;\n\t\t\t\t\t\t\t\titem.chunks.delete(newChunk);\n\t\t\t\t\t\t\t\tisExistingChunk = item.chunks.size !== oldSize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (item.cacheGroup.reuseExistingChunk) {\n\t\t\t\t\t\t\touter: for (const chunk of item.chunks) {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(chunk) !==\n\t\t\t\t\t\t\t\t\titem.modules.size\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\titem.chunks.size > 1 &&\n\t\t\t\t\t\t\t\t\tchunkGraph.getNumberOfEntryModules(chunk) > 0\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\tif (!chunkGraph.isModuleInChunk(module, chunk)) {\n\t\t\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!newChunk || !newChunk.name) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tchunk.name &&\n\t\t\t\t\t\t\t\t\tchunk.name.length < newChunk.name.length\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tchunk.name &&\n\t\t\t\t\t\t\t\t\tchunk.name.length === newChunk.name.length &&\n\t\t\t\t\t\t\t\t\tchunk.name < newChunk.name\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (newChunk) {\n\t\t\t\t\t\t\t\titem.chunks.delete(newChunk);\n\t\t\t\t\t\t\t\tchunkName = undefined;\n\t\t\t\t\t\t\t\tisExistingChunk = true;\n\t\t\t\t\t\t\t\tisReusedWithAllModules = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst enforced =\n\t\t\t\t\t\t\titem.cacheGroup._conditionalEnforce &&\n\t\t\t\t\t\t\tcheckMinSize(item.sizes, item.cacheGroup.enforceSizeThreshold);\n\n\t\t\t\t\t\tconst usedChunks = new Set(item.chunks);\n\n\t\t\t\t\t\t// Check if maxRequests condition can be fulfilled\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!enforced &&\n\t\t\t\t\t\t\t(Number.isFinite(item.cacheGroup.maxInitialRequests) ||\n\t\t\t\t\t\t\t\tNumber.isFinite(item.cacheGroup.maxAsyncRequests))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t// respect max requests\n\t\t\t\t\t\t\t\tconst maxRequests = chunk.isOnlyInitial()\n\t\t\t\t\t\t\t\t\t? item.cacheGroup.maxInitialRequests\n\t\t\t\t\t\t\t\t\t: chunk.canBeInitial()\n\t\t\t\t\t\t\t\t\t? Math.min(\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxInitialRequests,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxAsyncRequests\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxAsyncRequests;\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tisFinite(maxRequests) &&\n\t\t\t\t\t\t\t\t\tgetRequests(chunk) >= maxRequests\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tusedChunks.delete(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\touter: for (const chunk of usedChunks) {\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tif (chunkGraph.isModuleInChunk(module, chunk)) continue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tusedChunks.delete(chunk);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Were some (invalid) chunks removed from usedChunks?\n\t\t\t\t\t\t// => readd all modules to the queue, as things could have been changed\n\t\t\t\t\t\tif (usedChunks.size < item.chunks.size) {\n\t\t\t\t\t\t\tif (isExistingChunk) usedChunks.add(newChunk);\n\t\t\t\t\t\t\tif (usedChunks.size >= item.cacheGroup.minChunks) {\n\t\t\t\t\t\t\t\tconst chunksArr = Array.from(usedChunks);\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\n\t\t\t\t\t\t\t\t\t\titem.cacheGroup,\n\t\t\t\t\t\t\t\t\t\titem.cacheGroupIndex,\n\t\t\t\t\t\t\t\t\t\tchunksArr,\n\t\t\t\t\t\t\t\t\t\tgetKey(usedChunks),\n\t\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Validate minRemainingSize constraint when a single chunk is left over\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!enforced &&\n\t\t\t\t\t\t\titem.cacheGroup._validateRemainingSize &&\n\t\t\t\t\t\t\tusedChunks.size === 1\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst [chunk] = usedChunks;\n\t\t\t\t\t\t\tlet chunkSizes = Object.create(null);\n\t\t\t\t\t\t\tfor (const module of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\t\t\t\t\t\tif (!item.modules.has(module)) {\n\t\t\t\t\t\t\t\t\tfor (const type of module.getSourceTypes()) {\n\t\t\t\t\t\t\t\t\t\tchunkSizes[type] =\n\t\t\t\t\t\t\t\t\t\t\t(chunkSizes[type] || 0) + module.size(type);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst violatingSizes = getViolatingMinSizes(\n\t\t\t\t\t\t\t\tchunkSizes,\n\t\t\t\t\t\t\t\titem.cacheGroup.minRemainingSize\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (violatingSizes !== undefined) {\n\t\t\t\t\t\t\t\tconst oldModulesSize = item.modules.size;\n\t\t\t\t\t\t\t\tremoveModulesWithSourceType(item, violatingSizes);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\titem.modules.size > 0 &&\n\t\t\t\t\t\t\t\t\titem.modules.size !== oldModulesSize\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t// queue this item again to be processed again\n\t\t\t\t\t\t\t\t\t// without violating modules\n\t\t\t\t\t\t\t\t\tchunksInfoMap.set(bestEntryKey, item);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Create the new chunk if not reusing one\n\t\t\t\t\t\tif (newChunk === undefined) {\n\t\t\t\t\t\t\tnewChunk = compilation.addChunk(chunkName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Walk through all chunks\n\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t// Add graph connections for splitted chunk\n\t\t\t\t\t\t\tchunk.split(newChunk);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add a note to the chunk\n\t\t\t\t\t\tnewChunk.chunkReason =\n\t\t\t\t\t\t\t(newChunk.chunkReason ? newChunk.chunkReason + \", \" : \"\") +\n\t\t\t\t\t\t\t(isReusedWithAllModules\n\t\t\t\t\t\t\t\t? \"reused as split chunk\"\n\t\t\t\t\t\t\t\t: \"split chunk\");\n\t\t\t\t\t\tif (item.cacheGroup.key) {\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (name: ${chunkName})`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (item.cacheGroup.filename) {\n\t\t\t\t\t\t\tnewChunk.filenameTemplate = item.cacheGroup.filename;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (item.cacheGroup.idHint) {\n\t\t\t\t\t\t\tnewChunk.idNameHints.add(item.cacheGroup.idHint);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!isReusedWithAllModules) {\n\t\t\t\t\t\t\t// Add all modules to the new chunk\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tif (!module.chunkCondition(newChunk, compilation)) continue;\n\t\t\t\t\t\t\t\t// Add module to new chunk\n\t\t\t\t\t\t\t\tchunkGraph.connectChunkAndModule(newChunk, module);\n\t\t\t\t\t\t\t\t// Remove module from used chunks\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Remove all modules from used chunks\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tObject.keys(item.cacheGroup.maxAsyncSize).length > 0 ||\n\t\t\t\t\t\t\tObject.keys(item.cacheGroup.maxInitialSize).length > 0\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n\t\t\t\t\t\t\tmaxSizeQueueMap.set(newChunk, {\n\t\t\t\t\t\t\t\tminSize: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? combineSizes(\n\t\t\t\t\t\t\t\t\t\t\toldMaxSizeSettings.minSize,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup._minSizeForMaxSize,\n\t\t\t\t\t\t\t\t\t\t\tMath.max\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.minSize,\n\t\t\t\t\t\t\t\tmaxAsyncSize: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? combineSizes(\n\t\t\t\t\t\t\t\t\t\t\toldMaxSizeSettings.maxAsyncSize,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxAsyncSize,\n\t\t\t\t\t\t\t\t\t\t\tMath.min\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxAsyncSize,\n\t\t\t\t\t\t\t\tmaxInitialSize: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? combineSizes(\n\t\t\t\t\t\t\t\t\t\t\toldMaxSizeSettings.maxInitialSize,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxInitialSize,\n\t\t\t\t\t\t\t\t\t\t\tMath.min\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxInitialSize,\n\t\t\t\t\t\t\t\tautomaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n\t\t\t\t\t\t\t\tkeys: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? oldMaxSizeSettings.keys.concat(item.cacheGroup.key)\n\t\t\t\t\t\t\t\t\t: [item.cacheGroup.key]\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// remove all modules from other entries and update size\n\t\t\t\t\t\tfor (const [key, info] of chunksInfoMap) {\n\t\t\t\t\t\t\tif (isOverlap(info.chunks, usedChunks)) {\n\t\t\t\t\t\t\t\t// update modules and total size\n\t\t\t\t\t\t\t\t// may remove it from the map when < minSize\n\t\t\t\t\t\t\t\tlet updated = false;\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\tif (info.modules.has(module)) {\n\t\t\t\t\t\t\t\t\t\t// remove module\n\t\t\t\t\t\t\t\t\t\tinfo.modules.delete(module);\n\t\t\t\t\t\t\t\t\t\t// update size\n\t\t\t\t\t\t\t\t\t\tfor (const key of module.getSourceTypes()) {\n\t\t\t\t\t\t\t\t\t\t\tinfo.sizes[key] -= module.size(key);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (updated) {\n\t\t\t\t\t\t\t\t\tif (info.modules.size === 0) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tremoveMinSizeViolatingModules(info) ||\n\t\t\t\t\t\t\t\t\t\t!checkMinSizeReduction(\n\t\t\t\t\t\t\t\t\t\t\tinfo.sizes,\n\t\t\t\t\t\t\t\t\t\t\tinfo.cacheGroup.minSizeReduction,\n\t\t\t\t\t\t\t\t\t\t\tinfo.chunks.size\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlogger.timeEnd(\"queue\");\n\n\t\t\t\t\tlogger.time(\"maxSize\");\n\n\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\tconst incorrectMinMaxSizeSet = new Set();\n\n\t\t\t\t\tconst { outputOptions } = compilation;\n\n\t\t\t\t\t// Make sure that maxSize is fulfilled\n\t\t\t\t\tconst { fallbackCacheGroup } = this.options;\n\t\t\t\t\tfor (const chunk of Array.from(compilation.chunks)) {\n\t\t\t\t\t\tconst chunkConfig = maxSizeQueueMap.get(chunk);\n\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\tminSize,\n\t\t\t\t\t\t\tmaxAsyncSize,\n\t\t\t\t\t\t\tmaxInitialSize,\n\t\t\t\t\t\t\tautomaticNameDelimiter\n\t\t\t\t\t\t} = chunkConfig || fallbackCacheGroup;\n\t\t\t\t\t\tif (!chunkConfig && !fallbackCacheGroup.chunksFilter(chunk))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t/** @type {SplitChunksSizes} */\n\t\t\t\t\t\tlet maxSize;\n\t\t\t\t\t\tif (chunk.isOnlyInitial()) {\n\t\t\t\t\t\t\tmaxSize = maxInitialSize;\n\t\t\t\t\t\t} else if (chunk.canBeInitial()) {\n\t\t\t\t\t\t\tmaxSize = combineSizes(maxAsyncSize, maxInitialSize, Math.min);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmaxSize = maxAsyncSize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (Object.keys(maxSize).length === 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const key of Object.keys(maxSize)) {\n\t\t\t\t\t\t\tconst maxSizeValue = maxSize[key];\n\t\t\t\t\t\t\tconst minSizeValue = minSize[key];\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\ttypeof minSizeValue === \"number\" &&\n\t\t\t\t\t\t\t\tminSizeValue > maxSizeValue\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst keys = chunkConfig && chunkConfig.keys;\n\t\t\t\t\t\t\t\tconst warningKey = `${\n\t\t\t\t\t\t\t\t\tkeys && keys.join()\n\t\t\t\t\t\t\t\t} ${minSizeValue} ${maxSizeValue}`;\n\t\t\t\t\t\t\t\tif (!incorrectMinMaxSizeSet.has(warningKey)) {\n\t\t\t\t\t\t\t\t\tincorrectMinMaxSizeSet.add(warningKey);\n\t\t\t\t\t\t\t\t\tcompilation.warnings.push(\n\t\t\t\t\t\t\t\t\t\tnew MinMaxSizeWarning(keys, minSizeValue, maxSizeValue)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst results = deterministicGroupingForModules({\n\t\t\t\t\t\t\tminSize,\n\t\t\t\t\t\t\tmaxSize: mapObject(maxSize, (value, key) => {\n\t\t\t\t\t\t\t\tconst minSizeValue = minSize[key];\n\t\t\t\t\t\t\t\treturn typeof minSizeValue === \"number\"\n\t\t\t\t\t\t\t\t\t? Math.max(value, minSizeValue)\n\t\t\t\t\t\t\t\t\t: value;\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\titems: chunkGraph.getChunkModulesIterable(chunk),\n\t\t\t\t\t\t\tgetKey(module) {\n\t\t\t\t\t\t\t\tconst cache = getKeyCache.get(module);\n\t\t\t\t\t\t\t\tif (cache !== undefined) return cache;\n\t\t\t\t\t\t\t\tconst ident = cachedMakePathsRelative(module.identifier());\n\t\t\t\t\t\t\t\tconst nameForCondition =\n\t\t\t\t\t\t\t\t\tmodule.nameForCondition && module.nameForCondition();\n\t\t\t\t\t\t\t\tconst name = nameForCondition\n\t\t\t\t\t\t\t\t\t? cachedMakePathsRelative(nameForCondition)\n\t\t\t\t\t\t\t\t\t: ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n\t\t\t\t\t\t\t\tconst fullKey =\n\t\t\t\t\t\t\t\t\tname +\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter +\n\t\t\t\t\t\t\t\t\thashFilename(ident, outputOptions);\n\t\t\t\t\t\t\t\tconst key = requestToId(fullKey);\n\t\t\t\t\t\t\t\tgetKeyCache.set(module, key);\n\t\t\t\t\t\t\t\treturn key;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgetSize(module) {\n\t\t\t\t\t\t\t\tconst size = Object.create(null);\n\t\t\t\t\t\t\t\tfor (const key of module.getSourceTypes()) {\n\t\t\t\t\t\t\t\t\tsize[key] = module.size(key);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn size;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (results.length <= 1) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\t\t\t\t\tconst group = results[i];\n\t\t\t\t\t\t\tconst key = this.options.hidePathInfo\n\t\t\t\t\t\t\t\t? hashFilename(group.key, outputOptions)\n\t\t\t\t\t\t\t\t: group.key;\n\t\t\t\t\t\t\tlet name = chunk.name\n\t\t\t\t\t\t\t\t? chunk.name + automaticNameDelimiter + key\n\t\t\t\t\t\t\t\t: null;\n\t\t\t\t\t\t\tif (name && name.length > 100) {\n\t\t\t\t\t\t\t\tname =\n\t\t\t\t\t\t\t\t\tname.slice(0, 100) +\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter +\n\t\t\t\t\t\t\t\t\thashFilename(name, outputOptions);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i !== results.length - 1) {\n\t\t\t\t\t\t\t\tconst newPart = compilation.addChunk(name);\n\t\t\t\t\t\t\t\tchunk.split(newPart);\n\t\t\t\t\t\t\t\tnewPart.chunkReason = chunk.chunkReason;\n\t\t\t\t\t\t\t\t// Add all modules to the new chunk\n\t\t\t\t\t\t\t\tfor (const module of group.items) {\n\t\t\t\t\t\t\t\t\tif (!module.chunkCondition(newPart, compilation)) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Add module to new chunk\n\t\t\t\t\t\t\t\t\tchunkGraph.connectChunkAndModule(newPart, module);\n\t\t\t\t\t\t\t\t\t// Remove module from used chunks\n\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// change the chunk to be a part\n\t\t\t\t\t\t\t\tchunk.name = name;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"maxSize\");\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}