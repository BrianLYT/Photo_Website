{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Factory = require(\"enhanced-resolve\").ResolverFactory;\n\nconst {\n  HookMap,\n  SyncHook,\n  SyncWaterfallHook\n} = require(\"tapable\");\n\nconst {\n  cachedCleverMerge,\n  removeOperations,\n  resolveByProperty\n} = require(\"./util/cleverMerge\");\n/** @typedef {import(\"enhanced-resolve\").ResolveOptions} ResolveOptions */\n\n/** @typedef {import(\"enhanced-resolve\").Resolver} Resolver */\n\n/** @typedef {import(\"../declarations/WebpackOptions\").ResolveOptions} WebpackResolveOptions */\n\n/** @typedef {import(\"../declarations/WebpackOptions\").ResolvePluginInstance} ResolvePluginInstance */\n\n/** @typedef {WebpackResolveOptions & {dependencyType?: string, resolveToContext?: boolean }} ResolveOptionsWithDependencyType */\n\n/**\n * @typedef {Object} WithOptions\n * @property {function(Partial<ResolveOptionsWithDependencyType>): ResolverWithOptions} withOptions create a resolver with additional/different options\n */\n\n/** @typedef {Resolver & WithOptions} ResolverWithOptions */\n// need to be hoisted on module level for caching identity\n\n\nconst EMPTY_RESOLVE_OPTIONS = {};\n/**\n * @param {ResolveOptionsWithDependencyType} resolveOptionsWithDepType enhanced options\n * @returns {ResolveOptions} merged options\n */\n\nconst convertToResolveOptions = resolveOptionsWithDepType => {\n  const {\n    dependencyType,\n    plugins,\n    ...remaining\n  } = resolveOptionsWithDepType; // check type compat\n\n  /** @type {Partial<ResolveOptions>} */\n\n  const partialOptions = { ...remaining,\n    plugins: plugins &&\n    /** @type {ResolvePluginInstance[]} */\n    plugins.filter(item => item !== \"...\")\n  };\n\n  if (!partialOptions.fileSystem) {\n    throw new Error(\"fileSystem is missing in resolveOptions, but it's required for enhanced-resolve\");\n  } // These weird types validate that we checked all non-optional properties\n\n\n  const options =\n  /** @type {Partial<ResolveOptions> & Pick<ResolveOptions, \"fileSystem\">} */\n  partialOptions;\n  return removeOperations(resolveByProperty(options, \"byDependency\", dependencyType));\n};\n/**\n * @typedef {Object} ResolverCache\n * @property {WeakMap<Object, ResolverWithOptions>} direct\n * @property {Map<string, ResolverWithOptions>} stringified\n */\n\n\nmodule.exports = class ResolverFactory {\n  constructor() {\n    this.hooks = Object.freeze({\n      /** @type {HookMap<SyncWaterfallHook<[ResolveOptionsWithDependencyType]>>} */\n      resolveOptions: new HookMap(() => new SyncWaterfallHook([\"resolveOptions\"])),\n\n      /** @type {HookMap<SyncHook<[Resolver, ResolveOptions, ResolveOptionsWithDependencyType]>>} */\n      resolver: new HookMap(() => new SyncHook([\"resolver\", \"resolveOptions\", \"userResolveOptions\"]))\n    });\n    /** @type {Map<string, ResolverCache>} */\n\n    this.cache = new Map();\n  }\n  /**\n   * @param {string} type type of resolver\n   * @param {ResolveOptionsWithDependencyType=} resolveOptions options\n   * @returns {ResolverWithOptions} the resolver\n   */\n\n\n  get(type) {\n    let resolveOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EMPTY_RESOLVE_OPTIONS;\n    let typedCaches = this.cache.get(type);\n\n    if (!typedCaches) {\n      typedCaches = {\n        direct: new WeakMap(),\n        stringified: new Map()\n      };\n      this.cache.set(type, typedCaches);\n    }\n\n    const cachedResolver = typedCaches.direct.get(resolveOptions);\n\n    if (cachedResolver) {\n      return cachedResolver;\n    }\n\n    const ident = JSON.stringify(resolveOptions);\n    const resolver = typedCaches.stringified.get(ident);\n\n    if (resolver) {\n      typedCaches.direct.set(resolveOptions, resolver);\n      return resolver;\n    }\n\n    const newResolver = this._create(type, resolveOptions);\n\n    typedCaches.direct.set(resolveOptions, newResolver);\n    typedCaches.stringified.set(ident, newResolver);\n    return newResolver;\n  }\n  /**\n   * @param {string} type type of resolver\n   * @param {ResolveOptionsWithDependencyType} resolveOptionsWithDepType options\n   * @returns {ResolverWithOptions} the resolver\n   */\n\n\n  _create(type, resolveOptionsWithDepType) {\n    /** @type {ResolveOptionsWithDependencyType} */\n    const originalResolveOptions = { ...resolveOptionsWithDepType\n    };\n    const resolveOptions = convertToResolveOptions(this.hooks.resolveOptions.for(type).call(resolveOptionsWithDepType));\n    const resolver =\n    /** @type {ResolverWithOptions} */\n    Factory.createResolver(resolveOptions);\n\n    if (!resolver) {\n      throw new Error(\"No resolver created\");\n    }\n    /** @type {WeakMap<Partial<ResolveOptionsWithDependencyType>, ResolverWithOptions>} */\n\n\n    const childCache = new WeakMap();\n\n    resolver.withOptions = options => {\n      const cacheEntry = childCache.get(options);\n      if (cacheEntry !== undefined) return cacheEntry;\n      const mergedOptions = cachedCleverMerge(originalResolveOptions, options);\n      const resolver = this.get(type, mergedOptions);\n      childCache.set(options, resolver);\n      return resolver;\n    };\n\n    this.hooks.resolver.for(type).call(resolver, resolveOptions, originalResolveOptions);\n    return resolver;\n  }\n\n};","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/ResolverFactory.js"],"names":["Factory","require","ResolverFactory","HookMap","SyncHook","SyncWaterfallHook","cachedCleverMerge","removeOperations","resolveByProperty","EMPTY_RESOLVE_OPTIONS","convertToResolveOptions","resolveOptionsWithDepType","dependencyType","plugins","remaining","partialOptions","filter","item","fileSystem","Error","options","module","exports","constructor","hooks","Object","freeze","resolveOptions","resolver","cache","Map","get","type","typedCaches","direct","WeakMap","stringified","set","cachedResolver","ident","JSON","stringify","newResolver","_create","originalResolveOptions","for","call","createResolver","childCache","withOptions","cacheEntry","undefined","mergedOptions"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Factory = require(\"enhanced-resolve\").ResolverFactory;\nconst { HookMap, SyncHook, SyncWaterfallHook } = require(\"tapable\");\nconst {\n\tcachedCleverMerge,\n\tremoveOperations,\n\tresolveByProperty\n} = require(\"./util/cleverMerge\");\n\n/** @typedef {import(\"enhanced-resolve\").ResolveOptions} ResolveOptions */\n/** @typedef {import(\"enhanced-resolve\").Resolver} Resolver */\n/** @typedef {import(\"../declarations/WebpackOptions\").ResolveOptions} WebpackResolveOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").ResolvePluginInstance} ResolvePluginInstance */\n\n/** @typedef {WebpackResolveOptions & {dependencyType?: string, resolveToContext?: boolean }} ResolveOptionsWithDependencyType */\n/**\n * @typedef {Object} WithOptions\n * @property {function(Partial<ResolveOptionsWithDependencyType>): ResolverWithOptions} withOptions create a resolver with additional/different options\n */\n\n/** @typedef {Resolver & WithOptions} ResolverWithOptions */\n\n// need to be hoisted on module level for caching identity\nconst EMPTY_RESOLVE_OPTIONS = {};\n\n/**\n * @param {ResolveOptionsWithDependencyType} resolveOptionsWithDepType enhanced options\n * @returns {ResolveOptions} merged options\n */\nconst convertToResolveOptions = resolveOptionsWithDepType => {\n\tconst { dependencyType, plugins, ...remaining } = resolveOptionsWithDepType;\n\n\t// check type compat\n\t/** @type {Partial<ResolveOptions>} */\n\tconst partialOptions = {\n\t\t...remaining,\n\t\tplugins:\n\t\t\tplugins &&\n\t\t\t/** @type {ResolvePluginInstance[]} */ (\n\t\t\t\tplugins.filter(item => item !== \"...\")\n\t\t\t)\n\t};\n\n\tif (!partialOptions.fileSystem) {\n\t\tthrow new Error(\n\t\t\t\"fileSystem is missing in resolveOptions, but it's required for enhanced-resolve\"\n\t\t);\n\t}\n\t// These weird types validate that we checked all non-optional properties\n\tconst options =\n\t\t/** @type {Partial<ResolveOptions> & Pick<ResolveOptions, \"fileSystem\">} */ (\n\t\t\tpartialOptions\n\t\t);\n\n\treturn removeOperations(\n\t\tresolveByProperty(options, \"byDependency\", dependencyType)\n\t);\n};\n\n/**\n * @typedef {Object} ResolverCache\n * @property {WeakMap<Object, ResolverWithOptions>} direct\n * @property {Map<string, ResolverWithOptions>} stringified\n */\n\nmodule.exports = class ResolverFactory {\n\tconstructor() {\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {HookMap<SyncWaterfallHook<[ResolveOptionsWithDependencyType]>>} */\n\t\t\tresolveOptions: new HookMap(\n\t\t\t\t() => new SyncWaterfallHook([\"resolveOptions\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncHook<[Resolver, ResolveOptions, ResolveOptionsWithDependencyType]>>} */\n\t\t\tresolver: new HookMap(\n\t\t\t\t() => new SyncHook([\"resolver\", \"resolveOptions\", \"userResolveOptions\"])\n\t\t\t)\n\t\t});\n\t\t/** @type {Map<string, ResolverCache>} */\n\t\tthis.cache = new Map();\n\t}\n\n\t/**\n\t * @param {string} type type of resolver\n\t * @param {ResolveOptionsWithDependencyType=} resolveOptions options\n\t * @returns {ResolverWithOptions} the resolver\n\t */\n\tget(type, resolveOptions = EMPTY_RESOLVE_OPTIONS) {\n\t\tlet typedCaches = this.cache.get(type);\n\t\tif (!typedCaches) {\n\t\t\ttypedCaches = {\n\t\t\t\tdirect: new WeakMap(),\n\t\t\t\tstringified: new Map()\n\t\t\t};\n\t\t\tthis.cache.set(type, typedCaches);\n\t\t}\n\t\tconst cachedResolver = typedCaches.direct.get(resolveOptions);\n\t\tif (cachedResolver) {\n\t\t\treturn cachedResolver;\n\t\t}\n\t\tconst ident = JSON.stringify(resolveOptions);\n\t\tconst resolver = typedCaches.stringified.get(ident);\n\t\tif (resolver) {\n\t\t\ttypedCaches.direct.set(resolveOptions, resolver);\n\t\t\treturn resolver;\n\t\t}\n\t\tconst newResolver = this._create(type, resolveOptions);\n\t\ttypedCaches.direct.set(resolveOptions, newResolver);\n\t\ttypedCaches.stringified.set(ident, newResolver);\n\t\treturn newResolver;\n\t}\n\n\t/**\n\t * @param {string} type type of resolver\n\t * @param {ResolveOptionsWithDependencyType} resolveOptionsWithDepType options\n\t * @returns {ResolverWithOptions} the resolver\n\t */\n\t_create(type, resolveOptionsWithDepType) {\n\t\t/** @type {ResolveOptionsWithDependencyType} */\n\t\tconst originalResolveOptions = { ...resolveOptionsWithDepType };\n\n\t\tconst resolveOptions = convertToResolveOptions(\n\t\t\tthis.hooks.resolveOptions.for(type).call(resolveOptionsWithDepType)\n\t\t);\n\t\tconst resolver = /** @type {ResolverWithOptions} */ (\n\t\t\tFactory.createResolver(resolveOptions)\n\t\t);\n\t\tif (!resolver) {\n\t\t\tthrow new Error(\"No resolver created\");\n\t\t}\n\t\t/** @type {WeakMap<Partial<ResolveOptionsWithDependencyType>, ResolverWithOptions>} */\n\t\tconst childCache = new WeakMap();\n\t\tresolver.withOptions = options => {\n\t\t\tconst cacheEntry = childCache.get(options);\n\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\tconst mergedOptions = cachedCleverMerge(originalResolveOptions, options);\n\t\t\tconst resolver = this.get(type, mergedOptions);\n\t\t\tchildCache.set(options, resolver);\n\t\t\treturn resolver;\n\t\t};\n\t\tthis.hooks.resolver\n\t\t\t.for(type)\n\t\t\t.call(resolver, resolveOptions, originalResolveOptions);\n\t\treturn resolver;\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}