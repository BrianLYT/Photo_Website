{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Mikola Lysenko @mikolalysenko\n*/\n\"use strict\";\n/* cspell:disable-next-line */\n// Refactor: Peter Somogyvari @petermetz\n\nconst compileSearch = (funcName, predicate, reversed, extraArgs, earlyOut) => {\n  const code = [\"function \", funcName, \"(a,l,h,\", extraArgs.join(\",\"), \"){\", earlyOut ? \"\" : \"var i=\", reversed ? \"l-1\" : \"h+1\", \";while(l<=h){var m=(l+h)>>>1,x=a[m]\"];\n\n  if (earlyOut) {\n    if (predicate.indexOf(\"c\") < 0) {\n      code.push(\";if(x===y){return m}else if(x<=y){\");\n    } else {\n      code.push(\";var p=c(x,y);if(p===0){return m}else if(p<=0){\");\n    }\n  } else {\n    code.push(\";if(\", predicate, \"){i=m;\");\n  }\n\n  if (reversed) {\n    code.push(\"l=m+1}else{h=m-1}\");\n  } else {\n    code.push(\"h=m-1}else{l=m+1}\");\n  }\n\n  code.push(\"}\");\n\n  if (earlyOut) {\n    code.push(\"return -1};\");\n  } else {\n    code.push(\"return i};\");\n  }\n\n  return code.join(\"\");\n};\n\nconst compileBoundsSearch = (predicate, reversed, suffix, earlyOut) => {\n  const arg1 = compileSearch(\"A\", \"x\" + predicate + \"y\", reversed, [\"y\"], earlyOut);\n  const arg2 = compileSearch(\"P\", \"c(x,y)\" + predicate + \"0\", reversed, [\"y\", \"c\"], earlyOut);\n  const fnHeader = \"function dispatchBinarySearch\";\n  const fnBody = \"(a,y,c,l,h){\\\nif(typeof(c)==='function'){\\\nreturn P(a,(l===void 0)?0:l|0,(h===void 0)?a.length-1:h|0,y,c)\\\n}else{\\\nreturn A(a,(c===void 0)?0:c|0,(l===void 0)?a.length-1:l|0,y)\\\n}}\\\nreturn dispatchBinarySearch\";\n  const fnArgList = [arg1, arg2, fnHeader, suffix, fnBody, suffix];\n  const fnSource = fnArgList.join(\"\");\n  const result = new Function(fnSource);\n  return result();\n};\n\nmodule.exports = {\n  ge: compileBoundsSearch(\">=\", false, \"GE\"),\n  gt: compileBoundsSearch(\">\", false, \"GT\"),\n  lt: compileBoundsSearch(\"<\", true, \"LT\"),\n  le: compileBoundsSearch(\"<=\", true, \"LE\"),\n  eq: compileBoundsSearch(\"-\", true, \"EQ\", true)\n};","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/util/binarySearchBounds.js"],"names":["compileSearch","funcName","predicate","reversed","extraArgs","earlyOut","code","join","indexOf","push","compileBoundsSearch","suffix","arg1","arg2","fnHeader","fnBody","fnArgList","fnSource","result","Function","module","exports","ge","gt","lt","le","eq"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;;AAEA,MAAMA,aAAa,GAAG,CAACC,QAAD,EAAWC,SAAX,EAAsBC,QAAtB,EAAgCC,SAAhC,EAA2CC,QAA3C,KAAwD;AAC7E,QAAMC,IAAI,GAAG,CACZ,WADY,EAEZL,QAFY,EAGZ,SAHY,EAIZG,SAAS,CAACG,IAAV,CAAe,GAAf,CAJY,EAKZ,IALY,EAMZF,QAAQ,GAAG,EAAH,GAAQ,QANJ,EAOZF,QAAQ,GAAG,KAAH,GAAW,KAPP,EAQZ,qCARY,CAAb;;AAWA,MAAIE,QAAJ,EAAc;AACb,QAAIH,SAAS,CAACM,OAAV,CAAkB,GAAlB,IAAyB,CAA7B,EAAgC;AAC/BF,MAAAA,IAAI,CAACG,IAAL,CAAU,oCAAV;AACA,KAFD,MAEO;AACNH,MAAAA,IAAI,CAACG,IAAL,CAAU,iDAAV;AACA;AACD,GAND,MAMO;AACNH,IAAAA,IAAI,CAACG,IAAL,CAAU,MAAV,EAAkBP,SAAlB,EAA6B,QAA7B;AACA;;AACD,MAAIC,QAAJ,EAAc;AACbG,IAAAA,IAAI,CAACG,IAAL,CAAU,mBAAV;AACA,GAFD,MAEO;AACNH,IAAAA,IAAI,CAACG,IAAL,CAAU,mBAAV;AACA;;AACDH,EAAAA,IAAI,CAACG,IAAL,CAAU,GAAV;;AACA,MAAIJ,QAAJ,EAAc;AACbC,IAAAA,IAAI,CAACG,IAAL,CAAU,aAAV;AACA,GAFD,MAEO;AACNH,IAAAA,IAAI,CAACG,IAAL,CAAU,YAAV;AACA;;AACD,SAAOH,IAAI,CAACC,IAAL,CAAU,EAAV,CAAP;AACA,CAjCD;;AAmCA,MAAMG,mBAAmB,GAAG,CAACR,SAAD,EAAYC,QAAZ,EAAsBQ,MAAtB,EAA8BN,QAA9B,KAA2C;AACtE,QAAMO,IAAI,GAAGZ,aAAa,CACzB,GADyB,EAEzB,MAAME,SAAN,GAAkB,GAFO,EAGzBC,QAHyB,EAIzB,CAAC,GAAD,CAJyB,EAKzBE,QALyB,CAA1B;AAQA,QAAMQ,IAAI,GAAGb,aAAa,CACzB,GADyB,EAEzB,WAAWE,SAAX,GAAuB,GAFE,EAGzBC,QAHyB,EAIzB,CAAC,GAAD,EAAM,GAAN,CAJyB,EAKzBE,QALyB,CAA1B;AAQA,QAAMS,QAAQ,GAAG,+BAAjB;AAEA,QAAMC,MAAM,GACX;AACF;AACA;AACA;AACA;AACA;AACA,4BAPC;AASA,QAAMC,SAAS,GAAG,CAACJ,IAAD,EAAOC,IAAP,EAAaC,QAAb,EAAuBH,MAAvB,EAA+BI,MAA/B,EAAuCJ,MAAvC,CAAlB;AACA,QAAMM,QAAQ,GAAGD,SAAS,CAACT,IAAV,CAAe,EAAf,CAAjB;AACA,QAAMW,MAAM,GAAG,IAAIC,QAAJ,CAAaF,QAAb,CAAf;AACA,SAAOC,MAAM,EAAb;AACA,CAhCD;;AAkCAE,MAAM,CAACC,OAAP,GAAiB;AAChBC,EAAAA,EAAE,EAAEZ,mBAAmB,CAAC,IAAD,EAAO,KAAP,EAAc,IAAd,CADP;AAEhBa,EAAAA,EAAE,EAAEb,mBAAmB,CAAC,GAAD,EAAM,KAAN,EAAa,IAAb,CAFP;AAGhBc,EAAAA,EAAE,EAAEd,mBAAmB,CAAC,GAAD,EAAM,IAAN,EAAY,IAAZ,CAHP;AAIhBe,EAAAA,EAAE,EAAEf,mBAAmB,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,CAJP;AAKhBgB,EAAAA,EAAE,EAAEhB,mBAAmB,CAAC,GAAD,EAAM,IAAN,EAAY,IAAZ,EAAkB,IAAlB;AALP,CAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Mikola Lysenko @mikolalysenko\n*/\n\n\"use strict\";\n\n/* cspell:disable-next-line */\n// Refactor: Peter Somogyvari @petermetz\n\nconst compileSearch = (funcName, predicate, reversed, extraArgs, earlyOut) => {\n\tconst code = [\n\t\t\"function \",\n\t\tfuncName,\n\t\t\"(a,l,h,\",\n\t\textraArgs.join(\",\"),\n\t\t\"){\",\n\t\tearlyOut ? \"\" : \"var i=\",\n\t\treversed ? \"l-1\" : \"h+1\",\n\t\t\";while(l<=h){var m=(l+h)>>>1,x=a[m]\"\n\t];\n\n\tif (earlyOut) {\n\t\tif (predicate.indexOf(\"c\") < 0) {\n\t\t\tcode.push(\";if(x===y){return m}else if(x<=y){\");\n\t\t} else {\n\t\t\tcode.push(\";var p=c(x,y);if(p===0){return m}else if(p<=0){\");\n\t\t}\n\t} else {\n\t\tcode.push(\";if(\", predicate, \"){i=m;\");\n\t}\n\tif (reversed) {\n\t\tcode.push(\"l=m+1}else{h=m-1}\");\n\t} else {\n\t\tcode.push(\"h=m-1}else{l=m+1}\");\n\t}\n\tcode.push(\"}\");\n\tif (earlyOut) {\n\t\tcode.push(\"return -1};\");\n\t} else {\n\t\tcode.push(\"return i};\");\n\t}\n\treturn code.join(\"\");\n};\n\nconst compileBoundsSearch = (predicate, reversed, suffix, earlyOut) => {\n\tconst arg1 = compileSearch(\n\t\t\"A\",\n\t\t\"x\" + predicate + \"y\",\n\t\treversed,\n\t\t[\"y\"],\n\t\tearlyOut\n\t);\n\n\tconst arg2 = compileSearch(\n\t\t\"P\",\n\t\t\"c(x,y)\" + predicate + \"0\",\n\t\treversed,\n\t\t[\"y\", \"c\"],\n\t\tearlyOut\n\t);\n\n\tconst fnHeader = \"function dispatchBinarySearch\";\n\n\tconst fnBody =\n\t\t\"(a,y,c,l,h){\\\nif(typeof(c)==='function'){\\\nreturn P(a,(l===void 0)?0:l|0,(h===void 0)?a.length-1:h|0,y,c)\\\n}else{\\\nreturn A(a,(c===void 0)?0:c|0,(l===void 0)?a.length-1:l|0,y)\\\n}}\\\nreturn dispatchBinarySearch\";\n\n\tconst fnArgList = [arg1, arg2, fnHeader, suffix, fnBody, suffix];\n\tconst fnSource = fnArgList.join(\"\");\n\tconst result = new Function(fnSource);\n\treturn result();\n};\n\nmodule.exports = {\n\tge: compileBoundsSearch(\">=\", false, \"GE\"),\n\tgt: compileBoundsSearch(\">\", false, \"GT\"),\n\tlt: compileBoundsSearch(\"<\", true, \"LT\"),\n\tle: compileBoundsSearch(\"<=\", true, \"LE\"),\n\teq: compileBoundsSearch(\"-\", true, \"EQ\", true)\n};\n"]},"metadata":{},"sourceType":"script"}