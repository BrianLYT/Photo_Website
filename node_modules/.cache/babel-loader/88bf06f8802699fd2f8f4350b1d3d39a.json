{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\"use strict\";\n\nconst createHash = require(\"../util/createHash\");\n\nconst ArraySerializer = require(\"./ArraySerializer\");\n\nconst DateObjectSerializer = require(\"./DateObjectSerializer\");\n\nconst ErrorObjectSerializer = require(\"./ErrorObjectSerializer\");\n\nconst MapObjectSerializer = require(\"./MapObjectSerializer\");\n\nconst NullPrototypeObjectSerializer = require(\"./NullPrototypeObjectSerializer\");\n\nconst PlainObjectSerializer = require(\"./PlainObjectSerializer\");\n\nconst RegExpObjectSerializer = require(\"./RegExpObjectSerializer\");\n\nconst SerializerMiddleware = require(\"./SerializerMiddleware\");\n\nconst SetObjectSerializer = require(\"./SetObjectSerializer\");\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n\n/** @typedef {import(\"./types\").ComplexSerializableType} ComplexSerializableType */\n\n/** @typedef {import(\"./types\").PrimitiveSerializableType} PrimitiveSerializableType */\n\n/** @typedef {new (...params: any[]) => any} Constructor */\n\n/*\n\nFormat:\n\nFile -> Section*\nSection -> ObjectSection | ReferenceSection | EscapeSection | OtherSection\n\nObjectSection -> ESCAPE (\n\tnumber:relativeOffset (number > 0) |\n\tstring:request (string|null):export\n) Section:value* ESCAPE ESCAPE_END_OBJECT\nReferenceSection -> ESCAPE number:relativeOffset (number < 0)\nEscapeSection -> ESCAPE ESCAPE_ESCAPE_VALUE (escaped value ESCAPE)\nEscapeSection -> ESCAPE ESCAPE_UNDEFINED (escaped value ESCAPE)\nOtherSection -> any (except ESCAPE)\n\nWhy using null as escape value?\nMultiple null values can merged by the BinaryMiddleware, which makes it very efficient\nTechnically any value can be used.\n\n*/\n\n/**\n * @typedef {Object} ObjectSerializerContext\n * @property {function(any): void} write\n */\n\n/**\n * @typedef {Object} ObjectDeserializerContext\n * @property {function(): any} read\n */\n\n/**\n * @typedef {Object} ObjectSerializer\n * @property {function(any, ObjectSerializerContext): void} serialize\n * @property {function(ObjectDeserializerContext): any} deserialize\n */\n\n\nconst setSetSize = (set, size) => {\n  let i = 0;\n\n  for (const item of set) {\n    if (i++ >= size) {\n      set.delete(item);\n    }\n  }\n};\n\nconst setMapSize = (map, size) => {\n  let i = 0;\n\n  for (const item of map.keys()) {\n    if (i++ >= size) {\n      map.delete(item);\n    }\n  }\n};\n/**\n * @param {Buffer} buffer buffer\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} hash\n */\n\n\nconst toHash = (buffer, hashFunction) => {\n  const hash = createHash(hashFunction);\n  hash.update(buffer);\n  return (\n    /** @type {string} */\n    hash.digest(\"latin1\")\n  );\n};\n\nconst ESCAPE = null;\nconst ESCAPE_ESCAPE_VALUE = null;\nconst ESCAPE_END_OBJECT = true;\nconst ESCAPE_UNDEFINED = false;\nconst CURRENT_VERSION = 2;\nconst serializers = new Map();\nconst serializerInversed = new Map();\nconst loadedRequests = new Set();\nconst NOT_SERIALIZABLE = {};\nconst jsTypes = new Map();\njsTypes.set(Object, new PlainObjectSerializer());\njsTypes.set(Array, new ArraySerializer());\njsTypes.set(null, new NullPrototypeObjectSerializer());\njsTypes.set(Map, new MapObjectSerializer());\njsTypes.set(Set, new SetObjectSerializer());\njsTypes.set(Date, new DateObjectSerializer());\njsTypes.set(RegExp, new RegExpObjectSerializer());\njsTypes.set(Error, new ErrorObjectSerializer(Error));\njsTypes.set(EvalError, new ErrorObjectSerializer(EvalError));\njsTypes.set(RangeError, new ErrorObjectSerializer(RangeError));\njsTypes.set(ReferenceError, new ErrorObjectSerializer(ReferenceError));\njsTypes.set(SyntaxError, new ErrorObjectSerializer(SyntaxError));\njsTypes.set(TypeError, new ErrorObjectSerializer(TypeError)); // If in a sandboxed environment (e. g. jest), this escapes the sandbox and registers\n// real Object and Array types to. These types may occur in the wild too, e. g. when\n// using Structured Clone in postMessage.\n\nif (exports.constructor !== Object) {\n  const Obj =\n  /** @type {typeof Object} */\n  exports.constructor;\n  const Fn =\n  /** @type {typeof Function} */\n  Obj.constructor;\n\n  for (const [type, config] of Array.from(jsTypes)) {\n    if (type) {\n      const Type = new Fn(`return ${type.name};`)();\n      jsTypes.set(Type, config);\n    }\n  }\n}\n\n{\n  let i = 1;\n\n  for (const [type, serializer] of jsTypes) {\n    serializers.set(type, {\n      request: \"\",\n      name: i++,\n      serializer\n    });\n  }\n}\n\nfor (const {\n  request,\n  name,\n  serializer\n} of serializers.values()) {\n  serializerInversed.set(`${request}/${name}`, serializer);\n}\n/** @type {Map<RegExp, (request: string) => boolean>} */\n\n\nconst loaders = new Map();\n/**\n * @typedef {ComplexSerializableType[]} DeserializedType\n * @typedef {PrimitiveSerializableType[]} SerializedType\n * @extends {SerializerMiddleware<DeserializedType, SerializedType>}\n */\n\nclass ObjectMiddleware extends SerializerMiddleware {\n  /**\n   * @param {function(any): void} extendContext context extensions\n   * @param {string | Hash} hashFunction hash function to use\n   */\n  constructor(extendContext) {\n    let hashFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"md4\";\n    super();\n    this.extendContext = extendContext;\n    this._hashFunction = hashFunction;\n  }\n  /**\n   * @param {RegExp} regExp RegExp for which the request is tested\n   * @param {function(string): boolean} loader loader to load the request, returns true when successful\n   * @returns {void}\n   */\n\n\n  static registerLoader(regExp, loader) {\n    loaders.set(regExp, loader);\n  }\n  /**\n   * @param {Constructor} Constructor the constructor\n   * @param {string} request the request which will be required when deserializing\n   * @param {string} name the name to make multiple serializer unique when sharing a request\n   * @param {ObjectSerializer} serializer the serializer\n   * @returns {void}\n   */\n\n\n  static register(Constructor, request, name, serializer) {\n    const key = request + \"/\" + name;\n\n    if (serializers.has(Constructor)) {\n      throw new Error(`ObjectMiddleware.register: serializer for ${Constructor.name} is already registered`);\n    }\n\n    if (serializerInversed.has(key)) {\n      throw new Error(`ObjectMiddleware.register: serializer for ${key} is already registered`);\n    }\n\n    serializers.set(Constructor, {\n      request,\n      name,\n      serializer\n    });\n    serializerInversed.set(key, serializer);\n  }\n  /**\n   * @param {Constructor} Constructor the constructor\n   * @returns {void}\n   */\n\n\n  static registerNotSerializable(Constructor) {\n    if (serializers.has(Constructor)) {\n      throw new Error(`ObjectMiddleware.registerNotSerializable: serializer for ${Constructor.name} is already registered`);\n    }\n\n    serializers.set(Constructor, NOT_SERIALIZABLE);\n  }\n\n  static getSerializerFor(object) {\n    const proto = Object.getPrototypeOf(object);\n    let c;\n\n    if (proto === null) {\n      // Object created with Object.create(null)\n      c = null;\n    } else {\n      c = proto.constructor;\n\n      if (!c) {\n        throw new Error(\"Serialization of objects with prototype without valid constructor property not possible\");\n      }\n    }\n\n    const config = serializers.get(c);\n    if (!config) throw new Error(`No serializer registered for ${c.name}`);\n    if (config === NOT_SERIALIZABLE) throw NOT_SERIALIZABLE;\n    return config;\n  }\n\n  static getDeserializerFor(request, name) {\n    const key = request + \"/\" + name;\n    const serializer = serializerInversed.get(key);\n\n    if (serializer === undefined) {\n      throw new Error(`No deserializer registered for ${key}`);\n    }\n\n    return serializer;\n  }\n\n  static _getDeserializerForWithoutError(request, name) {\n    const key = request + \"/\" + name;\n    const serializer = serializerInversed.get(key);\n    return serializer;\n  }\n  /**\n   * @param {DeserializedType} data data\n   * @param {Object} context context object\n   * @returns {SerializedType|Promise<SerializedType>} serialized data\n   */\n\n\n  serialize(data, context) {\n    /** @type {any[]} */\n    let result = [CURRENT_VERSION];\n    let currentPos = 0;\n    let referenceable = new Map();\n\n    const addReferenceable = item => {\n      referenceable.set(item, currentPos++);\n    };\n\n    let bufferDedupeMap = new Map();\n\n    const dedupeBuffer = buf => {\n      const len = buf.length;\n      const entry = bufferDedupeMap.get(len);\n\n      if (entry === undefined) {\n        bufferDedupeMap.set(len, buf);\n        return buf;\n      }\n\n      if (Buffer.isBuffer(entry)) {\n        if (len < 32) {\n          if (buf.equals(entry)) {\n            return entry;\n          }\n\n          bufferDedupeMap.set(len, [entry, buf]);\n          return buf;\n        } else {\n          const hash = toHash(entry, this._hashFunction);\n          const newMap = new Map();\n          newMap.set(hash, entry);\n          bufferDedupeMap.set(len, newMap);\n          const hashBuf = toHash(buf, this._hashFunction);\n\n          if (hash === hashBuf) {\n            return entry;\n          }\n\n          return buf;\n        }\n      } else if (Array.isArray(entry)) {\n        if (entry.length < 16) {\n          for (const item of entry) {\n            if (buf.equals(item)) {\n              return item;\n            }\n          }\n\n          entry.push(buf);\n          return buf;\n        } else {\n          const newMap = new Map();\n          const hash = toHash(buf, this._hashFunction);\n          let found;\n\n          for (const item of entry) {\n            const itemHash = toHash(item, this._hashFunction);\n            newMap.set(itemHash, item);\n            if (found === undefined && itemHash === hash) found = item;\n          }\n\n          bufferDedupeMap.set(len, newMap);\n\n          if (found === undefined) {\n            newMap.set(hash, buf);\n            return buf;\n          } else {\n            return found;\n          }\n        }\n      } else {\n        const hash = toHash(buf, this._hashFunction);\n        const item = entry.get(hash);\n\n        if (item !== undefined) {\n          return item;\n        }\n\n        entry.set(hash, buf);\n        return buf;\n      }\n    };\n\n    let currentPosTypeLookup = 0;\n    let objectTypeLookup = new Map();\n    const cycleStack = new Set();\n\n    const stackToString = item => {\n      const arr = Array.from(cycleStack);\n      arr.push(item);\n      return arr.map(item => {\n        if (typeof item === \"string\") {\n          if (item.length > 100) {\n            return `String ${JSON.stringify(item.slice(0, 100)).slice(0, -1)}...\"`;\n          }\n\n          return `String ${JSON.stringify(item)}`;\n        }\n\n        try {\n          const {\n            request,\n            name\n          } = ObjectMiddleware.getSerializerFor(item);\n\n          if (request) {\n            return `${request}${name ? `.${name}` : \"\"}`;\n          }\n        } catch (e) {// ignore -> fallback\n        }\n\n        if (typeof item === \"object\" && item !== null) {\n          if (item.constructor) {\n            if (item.constructor === Object) return `Object { ${Object.keys(item).join(\", \")} }`;\n            if (item.constructor === Map) return `Map { ${item.size} items }`;\n            if (item.constructor === Array) return `Array { ${item.length} items }`;\n            if (item.constructor === Set) return `Set { ${item.size} items }`;\n            if (item.constructor === RegExp) return item.toString();\n            return `${item.constructor.name}`;\n          }\n\n          return `Object [null prototype] { ${Object.keys(item).join(\", \")} }`;\n        }\n\n        try {\n          return `${item}`;\n        } catch (e) {\n          return `(${e.message})`;\n        }\n      }).join(\" -> \");\n    };\n\n    let hasDebugInfoAttached;\n    let ctx = {\n      write(value, key) {\n        try {\n          process(value);\n        } catch (e) {\n          if (e !== NOT_SERIALIZABLE) {\n            if (hasDebugInfoAttached === undefined) hasDebugInfoAttached = new WeakSet();\n\n            if (!hasDebugInfoAttached.has(e)) {\n              e.message += `\\nwhile serializing ${stackToString(value)}`;\n              hasDebugInfoAttached.add(e);\n            }\n          }\n\n          throw e;\n        }\n      },\n\n      setCircularReference(ref) {\n        addReferenceable(ref);\n      },\n\n      snapshot() {\n        return {\n          length: result.length,\n          cycleStackSize: cycleStack.size,\n          referenceableSize: referenceable.size,\n          currentPos,\n          objectTypeLookupSize: objectTypeLookup.size,\n          currentPosTypeLookup\n        };\n      },\n\n      rollback(snapshot) {\n        result.length = snapshot.length;\n        setSetSize(cycleStack, snapshot.cycleStackSize);\n        setMapSize(referenceable, snapshot.referenceableSize);\n        currentPos = snapshot.currentPos;\n        setMapSize(objectTypeLookup, snapshot.objectTypeLookupSize);\n        currentPosTypeLookup = snapshot.currentPosTypeLookup;\n      },\n\n      ...context\n    };\n    this.extendContext(ctx);\n\n    const process = item => {\n      if (Buffer.isBuffer(item)) {\n        // check if we can emit a reference\n        const ref = referenceable.get(item);\n\n        if (ref !== undefined) {\n          result.push(ESCAPE, ref - currentPos);\n          return;\n        }\n\n        const alreadyUsedBuffer = dedupeBuffer(item);\n\n        if (alreadyUsedBuffer !== item) {\n          const ref = referenceable.get(alreadyUsedBuffer);\n\n          if (ref !== undefined) {\n            referenceable.set(item, ref);\n            result.push(ESCAPE, ref - currentPos);\n            return;\n          }\n\n          item = alreadyUsedBuffer;\n        }\n\n        addReferenceable(item);\n        result.push(item);\n      } else if (item === ESCAPE) {\n        result.push(ESCAPE, ESCAPE_ESCAPE_VALUE);\n      } else if (typeof item === \"object\" // We don't have to check for null as ESCAPE is null and this has been checked before\n      ) {\n        // check if we can emit a reference\n        const ref = referenceable.get(item);\n\n        if (ref !== undefined) {\n          result.push(ESCAPE, ref - currentPos);\n          return;\n        }\n\n        if (cycleStack.has(item)) {\n          throw new Error(`This is a circular references. To serialize circular references use 'setCircularReference' somewhere in the circle during serialize and deserialize.`);\n        }\n\n        const {\n          request,\n          name,\n          serializer\n        } = ObjectMiddleware.getSerializerFor(item);\n        const key = `${request}/${name}`;\n        const lastIndex = objectTypeLookup.get(key);\n\n        if (lastIndex === undefined) {\n          objectTypeLookup.set(key, currentPosTypeLookup++);\n          result.push(ESCAPE, request, name);\n        } else {\n          result.push(ESCAPE, currentPosTypeLookup - lastIndex);\n        }\n\n        cycleStack.add(item);\n\n        try {\n          serializer.serialize(item, ctx);\n        } finally {\n          cycleStack.delete(item);\n        }\n\n        result.push(ESCAPE, ESCAPE_END_OBJECT);\n        addReferenceable(item);\n      } else if (typeof item === \"string\") {\n        if (item.length > 1) {\n          // short strings are shorter when not emitting a reference (this saves 1 byte per empty string)\n          // check if we can emit a reference\n          const ref = referenceable.get(item);\n\n          if (ref !== undefined) {\n            result.push(ESCAPE, ref - currentPos);\n            return;\n          }\n\n          addReferenceable(item);\n        }\n\n        if (item.length > 102400 && context.logger) {\n          context.logger.warn(`Serializing big strings (${Math.round(item.length / 1024)}kiB) impacts deserialization performance (consider using Buffer instead and decode when needed)`);\n        }\n\n        result.push(item);\n      } else if (typeof item === \"function\") {\n        if (!SerializerMiddleware.isLazy(item)) throw new Error(\"Unexpected function \" + item);\n        /** @type {SerializedType} */\n\n        const serializedData = SerializerMiddleware.getLazySerializedValue(item);\n\n        if (serializedData !== undefined) {\n          if (typeof serializedData === \"function\") {\n            result.push(serializedData);\n          } else {\n            throw new Error(\"Not implemented\");\n          }\n        } else if (SerializerMiddleware.isLazy(item, this)) {\n          throw new Error(\"Not implemented\");\n        } else {\n          const data = SerializerMiddleware.serializeLazy(item, data => this.serialize([data], context));\n          SerializerMiddleware.setLazySerializedValue(item, data);\n          result.push(data);\n        }\n      } else if (item === undefined) {\n        result.push(ESCAPE, ESCAPE_UNDEFINED);\n      } else {\n        result.push(item);\n      }\n    };\n\n    try {\n      for (const item of data) {\n        process(item);\n      }\n\n      return result;\n    } catch (e) {\n      if (e === NOT_SERIALIZABLE) return null;\n      throw e;\n    } finally {\n      // Get rid of these references to avoid leaking memory\n      // This happens because the optimized code v8 generates\n      // is optimized for our \"ctx.write\" method so it will reference\n      // it from e. g. Dependency.prototype.serialize -(IC)-> ctx.write\n      data = result = referenceable = bufferDedupeMap = objectTypeLookup = ctx = undefined;\n    }\n  }\n  /**\n   * @param {SerializedType} data data\n   * @param {Object} context context object\n   * @returns {DeserializedType|Promise<DeserializedType>} deserialized data\n   */\n\n\n  deserialize(data, context) {\n    let currentDataPos = 0;\n\n    const read = () => {\n      if (currentDataPos >= data.length) throw new Error(\"Unexpected end of stream\");\n      return data[currentDataPos++];\n    };\n\n    if (read() !== CURRENT_VERSION) throw new Error(\"Version mismatch, serializer changed\");\n    let currentPos = 0;\n    let referenceable = [];\n\n    const addReferenceable = item => {\n      referenceable.push(item);\n      currentPos++;\n    };\n\n    let currentPosTypeLookup = 0;\n    let objectTypeLookup = [];\n    let result = [];\n    let ctx = {\n      read() {\n        return decodeValue();\n      },\n\n      setCircularReference(ref) {\n        addReferenceable(ref);\n      },\n\n      ...context\n    };\n    this.extendContext(ctx);\n\n    const decodeValue = () => {\n      const item = read();\n\n      if (item === ESCAPE) {\n        const nextItem = read();\n\n        if (nextItem === ESCAPE_ESCAPE_VALUE) {\n          return ESCAPE;\n        } else if (nextItem === ESCAPE_UNDEFINED) {\n          return undefined;\n        } else if (nextItem === ESCAPE_END_OBJECT) {\n          throw new Error(`Unexpected end of object at position ${currentDataPos - 1}`);\n        } else {\n          const request = nextItem;\n          let serializer;\n\n          if (typeof request === \"number\") {\n            if (request < 0) {\n              // relative reference\n              return referenceable[currentPos + request];\n            }\n\n            serializer = objectTypeLookup[currentPosTypeLookup - request];\n          } else {\n            if (typeof request !== \"string\") {\n              throw new Error(`Unexpected type (${typeof request}) of request ` + `at position ${currentDataPos - 1}`);\n            }\n\n            const name = read();\n            serializer = ObjectMiddleware._getDeserializerForWithoutError(request, name);\n\n            if (serializer === undefined) {\n              if (request && !loadedRequests.has(request)) {\n                let loaded = false;\n\n                for (const [regExp, loader] of loaders) {\n                  if (regExp.test(request)) {\n                    if (loader(request)) {\n                      loaded = true;\n                      break;\n                    }\n                  }\n                }\n\n                if (!loaded) {\n                  require(request);\n                }\n\n                loadedRequests.add(request);\n              }\n\n              serializer = ObjectMiddleware.getDeserializerFor(request, name);\n            }\n\n            objectTypeLookup.push(serializer);\n            currentPosTypeLookup++;\n          }\n\n          try {\n            const item = serializer.deserialize(ctx);\n            const end1 = read();\n\n            if (end1 !== ESCAPE) {\n              throw new Error(\"Expected end of object\");\n            }\n\n            const end2 = read();\n\n            if (end2 !== ESCAPE_END_OBJECT) {\n              throw new Error(\"Expected end of object\");\n            }\n\n            addReferenceable(item);\n            return item;\n          } catch (err) {\n            // As this is only for error handling, we omit creating a Map for\n            // faster access to this information, as this would affect performance\n            // in the good case\n            let serializerEntry;\n\n            for (const entry of serializers) {\n              if (entry[1].serializer === serializer) {\n                serializerEntry = entry;\n                break;\n              }\n            }\n\n            const name = !serializerEntry ? \"unknown\" : !serializerEntry[1].request ? serializerEntry[0].name : serializerEntry[1].name ? `${serializerEntry[1].request} ${serializerEntry[1].name}` : serializerEntry[1].request;\n            err.message += `\\n(during deserialization of ${name})`;\n            throw err;\n          }\n        }\n      } else if (typeof item === \"string\") {\n        if (item.length > 1) {\n          addReferenceable(item);\n        }\n\n        return item;\n      } else if (Buffer.isBuffer(item)) {\n        addReferenceable(item);\n        return item;\n      } else if (typeof item === \"function\") {\n        return SerializerMiddleware.deserializeLazy(item, data => this.deserialize(data, context)[0]);\n      } else {\n        return item;\n      }\n    };\n\n    try {\n      while (currentDataPos < data.length) {\n        result.push(decodeValue());\n      }\n\n      return result;\n    } finally {\n      // Get rid of these references to avoid leaking memory\n      // This happens because the optimized code v8 generates\n      // is optimized for our \"ctx.read\" method so it will reference\n      // it from e. g. Dependency.prototype.deserialize -(IC)-> ctx.read\n      result = referenceable = data = objectTypeLookup = ctx = undefined;\n    }\n  }\n\n}\n\nmodule.exports = ObjectMiddleware;\nmodule.exports.NOT_SERIALIZABLE = NOT_SERIALIZABLE;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/serialization/ObjectMiddleware.js"],"names":["createHash","require","ArraySerializer","DateObjectSerializer","ErrorObjectSerializer","MapObjectSerializer","NullPrototypeObjectSerializer","PlainObjectSerializer","RegExpObjectSerializer","SerializerMiddleware","SetObjectSerializer","setSetSize","set","size","i","item","delete","setMapSize","map","keys","toHash","buffer","hashFunction","hash","update","digest","ESCAPE","ESCAPE_ESCAPE_VALUE","ESCAPE_END_OBJECT","ESCAPE_UNDEFINED","CURRENT_VERSION","serializers","Map","serializerInversed","loadedRequests","Set","NOT_SERIALIZABLE","jsTypes","Object","Array","Date","RegExp","Error","EvalError","RangeError","ReferenceError","SyntaxError","TypeError","exports","constructor","Obj","Fn","type","config","from","Type","name","serializer","request","values","loaders","ObjectMiddleware","extendContext","_hashFunction","registerLoader","regExp","loader","register","Constructor","key","has","registerNotSerializable","getSerializerFor","object","proto","getPrototypeOf","c","get","getDeserializerFor","undefined","_getDeserializerForWithoutError","serialize","data","context","result","currentPos","referenceable","addReferenceable","bufferDedupeMap","dedupeBuffer","buf","len","length","entry","Buffer","isBuffer","equals","newMap","hashBuf","isArray","push","found","itemHash","currentPosTypeLookup","objectTypeLookup","cycleStack","stackToString","arr","JSON","stringify","slice","e","join","toString","message","hasDebugInfoAttached","ctx","write","value","process","WeakSet","add","setCircularReference","ref","snapshot","cycleStackSize","referenceableSize","objectTypeLookupSize","rollback","alreadyUsedBuffer","lastIndex","logger","warn","Math","round","isLazy","serializedData","getLazySerializedValue","serializeLazy","setLazySerializedValue","deserialize","currentDataPos","read","decodeValue","nextItem","loaded","test","end1","end2","err","serializerEntry","deserializeLazy","module"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst createHash = require(\"../util/createHash\");\nconst ArraySerializer = require(\"./ArraySerializer\");\nconst DateObjectSerializer = require(\"./DateObjectSerializer\");\nconst ErrorObjectSerializer = require(\"./ErrorObjectSerializer\");\nconst MapObjectSerializer = require(\"./MapObjectSerializer\");\nconst NullPrototypeObjectSerializer = require(\"./NullPrototypeObjectSerializer\");\nconst PlainObjectSerializer = require(\"./PlainObjectSerializer\");\nconst RegExpObjectSerializer = require(\"./RegExpObjectSerializer\");\nconst SerializerMiddleware = require(\"./SerializerMiddleware\");\nconst SetObjectSerializer = require(\"./SetObjectSerializer\");\n\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n/** @typedef {import(\"./types\").ComplexSerializableType} ComplexSerializableType */\n/** @typedef {import(\"./types\").PrimitiveSerializableType} PrimitiveSerializableType */\n\n/** @typedef {new (...params: any[]) => any} Constructor */\n\n/*\n\nFormat:\n\nFile -> Section*\nSection -> ObjectSection | ReferenceSection | EscapeSection | OtherSection\n\nObjectSection -> ESCAPE (\n\tnumber:relativeOffset (number > 0) |\n\tstring:request (string|null):export\n) Section:value* ESCAPE ESCAPE_END_OBJECT\nReferenceSection -> ESCAPE number:relativeOffset (number < 0)\nEscapeSection -> ESCAPE ESCAPE_ESCAPE_VALUE (escaped value ESCAPE)\nEscapeSection -> ESCAPE ESCAPE_UNDEFINED (escaped value ESCAPE)\nOtherSection -> any (except ESCAPE)\n\nWhy using null as escape value?\nMultiple null values can merged by the BinaryMiddleware, which makes it very efficient\nTechnically any value can be used.\n\n*/\n\n/**\n * @typedef {Object} ObjectSerializerContext\n * @property {function(any): void} write\n */\n\n/**\n * @typedef {Object} ObjectDeserializerContext\n * @property {function(): any} read\n */\n\n/**\n * @typedef {Object} ObjectSerializer\n * @property {function(any, ObjectSerializerContext): void} serialize\n * @property {function(ObjectDeserializerContext): any} deserialize\n */\n\nconst setSetSize = (set, size) => {\n\tlet i = 0;\n\tfor (const item of set) {\n\t\tif (i++ >= size) {\n\t\t\tset.delete(item);\n\t\t}\n\t}\n};\n\nconst setMapSize = (map, size) => {\n\tlet i = 0;\n\tfor (const item of map.keys()) {\n\t\tif (i++ >= size) {\n\t\t\tmap.delete(item);\n\t\t}\n\t}\n};\n\n/**\n * @param {Buffer} buffer buffer\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} hash\n */\nconst toHash = (buffer, hashFunction) => {\n\tconst hash = createHash(hashFunction);\n\thash.update(buffer);\n\treturn /** @type {string} */ (hash.digest(\"latin1\"));\n};\n\nconst ESCAPE = null;\nconst ESCAPE_ESCAPE_VALUE = null;\nconst ESCAPE_END_OBJECT = true;\nconst ESCAPE_UNDEFINED = false;\n\nconst CURRENT_VERSION = 2;\n\nconst serializers = new Map();\nconst serializerInversed = new Map();\n\nconst loadedRequests = new Set();\n\nconst NOT_SERIALIZABLE = {};\n\nconst jsTypes = new Map();\njsTypes.set(Object, new PlainObjectSerializer());\njsTypes.set(Array, new ArraySerializer());\njsTypes.set(null, new NullPrototypeObjectSerializer());\njsTypes.set(Map, new MapObjectSerializer());\njsTypes.set(Set, new SetObjectSerializer());\njsTypes.set(Date, new DateObjectSerializer());\njsTypes.set(RegExp, new RegExpObjectSerializer());\njsTypes.set(Error, new ErrorObjectSerializer(Error));\njsTypes.set(EvalError, new ErrorObjectSerializer(EvalError));\njsTypes.set(RangeError, new ErrorObjectSerializer(RangeError));\njsTypes.set(ReferenceError, new ErrorObjectSerializer(ReferenceError));\njsTypes.set(SyntaxError, new ErrorObjectSerializer(SyntaxError));\njsTypes.set(TypeError, new ErrorObjectSerializer(TypeError));\n\n// If in a sandboxed environment (e. g. jest), this escapes the sandbox and registers\n// real Object and Array types to. These types may occur in the wild too, e. g. when\n// using Structured Clone in postMessage.\nif (exports.constructor !== Object) {\n\tconst Obj = /** @type {typeof Object} */ (exports.constructor);\n\tconst Fn = /** @type {typeof Function} */ (Obj.constructor);\n\tfor (const [type, config] of Array.from(jsTypes)) {\n\t\tif (type) {\n\t\t\tconst Type = new Fn(`return ${type.name};`)();\n\t\t\tjsTypes.set(Type, config);\n\t\t}\n\t}\n}\n\n{\n\tlet i = 1;\n\tfor (const [type, serializer] of jsTypes) {\n\t\tserializers.set(type, {\n\t\t\trequest: \"\",\n\t\t\tname: i++,\n\t\t\tserializer\n\t\t});\n\t}\n}\n\nfor (const { request, name, serializer } of serializers.values()) {\n\tserializerInversed.set(`${request}/${name}`, serializer);\n}\n\n/** @type {Map<RegExp, (request: string) => boolean>} */\nconst loaders = new Map();\n\n/**\n * @typedef {ComplexSerializableType[]} DeserializedType\n * @typedef {PrimitiveSerializableType[]} SerializedType\n * @extends {SerializerMiddleware<DeserializedType, SerializedType>}\n */\nclass ObjectMiddleware extends SerializerMiddleware {\n\t/**\n\t * @param {function(any): void} extendContext context extensions\n\t * @param {string | Hash} hashFunction hash function to use\n\t */\n\tconstructor(extendContext, hashFunction = \"md4\") {\n\t\tsuper();\n\t\tthis.extendContext = extendContext;\n\t\tthis._hashFunction = hashFunction;\n\t}\n\t/**\n\t * @param {RegExp} regExp RegExp for which the request is tested\n\t * @param {function(string): boolean} loader loader to load the request, returns true when successful\n\t * @returns {void}\n\t */\n\tstatic registerLoader(regExp, loader) {\n\t\tloaders.set(regExp, loader);\n\t}\n\n\t/**\n\t * @param {Constructor} Constructor the constructor\n\t * @param {string} request the request which will be required when deserializing\n\t * @param {string} name the name to make multiple serializer unique when sharing a request\n\t * @param {ObjectSerializer} serializer the serializer\n\t * @returns {void}\n\t */\n\tstatic register(Constructor, request, name, serializer) {\n\t\tconst key = request + \"/\" + name;\n\n\t\tif (serializers.has(Constructor)) {\n\t\t\tthrow new Error(\n\t\t\t\t`ObjectMiddleware.register: serializer for ${Constructor.name} is already registered`\n\t\t\t);\n\t\t}\n\n\t\tif (serializerInversed.has(key)) {\n\t\t\tthrow new Error(\n\t\t\t\t`ObjectMiddleware.register: serializer for ${key} is already registered`\n\t\t\t);\n\t\t}\n\n\t\tserializers.set(Constructor, {\n\t\t\trequest,\n\t\t\tname,\n\t\t\tserializer\n\t\t});\n\n\t\tserializerInversed.set(key, serializer);\n\t}\n\n\t/**\n\t * @param {Constructor} Constructor the constructor\n\t * @returns {void}\n\t */\n\tstatic registerNotSerializable(Constructor) {\n\t\tif (serializers.has(Constructor)) {\n\t\t\tthrow new Error(\n\t\t\t\t`ObjectMiddleware.registerNotSerializable: serializer for ${Constructor.name} is already registered`\n\t\t\t);\n\t\t}\n\n\t\tserializers.set(Constructor, NOT_SERIALIZABLE);\n\t}\n\n\tstatic getSerializerFor(object) {\n\t\tconst proto = Object.getPrototypeOf(object);\n\t\tlet c;\n\t\tif (proto === null) {\n\t\t\t// Object created with Object.create(null)\n\t\t\tc = null;\n\t\t} else {\n\t\t\tc = proto.constructor;\n\t\t\tif (!c) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Serialization of objects with prototype without valid constructor property not possible\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tconst config = serializers.get(c);\n\n\t\tif (!config) throw new Error(`No serializer registered for ${c.name}`);\n\t\tif (config === NOT_SERIALIZABLE) throw NOT_SERIALIZABLE;\n\n\t\treturn config;\n\t}\n\n\tstatic getDeserializerFor(request, name) {\n\t\tconst key = request + \"/\" + name;\n\t\tconst serializer = serializerInversed.get(key);\n\n\t\tif (serializer === undefined) {\n\t\t\tthrow new Error(`No deserializer registered for ${key}`);\n\t\t}\n\n\t\treturn serializer;\n\t}\n\n\tstatic _getDeserializerForWithoutError(request, name) {\n\t\tconst key = request + \"/\" + name;\n\t\tconst serializer = serializerInversed.get(key);\n\t\treturn serializer;\n\t}\n\n\t/**\n\t * @param {DeserializedType} data data\n\t * @param {Object} context context object\n\t * @returns {SerializedType|Promise<SerializedType>} serialized data\n\t */\n\tserialize(data, context) {\n\t\t/** @type {any[]} */\n\t\tlet result = [CURRENT_VERSION];\n\t\tlet currentPos = 0;\n\t\tlet referenceable = new Map();\n\t\tconst addReferenceable = item => {\n\t\t\treferenceable.set(item, currentPos++);\n\t\t};\n\t\tlet bufferDedupeMap = new Map();\n\t\tconst dedupeBuffer = buf => {\n\t\t\tconst len = buf.length;\n\t\t\tconst entry = bufferDedupeMap.get(len);\n\t\t\tif (entry === undefined) {\n\t\t\t\tbufferDedupeMap.set(len, buf);\n\t\t\t\treturn buf;\n\t\t\t}\n\t\t\tif (Buffer.isBuffer(entry)) {\n\t\t\t\tif (len < 32) {\n\t\t\t\t\tif (buf.equals(entry)) {\n\t\t\t\t\t\treturn entry;\n\t\t\t\t\t}\n\t\t\t\t\tbufferDedupeMap.set(len, [entry, buf]);\n\t\t\t\t\treturn buf;\n\t\t\t\t} else {\n\t\t\t\t\tconst hash = toHash(entry, this._hashFunction);\n\t\t\t\t\tconst newMap = new Map();\n\t\t\t\t\tnewMap.set(hash, entry);\n\t\t\t\t\tbufferDedupeMap.set(len, newMap);\n\t\t\t\t\tconst hashBuf = toHash(buf, this._hashFunction);\n\t\t\t\t\tif (hash === hashBuf) {\n\t\t\t\t\t\treturn entry;\n\t\t\t\t\t}\n\t\t\t\t\treturn buf;\n\t\t\t\t}\n\t\t\t} else if (Array.isArray(entry)) {\n\t\t\t\tif (entry.length < 16) {\n\t\t\t\t\tfor (const item of entry) {\n\t\t\t\t\t\tif (buf.equals(item)) {\n\t\t\t\t\t\t\treturn item;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tentry.push(buf);\n\t\t\t\t\treturn buf;\n\t\t\t\t} else {\n\t\t\t\t\tconst newMap = new Map();\n\t\t\t\t\tconst hash = toHash(buf, this._hashFunction);\n\t\t\t\t\tlet found;\n\t\t\t\t\tfor (const item of entry) {\n\t\t\t\t\t\tconst itemHash = toHash(item, this._hashFunction);\n\t\t\t\t\t\tnewMap.set(itemHash, item);\n\t\t\t\t\t\tif (found === undefined && itemHash === hash) found = item;\n\t\t\t\t\t}\n\t\t\t\t\tbufferDedupeMap.set(len, newMap);\n\t\t\t\t\tif (found === undefined) {\n\t\t\t\t\t\tnewMap.set(hash, buf);\n\t\t\t\t\t\treturn buf;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn found;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst hash = toHash(buf, this._hashFunction);\n\t\t\t\tconst item = entry.get(hash);\n\t\t\t\tif (item !== undefined) {\n\t\t\t\t\treturn item;\n\t\t\t\t}\n\t\t\t\tentry.set(hash, buf);\n\t\t\t\treturn buf;\n\t\t\t}\n\t\t};\n\t\tlet currentPosTypeLookup = 0;\n\t\tlet objectTypeLookup = new Map();\n\t\tconst cycleStack = new Set();\n\t\tconst stackToString = item => {\n\t\t\tconst arr = Array.from(cycleStack);\n\t\t\tarr.push(item);\n\t\t\treturn arr\n\t\t\t\t.map(item => {\n\t\t\t\t\tif (typeof item === \"string\") {\n\t\t\t\t\t\tif (item.length > 100) {\n\t\t\t\t\t\t\treturn `String ${JSON.stringify(item.slice(0, 100)).slice(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t-1\n\t\t\t\t\t\t\t)}...\"`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn `String ${JSON.stringify(item)}`;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst { request, name } = ObjectMiddleware.getSerializerFor(item);\n\t\t\t\t\t\tif (request) {\n\t\t\t\t\t\t\treturn `${request}${name ? `.${name}` : \"\"}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// ignore -> fallback\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof item === \"object\" && item !== null) {\n\t\t\t\t\t\tif (item.constructor) {\n\t\t\t\t\t\t\tif (item.constructor === Object)\n\t\t\t\t\t\t\t\treturn `Object { ${Object.keys(item).join(\", \")} }`;\n\t\t\t\t\t\t\tif (item.constructor === Map) return `Map { ${item.size} items }`;\n\t\t\t\t\t\t\tif (item.constructor === Array)\n\t\t\t\t\t\t\t\treturn `Array { ${item.length} items }`;\n\t\t\t\t\t\t\tif (item.constructor === Set) return `Set { ${item.size} items }`;\n\t\t\t\t\t\t\tif (item.constructor === RegExp) return item.toString();\n\t\t\t\t\t\t\treturn `${item.constructor.name}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn `Object [null prototype] { ${Object.keys(item).join(\n\t\t\t\t\t\t\t\", \"\n\t\t\t\t\t\t)} }`;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn `${item}`;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn `(${e.message})`;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.join(\" -> \");\n\t\t};\n\t\tlet hasDebugInfoAttached;\n\t\tlet ctx = {\n\t\t\twrite(value, key) {\n\t\t\t\ttry {\n\t\t\t\t\tprocess(value);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e !== NOT_SERIALIZABLE) {\n\t\t\t\t\t\tif (hasDebugInfoAttached === undefined)\n\t\t\t\t\t\t\thasDebugInfoAttached = new WeakSet();\n\t\t\t\t\t\tif (!hasDebugInfoAttached.has(e)) {\n\t\t\t\t\t\t\te.message += `\\nwhile serializing ${stackToString(value)}`;\n\t\t\t\t\t\t\thasDebugInfoAttached.add(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t},\n\t\t\tsetCircularReference(ref) {\n\t\t\t\taddReferenceable(ref);\n\t\t\t},\n\t\t\tsnapshot() {\n\t\t\t\treturn {\n\t\t\t\t\tlength: result.length,\n\t\t\t\t\tcycleStackSize: cycleStack.size,\n\t\t\t\t\treferenceableSize: referenceable.size,\n\t\t\t\t\tcurrentPos,\n\t\t\t\t\tobjectTypeLookupSize: objectTypeLookup.size,\n\t\t\t\t\tcurrentPosTypeLookup\n\t\t\t\t};\n\t\t\t},\n\t\t\trollback(snapshot) {\n\t\t\t\tresult.length = snapshot.length;\n\t\t\t\tsetSetSize(cycleStack, snapshot.cycleStackSize);\n\t\t\t\tsetMapSize(referenceable, snapshot.referenceableSize);\n\t\t\t\tcurrentPos = snapshot.currentPos;\n\t\t\t\tsetMapSize(objectTypeLookup, snapshot.objectTypeLookupSize);\n\t\t\t\tcurrentPosTypeLookup = snapshot.currentPosTypeLookup;\n\t\t\t},\n\t\t\t...context\n\t\t};\n\t\tthis.extendContext(ctx);\n\t\tconst process = item => {\n\t\t\tif (Buffer.isBuffer(item)) {\n\t\t\t\t// check if we can emit a reference\n\t\t\t\tconst ref = referenceable.get(item);\n\t\t\t\tif (ref !== undefined) {\n\t\t\t\t\tresult.push(ESCAPE, ref - currentPos);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst alreadyUsedBuffer = dedupeBuffer(item);\n\t\t\t\tif (alreadyUsedBuffer !== item) {\n\t\t\t\t\tconst ref = referenceable.get(alreadyUsedBuffer);\n\t\t\t\t\tif (ref !== undefined) {\n\t\t\t\t\t\treferenceable.set(item, ref);\n\t\t\t\t\t\tresult.push(ESCAPE, ref - currentPos);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\titem = alreadyUsedBuffer;\n\t\t\t\t}\n\t\t\t\taddReferenceable(item);\n\n\t\t\t\tresult.push(item);\n\t\t\t} else if (item === ESCAPE) {\n\t\t\t\tresult.push(ESCAPE, ESCAPE_ESCAPE_VALUE);\n\t\t\t} else if (\n\t\t\t\ttypeof item === \"object\"\n\t\t\t\t// We don't have to check for null as ESCAPE is null and this has been checked before\n\t\t\t) {\n\t\t\t\t// check if we can emit a reference\n\t\t\t\tconst ref = referenceable.get(item);\n\t\t\t\tif (ref !== undefined) {\n\t\t\t\t\tresult.push(ESCAPE, ref - currentPos);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (cycleStack.has(item)) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`This is a circular references. To serialize circular references use 'setCircularReference' somewhere in the circle during serialize and deserialize.`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst { request, name, serializer } =\n\t\t\t\t\tObjectMiddleware.getSerializerFor(item);\n\t\t\t\tconst key = `${request}/${name}`;\n\t\t\t\tconst lastIndex = objectTypeLookup.get(key);\n\n\t\t\t\tif (lastIndex === undefined) {\n\t\t\t\t\tobjectTypeLookup.set(key, currentPosTypeLookup++);\n\n\t\t\t\t\tresult.push(ESCAPE, request, name);\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(ESCAPE, currentPosTypeLookup - lastIndex);\n\t\t\t\t}\n\n\t\t\t\tcycleStack.add(item);\n\n\t\t\t\ttry {\n\t\t\t\t\tserializer.serialize(item, ctx);\n\t\t\t\t} finally {\n\t\t\t\t\tcycleStack.delete(item);\n\t\t\t\t}\n\n\t\t\t\tresult.push(ESCAPE, ESCAPE_END_OBJECT);\n\n\t\t\t\taddReferenceable(item);\n\t\t\t} else if (typeof item === \"string\") {\n\t\t\t\tif (item.length > 1) {\n\t\t\t\t\t// short strings are shorter when not emitting a reference (this saves 1 byte per empty string)\n\t\t\t\t\t// check if we can emit a reference\n\t\t\t\t\tconst ref = referenceable.get(item);\n\t\t\t\t\tif (ref !== undefined) {\n\t\t\t\t\t\tresult.push(ESCAPE, ref - currentPos);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\taddReferenceable(item);\n\t\t\t\t}\n\n\t\t\t\tif (item.length > 102400 && context.logger) {\n\t\t\t\t\tcontext.logger.warn(\n\t\t\t\t\t\t`Serializing big strings (${Math.round(\n\t\t\t\t\t\t\titem.length / 1024\n\t\t\t\t\t\t)}kiB) impacts deserialization performance (consider using Buffer instead and decode when needed)`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tresult.push(item);\n\t\t\t} else if (typeof item === \"function\") {\n\t\t\t\tif (!SerializerMiddleware.isLazy(item))\n\t\t\t\t\tthrow new Error(\"Unexpected function \" + item);\n\t\t\t\t/** @type {SerializedType} */\n\t\t\t\tconst serializedData =\n\t\t\t\t\tSerializerMiddleware.getLazySerializedValue(item);\n\t\t\t\tif (serializedData !== undefined) {\n\t\t\t\t\tif (typeof serializedData === \"function\") {\n\t\t\t\t\t\tresult.push(serializedData);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\"Not implemented\");\n\t\t\t\t\t}\n\t\t\t\t} else if (SerializerMiddleware.isLazy(item, this)) {\n\t\t\t\t\tthrow new Error(\"Not implemented\");\n\t\t\t\t} else {\n\t\t\t\t\tconst data = SerializerMiddleware.serializeLazy(item, data =>\n\t\t\t\t\t\tthis.serialize([data], context)\n\t\t\t\t\t);\n\t\t\t\t\tSerializerMiddleware.setLazySerializedValue(item, data);\n\t\t\t\t\tresult.push(data);\n\t\t\t\t}\n\t\t\t} else if (item === undefined) {\n\t\t\t\tresult.push(ESCAPE, ESCAPE_UNDEFINED);\n\t\t\t} else {\n\t\t\t\tresult.push(item);\n\t\t\t}\n\t\t};\n\n\t\ttry {\n\t\t\tfor (const item of data) {\n\t\t\t\tprocess(item);\n\t\t\t}\n\t\t\treturn result;\n\t\t} catch (e) {\n\t\t\tif (e === NOT_SERIALIZABLE) return null;\n\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\t// Get rid of these references to avoid leaking memory\n\t\t\t// This happens because the optimized code v8 generates\n\t\t\t// is optimized for our \"ctx.write\" method so it will reference\n\t\t\t// it from e. g. Dependency.prototype.serialize -(IC)-> ctx.write\n\t\t\tdata =\n\t\t\t\tresult =\n\t\t\t\treferenceable =\n\t\t\t\tbufferDedupeMap =\n\t\t\t\tobjectTypeLookup =\n\t\t\t\tctx =\n\t\t\t\t\tundefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {SerializedType} data data\n\t * @param {Object} context context object\n\t * @returns {DeserializedType|Promise<DeserializedType>} deserialized data\n\t */\n\tdeserialize(data, context) {\n\t\tlet currentDataPos = 0;\n\t\tconst read = () => {\n\t\t\tif (currentDataPos >= data.length)\n\t\t\t\tthrow new Error(\"Unexpected end of stream\");\n\n\t\t\treturn data[currentDataPos++];\n\t\t};\n\n\t\tif (read() !== CURRENT_VERSION)\n\t\t\tthrow new Error(\"Version mismatch, serializer changed\");\n\n\t\tlet currentPos = 0;\n\t\tlet referenceable = [];\n\t\tconst addReferenceable = item => {\n\t\t\treferenceable.push(item);\n\t\t\tcurrentPos++;\n\t\t};\n\t\tlet currentPosTypeLookup = 0;\n\t\tlet objectTypeLookup = [];\n\t\tlet result = [];\n\t\tlet ctx = {\n\t\t\tread() {\n\t\t\t\treturn decodeValue();\n\t\t\t},\n\t\t\tsetCircularReference(ref) {\n\t\t\t\taddReferenceable(ref);\n\t\t\t},\n\t\t\t...context\n\t\t};\n\t\tthis.extendContext(ctx);\n\t\tconst decodeValue = () => {\n\t\t\tconst item = read();\n\n\t\t\tif (item === ESCAPE) {\n\t\t\t\tconst nextItem = read();\n\n\t\t\t\tif (nextItem === ESCAPE_ESCAPE_VALUE) {\n\t\t\t\t\treturn ESCAPE;\n\t\t\t\t} else if (nextItem === ESCAPE_UNDEFINED) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t} else if (nextItem === ESCAPE_END_OBJECT) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Unexpected end of object at position ${currentDataPos - 1}`\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tconst request = nextItem;\n\t\t\t\t\tlet serializer;\n\n\t\t\t\t\tif (typeof request === \"number\") {\n\t\t\t\t\t\tif (request < 0) {\n\t\t\t\t\t\t\t// relative reference\n\t\t\t\t\t\t\treturn referenceable[currentPos + request];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tserializer = objectTypeLookup[currentPosTypeLookup - request];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (typeof request !== \"string\") {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Unexpected type (${typeof request}) of request ` +\n\t\t\t\t\t\t\t\t\t`at position ${currentDataPos - 1}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst name = read();\n\n\t\t\t\t\t\tserializer = ObjectMiddleware._getDeserializerForWithoutError(\n\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (serializer === undefined) {\n\t\t\t\t\t\t\tif (request && !loadedRequests.has(request)) {\n\t\t\t\t\t\t\t\tlet loaded = false;\n\t\t\t\t\t\t\t\tfor (const [regExp, loader] of loaders) {\n\t\t\t\t\t\t\t\t\tif (regExp.test(request)) {\n\t\t\t\t\t\t\t\t\t\tif (loader(request)) {\n\t\t\t\t\t\t\t\t\t\t\tloaded = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!loaded) {\n\t\t\t\t\t\t\t\t\trequire(request);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tloadedRequests.add(request);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tserializer = ObjectMiddleware.getDeserializerFor(request, name);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobjectTypeLookup.push(serializer);\n\t\t\t\t\t\tcurrentPosTypeLookup++;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst item = serializer.deserialize(ctx);\n\t\t\t\t\t\tconst end1 = read();\n\n\t\t\t\t\t\tif (end1 !== ESCAPE) {\n\t\t\t\t\t\t\tthrow new Error(\"Expected end of object\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst end2 = read();\n\n\t\t\t\t\t\tif (end2 !== ESCAPE_END_OBJECT) {\n\t\t\t\t\t\t\tthrow new Error(\"Expected end of object\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\taddReferenceable(item);\n\n\t\t\t\t\t\treturn item;\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t// As this is only for error handling, we omit creating a Map for\n\t\t\t\t\t\t// faster access to this information, as this would affect performance\n\t\t\t\t\t\t// in the good case\n\t\t\t\t\t\tlet serializerEntry;\n\t\t\t\t\t\tfor (const entry of serializers) {\n\t\t\t\t\t\t\tif (entry[1].serializer === serializer) {\n\t\t\t\t\t\t\t\tserializerEntry = entry;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst name = !serializerEntry\n\t\t\t\t\t\t\t? \"unknown\"\n\t\t\t\t\t\t\t: !serializerEntry[1].request\n\t\t\t\t\t\t\t? serializerEntry[0].name\n\t\t\t\t\t\t\t: serializerEntry[1].name\n\t\t\t\t\t\t\t? `${serializerEntry[1].request} ${serializerEntry[1].name}`\n\t\t\t\t\t\t\t: serializerEntry[1].request;\n\t\t\t\t\t\terr.message += `\\n(during deserialization of ${name})`;\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (typeof item === \"string\") {\n\t\t\t\tif (item.length > 1) {\n\t\t\t\t\taddReferenceable(item);\n\t\t\t\t}\n\n\t\t\t\treturn item;\n\t\t\t} else if (Buffer.isBuffer(item)) {\n\t\t\t\taddReferenceable(item);\n\n\t\t\t\treturn item;\n\t\t\t} else if (typeof item === \"function\") {\n\t\t\t\treturn SerializerMiddleware.deserializeLazy(\n\t\t\t\t\titem,\n\t\t\t\t\tdata => this.deserialize(data, context)[0]\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t};\n\n\t\ttry {\n\t\t\twhile (currentDataPos < data.length) {\n\t\t\t\tresult.push(decodeValue());\n\t\t\t}\n\t\t\treturn result;\n\t\t} finally {\n\t\t\t// Get rid of these references to avoid leaking memory\n\t\t\t// This happens because the optimized code v8 generates\n\t\t\t// is optimized for our \"ctx.read\" method so it will reference\n\t\t\t// it from e. g. Dependency.prototype.deserialize -(IC)-> ctx.read\n\t\t\tresult = referenceable = data = objectTypeLookup = ctx = undefined;\n\t\t}\n\t}\n}\n\nmodule.exports = ObjectMiddleware;\nmodule.exports.NOT_SERIALIZABLE = NOT_SERIALIZABLE;\n"]},"metadata":{},"sourceType":"script"}