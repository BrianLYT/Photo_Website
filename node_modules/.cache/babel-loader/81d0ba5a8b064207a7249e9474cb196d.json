{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst ConditionalInitFragment = require(\"../ConditionalInitFragment\");\n\nconst Dependency = require(\"../Dependency\");\n\nconst HarmonyLinkingError = require(\"../HarmonyLinkingError\");\n\nconst InitFragment = require(\"../InitFragment\");\n\nconst Template = require(\"../Template\");\n\nconst AwaitDependenciesInitFragment = require(\"../async-modules/AwaitDependenciesInitFragment\");\n\nconst {\n  filterRuntime,\n  mergeRuntime\n} = require(\"../util/runtime\");\n\nconst ModuleDependency = require(\"./ModuleDependency\");\n/** @typedef {import(\"webpack-sources\").ReplaceSource} ReplaceSource */\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n\n/** @typedef {import(\"../Dependency\").ReferencedExport} ReferencedExport */\n\n/** @typedef {import(\"../Dependency\").UpdateHashContext} UpdateHashContext */\n\n/** @typedef {import(\"../DependencyTemplate\").DependencyTemplateContext} DependencyTemplateContext */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n\n/** @typedef {import(\"../WebpackError\")} WebpackError */\n\n/** @typedef {import(\"../util/Hash\")} Hash */\n\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n\nconst ExportPresenceModes = {\n  NONE:\n  /** @type {0} */\n  0,\n  WARN:\n  /** @type {1} */\n  1,\n  AUTO:\n  /** @type {2} */\n  2,\n  ERROR:\n  /** @type {3} */\n  3,\n\n  fromUserOption(str) {\n    switch (str) {\n      case \"error\":\n        return ExportPresenceModes.ERROR;\n\n      case \"warn\":\n        return ExportPresenceModes.WARN;\n\n      case \"auto\":\n        return ExportPresenceModes.AUTO;\n\n      case false:\n        return ExportPresenceModes.NONE;\n\n      default:\n        throw new Error(`Invalid export presence value ${str}`);\n    }\n  }\n\n};\n\nclass HarmonyImportDependency extends ModuleDependency {\n  /**\n   *\n   * @param {string} request request string\n   * @param {number} sourceOrder source order\n   * @param {Record<string, any>=} assertions import assertions\n   */\n  constructor(request, sourceOrder, assertions) {\n    super(request);\n    this.sourceOrder = sourceOrder;\n    this.assertions = assertions;\n  }\n\n  get category() {\n    return \"esm\";\n  }\n  /**\n   * Returns list of exports referenced by this dependency\n   * @param {ModuleGraph} moduleGraph module graph\n   * @param {RuntimeSpec} runtime the runtime for which the module is analysed\n   * @returns {(string[] | ReferencedExport)[]} referenced exports\n   */\n\n\n  getReferencedExports(moduleGraph, runtime) {\n    return Dependency.NO_EXPORTS_REFERENCED;\n  }\n  /**\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @returns {string} name of the variable for the import\n   */\n\n\n  getImportVar(moduleGraph) {\n    const module = moduleGraph.getParentModule(this);\n    const meta = moduleGraph.getMeta(module);\n    let importVarMap = meta.importVarMap;\n    if (!importVarMap) meta.importVarMap = importVarMap = new Map();\n    let importVar = importVarMap.get(moduleGraph.getModule(this));\n    if (importVar) return importVar;\n    importVar = `${Template.toIdentifier(`${this.userRequest}`)}__WEBPACK_IMPORTED_MODULE_${importVarMap.size}__`;\n    importVarMap.set(moduleGraph.getModule(this), importVar);\n    return importVar;\n  }\n  /**\n   * @param {boolean} update create new variables or update existing one\n   * @param {DependencyTemplateContext} templateContext the template context\n   * @returns {[string, string]} the import statement and the compat statement\n   */\n\n\n  getImportStatement(update, _ref) {\n    let {\n      runtimeTemplate,\n      module,\n      moduleGraph,\n      chunkGraph,\n      runtimeRequirements\n    } = _ref;\n    return runtimeTemplate.importStatement({\n      update,\n      module: moduleGraph.getModule(this),\n      chunkGraph,\n      importVar: this.getImportVar(moduleGraph),\n      request: this.request,\n      originModule: module,\n      runtimeRequirements\n    });\n  }\n  /**\n   * @param {ModuleGraph} moduleGraph module graph\n   * @param {string[]} ids imported ids\n   * @param {string} additionalMessage extra info included in the error message\n   * @returns {WebpackError[] | undefined} errors\n   */\n\n\n  getLinkingErrors(moduleGraph, ids, additionalMessage) {\n    const importedModule = moduleGraph.getModule(this); // ignore errors for missing or failed modules\n\n    if (!importedModule || importedModule.getNumberOfErrors() > 0) {\n      return;\n    }\n\n    const parentModule = moduleGraph.getParentModule(this);\n    const exportsType = importedModule.getExportsType(moduleGraph, parentModule.buildMeta.strictHarmonyModule);\n\n    if (exportsType === \"namespace\" || exportsType === \"default-with-named\") {\n      if (ids.length === 0) {\n        return;\n      }\n\n      if ((exportsType !== \"default-with-named\" || ids[0] !== \"default\") && moduleGraph.isExportProvided(importedModule, ids) === false) {\n        // We are sure that it's not provided\n        // Try to provide detailed info in the error message\n        let pos = 0;\n        let exportsInfo = moduleGraph.getExportsInfo(importedModule);\n\n        while (pos < ids.length && exportsInfo) {\n          const id = ids[pos++];\n          const exportInfo = exportsInfo.getReadOnlyExportInfo(id);\n\n          if (exportInfo.provided === false) {\n            // We are sure that it's not provided\n            const providedExports = exportsInfo.getProvidedExports();\n            const moreInfo = !Array.isArray(providedExports) ? \" (possible exports unknown)\" : providedExports.length === 0 ? \" (module has no exports)\" : ` (possible exports: ${providedExports.join(\", \")})`;\n            return [new HarmonyLinkingError(`export ${ids.slice(0, pos).map(id => `'${id}'`).join(\".\")} ${additionalMessage} was not found in '${this.userRequest}'${moreInfo}`)];\n          }\n\n          exportsInfo = exportInfo.getNestedExportsInfo();\n        } // General error message\n\n\n        return [new HarmonyLinkingError(`export ${ids.map(id => `'${id}'`).join(\".\")} ${additionalMessage} was not found in '${this.userRequest}'`)];\n      }\n    }\n\n    switch (exportsType) {\n      case \"default-only\":\n        // It's has only a default export\n        if (ids.length > 0 && ids[0] !== \"default\") {\n          // In strict harmony modules we only support the default export\n          return [new HarmonyLinkingError(`Can't import the named export ${ids.map(id => `'${id}'`).join(\".\")} ${additionalMessage} from default-exporting module (only default export is available)`)];\n        }\n\n        break;\n\n      case \"default-with-named\":\n        // It has a default export and named properties redirect\n        // In some cases we still want to warn here\n        if (ids.length > 0 && ids[0] !== \"default\" && importedModule.buildMeta.defaultObject === \"redirect-warn\") {\n          // For these modules only the default export is supported\n          return [new HarmonyLinkingError(`Should not import the named export ${ids.map(id => `'${id}'`).join(\".\")} ${additionalMessage} from default-exporting module (only default export is available soon)`)];\n        }\n\n        break;\n    }\n  }\n\n  serialize(context) {\n    const {\n      write\n    } = context;\n    write(this.sourceOrder);\n    write(this.assertions);\n    super.serialize(context);\n  }\n\n  deserialize(context) {\n    const {\n      read\n    } = context;\n    this.sourceOrder = read();\n    this.assertions = read();\n    super.deserialize(context);\n  }\n\n}\n\nmodule.exports = HarmonyImportDependency;\n/** @type {WeakMap<Module, WeakMap<Module, RuntimeSpec | boolean>>} */\n\nconst importEmittedMap = new WeakMap();\nHarmonyImportDependency.Template = class HarmonyImportDependencyTemplate extends ModuleDependency.Template {\n  /**\n   * @param {Dependency} dependency the dependency for which the template should be applied\n   * @param {ReplaceSource} source the current replace source which can be modified\n   * @param {DependencyTemplateContext} templateContext the context object\n   * @returns {void}\n   */\n  apply(dependency, source, templateContext) {\n    const dep =\n    /** @type {HarmonyImportDependency} */\n    dependency;\n    const {\n      module,\n      chunkGraph,\n      moduleGraph,\n      runtime\n    } = templateContext;\n    const connection = moduleGraph.getConnection(dep);\n    if (connection && !connection.isTargetActive(runtime)) return;\n    const referencedModule = connection && connection.module;\n\n    if (connection && connection.weak && referencedModule && chunkGraph.getModuleId(referencedModule) === null) {\n      // in weak references, module might not be in any chunk\n      // but that's ok, we don't need that logic in this case\n      return;\n    }\n\n    const moduleKey = referencedModule ? referencedModule.identifier() : dep.request;\n    const key = `harmony import ${moduleKey}`;\n    const runtimeCondition = dep.weak ? false : connection ? filterRuntime(runtime, r => connection.isTargetActive(r)) : true;\n\n    if (module && referencedModule) {\n      let emittedModules = importEmittedMap.get(module);\n\n      if (emittedModules === undefined) {\n        emittedModules = new WeakMap();\n        importEmittedMap.set(module, emittedModules);\n      }\n\n      let mergedRuntimeCondition = runtimeCondition;\n      const oldRuntimeCondition = emittedModules.get(referencedModule) || false;\n\n      if (oldRuntimeCondition !== false && mergedRuntimeCondition !== true) {\n        if (mergedRuntimeCondition === false || oldRuntimeCondition === true) {\n          mergedRuntimeCondition = oldRuntimeCondition;\n        } else {\n          mergedRuntimeCondition = mergeRuntime(oldRuntimeCondition, mergedRuntimeCondition);\n        }\n      }\n\n      emittedModules.set(referencedModule, mergedRuntimeCondition);\n    }\n\n    const importStatement = dep.getImportStatement(false, templateContext);\n\n    if (referencedModule && templateContext.moduleGraph.isAsync(referencedModule)) {\n      templateContext.initFragments.push(new ConditionalInitFragment(importStatement[0], InitFragment.STAGE_HARMONY_IMPORTS, dep.sourceOrder, key, runtimeCondition));\n      templateContext.initFragments.push(new AwaitDependenciesInitFragment(new Set([dep.getImportVar(templateContext.moduleGraph)])));\n      templateContext.initFragments.push(new ConditionalInitFragment(importStatement[1], InitFragment.STAGE_ASYNC_HARMONY_IMPORTS, dep.sourceOrder, key + \" compat\", runtimeCondition));\n    } else {\n      templateContext.initFragments.push(new ConditionalInitFragment(importStatement[0] + importStatement[1], InitFragment.STAGE_HARMONY_IMPORTS, dep.sourceOrder, key, runtimeCondition));\n    }\n  }\n  /**\n   *\n   * @param {Module} module the module\n   * @param {Module} referencedModule the referenced module\n   * @returns {RuntimeSpec | boolean} runtimeCondition in which this import has been emitted\n   */\n\n\n  static getImportEmittedRuntime(module, referencedModule) {\n    const emittedModules = importEmittedMap.get(module);\n    if (emittedModules === undefined) return false;\n    return emittedModules.get(referencedModule) || false;\n  }\n\n};\nmodule.exports.ExportPresenceModes = ExportPresenceModes;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/dependencies/HarmonyImportDependency.js"],"names":["ConditionalInitFragment","require","Dependency","HarmonyLinkingError","InitFragment","Template","AwaitDependenciesInitFragment","filterRuntime","mergeRuntime","ModuleDependency","ExportPresenceModes","NONE","WARN","AUTO","ERROR","fromUserOption","str","Error","HarmonyImportDependency","constructor","request","sourceOrder","assertions","category","getReferencedExports","moduleGraph","runtime","NO_EXPORTS_REFERENCED","getImportVar","module","getParentModule","meta","getMeta","importVarMap","Map","importVar","get","getModule","toIdentifier","userRequest","size","set","getImportStatement","update","runtimeTemplate","chunkGraph","runtimeRequirements","importStatement","originModule","getLinkingErrors","ids","additionalMessage","importedModule","getNumberOfErrors","parentModule","exportsType","getExportsType","buildMeta","strictHarmonyModule","length","isExportProvided","pos","exportsInfo","getExportsInfo","id","exportInfo","getReadOnlyExportInfo","provided","providedExports","getProvidedExports","moreInfo","Array","isArray","join","slice","map","getNestedExportsInfo","defaultObject","serialize","context","write","deserialize","read","exports","importEmittedMap","WeakMap","HarmonyImportDependencyTemplate","apply","dependency","source","templateContext","dep","connection","getConnection","isTargetActive","referencedModule","weak","getModuleId","moduleKey","identifier","key","runtimeCondition","r","emittedModules","undefined","mergedRuntimeCondition","oldRuntimeCondition","isAsync","initFragments","push","STAGE_HARMONY_IMPORTS","Set","STAGE_ASYNC_HARMONY_IMPORTS","getImportEmittedRuntime"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst ConditionalInitFragment = require(\"../ConditionalInitFragment\");\nconst Dependency = require(\"../Dependency\");\nconst HarmonyLinkingError = require(\"../HarmonyLinkingError\");\nconst InitFragment = require(\"../InitFragment\");\nconst Template = require(\"../Template\");\nconst AwaitDependenciesInitFragment = require(\"../async-modules/AwaitDependenciesInitFragment\");\nconst { filterRuntime, mergeRuntime } = require(\"../util/runtime\");\nconst ModuleDependency = require(\"./ModuleDependency\");\n\n/** @typedef {import(\"webpack-sources\").ReplaceSource} ReplaceSource */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../Dependency\").ReferencedExport} ReferencedExport */\n/** @typedef {import(\"../Dependency\").UpdateHashContext} UpdateHashContext */\n/** @typedef {import(\"../DependencyTemplate\").DependencyTemplateContext} DependencyTemplateContext */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"../WebpackError\")} WebpackError */\n/** @typedef {import(\"../util/Hash\")} Hash */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\nconst ExportPresenceModes = {\n\tNONE: /** @type {0} */ (0),\n\tWARN: /** @type {1} */ (1),\n\tAUTO: /** @type {2} */ (2),\n\tERROR: /** @type {3} */ (3),\n\tfromUserOption(str) {\n\t\tswitch (str) {\n\t\t\tcase \"error\":\n\t\t\t\treturn ExportPresenceModes.ERROR;\n\t\t\tcase \"warn\":\n\t\t\t\treturn ExportPresenceModes.WARN;\n\t\t\tcase \"auto\":\n\t\t\t\treturn ExportPresenceModes.AUTO;\n\t\t\tcase false:\n\t\t\t\treturn ExportPresenceModes.NONE;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Invalid export presence value ${str}`);\n\t\t}\n\t}\n};\n\nclass HarmonyImportDependency extends ModuleDependency {\n\t/**\n\t *\n\t * @param {string} request request string\n\t * @param {number} sourceOrder source order\n\t * @param {Record<string, any>=} assertions import assertions\n\t */\n\tconstructor(request, sourceOrder, assertions) {\n\t\tsuper(request);\n\t\tthis.sourceOrder = sourceOrder;\n\t\tthis.assertions = assertions;\n\t}\n\n\tget category() {\n\t\treturn \"esm\";\n\t}\n\n\t/**\n\t * Returns list of exports referenced by this dependency\n\t * @param {ModuleGraph} moduleGraph module graph\n\t * @param {RuntimeSpec} runtime the runtime for which the module is analysed\n\t * @returns {(string[] | ReferencedExport)[]} referenced exports\n\t */\n\tgetReferencedExports(moduleGraph, runtime) {\n\t\treturn Dependency.NO_EXPORTS_REFERENCED;\n\t}\n\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @returns {string} name of the variable for the import\n\t */\n\tgetImportVar(moduleGraph) {\n\t\tconst module = moduleGraph.getParentModule(this);\n\t\tconst meta = moduleGraph.getMeta(module);\n\t\tlet importVarMap = meta.importVarMap;\n\t\tif (!importVarMap) meta.importVarMap = importVarMap = new Map();\n\t\tlet importVar = importVarMap.get(moduleGraph.getModule(this));\n\t\tif (importVar) return importVar;\n\t\timportVar = `${Template.toIdentifier(\n\t\t\t`${this.userRequest}`\n\t\t)}__WEBPACK_IMPORTED_MODULE_${importVarMap.size}__`;\n\t\timportVarMap.set(moduleGraph.getModule(this), importVar);\n\t\treturn importVar;\n\t}\n\n\t/**\n\t * @param {boolean} update create new variables or update existing one\n\t * @param {DependencyTemplateContext} templateContext the template context\n\t * @returns {[string, string]} the import statement and the compat statement\n\t */\n\tgetImportStatement(\n\t\tupdate,\n\t\t{ runtimeTemplate, module, moduleGraph, chunkGraph, runtimeRequirements }\n\t) {\n\t\treturn runtimeTemplate.importStatement({\n\t\t\tupdate,\n\t\t\tmodule: moduleGraph.getModule(this),\n\t\t\tchunkGraph,\n\t\t\timportVar: this.getImportVar(moduleGraph),\n\t\t\trequest: this.request,\n\t\t\toriginModule: module,\n\t\t\truntimeRequirements\n\t\t});\n\t}\n\n\t/**\n\t * @param {ModuleGraph} moduleGraph module graph\n\t * @param {string[]} ids imported ids\n\t * @param {string} additionalMessage extra info included in the error message\n\t * @returns {WebpackError[] | undefined} errors\n\t */\n\tgetLinkingErrors(moduleGraph, ids, additionalMessage) {\n\t\tconst importedModule = moduleGraph.getModule(this);\n\t\t// ignore errors for missing or failed modules\n\t\tif (!importedModule || importedModule.getNumberOfErrors() > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst parentModule = moduleGraph.getParentModule(this);\n\t\tconst exportsType = importedModule.getExportsType(\n\t\t\tmoduleGraph,\n\t\t\tparentModule.buildMeta.strictHarmonyModule\n\t\t);\n\t\tif (exportsType === \"namespace\" || exportsType === \"default-with-named\") {\n\t\t\tif (ids.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t(exportsType !== \"default-with-named\" || ids[0] !== \"default\") &&\n\t\t\t\tmoduleGraph.isExportProvided(importedModule, ids) === false\n\t\t\t) {\n\t\t\t\t// We are sure that it's not provided\n\n\t\t\t\t// Try to provide detailed info in the error message\n\t\t\t\tlet pos = 0;\n\t\t\t\tlet exportsInfo = moduleGraph.getExportsInfo(importedModule);\n\t\t\t\twhile (pos < ids.length && exportsInfo) {\n\t\t\t\t\tconst id = ids[pos++];\n\t\t\t\t\tconst exportInfo = exportsInfo.getReadOnlyExportInfo(id);\n\t\t\t\t\tif (exportInfo.provided === false) {\n\t\t\t\t\t\t// We are sure that it's not provided\n\t\t\t\t\t\tconst providedExports = exportsInfo.getProvidedExports();\n\t\t\t\t\t\tconst moreInfo = !Array.isArray(providedExports)\n\t\t\t\t\t\t\t? \" (possible exports unknown)\"\n\t\t\t\t\t\t\t: providedExports.length === 0\n\t\t\t\t\t\t\t? \" (module has no exports)\"\n\t\t\t\t\t\t\t: ` (possible exports: ${providedExports.join(\", \")})`;\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tnew HarmonyLinkingError(\n\t\t\t\t\t\t\t\t`export ${ids\n\t\t\t\t\t\t\t\t\t.slice(0, pos)\n\t\t\t\t\t\t\t\t\t.map(id => `'${id}'`)\n\t\t\t\t\t\t\t\t\t.join(\".\")} ${additionalMessage} was not found in '${\n\t\t\t\t\t\t\t\t\tthis.userRequest\n\t\t\t\t\t\t\t\t}'${moreInfo}`\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\texportsInfo = exportInfo.getNestedExportsInfo();\n\t\t\t\t}\n\n\t\t\t\t// General error message\n\t\t\t\treturn [\n\t\t\t\t\tnew HarmonyLinkingError(\n\t\t\t\t\t\t`export ${ids\n\t\t\t\t\t\t\t.map(id => `'${id}'`)\n\t\t\t\t\t\t\t.join(\".\")} ${additionalMessage} was not found in '${\n\t\t\t\t\t\t\tthis.userRequest\n\t\t\t\t\t\t}'`\n\t\t\t\t\t)\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\t\tswitch (exportsType) {\n\t\t\tcase \"default-only\":\n\t\t\t\t// It's has only a default export\n\t\t\t\tif (ids.length > 0 && ids[0] !== \"default\") {\n\t\t\t\t\t// In strict harmony modules we only support the default export\n\t\t\t\t\treturn [\n\t\t\t\t\t\tnew HarmonyLinkingError(\n\t\t\t\t\t\t\t`Can't import the named export ${ids\n\t\t\t\t\t\t\t\t.map(id => `'${id}'`)\n\t\t\t\t\t\t\t\t.join(\n\t\t\t\t\t\t\t\t\t\".\"\n\t\t\t\t\t\t\t\t)} ${additionalMessage} from default-exporting module (only default export is available)`\n\t\t\t\t\t\t)\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"default-with-named\":\n\t\t\t\t// It has a default export and named properties redirect\n\t\t\t\t// In some cases we still want to warn here\n\t\t\t\tif (\n\t\t\t\t\tids.length > 0 &&\n\t\t\t\t\tids[0] !== \"default\" &&\n\t\t\t\t\timportedModule.buildMeta.defaultObject === \"redirect-warn\"\n\t\t\t\t) {\n\t\t\t\t\t// For these modules only the default export is supported\n\t\t\t\t\treturn [\n\t\t\t\t\t\tnew HarmonyLinkingError(\n\t\t\t\t\t\t\t`Should not import the named export ${ids\n\t\t\t\t\t\t\t\t.map(id => `'${id}'`)\n\t\t\t\t\t\t\t\t.join(\n\t\t\t\t\t\t\t\t\t\".\"\n\t\t\t\t\t\t\t\t)} ${additionalMessage} from default-exporting module (only default export is available soon)`\n\t\t\t\t\t\t)\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tserialize(context) {\n\t\tconst { write } = context;\n\t\twrite(this.sourceOrder);\n\t\twrite(this.assertions);\n\t\tsuper.serialize(context);\n\t}\n\n\tdeserialize(context) {\n\t\tconst { read } = context;\n\t\tthis.sourceOrder = read();\n\t\tthis.assertions = read();\n\t\tsuper.deserialize(context);\n\t}\n}\n\nmodule.exports = HarmonyImportDependency;\n\n/** @type {WeakMap<Module, WeakMap<Module, RuntimeSpec | boolean>>} */\nconst importEmittedMap = new WeakMap();\n\nHarmonyImportDependency.Template = class HarmonyImportDependencyTemplate extends (\n\tModuleDependency.Template\n) {\n\t/**\n\t * @param {Dependency} dependency the dependency for which the template should be applied\n\t * @param {ReplaceSource} source the current replace source which can be modified\n\t * @param {DependencyTemplateContext} templateContext the context object\n\t * @returns {void}\n\t */\n\tapply(dependency, source, templateContext) {\n\t\tconst dep = /** @type {HarmonyImportDependency} */ (dependency);\n\t\tconst { module, chunkGraph, moduleGraph, runtime } = templateContext;\n\n\t\tconst connection = moduleGraph.getConnection(dep);\n\t\tif (connection && !connection.isTargetActive(runtime)) return;\n\n\t\tconst referencedModule = connection && connection.module;\n\n\t\tif (\n\t\t\tconnection &&\n\t\t\tconnection.weak &&\n\t\t\treferencedModule &&\n\t\t\tchunkGraph.getModuleId(referencedModule) === null\n\t\t) {\n\t\t\t// in weak references, module might not be in any chunk\n\t\t\t// but that's ok, we don't need that logic in this case\n\t\t\treturn;\n\t\t}\n\n\t\tconst moduleKey = referencedModule\n\t\t\t? referencedModule.identifier()\n\t\t\t: dep.request;\n\t\tconst key = `harmony import ${moduleKey}`;\n\n\t\tconst runtimeCondition = dep.weak\n\t\t\t? false\n\t\t\t: connection\n\t\t\t? filterRuntime(runtime, r => connection.isTargetActive(r))\n\t\t\t: true;\n\n\t\tif (module && referencedModule) {\n\t\t\tlet emittedModules = importEmittedMap.get(module);\n\t\t\tif (emittedModules === undefined) {\n\t\t\t\temittedModules = new WeakMap();\n\t\t\t\timportEmittedMap.set(module, emittedModules);\n\t\t\t}\n\t\t\tlet mergedRuntimeCondition = runtimeCondition;\n\t\t\tconst oldRuntimeCondition = emittedModules.get(referencedModule) || false;\n\t\t\tif (oldRuntimeCondition !== false && mergedRuntimeCondition !== true) {\n\t\t\t\tif (mergedRuntimeCondition === false || oldRuntimeCondition === true) {\n\t\t\t\t\tmergedRuntimeCondition = oldRuntimeCondition;\n\t\t\t\t} else {\n\t\t\t\t\tmergedRuntimeCondition = mergeRuntime(\n\t\t\t\t\t\toldRuntimeCondition,\n\t\t\t\t\t\tmergedRuntimeCondition\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\temittedModules.set(referencedModule, mergedRuntimeCondition);\n\t\t}\n\n\t\tconst importStatement = dep.getImportStatement(false, templateContext);\n\t\tif (\n\t\t\treferencedModule &&\n\t\t\ttemplateContext.moduleGraph.isAsync(referencedModule)\n\t\t) {\n\t\t\ttemplateContext.initFragments.push(\n\t\t\t\tnew ConditionalInitFragment(\n\t\t\t\t\timportStatement[0],\n\t\t\t\t\tInitFragment.STAGE_HARMONY_IMPORTS,\n\t\t\t\t\tdep.sourceOrder,\n\t\t\t\t\tkey,\n\t\t\t\t\truntimeCondition\n\t\t\t\t)\n\t\t\t);\n\t\t\ttemplateContext.initFragments.push(\n\t\t\t\tnew AwaitDependenciesInitFragment(\n\t\t\t\t\tnew Set([dep.getImportVar(templateContext.moduleGraph)])\n\t\t\t\t)\n\t\t\t);\n\t\t\ttemplateContext.initFragments.push(\n\t\t\t\tnew ConditionalInitFragment(\n\t\t\t\t\timportStatement[1],\n\t\t\t\t\tInitFragment.STAGE_ASYNC_HARMONY_IMPORTS,\n\t\t\t\t\tdep.sourceOrder,\n\t\t\t\t\tkey + \" compat\",\n\t\t\t\t\truntimeCondition\n\t\t\t\t)\n\t\t\t);\n\t\t} else {\n\t\t\ttemplateContext.initFragments.push(\n\t\t\t\tnew ConditionalInitFragment(\n\t\t\t\t\timportStatement[0] + importStatement[1],\n\t\t\t\t\tInitFragment.STAGE_HARMONY_IMPORTS,\n\t\t\t\t\tdep.sourceOrder,\n\t\t\t\t\tkey,\n\t\t\t\t\truntimeCondition\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param {Module} module the module\n\t * @param {Module} referencedModule the referenced module\n\t * @returns {RuntimeSpec | boolean} runtimeCondition in which this import has been emitted\n\t */\n\tstatic getImportEmittedRuntime(module, referencedModule) {\n\t\tconst emittedModules = importEmittedMap.get(module);\n\t\tif (emittedModules === undefined) return false;\n\t\treturn emittedModules.get(referencedModule) || false;\n\t}\n};\n\nmodule.exports.ExportPresenceModes = ExportPresenceModes;\n"]},"metadata":{},"sourceType":"script"}