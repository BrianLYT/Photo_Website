{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/** @template T @typedef {(string | Record<string, string | string[] | T>)[] | Record<string, string | string[] | T>} ContainerOptionsFormat */\n\n/**\n * @template T\n * @template N\n * @param {ContainerOptionsFormat<T>} options options passed by the user\n * @param {function(string | string[], string) : N} normalizeSimple normalize a simple item\n * @param {function(T, string) : N} normalizeOptions normalize a complex item\n * @param {function(string, N): void} fn processing function\n * @returns {void}\n */\n\nconst process = (options, normalizeSimple, normalizeOptions, fn) => {\n  const array = items => {\n    for (const item of items) {\n      if (typeof item === \"string\") {\n        fn(item, normalizeSimple(item, item));\n      } else if (item && typeof item === \"object\") {\n        object(item);\n      } else {\n        throw new Error(\"Unexpected options format\");\n      }\n    }\n  };\n\n  const object = obj => {\n    for (const [key, value] of Object.entries(obj)) {\n      if (typeof value === \"string\" || Array.isArray(value)) {\n        fn(key, normalizeSimple(value, key));\n      } else {\n        fn(key, normalizeOptions(value, key));\n      }\n    }\n  };\n\n  if (!options) {\n    return;\n  } else if (Array.isArray(options)) {\n    array(options);\n  } else if (typeof options === \"object\") {\n    object(options);\n  } else {\n    throw new Error(\"Unexpected options format\");\n  }\n};\n/**\n * @template T\n * @template R\n * @param {ContainerOptionsFormat<T>} options options passed by the user\n * @param {function(string | string[], string) : R} normalizeSimple normalize a simple item\n * @param {function(T, string) : R} normalizeOptions normalize a complex item\n * @returns {[string, R][]} parsed options\n */\n\n\nconst parseOptions = (options, normalizeSimple, normalizeOptions) => {\n  /** @type {[string, R][]} */\n  const items = [];\n  process(options, normalizeSimple, normalizeOptions, (key, value) => {\n    items.push([key, value]);\n  });\n  return items;\n};\n/**\n * @template T\n * @param {string} scope scope name\n * @param {ContainerOptionsFormat<T>} options options passed by the user\n * @returns {Record<string, string | string[] | T>} options to spread or pass\n */\n\n\nconst scope = (scope, options) => {\n  /** @type {Record<string, string | string[] | T>} */\n  const obj = {};\n  process(options, item =>\n  /** @type {string | string[] | T} */\n  item, item =>\n  /** @type {string | string[] | T} */\n  item, (key, value) => {\n    obj[key.startsWith(\"./\") ? `${scope}${key.slice(1)}` : `${scope}/${key}`] = value;\n  });\n  return obj;\n};\n\nexports.parseOptions = parseOptions;\nexports.scope = scope;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack/lib/container/options.js"],"names":["process","options","normalizeSimple","normalizeOptions","fn","array","items","item","object","Error","obj","key","value","Object","entries","Array","isArray","parseOptions","push","scope","startsWith","slice","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMA,OAAO,GAAG,CAACC,OAAD,EAAUC,eAAV,EAA2BC,gBAA3B,EAA6CC,EAA7C,KAAoD;AACnE,QAAMC,KAAK,GAAGC,KAAK,IAAI;AACtB,SAAK,MAAMC,IAAX,IAAmBD,KAAnB,EAA0B;AACzB,UAAI,OAAOC,IAAP,KAAgB,QAApB,EAA8B;AAC7BH,QAAAA,EAAE,CAACG,IAAD,EAAOL,eAAe,CAACK,IAAD,EAAOA,IAAP,CAAtB,CAAF;AACA,OAFD,MAEO,IAAIA,IAAI,IAAI,OAAOA,IAAP,KAAgB,QAA5B,EAAsC;AAC5CC,QAAAA,MAAM,CAACD,IAAD,CAAN;AACA,OAFM,MAEA;AACN,cAAM,IAAIE,KAAJ,CAAU,2BAAV,CAAN;AACA;AACD;AACD,GAVD;;AAWA,QAAMD,MAAM,GAAGE,GAAG,IAAI;AACrB,SAAK,MAAM,CAACC,GAAD,EAAMC,KAAN,CAAX,IAA2BC,MAAM,CAACC,OAAP,CAAeJ,GAAf,CAA3B,EAAgD;AAC/C,UAAI,OAAOE,KAAP,KAAiB,QAAjB,IAA6BG,KAAK,CAACC,OAAN,CAAcJ,KAAd,CAAjC,EAAuD;AACtDR,QAAAA,EAAE,CAACO,GAAD,EAAMT,eAAe,CAACU,KAAD,EAAQD,GAAR,CAArB,CAAF;AACA,OAFD,MAEO;AACNP,QAAAA,EAAE,CAACO,GAAD,EAAMR,gBAAgB,CAACS,KAAD,EAAQD,GAAR,CAAtB,CAAF;AACA;AACD;AACD,GARD;;AASA,MAAI,CAACV,OAAL,EAAc;AACb;AACA,GAFD,MAEO,IAAIc,KAAK,CAACC,OAAN,CAAcf,OAAd,CAAJ,EAA4B;AAClCI,IAAAA,KAAK,CAACJ,OAAD,CAAL;AACA,GAFM,MAEA,IAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AACvCO,IAAAA,MAAM,CAACP,OAAD,CAAN;AACA,GAFM,MAEA;AACN,UAAM,IAAIQ,KAAJ,CAAU,2BAAV,CAAN;AACA;AACD,CA9BD;AAgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMQ,YAAY,GAAG,CAAChB,OAAD,EAAUC,eAAV,EAA2BC,gBAA3B,KAAgD;AACpE;AACA,QAAMG,KAAK,GAAG,EAAd;AACAN,EAAAA,OAAO,CAACC,OAAD,EAAUC,eAAV,EAA2BC,gBAA3B,EAA6C,CAACQ,GAAD,EAAMC,KAAN,KAAgB;AACnEN,IAAAA,KAAK,CAACY,IAAN,CAAW,CAACP,GAAD,EAAMC,KAAN,CAAX;AACA,GAFM,CAAP;AAGA,SAAON,KAAP;AACA,CAPD;AASA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMa,KAAK,GAAG,CAACA,KAAD,EAAQlB,OAAR,KAAoB;AACjC;AACA,QAAMS,GAAG,GAAG,EAAZ;AACAV,EAAAA,OAAO,CACNC,OADM,EAENM,IAAI;AAAI;AAAsCA,EAAAA,IAFxC,EAGNA,IAAI;AAAI;AAAsCA,EAAAA,IAHxC,EAIN,CAACI,GAAD,EAAMC,KAAN,KAAgB;AACfF,IAAAA,GAAG,CACFC,GAAG,CAACS,UAAJ,CAAe,IAAf,IAAwB,GAAED,KAAM,GAAER,GAAG,CAACU,KAAJ,CAAU,CAAV,CAAa,EAA/C,GAAoD,GAAEF,KAAM,IAAGR,GAAI,EADjE,CAAH,GAEIC,KAFJ;AAGA,GARK,CAAP;AAUA,SAAOF,GAAP;AACA,CAdD;;AAgBAY,OAAO,CAACL,YAAR,GAAuBA,YAAvB;AACAK,OAAO,CAACH,KAAR,GAAgBA,KAAhB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @template T @typedef {(string | Record<string, string | string[] | T>)[] | Record<string, string | string[] | T>} ContainerOptionsFormat */\n\n/**\n * @template T\n * @template N\n * @param {ContainerOptionsFormat<T>} options options passed by the user\n * @param {function(string | string[], string) : N} normalizeSimple normalize a simple item\n * @param {function(T, string) : N} normalizeOptions normalize a complex item\n * @param {function(string, N): void} fn processing function\n * @returns {void}\n */\nconst process = (options, normalizeSimple, normalizeOptions, fn) => {\n\tconst array = items => {\n\t\tfor (const item of items) {\n\t\t\tif (typeof item === \"string\") {\n\t\t\t\tfn(item, normalizeSimple(item, item));\n\t\t\t} else if (item && typeof item === \"object\") {\n\t\t\t\tobject(item);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Unexpected options format\");\n\t\t\t}\n\t\t}\n\t};\n\tconst object = obj => {\n\t\tfor (const [key, value] of Object.entries(obj)) {\n\t\t\tif (typeof value === \"string\" || Array.isArray(value)) {\n\t\t\t\tfn(key, normalizeSimple(value, key));\n\t\t\t} else {\n\t\t\t\tfn(key, normalizeOptions(value, key));\n\t\t\t}\n\t\t}\n\t};\n\tif (!options) {\n\t\treturn;\n\t} else if (Array.isArray(options)) {\n\t\tarray(options);\n\t} else if (typeof options === \"object\") {\n\t\tobject(options);\n\t} else {\n\t\tthrow new Error(\"Unexpected options format\");\n\t}\n};\n\n/**\n * @template T\n * @template R\n * @param {ContainerOptionsFormat<T>} options options passed by the user\n * @param {function(string | string[], string) : R} normalizeSimple normalize a simple item\n * @param {function(T, string) : R} normalizeOptions normalize a complex item\n * @returns {[string, R][]} parsed options\n */\nconst parseOptions = (options, normalizeSimple, normalizeOptions) => {\n\t/** @type {[string, R][]} */\n\tconst items = [];\n\tprocess(options, normalizeSimple, normalizeOptions, (key, value) => {\n\t\titems.push([key, value]);\n\t});\n\treturn items;\n};\n\n/**\n * @template T\n * @param {string} scope scope name\n * @param {ContainerOptionsFormat<T>} options options passed by the user\n * @returns {Record<string, string | string[] | T>} options to spread or pass\n */\nconst scope = (scope, options) => {\n\t/** @type {Record<string, string | string[] | T>} */\n\tconst obj = {};\n\tprocess(\n\t\toptions,\n\t\titem => /** @type {string | string[] | T} */ (item),\n\t\titem => /** @type {string | string[] | T} */ (item),\n\t\t(key, value) => {\n\t\t\tobj[\n\t\t\t\tkey.startsWith(\"./\") ? `${scope}${key.slice(1)}` : `${scope}/${key}`\n\t\t\t] = value;\n\t\t}\n\t);\n\treturn obj;\n};\n\nexports.parseOptions = parseOptions;\nexports.scope = scope;\n"]},"metadata":{},"sourceType":"script"}