{"ast":null,"code":"'use strict';\n\nvar _types = require('../types');\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nlet file = null;\nlet setupArgs = [];\nlet initialized = false;\n/**\n * This file is a small bootstrapper for workers. It sets up the communication\n * between the worker and the parent process, interpreting parent messages and\n * sending results back.\n *\n * The file loaded will be lazily initialized the first time any of the workers\n * is called. This is done for optimal performance: if the farm is initialized,\n * but no call is made to it, child Node processes will be consuming the least\n * possible amount of memory.\n *\n * If an invalid message is detected, the child will exit (by throwing) with a\n * non-zero exit code.\n */\n\nconst messageListener = request => {\n  switch (request[0]) {\n    case _types.CHILD_MESSAGE_INITIALIZE:\n      const init = request;\n      file = init[2];\n      setupArgs = request[3];\n      break;\n\n    case _types.CHILD_MESSAGE_CALL:\n      const call = request;\n      execMethod(call[2], call[3]);\n      break;\n\n    case _types.CHILD_MESSAGE_END:\n      end();\n      break;\n\n    default:\n      throw new TypeError('Unexpected request from parent process: ' + request[0]);\n  }\n};\n\nprocess.on('message', messageListener);\n\nfunction reportSuccess(result) {\n  if (!process || !process.send) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  process.send([_types.PARENT_MESSAGE_OK, result]);\n}\n\nfunction reportClientError(error) {\n  return reportError(error, _types.PARENT_MESSAGE_CLIENT_ERROR);\n}\n\nfunction reportInitializeError(error) {\n  return reportError(error, _types.PARENT_MESSAGE_SETUP_ERROR);\n}\n\nfunction reportError(error, type) {\n  if (!process || !process.send) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  if (error == null) {\n    error = new Error('\"null\" or \"undefined\" thrown');\n  }\n\n  process.send([type, error.constructor && error.constructor.name, error.message, error.stack, typeof error === 'object' ? { ...error\n  } : error]);\n}\n\nfunction end() {\n  const main = require(file);\n\n  if (!main.teardown) {\n    exitProcess();\n    return;\n  }\n\n  execFunction(main.teardown, main, [], exitProcess, exitProcess);\n}\n\nfunction exitProcess() {\n  // Clean up open handles so the process ideally exits gracefully\n  process.removeListener('message', messageListener);\n}\n\nfunction execMethod(method, args) {\n  const main = require(file);\n\n  let fn;\n\n  if (method === 'default') {\n    fn = main.__esModule ? main['default'] : main;\n  } else {\n    fn = main[method];\n  }\n\n  function execHelper() {\n    execFunction(fn, main, args, reportSuccess, reportClientError);\n  }\n\n  if (initialized || !main.setup) {\n    execHelper();\n    return;\n  }\n\n  initialized = true;\n  execFunction(main.setup, main, setupArgs, execHelper, reportInitializeError);\n}\n\nconst isPromise = obj => !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';\n\nfunction execFunction(fn, ctx, args, onResult, onError) {\n  let result;\n\n  try {\n    result = fn.apply(ctx, args);\n  } catch (err) {\n    onError(err);\n    return;\n  }\n\n  if (isPromise(result)) {\n    result.then(onResult, onError);\n  } else {\n    onResult(result);\n  }\n}","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/jest-worker/build/workers/processChild.js"],"names":["_types","require","file","setupArgs","initialized","messageListener","request","CHILD_MESSAGE_INITIALIZE","init","CHILD_MESSAGE_CALL","call","execMethod","CHILD_MESSAGE_END","end","TypeError","process","on","reportSuccess","result","send","Error","PARENT_MESSAGE_OK","reportClientError","error","reportError","PARENT_MESSAGE_CLIENT_ERROR","reportInitializeError","PARENT_MESSAGE_SETUP_ERROR","type","constructor","name","message","stack","main","teardown","exitProcess","execFunction","removeListener","method","args","fn","__esModule","execHelper","setup","isPromise","obj","then","ctx","onResult","onError","apply","err"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _types = require('../types');\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nlet file = null;\nlet setupArgs = [];\nlet initialized = false;\n/**\n * This file is a small bootstrapper for workers. It sets up the communication\n * between the worker and the parent process, interpreting parent messages and\n * sending results back.\n *\n * The file loaded will be lazily initialized the first time any of the workers\n * is called. This is done for optimal performance: if the farm is initialized,\n * but no call is made to it, child Node processes will be consuming the least\n * possible amount of memory.\n *\n * If an invalid message is detected, the child will exit (by throwing) with a\n * non-zero exit code.\n */\n\nconst messageListener = request => {\n  switch (request[0]) {\n    case _types.CHILD_MESSAGE_INITIALIZE:\n      const init = request;\n      file = init[2];\n      setupArgs = request[3];\n      break;\n\n    case _types.CHILD_MESSAGE_CALL:\n      const call = request;\n      execMethod(call[2], call[3]);\n      break;\n\n    case _types.CHILD_MESSAGE_END:\n      end();\n      break;\n\n    default:\n      throw new TypeError(\n        'Unexpected request from parent process: ' + request[0]\n      );\n  }\n};\n\nprocess.on('message', messageListener);\n\nfunction reportSuccess(result) {\n  if (!process || !process.send) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  process.send([_types.PARENT_MESSAGE_OK, result]);\n}\n\nfunction reportClientError(error) {\n  return reportError(error, _types.PARENT_MESSAGE_CLIENT_ERROR);\n}\n\nfunction reportInitializeError(error) {\n  return reportError(error, _types.PARENT_MESSAGE_SETUP_ERROR);\n}\n\nfunction reportError(error, type) {\n  if (!process || !process.send) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  if (error == null) {\n    error = new Error('\"null\" or \"undefined\" thrown');\n  }\n\n  process.send([\n    type,\n    error.constructor && error.constructor.name,\n    error.message,\n    error.stack,\n    typeof error === 'object' ? {...error} : error\n  ]);\n}\n\nfunction end() {\n  const main = require(file);\n\n  if (!main.teardown) {\n    exitProcess();\n    return;\n  }\n\n  execFunction(main.teardown, main, [], exitProcess, exitProcess);\n}\n\nfunction exitProcess() {\n  // Clean up open handles so the process ideally exits gracefully\n  process.removeListener('message', messageListener);\n}\n\nfunction execMethod(method, args) {\n  const main = require(file);\n\n  let fn;\n\n  if (method === 'default') {\n    fn = main.__esModule ? main['default'] : main;\n  } else {\n    fn = main[method];\n  }\n\n  function execHelper() {\n    execFunction(fn, main, args, reportSuccess, reportClientError);\n  }\n\n  if (initialized || !main.setup) {\n    execHelper();\n    return;\n  }\n\n  initialized = true;\n  execFunction(main.setup, main, setupArgs, execHelper, reportInitializeError);\n}\n\nconst isPromise = obj =>\n  !!obj &&\n  (typeof obj === 'object' || typeof obj === 'function') &&\n  typeof obj.then === 'function';\n\nfunction execFunction(fn, ctx, args, onResult, onError) {\n  let result;\n\n  try {\n    result = fn.apply(ctx, args);\n  } catch (err) {\n    onError(err);\n    return;\n  }\n\n  if (isPromise(result)) {\n    result.then(onResult, onError);\n  } else {\n    onResult(result);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}