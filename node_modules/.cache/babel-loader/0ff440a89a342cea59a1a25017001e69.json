{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  getMap,\n  getSourceAndMap\n} = require(\"./helpers/getFromStreamChunks\");\n\nconst splitIntoLines = require(\"./helpers/splitIntoLines\");\n\nconst getGeneratedSourceInfo = require(\"./helpers/getGeneratedSourceInfo\");\n\nconst Source = require(\"./Source\");\n\nconst splitIntoPotentialTokens = require(\"./helpers/splitIntoPotentialTokens\");\n\nclass OriginalSource extends Source {\n  constructor(value, name) {\n    super();\n    const isBuffer = Buffer.isBuffer(value);\n    this._value = isBuffer ? undefined : value;\n    this._valueAsBuffer = isBuffer ? value : undefined;\n    this._name = name;\n  }\n\n  getName() {\n    return this._name;\n  }\n\n  source() {\n    if (this._value === undefined) {\n      this._value = this._valueAsBuffer.toString(\"utf-8\");\n    }\n\n    return this._value;\n  }\n\n  buffer() {\n    if (this._valueAsBuffer === undefined) {\n      this._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n    }\n\n    return this._valueAsBuffer;\n  }\n\n  map(options) {\n    return getMap(this, options);\n  }\n\n  sourceAndMap(options) {\n    return getSourceAndMap(this, options);\n  }\n  /**\n   * @param {object} options options\n   * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code\n   * @param {function(number, string, string)} onSource called for each source\n   * @param {function(number, string)} onName called for each name\n   * @returns {void}\n   */\n\n\n  streamChunks(options, onChunk, onSource, onName) {\n    if (this._value === undefined) {\n      this._value = this._valueAsBuffer.toString(\"utf-8\");\n    }\n\n    onSource(0, this._name, this._value);\n    const finalSource = !!(options && options.finalSource);\n\n    if (!options || options.columns !== false) {\n      // With column info we need to read all lines and split them\n      const matches = splitIntoPotentialTokens(this._value);\n      let line = 1;\n      let column = 0;\n\n      if (matches !== null) {\n        for (const match of matches) {\n          const isEndOfLine = match.endsWith(\"\\n\");\n\n          if (isEndOfLine && match.length === 1) {\n            if (!finalSource) onChunk(match, line, column, -1, -1, -1, -1);\n          } else {\n            const chunk = finalSource ? undefined : match;\n            onChunk(chunk, line, column, 0, line, column, -1);\n          }\n\n          if (isEndOfLine) {\n            line++;\n            column = 0;\n          } else {\n            column += match.length;\n          }\n        }\n      }\n\n      return {\n        generatedLine: line,\n        generatedColumn: column,\n        source: finalSource ? this._value : undefined\n      };\n    } else if (finalSource) {\n      // Without column info and with final source we only\n      // need meta info to generate mapping\n      const result = getGeneratedSourceInfo(this._value);\n      const {\n        generatedLine,\n        generatedColumn\n      } = result;\n\n      if (generatedColumn === 0) {\n        for (let line = 1; line < generatedLine; line++) onChunk(undefined, line, 0, 0, line, 0, -1);\n      } else {\n        for (let line = 1; line <= generatedLine; line++) onChunk(undefined, line, 0, 0, line, 0, -1);\n      }\n\n      return result;\n    } else {\n      // Without column info, but also without final source\n      // we need to split source by lines\n      let line = 1;\n      const matches = splitIntoLines(this._value);\n      let match;\n\n      for (match of matches) {\n        onChunk(finalSource ? undefined : match, line, 0, 0, line, 0, -1);\n        line++;\n      }\n\n      return matches.length === 0 || match.endsWith(\"\\n\") ? {\n        generatedLine: matches.length + 1,\n        generatedColumn: 0,\n        source: finalSource ? this._value : undefined\n      } : {\n        generatedLine: matches.length,\n        generatedColumn: match.length,\n        source: finalSource ? this._value : undefined\n      };\n    }\n  }\n\n  updateHash(hash) {\n    if (this._valueAsBuffer === undefined) {\n      this._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n    }\n\n    hash.update(\"OriginalSource\");\n    hash.update(this._valueAsBuffer);\n    hash.update(this._name || \"\");\n  }\n\n}\n\nmodule.exports = OriginalSource;","map":{"version":3,"sources":["G:/0_coding/Side Project/photo-website/node_modules/webpack-sources/lib/OriginalSource.js"],"names":["getMap","getSourceAndMap","require","splitIntoLines","getGeneratedSourceInfo","Source","splitIntoPotentialTokens","OriginalSource","constructor","value","name","isBuffer","Buffer","_value","undefined","_valueAsBuffer","_name","getName","source","toString","buffer","from","map","options","sourceAndMap","streamChunks","onChunk","onSource","onName","finalSource","columns","matches","line","column","match","isEndOfLine","endsWith","length","chunk","generatedLine","generatedColumn","result","updateHash","hash","update","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst { getMap, getSourceAndMap } = require(\"./helpers/getFromStreamChunks\");\nconst splitIntoLines = require(\"./helpers/splitIntoLines\");\nconst getGeneratedSourceInfo = require(\"./helpers/getGeneratedSourceInfo\");\nconst Source = require(\"./Source\");\nconst splitIntoPotentialTokens = require(\"./helpers/splitIntoPotentialTokens\");\n\nclass OriginalSource extends Source {\n\tconstructor(value, name) {\n\t\tsuper();\n\t\tconst isBuffer = Buffer.isBuffer(value);\n\t\tthis._value = isBuffer ? undefined : value;\n\t\tthis._valueAsBuffer = isBuffer ? value : undefined;\n\t\tthis._name = name;\n\t}\n\n\tgetName() {\n\t\treturn this._name;\n\t}\n\n\tsource() {\n\t\tif (this._value === undefined) {\n\t\t\tthis._value = this._valueAsBuffer.toString(\"utf-8\");\n\t\t}\n\t\treturn this._value;\n\t}\n\n\tbuffer() {\n\t\tif (this._valueAsBuffer === undefined) {\n\t\t\tthis._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n\t\t}\n\t\treturn this._valueAsBuffer;\n\t}\n\n\tmap(options) {\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\t/**\n\t * @param {object} options options\n\t * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code\n\t * @param {function(number, string, string)} onSource called for each source\n\t * @param {function(number, string)} onName called for each name\n\t * @returns {void}\n\t */\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tif (this._value === undefined) {\n\t\t\tthis._value = this._valueAsBuffer.toString(\"utf-8\");\n\t\t}\n\t\tonSource(0, this._name, this._value);\n\t\tconst finalSource = !!(options && options.finalSource);\n\t\tif (!options || options.columns !== false) {\n\t\t\t// With column info we need to read all lines and split them\n\t\t\tconst matches = splitIntoPotentialTokens(this._value);\n\t\t\tlet line = 1;\n\t\t\tlet column = 0;\n\t\t\tif (matches !== null) {\n\t\t\t\tfor (const match of matches) {\n\t\t\t\t\tconst isEndOfLine = match.endsWith(\"\\n\");\n\t\t\t\t\tif (isEndOfLine && match.length === 1) {\n\t\t\t\t\t\tif (!finalSource) onChunk(match, line, column, -1, -1, -1, -1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst chunk = finalSource ? undefined : match;\n\t\t\t\t\t\tonChunk(chunk, line, column, 0, line, column, -1);\n\t\t\t\t\t}\n\t\t\t\t\tif (isEndOfLine) {\n\t\t\t\t\t\tline++;\n\t\t\t\t\t\tcolumn = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolumn += match.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tgeneratedLine: line,\n\t\t\t\tgeneratedColumn: column,\n\t\t\t\tsource: finalSource ? this._value : undefined\n\t\t\t};\n\t\t} else if (finalSource) {\n\t\t\t// Without column info and with final source we only\n\t\t\t// need meta info to generate mapping\n\t\t\tconst result = getGeneratedSourceInfo(this._value);\n\t\t\tconst { generatedLine, generatedColumn } = result;\n\t\t\tif (generatedColumn === 0) {\n\t\t\t\tfor (let line = 1; line < generatedLine; line++)\n\t\t\t\t\tonChunk(undefined, line, 0, 0, line, 0, -1);\n\t\t\t} else {\n\t\t\t\tfor (let line = 1; line <= generatedLine; line++)\n\t\t\t\t\tonChunk(undefined, line, 0, 0, line, 0, -1);\n\t\t\t}\n\t\t\treturn result;\n\t\t} else {\n\t\t\t// Without column info, but also without final source\n\t\t\t// we need to split source by lines\n\t\t\tlet line = 1;\n\t\t\tconst matches = splitIntoLines(this._value);\n\t\t\tlet match;\n\t\t\tfor (match of matches) {\n\t\t\t\tonChunk(finalSource ? undefined : match, line, 0, 0, line, 0, -1);\n\t\t\t\tline++;\n\t\t\t}\n\t\t\treturn matches.length === 0 || match.endsWith(\"\\n\")\n\t\t\t\t? {\n\t\t\t\t\t\tgeneratedLine: matches.length + 1,\n\t\t\t\t\t\tgeneratedColumn: 0,\n\t\t\t\t\t\tsource: finalSource ? this._value : undefined\n\t\t\t\t  }\n\t\t\t\t: {\n\t\t\t\t\t\tgeneratedLine: matches.length,\n\t\t\t\t\t\tgeneratedColumn: match.length,\n\t\t\t\t\t\tsource: finalSource ? this._value : undefined\n\t\t\t\t  };\n\t\t}\n\t}\n\n\tupdateHash(hash) {\n\t\tif (this._valueAsBuffer === undefined) {\n\t\t\tthis._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n\t\t}\n\t\thash.update(\"OriginalSource\");\n\t\thash.update(this._valueAsBuffer);\n\t\thash.update(this._name || \"\");\n\t}\n}\n\nmodule.exports = OriginalSource;\n"]},"metadata":{},"sourceType":"script"}